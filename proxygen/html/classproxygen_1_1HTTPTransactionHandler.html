<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: proxygen::HTTPTransactionHandler Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classproxygen_1_1HTTPTransactionHandler.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classproxygen_1_1HTTPTransactionHandler-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">proxygen::HTTPTransactionHandler Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="HTTPTransaction_8h_source.html">HTTPTransaction.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for proxygen::HTTPTransactionHandler:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classproxygen_1_1HTTPTransactionHandler.png" usemap="#proxygen::HTTPTransactionHandler_map" alt=""/>
  <map id="proxygen::HTTPTransactionHandler_map" name="proxygen::HTTPTransactionHandler_map">
<area href="classCurlService_1_1CurlClient.html" alt="CurlService::CurlClient" shape="rect" coords="339,56,668,80"/>
<area href="classproxygen_1_1CodecErrorResponseHandler.html" alt="proxygen::CodecErrorResponseHandler" shape="rect" coords="339,112,668,136"/>
<area href="classproxygen_1_1HTTPDirectResponseHandler.html" alt="proxygen::HTTPDirectResponseHandler" shape="rect" coords="339,168,668,192"/>
<area href="classproxygen_1_1HTTPMessageFilter.html" alt="proxygen::HTTPMessageFilter" shape="rect" coords="339,224,668,248"/>
<area href="classproxygen_1_1HTTPPushTransactionHandler.html" alt="proxygen::HTTPPushTransactionHandler" shape="rect" coords="339,280,668,304"/>
<area href="classproxygen_1_1MockHTTPHandler.html" alt="proxygen::MockHTTPHandler" shape="rect" coords="339,336,668,360"/>
<area href="classproxygen_1_1RequestHandlerAdaptor.html" alt="proxygen::RequestHandlerAdaptor" shape="rect" coords="339,392,668,416"/>
<area href="classProxyService_1_1ProxyHandler_1_1ServerTransactionHandler.html" alt="ProxyService::ProxyHandler::ServerTransactionHandler" shape="rect" coords="339,448,668,472"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a4eb50d5627d26f6ca0d8e8283259d8a4"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPTransactionHandler.html#a4eb50d5627d26f6ca0d8e8283259d8a4">setTransaction</a> (<a class="el" href="classproxygen_1_1HTTPTransaction.html">HTTPTransaction</a> *txn) noexcept=0</td></tr>
<tr class="separator:a4eb50d5627d26f6ca0d8e8283259d8a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67eb253d121a26772f4caa56847ed7cd"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPTransactionHandler.html#a67eb253d121a26772f4caa56847ed7cd">detachTransaction</a> () noexcept=0</td></tr>
<tr class="separator:a67eb253d121a26772f4caa56847ed7cd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a5e431cbb4c065285c5ad65acaceb0b22"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPTransactionHandler.html#a5e431cbb4c065285c5ad65acaceb0b22">onHeadersComplete</a> (std::unique_ptr&lt; <a class="el" href="classproxygen_1_1HTTPMessage.html">HTTPMessage</a> &gt; msg) noexcept=0</td></tr>
<tr class="separator:a5e431cbb4c065285c5ad65acaceb0b22"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a56a25d7fb8ac5ddf1ed5b16eaca3c5df"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPTransactionHandler.html#a56a25d7fb8ac5ddf1ed5b16eaca3c5df">onBody</a> (std::unique_ptr&lt; folly::IOBuf &gt; chain) noexcept=0</td></tr>
<tr class="separator:a56a25d7fb8ac5ddf1ed5b16eaca3c5df"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa760cd4a327aaa62293b1d09c5811298"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPTransactionHandler.html#aa760cd4a327aaa62293b1d09c5811298">onChunkHeader</a> (size_t) noexcept</td></tr>
<tr class="separator:aa760cd4a327aaa62293b1d09c5811298"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4befff61cff93d6e2c9459e39556419"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPTransactionHandler.html#ad4befff61cff93d6e2c9459e39556419">onChunkComplete</a> () noexcept</td></tr>
<tr class="separator:ad4befff61cff93d6e2c9459e39556419"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a219de67110f915deda30d18327f26393"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPTransactionHandler.html#a219de67110f915deda30d18327f26393">onTrailers</a> (std::unique_ptr&lt; <a class="el" href="classproxygen_1_1HTTPHeaders.html">HTTPHeaders</a> &gt; trailers) noexcept=0</td></tr>
<tr class="separator:a219de67110f915deda30d18327f26393"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:afdc4d4dec715841ba0c5bb5e58b1d53c"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPTransactionHandler.html#afdc4d4dec715841ba0c5bb5e58b1d53c">onEOM</a> () noexcept=0</td></tr>
<tr class="separator:afdc4d4dec715841ba0c5bb5e58b1d53c"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acda954bf78c4d2aad951698e78c40a0f"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPTransactionHandler.html#acda954bf78c4d2aad951698e78c40a0f">onUpgrade</a> (<a class="el" href="namespaceproxygen.html#a7feed732013b7cc0e2213b19c7b82745">UpgradeProtocol</a> protocol) noexcept=0</td></tr>
<tr class="separator:acda954bf78c4d2aad951698e78c40a0f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a585c21327eb30ab85ebdb84f663dab3b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPTransactionHandler.html#a585c21327eb30ab85ebdb84f663dab3b">onError</a> (const <a class="el" href="classproxygen_1_1HTTPException.html">HTTPException</a> &amp;error) noexcept=0</td></tr>
<tr class="separator:a585c21327eb30ab85ebdb84f663dab3b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0a50acdb32cb51ecbf6a72730053a36b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPTransactionHandler.html#a0a50acdb32cb51ecbf6a72730053a36b">onEgressPaused</a> () noexcept=0</td></tr>
<tr class="separator:a0a50acdb32cb51ecbf6a72730053a36b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7715b02e413859c26426adbbde7e53d8"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPTransactionHandler.html#a7715b02e413859c26426adbbde7e53d8">onEgressResumed</a> () noexcept=0</td></tr>
<tr class="separator:a7715b02e413859c26426adbbde7e53d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9d65c4524f5e38f10d42e0290d51fea6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPTransactionHandler.html#a9d65c4524f5e38f10d42e0290d51fea6">onPushedTransaction</a> (<a class="el" href="classproxygen_1_1HTTPTransaction.html">HTTPTransaction</a> *) noexcept</td></tr>
<tr class="separator:a9d65c4524f5e38f10d42e0290d51fea6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a1e6d98064defaccbc8398b81524dd6"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPTransactionHandler.html#a2a1e6d98064defaccbc8398b81524dd6">onExTransaction</a> (<a class="el" href="classproxygen_1_1HTTPTransaction.html">HTTPTransaction</a> *) noexcept</td></tr>
<tr class="separator:a2a1e6d98064defaccbc8398b81524dd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe33bf69be66a24c82a38b13ee087b42"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPTransactionHandler.html#abe33bf69be66a24c82a38b13ee087b42">onGoaway</a> (<a class="el" href="namespaceproxygen.html#a3d6f6c837ecc1ee254de4e790826ae9b">ErrorCode</a>) noexcept</td></tr>
<tr class="separator:abe33bf69be66a24c82a38b13ee087b42"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae02ae6fb2697e15ca7297fe02dbd20b9"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPTransactionHandler.html#ae02ae6fb2697e15ca7297fe02dbd20b9">~HTTPTransactionHandler</a> ()</td></tr>
<tr class="separator:ae02ae6fb2697e15ca7297fe02dbd20b9"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock">
<p>Definition at line <a class="el" href="HTTPTransaction_8h_source.html#l00133">133</a> of file <a class="el" href="HTTPTransaction_8h_source.html">HTTPTransaction.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="ae02ae6fb2697e15ca7297fe02dbd20b9"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual proxygen::HTTPTransactionHandler::~HTTPTransactionHandler </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="HTTPTransaction_8h_source.html#l00258">258</a> of file <a class="el" href="HTTPTransaction_8h_source.html">HTTPTransaction.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00258"></a><span class="lineno">  258</span>&#160;{}</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="a67eb253d121a26772f4caa56847ed7cd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPTransactionHandler::detachTransaction </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called once after a transaction successfully completes. It will be called even if a read or write error happened earlier. This is a terminal callback, which means that the <a class="el" href="classproxygen_1_1HTTPTransaction.html">HTTPTransaction</a> object that gives this call will be invalid after this function completes. </p>

<p>Implemented in <a class="el" href="classProxyService_1_1ProxyHandler_1_1ServerTransactionHandler.html#a0365bccc4c6f9a0e21d8c1f8f617422c">ProxyService::ProxyHandler::ServerTransactionHandler</a>, <a class="el" href="classproxygen_1_1HTTPMessageFilter.html#a3214b35fc1b0eac4e3ce90eafd7105d3">proxygen::HTTPMessageFilter</a>, <a class="el" href="classCurlService_1_1CurlClient.html#acdae4e65f5bdf0126630dcb03ec4a7fb">CurlService::CurlClient</a>, <a class="el" href="classproxygen_1_1RequestHandlerAdaptor.html#a0d8579a5ceaefe90c6e619825a854596">proxygen::RequestHandlerAdaptor</a>, <a class="el" href="classproxygen_1_1PushHandler_1_1InnerPushHandler.html#a0ab3cb4e9786c665c31f80e09e823c09">proxygen::PushHandler::InnerPushHandler</a>, <a class="el" href="classproxygen_1_1HTTPDirectResponseHandler.html#ae26e1a8188755b57dc2278fb372ce1d3">proxygen::HTTPDirectResponseHandler</a>, and <a class="el" href="classproxygen_1_1CodecErrorResponseHandler.html#af9d9d69d23411943857745fa7e8a5bf7">proxygen::CodecErrorResponseHandler</a>.</p>

<p>Referenced by <a class="el" href="HTTPMessageFilters_8h_source.html#l00063">proxygen::HTTPMessageFilter::detachTransaction()</a>, and <a class="el" href="HTTPTransaction_8cpp_source.html#l00112">proxygen::HTTPTransaction::onDelayedDestroy()</a>.</p>

</div>
</div>
<a class="anchor" id="a56a25d7fb8ac5ddf1ed5b16eaca3c5df"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPTransactionHandler::onBody </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; folly::IOBuf &gt;&#160;</td>
          <td class="paramname"><em>chain</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Can be called multiple times per transaction. If you had previously called pauseIngress(), this callback will be delayed until you call resumeIngress(). </p>

<p>Implemented in <a class="el" href="classproxygen_1_1HTTPPushTransactionHandler.html#a7b1a3456854a5243d2fe951ad5f88b31">proxygen::HTTPPushTransactionHandler</a>, <a class="el" href="classproxygen_1_1MockHTTPHandler.html#adc583bd7c6ec45ede9ebee8f8e686dd1">proxygen::MockHTTPHandler</a>, <a class="el" href="classProxyService_1_1ProxyHandler_1_1ServerTransactionHandler.html#a609346e46c143aec4097a305ecdf482f">ProxyService::ProxyHandler::ServerTransactionHandler</a>, <a class="el" href="classCurlService_1_1CurlClient.html#a347b9f1409c93387bfaf2ff88a400138">CurlService::CurlClient</a>, <a class="el" href="classproxygen_1_1RequestHandlerAdaptor.html#ac4e3c60cd3addc2eb05dc8da0a7f97bd">proxygen::RequestHandlerAdaptor</a>, <a class="el" href="classproxygen_1_1HTTPMessageFilter.html#a01e700144389e09a8e47c831973eb95a">proxygen::HTTPMessageFilter</a>, <a class="el" href="classproxygen_1_1HTTPDirectResponseHandler.html#a339738385d32697a915f8fe2d64ee27c">proxygen::HTTPDirectResponseHandler</a>, <a class="el" href="classproxygen_1_1CodecErrorResponseHandler.html#a6954568eda49450938d616b74095d5da">proxygen::CodecErrorResponseHandler</a>, and <a class="el" href="classproxygen_1_1MockHTTPMessageFilter.html#a60437ec6bdef57525ace27f4ae2d45e9">proxygen::MockHTTPMessageFilter</a>.</p>

<p>Referenced by <a class="el" href="HTTPMessageFilters_8h_source.html#l00086">proxygen::HTTPMessageFilter::nextOnBody()</a>, <a class="el" href="HTTPMessageFilters_8h_source.html#l00037">proxygen::HTTPMessageFilter::onBody()</a>, and <a class="el" href="HTTPTransaction_8cpp_source.html#l00279">proxygen::HTTPTransaction::processIngressBody()</a>.</p>

</div>
</div>
<a class="anchor" id="ad4befff61cff93d6e2c9459e39556419"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPTransactionHandler::onChunkComplete </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Can be called multiple times per transaction. If you had previously called pauseIngress(), this callback will be delayed until you call resumeIngress(). This signifies the end of a chunk. </p>

<p>Reimplemented in <a class="el" href="classproxygen_1_1HTTPPushTransactionHandler.html#a02db8a33eb84cecb89a9b591f20770b0">proxygen::HTTPPushTransactionHandler</a>, <a class="el" href="classproxygen_1_1RequestHandlerAdaptor.html#aaef87cccbaa44c73179bc341b8a7d7d4">proxygen::RequestHandlerAdaptor</a>, and <a class="el" href="classproxygen_1_1HTTPMessageFilter.html#a71664ad5f304232061833473582df6a9">proxygen::HTTPMessageFilter</a>.</p>

<p>Definition at line <a class="el" href="HTTPTransaction_8h_source.html#l00180">180</a> of file <a class="el" href="HTTPTransaction_8h_source.html">HTTPTransaction.h</a>.</p>

<p>Referenced by <a class="el" href="HTTPMessageFilters_8h_source.html#l00092">proxygen::HTTPMessageFilter::nextOnChunkComplete()</a>, <a class="el" href="HTTPMessageFilters_8h_source.html#l00043">proxygen::HTTPMessageFilter::onChunkComplete()</a>, and <a class="el" href="HTTPTransaction_8cpp_source.html#l00350">proxygen::HTTPTransaction::processIngressChunkComplete()</a>.</p>
<div class="fragment"><div class="line"><a name="l00180"></a><span class="lineno">  180</span>&#160;{}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa760cd4a327aaa62293b1d09c5811298"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPTransactionHandler::onChunkHeader </td>
          <td>(</td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Can be called multiple times per transaction. If you had previously called pauseIngress(), this callback will be delayed until you call resumeIngress(). This signifies the beginning of a chunk of length 'length'. You will receive <a class="el" href="classproxygen_1_1HTTPTransactionHandler.html#a56a25d7fb8ac5ddf1ed5b16eaca3c5df">onBody()</a> after this. Also, the length will be greater than zero. </p>

<p>Reimplemented in <a class="el" href="classproxygen_1_1HTTPPushTransactionHandler.html#a4b64ee5a1e2fd9882d74020071b1f665">proxygen::HTTPPushTransactionHandler</a>, <a class="el" href="classproxygen_1_1RequestHandlerAdaptor.html#af1cdb0ac0c8baab9afc7372e35800399">proxygen::RequestHandlerAdaptor</a>, and <a class="el" href="classproxygen_1_1HTTPMessageFilter.html#a2bf20ce08d109d3f5a162c3c9a39a2cb">proxygen::HTTPMessageFilter</a>.</p>

<p>Definition at line <a class="el" href="HTTPTransaction_8h_source.html#l00173">173</a> of file <a class="el" href="HTTPTransaction_8h_source.html">HTTPTransaction.h</a>.</p>

<p>Referenced by <a class="el" href="HTTPMessageFilters_8h_source.html#l00089">proxygen::HTTPMessageFilter::nextOnChunkHeader()</a>, <a class="el" href="HTTPMessageFilters_8h_source.html#l00040">proxygen::HTTPMessageFilter::onChunkHeader()</a>, and <a class="el" href="HTTPTransaction_8cpp_source.html#l00324">proxygen::HTTPTransaction::processIngressChunkHeader()</a>.</p>
<div class="fragment"><div class="line"><a name="l00173"></a><span class="lineno">  173</span>&#160;{}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a0a50acdb32cb51ecbf6a72730053a36b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPTransactionHandler::onEgressPaused </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>If the remote side's receive buffer fills up, this callback will be invoked so you can attempt to stop sending to the remote side. </p>

<p>Implemented in <a class="el" href="classProxyService_1_1ProxyHandler_1_1ServerTransactionHandler.html#a07c6814d546a863d8139bc7c765f07ae">ProxyService::ProxyHandler::ServerTransactionHandler</a>, <a class="el" href="classproxygen_1_1HTTPMessageFilter.html#a8cc01d5f144c15324f012895d9cad11e">proxygen::HTTPMessageFilter</a>, <a class="el" href="classCurlService_1_1CurlClient.html#a26480fe7beb7f338dcf2dd1f6be11628">CurlService::CurlClient</a>, <a class="el" href="classproxygen_1_1RequestHandlerAdaptor.html#a81805401f927660c2bfd86e6aaa1855a">proxygen::RequestHandlerAdaptor</a>, <a class="el" href="classproxygen_1_1PushHandler_1_1InnerPushHandler.html#a4e236ef74e273b9ff1b630d827c2fe2c">proxygen::PushHandler::InnerPushHandler</a>, <a class="el" href="classproxygen_1_1HTTPDirectResponseHandler.html#a1574b64f55e866a3c494985850539cdd">proxygen::HTTPDirectResponseHandler</a>, and <a class="el" href="classproxygen_1_1CodecErrorResponseHandler.html#a11978d258bea9a4c3b66d00f51abb085">proxygen::CodecErrorResponseHandler</a>.</p>

<p>Referenced by <a class="el" href="HTTPMessageFilters_8h_source.html#l00066">proxygen::HTTPMessageFilter::onEgressPaused()</a>, and <a class="el" href="HTTPTransaction_8cpp_source.html#l01214">proxygen::HTTPTransaction::updateHandlerPauseState()</a>.</p>

</div>
</div>
<a class="anchor" id="a7715b02e413859c26426adbbde7e53d8"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPTransactionHandler::onEgressResumed </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>This callback lets you know that the remote side has resumed reading and you can now continue to send data. </p>

<p>Implemented in <a class="el" href="classProxyService_1_1ProxyHandler_1_1ServerTransactionHandler.html#ae3be2fc3a4ef0ed497a1aba8eb85164b">ProxyService::ProxyHandler::ServerTransactionHandler</a>, <a class="el" href="classproxygen_1_1HTTPMessageFilter.html#a127c78c7c6e6dad9c9422cbd6b327ff9">proxygen::HTTPMessageFilter</a>, <a class="el" href="classCurlService_1_1CurlClient.html#a40fc8dafd3a048f5311b84e68a9495a3">CurlService::CurlClient</a>, <a class="el" href="classproxygen_1_1RequestHandlerAdaptor.html#afa48af2f61d214eda8ed89e1fdd5f818">proxygen::RequestHandlerAdaptor</a>, <a class="el" href="classproxygen_1_1PushHandler_1_1InnerPushHandler.html#a0dbb54134905e352ab5157d4abea6a69">proxygen::PushHandler::InnerPushHandler</a>, <a class="el" href="classproxygen_1_1HTTPDirectResponseHandler.html#aad84d594813f254e66b2fba933fb5a7a">proxygen::HTTPDirectResponseHandler</a>, and <a class="el" href="classproxygen_1_1CodecErrorResponseHandler.html#a14f5d408dd0540be026594f9ffc71258">proxygen::CodecErrorResponseHandler</a>.</p>

<p>Referenced by <a class="el" href="HTTPMessageFilters_8h_source.html#l00069">proxygen::HTTPMessageFilter::onEgressResumed()</a>, and <a class="el" href="HTTPTransaction_8cpp_source.html#l01214">proxygen::HTTPTransaction::updateHandlerPauseState()</a>.</p>

</div>
</div>
<a class="anchor" id="afdc4d4dec715841ba0c5bb5e58b1d53c"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPTransactionHandler::onEOM </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Can be called once per transaction. If you had previously called pauseIngress(), this callback will be delayed until you call resumeIngress(). After this callback is received, there will be no more normal ingress callbacks received (onEgress*() and <a class="el" href="classproxygen_1_1HTTPTransactionHandler.html#a585c21327eb30ab85ebdb84f663dab3b">onError()</a> may still be invoked). The Handler should consider ingress complete after receiving this message. This Transaction is still valid, and work may still occur on it until detachTransaction is called. </p>

<p>Implemented in <a class="el" href="classproxygen_1_1HTTPPushTransactionHandler.html#afc714e461a1ab5a38e4d697c5613075a">proxygen::HTTPPushTransactionHandler</a>, <a class="el" href="classProxyService_1_1ProxyHandler_1_1ServerTransactionHandler.html#a30095290901a45c5d07bae0d7d4ea986">ProxyService::ProxyHandler::ServerTransactionHandler</a>, <a class="el" href="classCurlService_1_1CurlClient.html#a7c4b2f28e543ff77e626745c0917ae42">CurlService::CurlClient</a>, <a class="el" href="classproxygen_1_1RequestHandlerAdaptor.html#a686889643d8a950285fce8de5c287a15">proxygen::RequestHandlerAdaptor</a>, <a class="el" href="classproxygen_1_1HTTPMessageFilter.html#adb0375265454cdc5c395de62c7532cc7">proxygen::HTTPMessageFilter</a>, <a class="el" href="classproxygen_1_1HTTPDirectResponseHandler.html#a24796846b4fdac717d5880f6f97b8a64">proxygen::HTTPDirectResponseHandler</a>, and <a class="el" href="classproxygen_1_1CodecErrorResponseHandler.html#a478113c15632fd80373ba1568d67ebea">proxygen::CodecErrorResponseHandler</a>.</p>

<p>Referenced by <a class="el" href="HTTPMessageFilters_8h_source.html#l00098">proxygen::HTTPMessageFilter::nextOnEOM()</a>, <a class="el" href="HTTPMessageFilters_8h_source.html#l00049">proxygen::HTTPMessageFilter::onEOM()</a>, and <a class="el" href="HTTPTransaction_8cpp_source.html#l00457">proxygen::HTTPTransaction::processIngressEOM()</a>.</p>

</div>
</div>
<a class="anchor" id="a585c21327eb30ab85ebdb84f663dab3b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPTransactionHandler::onError </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="classproxygen_1_1HTTPException.html">HTTPException</a> &amp;&#160;</td>
          <td class="paramname"><em>error</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Can be called at any time before <a class="el" href="classproxygen_1_1HTTPTransactionHandler.html#a67eb253d121a26772f4caa56847ed7cd">detachTransaction()</a>. This callback implies that an error has occurred. To determine if ingress or egress is affected, check the direciont on the <a class="el" href="classproxygen_1_1HTTPException.html">HTTPException</a>. If the direction is INGRESS, it MAY still be possible to send egress. </p>

<p>Implemented in <a class="el" href="classProxyService_1_1ProxyHandler_1_1ServerTransactionHandler.html#aad8d2903436d31bdde9734c71c7de457">ProxyService::ProxyHandler::ServerTransactionHandler</a>, <a class="el" href="classCurlService_1_1CurlClient.html#ac58be91bdc9ec7fb485e343263d59678">CurlService::CurlClient</a>, <a class="el" href="classproxygen_1_1HTTPMessageFilter.html#a05d0e397267677aef5db7d46beadbaf9">proxygen::HTTPMessageFilter</a>, <a class="el" href="classproxygen_1_1RequestHandlerAdaptor.html#aea5acf45b01dffd8ec01f646a61abc65">proxygen::RequestHandlerAdaptor</a>, <a class="el" href="classproxygen_1_1PushHandler_1_1InnerPushHandler.html#ad08ffadd89152a6f8f20f9b69b26014c">proxygen::PushHandler::InnerPushHandler</a>, <a class="el" href="classproxygen_1_1HTTPDirectResponseHandler.html#adf29d70e8ff6c37db793d602e6fa6988">proxygen::HTTPDirectResponseHandler</a>, and <a class="el" href="classproxygen_1_1CodecErrorResponseHandler.html#a528f7a698e0c1651dc1138f8a5cce25b">proxygen::CodecErrorResponseHandler</a>.</p>

<p>Referenced by <a class="el" href="HTTPMessageFilters_8h_source.html#l00101">proxygen::HTTPMessageFilter::nextOnError()</a>, <a class="el" href="HTTPMessageFilters_8h_source.html#l00055">proxygen::HTTPMessageFilter::onError()</a>, and <a class="el" href="HTTPTransaction_8cpp_source.html#l00535">proxygen::HTTPTransaction::onError()</a>.</p>

</div>
</div>
<a class="anchor" id="a2a1e6d98064defaccbc8398b81524dd6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPTransactionHandler::onExTransaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPTransaction.html">HTTPTransaction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ask the handler to construct a handler for a ExTransaction associated with its transaction. </p>

<p>Reimplemented in <a class="el" href="classproxygen_1_1HTTPMessageFilter.html#adadb9db88f45c3fc5c0a8c9166cf5fbc">proxygen::HTTPMessageFilter</a>, and <a class="el" href="classproxygen_1_1RequestHandlerAdaptor.html#abf85d528ff0849d89ec2e40b5f7758b7">proxygen::RequestHandlerAdaptor</a>.</p>

<p>Definition at line <a class="el" href="HTTPTransaction_8h_source.html#l00247">247</a> of file <a class="el" href="HTTPTransaction_8h_source.html">HTTPTransaction.h</a>.</p>

<p>Referenced by <a class="el" href="HTTPMessageFilters_8h_source.html#l00075">proxygen::HTTPMessageFilter::onExTransaction()</a>, and <a class="el" href="HTTPTransaction_8cpp_source.html#l01290">proxygen::HTTPTransaction::onExTransaction()</a>.</p>
<div class="fragment"><div class="line"><a name="l00247"></a><span class="lineno">  247</span>&#160;{}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="abe33bf69be66a24c82a38b13ee087b42"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPTransactionHandler::onGoaway </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceproxygen.html#a3d6f6c837ecc1ee254de4e790826ae9b">ErrorCode</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Inform the handler that a GOAWAY has been received on the transport. This callback will only be invoked if the transport is SPDY or HTTP/2. It may be invoked multiple times, as HTTP/2 allows this.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">code</td><td>The error code received in the GOAWAY frame </td></tr>
  </table>
  </dd>
</dl>

<p>Definition at line <a class="el" href="HTTPTransaction_8h_source.html#l00256">256</a> of file <a class="el" href="HTTPTransaction_8h_source.html">HTTPTransaction.h</a>.</p>

<p>Referenced by <a class="el" href="HTTPTransaction_8cpp_source.html#l00609">proxygen::HTTPTransaction::onGoaway()</a>.</p>
<div class="fragment"><div class="line"><a name="l00256"></a><span class="lineno">  256</span>&#160;{}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a5e431cbb4c065285c5ad65acaceb0b22"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPTransactionHandler::onHeadersComplete </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classproxygen_1_1HTTPMessage.html">HTTPMessage</a> &gt;&#160;</td>
          <td class="paramname"><em>msg</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called at most once per transaction. This is usually the first ingress callback. It is possible to get a read error before this however. If you had previously called pauseIngress(), this callback will be delayed until you call resumeIngress(). </p>

<p>Implemented in <a class="el" href="classproxygen_1_1HTTPPushTransactionHandler.html#abba4468f876968221a030ee0f0aaef8c">proxygen::HTTPPushTransactionHandler</a>, <a class="el" href="classproxygen_1_1MockHTTPHandler.html#a2fc2b5715a2a320fb87397d76b6795b2">proxygen::MockHTTPHandler</a>, <a class="el" href="classProxyService_1_1ProxyHandler_1_1ServerTransactionHandler.html#a1b0d44937330471adf749b195db63acb">ProxyService::ProxyHandler::ServerTransactionHandler</a>, <a class="el" href="classCurlService_1_1CurlClient.html#abfa6047eebf33dae96acd69f3f072956">CurlService::CurlClient</a>, <a class="el" href="classproxygen_1_1RequestHandlerAdaptor.html#a0f3e9bc5bdf92afd15b1f6909a46ead8">proxygen::RequestHandlerAdaptor</a>, <a class="el" href="classproxygen_1_1HTTPMessageFilter.html#a2e5ce5153f1507ebcd0a0403799f59d2">proxygen::HTTPMessageFilter</a>, <a class="el" href="classproxygen_1_1HTTPDirectResponseHandler.html#a2c09d64debfda5325d4e73f30bd0cb0a">proxygen::HTTPDirectResponseHandler</a>, <a class="el" href="classproxygen_1_1CodecErrorResponseHandler.html#a53f53233df1aa329d58c6e4c25792b21">proxygen::CodecErrorResponseHandler</a>, and <a class="el" href="classproxygen_1_1MockHTTPMessageFilter.html#ab1814ccd8fca9403bf599708586c8105">proxygen::MockHTTPMessageFilter</a>.</p>

<p>Referenced by <a class="el" href="HTTPMessageFilters_8h_source.html#l00083">proxygen::HTTPMessageFilter::nextOnHeadersComplete()</a>, <a class="el" href="HTTPMessageFilters_8h_source.html#l00034">proxygen::HTTPMessageFilter::onHeadersComplete()</a>, <a class="el" href="HTTPTransaction_8cpp_source.html#l00204">proxygen::HTTPTransaction::processIngressHeadersComplete()</a>, and <a class="el" href="RequestHandlerAdaptorTest_8cpp_source.html#l00034">testExpectHandling()</a>.</p>

</div>
</div>
<a class="anchor" id="a9d65c4524f5e38f10d42e0290d51fea6"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPTransactionHandler::onPushedTransaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPTransaction.html">HTTPTransaction</a> *&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Ask the handler to construct a handler for a pushed transaction associated with its transaction.</p>
<p>TODO: Reconsider default implementation here. If the handler does not implement, better set max initiated to 0 in a settings frame? </p>

<p>Reimplemented in <a class="el" href="classproxygen_1_1HTTPPushTransactionHandler.html#aefddbdf79b892a9c8c8217e51fb5015e">proxygen::HTTPPushTransactionHandler</a>, and <a class="el" href="classproxygen_1_1HTTPMessageFilter.html#a29c237ffff978986025d5fcba8a15587">proxygen::HTTPMessageFilter</a>.</p>

<p>Definition at line <a class="el" href="HTTPTransaction_8h_source.html#l00241">241</a> of file <a class="el" href="HTTPTransaction_8h_source.html">HTTPTransaction.h</a>.</p>

<p>Referenced by <a class="el" href="HTTPMessageFilters_8h_source.html#l00072">proxygen::HTTPMessageFilter::onPushedTransaction()</a>, and <a class="el" href="HTTPTransaction_8cpp_source.html#l01274">proxygen::HTTPTransaction::onPushedTransaction()</a>.</p>
<div class="fragment"><div class="line"><a name="l00241"></a><span class="lineno">  241</span>&#160;{}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a219de67110f915deda30d18327f26393"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPTransactionHandler::onTrailers </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classproxygen_1_1HTTPHeaders.html">HTTPHeaders</a> &gt;&#160;</td>
          <td class="paramname"><em>trailers</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Can be called any number of times per transaction. If you had previously called pauseIngress(), this callback will be delayed until you call resumeIngress(). Trailers can be received once right before the EOM of a chunked HTTP/1.1 reponse or multiple times per transaction from SPDY and HTTP/2.0 HEADERS frames. </p>

<p>Implemented in <a class="el" href="classproxygen_1_1HTTPPushTransactionHandler.html#a3ef08caffef20fa7e02f66f68eb7ac7a">proxygen::HTTPPushTransactionHandler</a>, <a class="el" href="classproxygen_1_1MockHTTPHandler.html#abcdbbe27d03be815ce488611b7d3d9db">proxygen::MockHTTPHandler</a>, <a class="el" href="classProxyService_1_1ProxyHandler_1_1ServerTransactionHandler.html#a524714d69faf9ba16ce4c9050ba4882c">ProxyService::ProxyHandler::ServerTransactionHandler</a>, <a class="el" href="classCurlService_1_1CurlClient.html#a13f4e9d8894fba072798f6909f8f740b">CurlService::CurlClient</a>, <a class="el" href="classproxygen_1_1RequestHandlerAdaptor.html#ae4260f78cff36b8b745c5071ed1fb2f5">proxygen::RequestHandlerAdaptor</a>, <a class="el" href="classproxygen_1_1HTTPMessageFilter.html#a9fdaf7b45f3c1e662a9844b07b426986">proxygen::HTTPMessageFilter</a>, <a class="el" href="classproxygen_1_1MockHTTPMessageFilter.html#abf61c2dd6a174c2900743065c035d6d5">proxygen::MockHTTPMessageFilter</a>, <a class="el" href="classproxygen_1_1HTTPDirectResponseHandler.html#ab2778c94e47c7d5894694076020ab1e7">proxygen::HTTPDirectResponseHandler</a>, and <a class="el" href="classproxygen_1_1CodecErrorResponseHandler.html#a0d1ffa7ca3489d9cb76a1f1015eb8d9f">proxygen::CodecErrorResponseHandler</a>.</p>

<p>Referenced by <a class="el" href="HTTPMessageFilters_8h_source.html#l00095">proxygen::HTTPMessageFilter::nextOnTrailers()</a>, <a class="el" href="HTTPMessageFilters_8h_source.html#l00046">proxygen::HTTPMessageFilter::onTrailers()</a>, and <a class="el" href="HTTPTransaction_8cpp_source.html#l00377">proxygen::HTTPTransaction::processIngressTrailers()</a>.</p>

</div>
</div>
<a class="anchor" id="acda954bf78c4d2aad951698e78c40a0f"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPTransactionHandler::onUpgrade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespaceproxygen.html#a7feed732013b7cc0e2213b19c7b82745">UpgradeProtocol</a>&#160;</td>
          <td class="paramname"><em>protocol</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Can be called once per transaction. If you had previously called pauseIngress(), this callback will be delayed until you call resumeIngress(). After this callback is invoked, further data will be forwarded using the <a class="el" href="classproxygen_1_1HTTPTransactionHandler.html#a56a25d7fb8ac5ddf1ed5b16eaca3c5df">onBody()</a> callback. Once the data transfer is completed (EOF recevied in case of CONNECT), <a class="el" href="classproxygen_1_1HTTPTransactionHandler.html#afdc4d4dec715841ba0c5bb5e58b1d53c">onEOM()</a> callback will be invoked. </p>

<p>Implemented in <a class="el" href="classproxygen_1_1HTTPPushTransactionHandler.html#ae2af3eeea0e94e4220fbb31d7303624f">proxygen::HTTPPushTransactionHandler</a>, <a class="el" href="classProxyService_1_1ProxyHandler_1_1ServerTransactionHandler.html#a199712dacd5f7679c47b01d2019db981">ProxyService::ProxyHandler::ServerTransactionHandler</a>, <a class="el" href="classCurlService_1_1CurlClient.html#ae64a3832725897be431f2473cf3abd8b">CurlService::CurlClient</a>, <a class="el" href="classproxygen_1_1HTTPMessageFilter.html#a8553e010c148a72a93920d7992d81421">proxygen::HTTPMessageFilter</a>, <a class="el" href="classproxygen_1_1RequestHandlerAdaptor.html#a422adcb6af8718e70ba06b4ecefdb984">proxygen::RequestHandlerAdaptor</a>, <a class="el" href="classproxygen_1_1HTTPDirectResponseHandler.html#aabd20b77c9340d97ceb79d8ab2064d1f">proxygen::HTTPDirectResponseHandler</a>, and <a class="el" href="classproxygen_1_1CodecErrorResponseHandler.html#a85661a89d97edc0e729ab79a48dfd7e1">proxygen::CodecErrorResponseHandler</a>.</p>

<p>Referenced by <a class="el" href="HTTPMessageFilters_8h_source.html#l00052">proxygen::HTTPMessageFilter::onUpgrade()</a>, and <a class="el" href="HTTPTransaction_8cpp_source.html#l00403">proxygen::HTTPTransaction::processIngressUpgrade()</a>.</p>

</div>
</div>
<a class="anchor" id="a4eb50d5627d26f6ca0d8e8283259d8a4"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPTransactionHandler::setTransaction </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPTransaction.html">HTTPTransaction</a> *&#160;</td>
          <td class="paramname"><em>txn</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span><span class="mlabel">noexcept</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called once per transaction. This notifies the handler of which transaction it should talk to and will receive callbacks from. </p>

<p>Implemented in <a class="el" href="classProxyService_1_1ProxyHandler_1_1ServerTransactionHandler.html#a4c68de0256e08ac4bace1eed0907009e">ProxyService::ProxyHandler::ServerTransactionHandler</a>, <a class="el" href="classproxygen_1_1HTTPMessageFilter.html#a61880d9d1bdec908b8c18fcb50704998">proxygen::HTTPMessageFilter</a>, <a class="el" href="classCurlService_1_1CurlClient.html#a3b1e05c84ebfc6691f2f80f299018070">CurlService::CurlClient</a>, <a class="el" href="classproxygen_1_1RequestHandlerAdaptor.html#a00d6dad4f26828a383e94cb542823153">proxygen::RequestHandlerAdaptor</a>, <a class="el" href="classproxygen_1_1PushHandler_1_1InnerPushHandler.html#a02c94579e3e2662bc4ef5f5f774e452d">proxygen::PushHandler::InnerPushHandler</a>, <a class="el" href="classproxygen_1_1HTTPDirectResponseHandler.html#a8fe2988e6693f8d29ef02f812857cba8">proxygen::HTTPDirectResponseHandler</a>, and <a class="el" href="classproxygen_1_1CodecErrorResponseHandler.html#aef0fd13f2c1b669bf81502ea0a10e5c3">proxygen::CodecErrorResponseHandler</a>.</p>

<p>Referenced by <a class="el" href="HTTPTransaction_8h_source.html#l00477">proxygen::HTTPTransaction::setHandler()</a>, and <a class="el" href="HTTPMessageFilters_8h_source.html#l00060">proxygen::HTTPMessageFilter::setTransaction()</a>.</p>

</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>proxygen/lib/http/session/<a class="el" href="HTTPTransaction_8h_source.html">HTTPTransaction.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceproxygen.html">proxygen</a></li><li class="navelem"><a class="el" href="classproxygen_1_1HTTPTransactionHandler.html">HTTPTransactionHandler</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
