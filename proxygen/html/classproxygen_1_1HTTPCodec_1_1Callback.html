<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.11"/>
<title>proxygen: proxygen::HTTPCodec::Callback Class Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="navtree.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="resize.js"></script>
<script type="text/javascript" src="navtreedata.js"></script>
<script type="text/javascript" src="navtree.js"></script>
<script type="text/javascript">
  $(document).ready(initResizable);
  $(window).load(resizeHeight);
</script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">proxygen
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.11 -->
  <div id="navrow1" class="tabs">
    <ul class="tablist">
      <li><a href="index.html"><span>Main&#160;Page</span></a></li>
      <li><a href="pages.html"><span>Related&#160;Pages</span></a></li>
      <li><a href="namespaces.html"><span>Namespaces</span></a></li>
      <li class="current"><a href="annotated.html"><span>Classes</span></a></li>
      <li><a href="files.html"><span>Files</span></a></li>
    </ul>
  </div>
  <div id="navrow2" class="tabs2">
    <ul class="tablist">
      <li><a href="annotated.html"><span>Class&#160;List</span></a></li>
      <li><a href="hierarchy.html"><span>Class&#160;Hierarchy</span></a></li>
      <li><a href="functions.html"><span>Class&#160;Members</span></a></li>
    </ul>
  </div>
</div><!-- top -->
<div id="side-nav" class="ui-resizable side-nav-resizable">
  <div id="nav-tree">
    <div id="nav-tree-contents">
      <div id="nav-sync" class="sync"></div>
    </div>
  </div>
  <div id="splitbar" style="-moz-user-select:none;" 
       class="ui-resizable-handle">
  </div>
</div>
<script type="text/javascript">
$(document).ready(function(){initNavTree('classproxygen_1_1HTTPCodec_1_1Callback.html','');});
</script>
<div id="doc-content">
<div class="header">
  <div class="summary">
<a href="#pub-methods">Public Member Functions</a> &#124;
<a href="classproxygen_1_1HTTPCodec_1_1Callback-members.html">List of all members</a>  </div>
  <div class="headertitle">
<div class="title">proxygen::HTTPCodec::Callback Class Reference<span class="mlabels"><span class="mlabel">abstract</span></span></div>  </div>
</div><!--header-->
<div class="contents">

<p><code>#include &lt;<a class="el" href="HTTPCodec_8h_source.html">HTTPCodec.h</a>&gt;</code></p>
<div class="dynheader">
Inheritance diagram for proxygen::HTTPCodec::Callback:</div>
<div class="dyncontent">
 <div class="center">
  <img src="classproxygen_1_1HTTPCodec_1_1Callback.png" usemap="#proxygen::HTTPCodec::Callback_map" alt=""/>
  <map id="proxygen::HTTPCodec::Callback_map" name="proxygen::HTTPCodec::Callback_map">
<area href="classHTTP1xCodecCallback.html" alt="HTTP1xCodecCallback" shape="rect" coords="0,56,219,80"/>
<area href="classproxygen_1_1FakeHTTPCodecCallback.html" alt="proxygen::FakeHTTPCodecCallback" shape="rect" coords="229,56,448,80"/>
<area href="classproxygen_1_1HTTPSession.html" alt="proxygen::HTTPSession" shape="rect" coords="458,56,677,80"/>
<area href="classproxygen_1_1MockHTTPCodecCallback.html" alt="proxygen::MockHTTPCodecCallback" shape="rect" coords="687,56,906,80"/>
<area href="classproxygen_1_1RFC1867Codec.html" alt="proxygen::RFC1867Codec" shape="rect" coords="916,56,1135,80"/>
<area href="classproxygen_1_1HTTPDownstreamSession.html" alt="proxygen::HTTPDownstreamSession" shape="rect" coords="343,112,562,136"/>
<area href="classproxygen_1_1HTTPUpstreamSession.html" alt="proxygen::HTTPUpstreamSession" shape="rect" coords="572,112,791,136"/>
</map>
 </div></div>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="pub-methods"></a>
Public Member Functions</h2></td></tr>
<tr class="memitem:a7bcd0c639fd05f92b31806cee4f4b1aa"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#a7bcd0c639fd05f92b31806cee4f4b1aa">onMessageBegin</a> (<a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a> <a class="el" href="structstream.html">stream</a>, <a class="el" href="classproxygen_1_1HTTPMessage.html">HTTPMessage</a> *msg)=0</td></tr>
<tr class="separator:a7bcd0c639fd05f92b31806cee4f4b1aa"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2a54bb421215a2929e2c8ee0d2112032"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#a2a54bb421215a2929e2c8ee0d2112032">onPushMessageBegin</a> (<a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>, <a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>, <a class="el" href="classproxygen_1_1HTTPMessage.html">HTTPMessage</a> *)</td></tr>
<tr class="separator:a2a54bb421215a2929e2c8ee0d2112032"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abe873557040a9184715f7f5a47c863a1"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#abe873557040a9184715f7f5a47c863a1">onExMessageBegin</a> (<a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>, <a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>, bool, <a class="el" href="classproxygen_1_1HTTPMessage.html">HTTPMessage</a> *)</td></tr>
<tr class="separator:abe873557040a9184715f7f5a47c863a1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c462d2b3485d0d1077a9ba775f90ebc"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#a7c462d2b3485d0d1077a9ba775f90ebc">onHeadersComplete</a> (<a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a> <a class="el" href="structstream.html">stream</a>, std::unique_ptr&lt; <a class="el" href="classproxygen_1_1HTTPMessage.html">HTTPMessage</a> &gt; msg)=0</td></tr>
<tr class="separator:a7c462d2b3485d0d1077a9ba775f90ebc"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af6661786cb419aa6b0138ed1d8085d52"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#af6661786cb419aa6b0138ed1d8085d52">onBody</a> (<a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a> <a class="el" href="structstream.html">stream</a>, std::unique_ptr&lt; folly::IOBuf &gt; chain, uint16_t padding)=0</td></tr>
<tr class="separator:af6661786cb419aa6b0138ed1d8085d52"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae106b662c7e855b4677ec55d4235e66d"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#ae106b662c7e855b4677ec55d4235e66d">onChunkHeader</a> (<a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>, size_t)</td></tr>
<tr class="separator:ae106b662c7e855b4677ec55d4235e66d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad1fa297ee8929ea5032b7037956198b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#aad1fa297ee8929ea5032b7037956198b">onChunkComplete</a> (<a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>)</td></tr>
<tr class="separator:aad1fa297ee8929ea5032b7037956198b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3ecee42ce8c09840aa67ee824c5cfe3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#aa3ecee42ce8c09840aa67ee824c5cfe3">onTrailersComplete</a> (<a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a> <a class="el" href="structstream.html">stream</a>, std::unique_ptr&lt; <a class="el" href="classproxygen_1_1HTTPHeaders.html">HTTPHeaders</a> &gt; trailers)=0</td></tr>
<tr class="separator:aa3ecee42ce8c09840aa67ee824c5cfe3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b42c169cc7f48b42be7f97b463db08e"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#a8b42c169cc7f48b42be7f97b463db08e">onMessageComplete</a> (<a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a> <a class="el" href="structstream.html">stream</a>, bool upgrade)=0</td></tr>
<tr class="separator:a8b42c169cc7f48b42be7f97b463db08e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39e04260da7dd1a074393fe473d6ac34"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#a39e04260da7dd1a074393fe473d6ac34">onError</a> (<a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a> <a class="el" href="structstream.html">stream</a>, const <a class="el" href="classproxygen_1_1HTTPException.html">HTTPException</a> &amp;error, bool newTxn=false)=0</td></tr>
<tr class="separator:a39e04260da7dd1a074393fe473d6ac34"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a110afc4d5324a47b9b2f6356afc70bbf"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#a110afc4d5324a47b9b2f6356afc70bbf">onAbort</a> (<a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>, <a class="el" href="namespaceproxygen.html#a3d6f6c837ecc1ee254de4e790826ae9b">ErrorCode</a>)</td></tr>
<tr class="separator:a110afc4d5324a47b9b2f6356afc70bbf"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a43441f24ed1f9680a2909d1617822b61"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#a43441f24ed1f9680a2909d1617822b61">onFrameHeader</a> (<a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>, uint8_t, uint64_t, uint8_t, uint16_t=0)</td></tr>
<tr class="separator:a43441f24ed1f9680a2909d1617822b61"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a782493dc0d063e7f5c626db2617d042b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#a782493dc0d063e7f5c626db2617d042b">onGoaway</a> (uint64_t, <a class="el" href="namespaceproxygen.html#a3d6f6c837ecc1ee254de4e790826ae9b">ErrorCode</a>, std::unique_ptr&lt; folly::IOBuf &gt;=<a class="el" href="http__parser__cpp_8cpp.html#ab979d9d4b4923f7c54d6caa6e1a61936">nullptr</a>)</td></tr>
<tr class="separator:a782493dc0d063e7f5c626db2617d042b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1740eddb4466d8d9a411f558d37c7d39"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#a1740eddb4466d8d9a411f558d37c7d39">onPingRequest</a> (uint64_t)</td></tr>
<tr class="separator:a1740eddb4466d8d9a411f558d37c7d39"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6ebe6de42080d9b8834f48add6f63553"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#a6ebe6de42080d9b8834f48add6f63553">onPingReply</a> (uint64_t)</td></tr>
<tr class="separator:a6ebe6de42080d9b8834f48add6f63553"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2e07b2b70565c4f2782d8767abf0e780"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#a2e07b2b70565c4f2782d8767abf0e780">onWindowUpdate</a> (<a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>, uint32_t)</td></tr>
<tr class="separator:a2e07b2b70565c4f2782d8767abf0e780"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a74342e68c4a6845289a3385f947d1b65"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#a74342e68c4a6845289a3385f947d1b65">onSettings</a> (const <a class="el" href="namespaceproxygen.html#a178ae546fbff60576dc3e3ce2de52410">SettingsList</a> &amp;)</td></tr>
<tr class="separator:a74342e68c4a6845289a3385f947d1b65"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a9ec9c7daad56b25852e4d7b31ffc1ae7"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#a9ec9c7daad56b25852e4d7b31ffc1ae7">onSettingsAck</a> ()</td></tr>
<tr class="separator:a9ec9c7daad56b25852e4d7b31ffc1ae7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa3960bf891965283f9a99797af9e99b3"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#aa3960bf891965283f9a99797af9e99b3">onPriority</a> (<a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>, const <a class="el" href="classproxygen_1_1HTTPMessage.html#a488cdeffada45d57bf30cf2b9059bd5a">HTTPMessage::HTTPPriority</a> &amp;)</td></tr>
<tr class="separator:aa3960bf891965283f9a99797af9e99b3"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a862f51146984af8fbb64d32d1d27f094"><td class="memItemLeft" align="right" valign="top">virtual bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#a862f51146984af8fbb64d32d1d27f094">onNativeProtocolUpgrade</a> (<a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>, <a class="el" href="namespaceproxygen.html#a470a61083ee151f964f0382f345a2b42">CodecProtocol</a>, const std::string &amp;, <a class="el" href="classproxygen_1_1HTTPMessage.html">HTTPMessage</a> &amp;)</td></tr>
<tr class="separator:a862f51146984af8fbb64d32d1d27f094"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:acdc27546d6ace641570c28299d83898b"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#acdc27546d6ace641570c28299d83898b">onGenerateFrameHeader</a> (<a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>, uint8_t, uint64_t, uint16_t=0)</td></tr>
<tr class="separator:acdc27546d6ace641570c28299d83898b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a982896bcd896ea45a10b03a294ded590"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#a982896bcd896ea45a10b03a294ded590">onCertificateRequest</a> (uint16_t, std::unique_ptr&lt; folly::IOBuf &gt;)</td></tr>
<tr class="separator:a982896bcd896ea45a10b03a294ded590"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a39962dfe4038936e8042e725e50c2d45"><td class="memItemLeft" align="right" valign="top">virtual void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#a39962dfe4038936e8042e725e50c2d45">onCertificate</a> (uint16_t, std::unique_ptr&lt; folly::IOBuf &gt;)</td></tr>
<tr class="separator:a39962dfe4038936e8042e725e50c2d45"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a65779e4b1763aa1daa424f02a5ca3f05"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#a65779e4b1763aa1daa424f02a5ca3f05">numOutgoingStreams</a> () const </td></tr>
<tr class="separator:a65779e4b1763aa1daa424f02a5ca3f05"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aad2decb51a53dc21448547ba34b0409a"><td class="memItemLeft" align="right" valign="top">virtual uint32_t&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#aad2decb51a53dc21448547ba34b0409a">numIncomingStreams</a> () const </td></tr>
<tr class="separator:aad2decb51a53dc21448547ba34b0409a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a05e9e9907d24e577604f7941da8123bd"><td class="memItemLeft" align="right" valign="top">virtual&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#a05e9e9907d24e577604f7941da8123bd">~Callback</a> ()</td></tr>
<tr class="separator:a05e9e9907d24e577604f7941da8123bd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html">Callback</a> interface that users of <a class="el" href="classproxygen_1_1HTTPCodec.html">HTTPCodec</a> must implement </p>

<p>Definition at line <a class="el" href="HTTPCodec_8h_source.html#l00078">78</a> of file <a class="el" href="HTTPCodec_8h_source.html">HTTPCodec.h</a>.</p>
</div><h2 class="groupheader">Constructor &amp; Destructor Documentation</h2>
<a class="anchor" id="a05e9e9907d24e577604f7941da8123bd"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual proxygen::HTTPCodec::Callback::~Callback </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Definition at line <a class="el" href="HTTPCodec_8h_source.html#l00329">329</a> of file <a class="el" href="HTTPCodec_8h_source.html">HTTPCodec.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00329"></a><span class="lineno">  329</span>&#160;{}</div></div><!-- fragment -->
</div>
</div>
<h2 class="groupheader">Member Function Documentation</h2>
<a class="anchor" id="aad2decb51a53dc21448547ba34b0409a"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t proxygen::HTTPCodec::Callback::numIncomingStreams </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of open streams started by the remote side. Parallel codecs with a maximum number of streams will invoke this to determine if a new stream exceeds the limit. </p>

<p>Reimplemented in <a class="el" href="classproxygen_1_1HTTPSession.html#a32ded5f1b237ce4aac4dacb8d8844b6f">proxygen::HTTPSession</a>, and <a class="el" href="classproxygen_1_1FakeHTTPCodecCallback.html#a1aa4525d399761ddc2f08b839cc266b1">proxygen::FakeHTTPCodecCallback</a>.</p>

<p>Definition at line <a class="el" href="HTTPCodec_8h_source.html#l00327">327</a> of file <a class="el" href="HTTPCodec_8h_source.html">HTTPCodec.h</a>.</p>

<p>Referenced by <a class="el" href="SPDYCodec_8cpp_source.html#l01283">proxygen::SPDYCodec::onSynStream()</a>, and <a class="el" href="HTTP2Codec_8cpp_source.html#l00581">proxygen::HTTP2Codec::parseHeadersCheckConcurrentStreams()</a>.</p>
<div class="fragment"><div class="line"><a name="l00327"></a><span class="lineno">  327</span>&#160;{ <span class="keywordflow">return</span> 0; }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a65779e4b1763aa1daa424f02a5ca3f05"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual uint32_t proxygen::HTTPCodec::Callback::numOutgoingStreams </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td> const</td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Return the number of open streams started by this codec callback. Parallel codecs with a maximum number of streams will invoke this to determine if a new stream exceeds the limit. </p>

<p>Reimplemented in <a class="el" href="classproxygen_1_1HTTPSession.html#ac9f475ec074ab357ffeeb614cfe3f83d">proxygen::HTTPSession</a>, and <a class="el" href="classproxygen_1_1FakeHTTPCodecCallback.html#a03af9af000004c543ee9999debf25390">proxygen::FakeHTTPCodecCallback</a>.</p>

<p>Definition at line <a class="el" href="HTTPCodec_8h_source.html#l00320">320</a> of file <a class="el" href="HTTPCodec_8h_source.html">HTTPCodec.h</a>.</p>
<div class="fragment"><div class="line"><a name="l00320"></a><span class="lineno">  320</span>&#160;{ <span class="keywordflow">return</span> 0; }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a110afc4d5324a47b9b2f6356afc70bbf"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPCodec::Callback::onAbort </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceproxygen.html#a3d6f6c837ecc1ee254de4e790826ae9b">ErrorCode</a>&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when the peer has asked to shut down a stream immediately. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream ID </td></tr>
    <tr><td class="paramname">code</td><td>The code the stream was aborted with </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Not applicable to all protocols. </dd></dl>

<p>Reimplemented in <a class="el" href="classproxygen_1_1HTTPSession.html#ac3183c78b441791ee835660ffb91ed9f">proxygen::HTTPSession</a>, and <a class="el" href="classproxygen_1_1FakeHTTPCodecCallback.html#a3f66d4797b2c12c5485986f90fa1b331">proxygen::FakeHTTPCodecCallback</a>.</p>

<p>Definition at line <a class="el" href="HTTPCodec_8h_source.html#l00192">192</a> of file <a class="el" href="HTTPCodec_8h_source.html">HTTPCodec.h</a>.</p>

<p>Referenced by <a class="el" href="SPDYCodec_8cpp_source.html#l01337">proxygen::SPDYCodec::onRstStream()</a>, and <a class="el" href="HTTP2Codec_8cpp_source.html#l00683">proxygen::HTTP2Codec::parseRstStream()</a>.</p>
<div class="fragment"><div class="line"><a name="l00194"></a><span class="lineno">  194</span>&#160;                     {}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="af6661786cb419aa6b0138ed1d8085d52"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPCodec::Callback::onBody </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; folly::IOBuf &gt;&#160;</td>
          <td class="paramname"><em>chain</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"><em>padding</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called for each block of message body data </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream ID </td></tr>
    <tr><td class="paramname">chain</td><td>One or more buffers of body data. The codec will remove any protocol framing, such as HTTP/1.1 chunk headers, from the buffers before calling this function. </td></tr>
    <tr><td class="paramname">padding</td><td>Number of pad bytes that came with the data segment </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classproxygen_1_1HTTPSession.html#a4ef5f45a171469eadd34144f3a00802c">proxygen::HTTPSession</a>, <a class="el" href="classproxygen_1_1MockHTTPCodecCallback.html#ac4e58e068ff76da169802b8668befd73">proxygen::MockHTTPCodecCallback</a>, <a class="el" href="classproxygen_1_1FakeHTTPCodecCallback.html#a43e0a21206fd5d3b34959818ecb5a5c1">proxygen::FakeHTTPCodecCallback</a>, <a class="el" href="classproxygen_1_1RFC1867Codec.html#a4a6f31403b32e593888d89274023614a">proxygen::RFC1867Codec</a>, and <a class="el" href="classHTTP1xCodecCallback.html#a45c3eac90864197e1ec5334016629431">HTTP1xCodecCallback</a>.</p>

<p>Referenced by <a class="el" href="HTTP1xCodec_8cpp_source.html#l01144">proxygen::HTTP1xCodec::onBody()</a>, <a class="el" href="HTTP1xCodec_8cpp_source.html#l00177">proxygen::HTTP1xCodec::onIngress()</a>, <a class="el" href="HTTP2Codec_8cpp_source.html#l00275">proxygen::HTTP2Codec::parseAllData()</a>, <a class="el" href="HTTP2Codec_8cpp_source.html#l00293">proxygen::HTTP2Codec::parseDataFrameData()</a>, and <a class="el" href="SPDYCodec_8cpp_source.html#l00246">proxygen::SPDYCodec::parseIngress()</a>.</p>

</div>
</div>
<a class="anchor" id="a39962dfe4038936e8042e725e50c2d45"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPCodec::Callback::onCertificate </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; folly::IOBuf &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called upon receipt of an authenticator, for protocols that support secondary certificate authentication. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">certId</td><td>The Cert-ID identifying this authenticator </td></tr>
    <tr><td class="paramname">authenticator</td><td>The authenticator request </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Not all protocols support secondary certificate authentication. HTTP/2 does, but HTTP/1.1 doesn't. </dd></dl>

<p>Reimplemented in <a class="el" href="classproxygen_1_1HTTPSession.html#a4bdeeff83639f5b0afdec5b2d92ea48d">proxygen::HTTPSession</a>, <a class="el" href="classproxygen_1_1FakeHTTPCodecCallback.html#af2175032d60674dc99e7ddc7859f2a02">proxygen::FakeHTTPCodecCallback</a>, and <a class="el" href="classproxygen_1_1MockHTTPCodecCallback.html#aef5b399bf8a0191cb96354611ff945fc">proxygen::MockHTTPCodecCallback</a>.</p>

<p>Definition at line <a class="el" href="HTTPCodec_8h_source.html#l00310">310</a> of file <a class="el" href="HTTPCodec_8h_source.html">HTTPCodec.h</a>.</p>

<p>Referenced by <a class="el" href="HTTP2Codec_8cpp_source.html#l00949">proxygen::HTTP2Codec::parseCertificate()</a>.</p>
<div class="fragment"><div class="line"><a name="l00312"></a><span class="lineno">  312</span>&#160;                                     {</div><div class="line"><a name="l00313"></a><span class="lineno">  313</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a982896bcd896ea45a10b03a294ded590"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPCodec::Callback::onCertificateRequest </td>
          <td>(</td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; folly::IOBuf &gt;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called upon receipt of a certificate request frame, for protocols that support secondary certificate authentication. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">requestId</td><td>The Request-ID identifying the certificate request </td></tr>
    <tr><td class="paramname">authRequest</td><td>The authenticator request </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Not all protocols support secondary certificate authentication. HTTP/2 does, but HTTP/1.1 doesn't. </dd></dl>

<p>Reimplemented in <a class="el" href="classproxygen_1_1HTTPSession.html#ae98209dbf84dc096fb2ace705407fd47">proxygen::HTTPSession</a>, <a class="el" href="classproxygen_1_1FakeHTTPCodecCallback.html#a404bde70243206b37309b8df0dd5f717">proxygen::FakeHTTPCodecCallback</a>, and <a class="el" href="classproxygen_1_1MockHTTPCodecCallback.html#a6890b812cc7565952643b5cec3f131c6">proxygen::MockHTTPCodecCallback</a>.</p>

<p>Definition at line <a class="el" href="HTTPCodec_8h_source.html#l00297">297</a> of file <a class="el" href="HTTPCodec_8h_source.html">HTTPCodec.h</a>.</p>

<p>Referenced by <a class="el" href="HTTP2Codec_8cpp_source.html#l00935">proxygen::HTTP2Codec::parseCertificateRequest()</a>.</p>
<div class="fragment"><div class="line"><a name="l00299"></a><span class="lineno">  299</span>&#160;                                     {</div><div class="line"><a name="l00300"></a><span class="lineno">  300</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aad1fa297ee8929ea5032b7037956198b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPCodec::Callback::onChunkComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when the terminating CRLF is received to end a chunk of HTTP body data.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream ID </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classproxygen_1_1HTTPSession.html#a201f8d42c3a6754e2743b5e5661b901e">proxygen::HTTPSession</a>, <a class="el" href="classproxygen_1_1FakeHTTPCodecCallback.html#a5e8de5c57251fe0c3e28ca30573ae291">proxygen::FakeHTTPCodecCallback</a>, and <a class="el" href="classHTTP1xCodecCallback.html#ab9f5539148d7b2f8ba195a56aefc13b0">HTTP1xCodecCallback</a>.</p>

<p>Definition at line <a class="el" href="HTTPCodec_8h_source.html#l00156">156</a> of file <a class="el" href="HTTPCodec_8h_source.html">HTTPCodec.h</a>.</p>

<p>Referenced by <a class="el" href="HTTP1xCodec_8cpp_source.html#l01171">proxygen::HTTP1xCodec::onChunkComplete()</a>.</p>
<div class="fragment"><div class="line"><a name="l00156"></a><span class="lineno">  156</span>&#160;{}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="ae106b662c7e855b4677ec55d4235e66d"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPCodec::Callback::onChunkHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called for each HTTP chunk header.</p>
<p><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#ae106b662c7e855b4677ec55d4235e66d">onChunkHeader()</a> will be called when the chunk header is received. As the chunk data arrives, it will be passed to the callback normally with <a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#af6661786cb419aa6b0138ed1d8085d52">onBody()</a> calls. Note that the chunk data may arrive in multiple <a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#af6661786cb419aa6b0138ed1d8085d52">onBody()</a> calls: it is not guaranteed to arrive in a single <a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#af6661786cb419aa6b0138ed1d8085d52">onBody()</a> call.</p>
<p>After the chunk data has been received and the terminating CRLF has been received, <a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html#aad1fa297ee8929ea5032b7037956198b">onChunkComplete()</a> will be called.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream ID </td></tr>
    <tr><td class="paramname">length</td><td>The chunk length. </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classproxygen_1_1HTTPSession.html#a3137afb711666467861a8d61d9f15824">proxygen::HTTPSession</a>, <a class="el" href="classproxygen_1_1FakeHTTPCodecCallback.html#adb95188db25583e64a9ff905513f4072">proxygen::FakeHTTPCodecCallback</a>, and <a class="el" href="classHTTP1xCodecCallback.html#a37b309b40fb28e30cf01c25e737801b7">HTTP1xCodecCallback</a>.</p>

<p>Definition at line <a class="el" href="HTTPCodec_8h_source.html#l00148">148</a> of file <a class="el" href="HTTPCodec_8h_source.html">HTTPCodec.h</a>.</p>

<p>Referenced by <a class="el" href="HTTP1xCodec_8cpp_source.html#l01160">proxygen::HTTP1xCodec::onChunkHeader()</a>.</p>
<div class="fragment"><div class="line"><a name="l00148"></a><span class="lineno">  148</span>&#160;{}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a39e04260da7dd1a074393fe473d6ac34"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPCodec::Callback::onError </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classproxygen_1_1HTTPException.html">HTTPException</a> &amp;&#160;</td>
          <td class="paramname"><em>error</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>newTxn</em> = <code>false</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a parsing or protocol error has occurred </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream ID </td></tr>
    <tr><td class="paramname">error</td><td>Description of the error </td></tr>
    <tr><td class="paramname">newTxn</td><td>true if onMessageBegin has not been called for txn </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classproxygen_1_1HTTPSession.html#ab44f22d1c1900f583f4e8584fb2f0105">proxygen::HTTPSession</a>, <a class="el" href="classproxygen_1_1MockHTTPCodecCallback.html#accda1fe4c5523b1fed69b013a3ed63e5">proxygen::MockHTTPCodecCallback</a>, <a class="el" href="classproxygen_1_1FakeHTTPCodecCallback.html#a83e8a0e41d47d585814fe8316ff919d3">proxygen::FakeHTTPCodecCallback</a>, <a class="el" href="classproxygen_1_1RFC1867Codec.html#a072b62abe677260b50cf8b2b5b93f9c2">proxygen::RFC1867Codec</a>, and <a class="el" href="classHTTP1xCodecCallback.html#ade76ef6d005c0b44518982f4c743f50c">HTTP1xCodecCallback</a>.</p>

<p>Referenced by <a class="el" href="HTTP2Codec_8cpp_source.html#l01614">proxygen::HTTP2Codec::checkConnectionError()</a>, <a class="el" href="SPDYCodec_8cpp_source.html#l01474">proxygen::SPDYCodec::failSession()</a>, <a class="el" href="SPDYCodec_8cpp_source.html#l01444">proxygen::SPDYCodec::failStream()</a>, <a class="el" href="HTTP1xCodec_8cpp_source.html#l00257">proxygen::HTTP1xCodec::onParserError()</a>, <a class="el" href="HTTP2Codec_8cpp_source.html#l00501">proxygen::HTTP2Codec::parseHeadersDecodeFrames()</a>, <a class="el" href="HTTP2Codec_8cpp_source.html#l01632">proxygen::HTTP2Codec::streamError()</a>, and <a class="el" href="HTTPDownstreamSessionTest_8cpp_source.html#l00802">TEST()</a>.</p>

</div>
</div>
<a class="anchor" id="abe873557040a9184715f7f5a47c863a1"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPCodec::Callback::onExMessageBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPMessage.html">HTTPMessage</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a new extended message is seen while parsing the ingress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream ID </td></tr>
    <tr><td class="paramname">controlStream</td><td>The stream ID of the associated stream, which can never be 0 </td></tr>
    <tr><td class="paramname">msg</td><td>A newly allocated <a class="el" href="classproxygen_1_1HTTPMessage.html">HTTPMessage</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classproxygen_1_1HTTPSession.html#a597d69aedaebffdb4c442ca9d1d6408b">proxygen::HTTPSession</a>, and <a class="el" href="classproxygen_1_1FakeHTTPCodecCallback.html#a4b5bd19125263aa65637b2f5aff8b415">proxygen::FakeHTTPCodecCallback</a>.</p>

<p>Definition at line <a class="el" href="HTTPCodec_8h_source.html#l00107">107</a> of file <a class="el" href="HTTPCodec_8h_source.html">HTTPCodec.h</a>.</p>

<p>Referenced by <a class="el" href="HTTP2Codec_8cpp_source.html#l00418">proxygen::HTTP2Codec::parseHeadersImpl()</a>.</p>
<div class="fragment"><div class="line"><a name="l00110"></a><span class="lineno">  110</span>&#160;                                                  {}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a43441f24ed1f9680a2909d1617822b61"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPCodec::Callback::onFrameHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called upon receipt of a frame header. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream_id</td><td>The stream ID </td></tr>
    <tr><td class="paramname">flags</td><td>The flags field of frame header </td></tr>
    <tr><td class="paramname">length</td><td>The length field of frame header </td></tr>
    <tr><td class="paramname">type</td><td>The type field of frame header </td></tr>
    <tr><td class="paramname">version</td><td>The version of frame (SPDY only) </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Not all protocols have frames. SPDY and HTTP/2 do, but HTTP/1.1 doesn't. </dd></dl>

<p>Reimplemented in <a class="el" href="classproxygen_1_1FakeHTTPCodecCallback.html#a722c3094de807039d40675071c028f43">proxygen::FakeHTTPCodecCallback</a>.</p>

<p>Definition at line <a class="el" href="HTTPCodec_8h_source.html#l00206">206</a> of file <a class="el" href="HTTPCodec_8h_source.html">HTTPCodec.h</a>.</p>

<p>Referenced by <a class="el" href="HTTP2Codec_8cpp_source.html#l00064">proxygen::HTTP2Codec::onIngress()</a>, and <a class="el" href="SPDYCodec_8cpp_source.html#l00246">proxygen::SPDYCodec::parseIngress()</a>.</p>
<div class="fragment"><div class="line"><a name="l00211"></a><span class="lineno">  211</span>&#160;                        {}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="acdc27546d6ace641570c28299d83898b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPCodec::Callback::onGenerateFrameHeader </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint8_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint16_t&#160;</td>
          <td class="paramname"> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called after a header frame is generated. This only applies to framed codecs. </p>

<p>Definition at line <a class="el" href="HTTPCodec_8h_source.html#l00283">283</a> of file <a class="el" href="HTTPCodec_8h_source.html">HTTPCodec.h</a>.</p>

<p>Referenced by <a class="el" href="HTTP2Codec_8cpp_source.html#l01251">proxygen::HTTP2Codec::generateHeaderCallbackWrapper()</a>.</p>
<div class="fragment"><div class="line"><a name="l00287"></a><span class="lineno">  287</span>&#160;                        {}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a782493dc0d063e7f5c626db2617d042b"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPCodec::Callback::onGoaway </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceproxygen.html#a3d6f6c837ecc1ee254de4e790826ae9b">ErrorCode</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; folly::IOBuf &gt;&#160;</td>
          <td class="paramname"> = <code><a class="el" href="http__parser__cpp_8cpp.html#ab979d9d4b4923f7c54d6caa6e1a61936">nullptr</a></code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called upon receipt of a goaway. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">lastGoodStreamID</td><td>Last successful stream created by the receiver </td></tr>
    <tr><td class="paramname">code</td><td>The code the connection was aborted with </td></tr>
    <tr><td class="paramname">debugData</td><td>The additional debug data for diagnostic purpose </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Not all protocols have goaways. SPDY does, but HTTP/1.1 doesn't. </dd></dl>

<p>Reimplemented in <a class="el" href="classproxygen_1_1HTTPSession.html#a22d185dd9d6777d445ae30269345c942">proxygen::HTTPSession</a>, <a class="el" href="classproxygen_1_1FakeHTTPCodecCallback.html#af0c6ee01c15862bc87e5938019426591">proxygen::FakeHTTPCodecCallback</a>, and <a class="el" href="classproxygen_1_1MockHTTPCodecCallback.html#ab9c7e41e4d0aeed9b01a64ea468492f3">proxygen::MockHTTPCodecCallback</a>.</p>

<p>Definition at line <a class="el" href="HTTPCodec_8h_source.html#l00220">220</a> of file <a class="el" href="HTTPCodec_8h_source.html">HTTPCodec.h</a>.</p>

<p>Referenced by <a class="el" href="SPDYCodec_8cpp_source.html#l01416">proxygen::SPDYCodec::onGoaway()</a>, and <a class="el" href="HTTP2Codec_8cpp_source.html#l00873">proxygen::HTTP2Codec::parseGoaway()</a>.</p>
<div class="fragment"><div class="line"><a name="l00223"></a><span class="lineno">  223</span>&#160;                                               {}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a7c462d2b3485d0d1077a9ba775f90ebc"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPCodec::Callback::onHeadersComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classproxygen_1_1HTTPMessage.html">HTTPMessage</a> &gt;&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when all the headers of an ingress message have been parsed </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream ID </td></tr>
    <tr><td class="paramname">msg</td><td>The message </td></tr>
    <tr><td class="paramname">size</td><td>Size of the ingress header </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classproxygen_1_1HTTPSession.html#a01cf2e4876e0d44c1b7974833bef3272">proxygen::HTTPSession</a>, <a class="el" href="classproxygen_1_1MockHTTPCodecCallback.html#a1844c9fda354a134d1d665b73037af6e">proxygen::MockHTTPCodecCallback</a>, <a class="el" href="classproxygen_1_1FakeHTTPCodecCallback.html#a3f55acceddc05d771c992c3a04a51f2f">proxygen::FakeHTTPCodecCallback</a>, <a class="el" href="classproxygen_1_1RFC1867Codec.html#a9e01714bafae9a4c2c5aaa7df2182974">proxygen::RFC1867Codec</a>, and <a class="el" href="classHTTP1xCodecCallback.html#a931173aed9988e11ed2222cf1545189e">HTTP1xCodecCallback</a>.</p>

<p>Referenced by <a class="el" href="HTTP1xCodec_8cpp_source.html#l00926">proxygen::HTTP1xCodec::onHeadersComplete()</a>, <a class="el" href="SPDYCodec_8cpp_source.html#l01238">proxygen::SPDYCodec::onSynCommon()</a>, and <a class="el" href="HTTP2Codec_8cpp_source.html#l00418">proxygen::HTTP2Codec::parseHeadersImpl()</a>.</p>

</div>
</div>
<a class="anchor" id="a7bcd0c639fd05f92b31806cee4f4b1aa"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPCodec::Callback::onMessageBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPMessage.html">HTTPMessage</a> *&#160;</td>
          <td class="paramname"><em>msg</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a new message is seen while parsing the ingress </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream ID </td></tr>
    <tr><td class="paramname">msg</td><td>A newly allocated <a class="el" href="classproxygen_1_1HTTPMessage.html">HTTPMessage</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classproxygen_1_1HTTPSession.html#a0a4087a0c6fbfbb6a419dff46c0d3517">proxygen::HTTPSession</a>, <a class="el" href="classproxygen_1_1FakeHTTPCodecCallback.html#ab67a7d12ac1032f91c90630bbbca2198">proxygen::FakeHTTPCodecCallback</a>, <a class="el" href="classproxygen_1_1RFC1867Codec.html#a68fcd8fdcd4cf0701b738580998c0973">proxygen::RFC1867Codec</a>, and <a class="el" href="classHTTP1xCodecCallback.html#a39aea280119e87229685df6b4b18dcbb">HTTP1xCodecCallback</a>.</p>

<p>Referenced by <a class="el" href="SPDYCodec_8cpp_source.html#l01271">proxygen::SPDYCodec::deliverOnMessageBegin()</a>, <a class="el" href="HTTP1xCodec_8cpp_source.html#l00817">proxygen::HTTP1xCodec::onMessageBegin()</a>, and <a class="el" href="HTTP2Codec_8cpp_source.html#l00418">proxygen::HTTP2Codec::parseHeadersImpl()</a>.</p>

</div>
</div>
<a class="anchor" id="a8b42c169cc7f48b42be7f97b463db08e"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPCodec::Callback::onMessageComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>upgrade</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called at end of a message (including body and trailers, if applicable) </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream ID </td></tr>
    <tr><td class="paramname">upgrade</td><td>Whether the connection has been upgraded to another protocol. </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classproxygen_1_1HTTPSession.html#a564c10e0a4a6fbf287eed792501337f8">proxygen::HTTPSession</a>, <a class="el" href="classproxygen_1_1FakeHTTPCodecCallback.html#af9282cb39daeaa5c68c7138fb4b6b788">proxygen::FakeHTTPCodecCallback</a>, <a class="el" href="classproxygen_1_1RFC1867Codec.html#ae24ab3cb16d38f484a3c659949c250b3">proxygen::RFC1867Codec</a>, and <a class="el" href="classHTTP1xCodecCallback.html#a7a8ad6d532d80bf525f344e24114fd00">HTTP1xCodecCallback</a>.</p>

<p>Referenced by <a class="el" href="HTTP2Codec_8cpp_source.html#l00246">proxygen::HTTP2Codec::handleEndStream()</a>, <a class="el" href="HTTP1xCodec_8cpp_source.html#l00231">proxygen::HTTP1xCodec::onIngressEOF()</a>, <a class="el" href="HTTP1xCodec_8cpp_source.html#l01180">proxygen::HTTP1xCodec::onMessageComplete()</a>, and <a class="el" href="SPDYCodec_8cpp_source.html#l00246">proxygen::SPDYCodec::parseIngress()</a>.</p>

</div>
</div>
<a class="anchor" id="a862f51146984af8fbb64d32d1d27f094"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual bool proxygen::HTTPCodec::Callback::onNativeProtocolUpgrade </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespaceproxygen.html#a470a61083ee151f964f0382f345a2b42">CodecProtocol</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPMessage.html">HTTPMessage</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called upon receipt of a valid protocol switch. Return false if protocol switch could not be completed. </p>

<p>Reimplemented in <a class="el" href="classproxygen_1_1FakeHTTPCodecCallback.html#a21710f2e103aba11c680e9369059013b">proxygen::FakeHTTPCodecCallback</a>, <a class="el" href="classproxygen_1_1HTTPUpstreamSession.html#a8b2225a822624032bbdd5985b8fef035">proxygen::HTTPUpstreamSession</a>, and <a class="el" href="classproxygen_1_1HTTPDownstreamSession.html#a1c526ad7c5af7bc309bfb4f1a9a4ea9b">proxygen::HTTPDownstreamSession</a>.</p>

<p>Definition at line <a class="el" href="HTTPCodec_8h_source.html#l00271">271</a> of file <a class="el" href="HTTPCodec_8h_source.html">HTTPCodec.h</a>.</p>

<p>Referenced by <a class="el" href="HTTP1xCodec_8cpp_source.html#l00926">proxygen::HTTP1xCodec::onHeadersComplete()</a>, and <a class="el" href="HTTP1xCodec_8cpp_source.html#l01180">proxygen::HTTP1xCodec::onMessageComplete()</a>.</p>
<div class="fragment"><div class="line"><a name="l00275"></a><span class="lineno">  275</span>&#160;                        {</div><div class="line"><a name="l00276"></a><span class="lineno">  276</span>&#160;      <span class="keywordflow">return</span> <span class="keyword">false</span>;</div><div class="line"><a name="l00277"></a><span class="lineno">  277</span>&#160;    }</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a6ebe6de42080d9b8834f48add6f63553"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPCodec::Callback::onPingReply </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called upon receipt of a ping reply </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uniqueID</td><td>Unique identifier for the ping </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Not all protocols have pings. SPDY does, but HTTP/1.1 doesn't. </dd></dl>

<p>Reimplemented in <a class="el" href="classproxygen_1_1HTTPSession.html#a1ce7c717bb5a5e5410a3f7f2506cd8a9">proxygen::HTTPSession</a>, and <a class="el" href="classproxygen_1_1FakeHTTPCodecCallback.html#a260f3b8e79817c12256b865d27d54e65">proxygen::FakeHTTPCodecCallback</a>.</p>

<p>Definition at line <a class="el" href="HTTPCodec_8h_source.html#l00237">237</a> of file <a class="el" href="HTTPCodec_8h_source.html">HTTPCodec.h</a>.</p>

<p>Referenced by <a class="el" href="SPDYCodec_8cpp_source.html#l01393">proxygen::SPDYCodec::onPing()</a>, and <a class="el" href="HTTP2Codec_8cpp_source.html#l00858">proxygen::HTTP2Codec::parsePing()</a>.</p>
<div class="fragment"><div class="line"><a name="l00237"></a><span class="lineno">  237</span>&#160;{}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a1740eddb4466d8d9a411f558d37c7d39"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPCodec::Callback::onPingRequest </td>
          <td>(</td>
          <td class="paramtype">uint64_t&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called upon receipt of a ping request </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">uniqueID</td><td>Unique identifier for the ping </td></tr>
  </table>
  </dd>
</dl>
<dl class="section note"><dt>Note</dt><dd>Not all protocols have pings. SPDY does, but HTTP/1.1 doesn't. </dd></dl>

<p>Reimplemented in <a class="el" href="classproxygen_1_1HTTPSession.html#ab5e3ba18cca07e6e6bfff73e1d549c21">proxygen::HTTPSession</a>, and <a class="el" href="classproxygen_1_1FakeHTTPCodecCallback.html#ac85d4d70ee22320b8e853d546ce9b593">proxygen::FakeHTTPCodecCallback</a>.</p>

<p>Definition at line <a class="el" href="HTTPCodec_8h_source.html#l00230">230</a> of file <a class="el" href="HTTPCodec_8h_source.html">HTTPCodec.h</a>.</p>

<p>Referenced by <a class="el" href="SPDYCodec_8cpp_source.html#l01393">proxygen::SPDYCodec::onPing()</a>, and <a class="el" href="HTTP2Codec_8cpp_source.html#l00858">proxygen::HTTP2Codec::parsePing()</a>.</p>
<div class="fragment"><div class="line"><a name="l00230"></a><span class="lineno">  230</span>&#160;{}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa3960bf891965283f9a99797af9e99b3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPCodec::Callback::onPriority </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="classproxygen_1_1HTTPMessage.html#a488cdeffada45d57bf30cf2b9059bd5a">HTTPMessage::HTTPPriority</a> &amp;&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called upon receipt of a priority frame, for protocols that support dynamic priority </p>

<p>Reimplemented in <a class="el" href="classproxygen_1_1HTTPSession.html#a1da743cba2417a010d2d1fa7a7333f79">proxygen::HTTPSession</a>, and <a class="el" href="classproxygen_1_1FakeHTTPCodecCallback.html#aa61996c525eee96c7bb27eb3653da527">proxygen::FakeHTTPCodecCallback</a>.</p>

<p>Definition at line <a class="el" href="HTTPCodec_8h_source.html#l00263">263</a> of file <a class="el" href="HTTPCodec_8h_source.html">HTTPCodec.h</a>.</p>

<p>Referenced by <a class="el" href="HTTP2Codec_8cpp_source.html#l00647">proxygen::HTTP2Codec::parsePriority()</a>.</p>
<div class="fragment"><div class="line"><a name="l00265"></a><span class="lineno">  265</span>&#160;                                          {}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a2a54bb421215a2929e2c8ee0d2112032"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPCodec::Callback::onPushMessageBegin </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPMessage.html">HTTPMessage</a> *&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when a new push message is seen while parsing the ingress.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream ID </td></tr>
    <tr><td class="paramname">assocStream</td><td>The stream ID of the associated stream, which can never be 0 </td></tr>
    <tr><td class="paramname">msg</td><td>A newly allocated <a class="el" href="classproxygen_1_1HTTPMessage.html">HTTPMessage</a> </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classproxygen_1_1HTTPSession.html#ac22c3f0f0f6c3162a805150faeae3577">proxygen::HTTPSession</a>, <a class="el" href="classproxygen_1_1FakeHTTPCodecCallback.html#a12590d00a1fdfec638b6f736d7af8991">proxygen::FakeHTTPCodecCallback</a>, and <a class="el" href="classHTTP1xCodecCallback.html#adcbd6ed2fa495238b09bf35a778e4900">HTTP1xCodecCallback</a>.</p>

<p>Definition at line <a class="el" href="HTTPCodec_8h_source.html#l00095">95</a> of file <a class="el" href="HTTPCodec_8h_source.html">HTTPCodec.h</a>.</p>

<p>Referenced by <a class="el" href="SPDYCodec_8cpp_source.html#l01271">proxygen::SPDYCodec::deliverOnMessageBegin()</a>, and <a class="el" href="HTTP2Codec_8cpp_source.html#l00418">proxygen::HTTP2Codec::parseHeadersImpl()</a>.</p>
<div class="fragment"><div class="line"><a name="l00097"></a><span class="lineno">   97</span>&#160;                                                    {}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a74342e68c4a6845289a3385f947d1b65"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPCodec::Callback::onSettings </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="namespaceproxygen.html#a178ae546fbff60576dc3e3ce2de52410">SettingsList</a> &amp;&#160;</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called upon receipt of a settings frame, for protocols that support settings.</p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">settings</td><td>a list of settings that were sent in the settings frame </td></tr>
  </table>
  </dd>
</dl>

<p>Reimplemented in <a class="el" href="classproxygen_1_1HTTPSession.html#a51b54c75597c9ead6142aa8c26689b09">proxygen::HTTPSession</a>, and <a class="el" href="classproxygen_1_1FakeHTTPCodecCallback.html#a05e83f25b2763f0916b71d59018b42ac">proxygen::FakeHTTPCodecCallback</a>.</p>

<p>Definition at line <a class="el" href="HTTPCodec_8h_source.html#l00251">251</a> of file <a class="el" href="HTTPCodec_8h_source.html">HTTPCodec.h</a>.</p>

<p>Referenced by <a class="el" href="HTTP2Codec_8cpp_source.html#l00725">proxygen::HTTP2Codec::handleSettings()</a>, and <a class="el" href="SPDYCodec_8cpp_source.html#l01345">proxygen::SPDYCodec::onSettings()</a>.</p>
<div class="fragment"><div class="line"><a name="l00251"></a><span class="lineno">  251</span>&#160;{}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="a9ec9c7daad56b25852e4d7b31ffc1ae7"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPCodec::Callback::onSettingsAck </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called upon receipt of a settings frame with ACK set, for protocols that support settings ack. </p>

<p>Reimplemented in <a class="el" href="classproxygen_1_1HTTPSession.html#a2761f5d6f21da00af36fe73385339e9a">proxygen::HTTPSession</a>, and <a class="el" href="classproxygen_1_1FakeHTTPCodecCallback.html#a5ad84649535a96761f540af001f38439">proxygen::FakeHTTPCodecCallback</a>.</p>

<p>Definition at line <a class="el" href="HTTPCodec_8h_source.html#l00257">257</a> of file <a class="el" href="HTTPCodec_8h_source.html">HTTPCodec.h</a>.</p>

<p>Referenced by <a class="el" href="HTTP2Codec_8cpp_source.html#l00715">proxygen::HTTP2Codec::handleSettingsAck()</a>.</p>
<div class="fragment"><div class="line"><a name="l00257"></a><span class="lineno">  257</span>&#160;{}</div></div><!-- fragment -->
</div>
</div>
<a class="anchor" id="aa3ecee42ce8c09840aa67ee824c5cfe3"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPCodec::Callback::onTrailersComplete </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>&#160;</td>
          <td class="paramname"><em>stream</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classproxygen_1_1HTTPHeaders.html">HTTPHeaders</a> &gt;&#160;</td>
          <td class="paramname"><em>trailers</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">pure virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called when all the trailers of an ingress message have been parsed, but only if the number of trailers is nonzero. </p><dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">stream</td><td>The stream ID </td></tr>
    <tr><td class="paramname">trailers</td><td>The message trailers </td></tr>
  </table>
  </dd>
</dl>

<p>Implemented in <a class="el" href="classproxygen_1_1HTTPSession.html#a78452f9b06f73e48e2397923fb71d0dd">proxygen::HTTPSession</a>, <a class="el" href="classproxygen_1_1MockHTTPCodecCallback.html#a9d4e0dded6c6f755ff821f73826c8944">proxygen::MockHTTPCodecCallback</a>, <a class="el" href="classproxygen_1_1FakeHTTPCodecCallback.html#a351269d6163acd4ebe7fc53427d37c30">proxygen::FakeHTTPCodecCallback</a>, <a class="el" href="classproxygen_1_1RFC1867Codec.html#a7fd36951ef46b15fdc75149fa3976d72">proxygen::RFC1867Codec</a>, and <a class="el" href="classHTTP1xCodecCallback.html#a90d3f9b28edbed340ce02d2eb83bbd16">HTTP1xCodecCallback</a>.</p>

<p>Referenced by <a class="el" href="HTTP1xCodec_8cpp_source.html#l01180">proxygen::HTTP1xCodec::onMessageComplete()</a>, and <a class="el" href="HTTP2Codec_8cpp_source.html#l00418">proxygen::HTTP2Codec::parseHeadersImpl()</a>.</p>

</div>
</div>
<a class="anchor" id="a2e07b2b70565c4f2782d8767abf0e780"></a>
<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">virtual void proxygen::HTTPCodec::Callback::onWindowUpdate </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classproxygen_1_1HTTPCodec.html#addee32fd97cd4864b2a4b2f8a99c11c1">StreamID</a>&#160;</td>
          <td class="paramname">, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">uint32_t&#160;</td>
          <td class="paramname">&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span><span class="mlabel">virtual</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Called upon receipt of a window update, for protocols that support flow control. For instance spdy/3 and higher. </p>

<p>Reimplemented in <a class="el" href="classproxygen_1_1HTTPSession.html#aa0fb58504e91e4f38601e2fdd0cebb42">proxygen::HTTPSession</a>, and <a class="el" href="classproxygen_1_1FakeHTTPCodecCallback.html#a5093f7de3631c3d81df1253e484d228b">proxygen::FakeHTTPCodecCallback</a>.</p>

<p>Definition at line <a class="el" href="HTTPCodec_8h_source.html#l00243">243</a> of file <a class="el" href="HTTPCodec_8h_source.html">HTTPCodec.h</a>.</p>

<p>Referenced by <a class="el" href="SPDYCodec_8cpp_source.html#l01439">proxygen::SPDYCodec::onWindowUpdate()</a>, and <a class="el" href="HTTP2Codec_8cpp_source.html#l00902">proxygen::HTTP2Codec::parseWindowUpdate()</a>.</p>
<div class="fragment"><div class="line"><a name="l00243"></a><span class="lineno">  243</span>&#160;{}</div></div><!-- fragment -->
</div>
</div>
<hr/>The documentation for this class was generated from the following file:<ul>
<li>proxygen/lib/http/codec/<a class="el" href="HTTPCodec_8h_source.html">HTTPCodec.h</a></li>
</ul>
</div><!-- contents -->
</div><!-- doc-content -->
<!-- start footer part -->
<div id="nav-path" class="navpath"><!-- id is needed for treeview function! -->
  <ul>
    <li class="navelem"><a class="el" href="namespaceproxygen.html">proxygen</a></li><li class="navelem"><a class="el" href="classproxygen_1_1HTTPCodec.html">HTTPCodec</a></li><li class="navelem"><a class="el" href="classproxygen_1_1HTTPCodec_1_1Callback.html">Callback</a></li>
    <li class="footer">Generated by
    <a href="http://www.doxygen.org/index.html">
    <img class="footer" src="doxygen.png" alt="doxygen"/></a> 1.8.11 </li>
  </ul>
</div>
</body>
</html>
