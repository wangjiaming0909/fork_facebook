\section{proxygen\+:\+:Structured\+Headers\+Buffer Class Reference}
\label{classproxygen_1_1StructuredHeadersBuffer}\index{proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}}


{\ttfamily \#include $<$Structured\+Headers\+Buffer.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Structured\+Headers\+Buffer} (const std\+::string \&s)
\item 
{\bf Structured\+Headers\+::\+Decode\+Error} {\bf parse\+Identifier} ({\bf Structured\+Header\+Item} \&result)
\item 
{\bf Structured\+Headers\+::\+Decode\+Error} {\bf parse\+Identifier} (std\+::string \&result)
\item 
{\bf Structured\+Headers\+::\+Decode\+Error} {\bf parse\+Item} ({\bf Structured\+Header\+Item} \&result)
\item 
{\bf Decode\+Error} {\bf remove\+Symbol} (const std\+::string \&symbol, bool strict)
\item 
{\bf Decode\+Error} {\bf remove\+Optional\+Whitespace} ()
\item 
bool {\bf is\+Empty} ()
\item 
{\bf Decode\+Error} {\bf handle\+Decode\+Error} (const {\bf Decode\+Error} \&err)
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Decode\+Error} {\bf parse\+Binary\+Content} ({\bf Structured\+Header\+Item} \&result)
\item 
{\bf Decode\+Error} {\bf parse\+Number} ({\bf Structured\+Header\+Item} \&result)
\item 
{\bf Decode\+Error} {\bf parse\+String} ({\bf Structured\+Header\+Item} \&result)
\item 
{\bf Decode\+Error} {\bf parse\+Integer} (const std\+::string \&input, {\bf Structured\+Header\+Item} \&result)
\item 
{\bf Decode\+Error} {\bf parse\+Float} (const std\+::string \&input, {\bf Structured\+Header\+Item} \&result)
\item 
char {\bf peek} ()
\item 
void {\bf advance\+Cursor} ()
\item 
int32\+\_\+t {\bf get\+Num\+Chars\+Parsed} ()
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
folly\+::\+String\+Piece {\bf content\+\_\+}
\item 
folly\+::\+String\+Piece {\bf original\+Content\+\_\+}
\end{DoxyCompactItemize}


\subsection{Detailed Description}


Definition at line 20 of file Structured\+Headers\+Buffer.\+h.



\subsection{Constructor \& Destructor Documentation}
\index{proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}!Structured\+Headers\+Buffer@{Structured\+Headers\+Buffer}}
\index{Structured\+Headers\+Buffer@{Structured\+Headers\+Buffer}!proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}}
\subsubsection[{Structured\+Headers\+Buffer(const std\+::string \&s)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+Structured\+Headers\+Buffer\+::\+Structured\+Headers\+Buffer (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{s}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}\label{classproxygen_1_1StructuredHeadersBuffer_aeb5e354d244311294677a95a54c88f17}


Definition at line 23 of file Structured\+Headers\+Buffer.\+h.


\begin{DoxyCode}
23                                                        :
24     content_(s),
25     originalContent_(s) \{\}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}!advance\+Cursor@{advance\+Cursor}}
\index{advance\+Cursor@{advance\+Cursor}!proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}}
\subsubsection[{advance\+Cursor()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Structured\+Headers\+Buffer\+::advance\+Cursor (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1StructuredHeadersBuffer_a82b7f82057bb2de73f36406e5119f96e}


Definition at line 281 of file Structured\+Headers\+Buffer.\+cpp.


\begin{DoxyCode}
281                                             \{
282   content_.advance(1);
283 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}!get\+Num\+Chars\+Parsed@{get\+Num\+Chars\+Parsed}}
\index{get\+Num\+Chars\+Parsed@{get\+Num\+Chars\+Parsed}!proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}}
\subsubsection[{get\+Num\+Chars\+Parsed()}]{\setlength{\rightskip}{0pt plus 5cm}int32\+\_\+t proxygen\+::\+Structured\+Headers\+Buffer\+::get\+Num\+Chars\+Parsed (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1StructuredHeadersBuffer_a1e13256afe049b9afa34daa8a7df373b}


Definition at line 289 of file Structured\+Headers\+Buffer.\+cpp.


\begin{DoxyCode}
289                                                    \{
290   \textcolor{keywordflow}{return} std::distance(originalContent_.begin(), content_.begin());
291 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}!handle\+Decode\+Error@{handle\+Decode\+Error}}
\index{handle\+Decode\+Error@{handle\+Decode\+Error}!proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}}
\subsubsection[{handle\+Decode\+Error(const Decode\+Error \&err)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decode\+Error} proxygen\+::\+Structured\+Headers\+Buffer\+::handle\+Decode\+Error (
\begin{DoxyParamCaption}
\item[{const {\bf Decode\+Error} \&}]{err}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1StructuredHeadersBuffer_a4481d25ba4baa86b0bcc5738ba6ac6db}


Definition at line 269 of file Structured\+Headers\+Buffer.\+cpp.



References proxygen\+::\+Structured\+Headers\+::decode\+Error\+Description, and proxygen\+::\+E\+R\+R\+OR.


\begin{DoxyCode}
269                                                                              \{
270   LOG\_EVERY\_N(ERROR, 1000) << \textcolor{stringliteral}{"Error message: "} <<
271     decodeErrorDescription.at(err) <<
272     \textcolor{stringliteral}{". Number of characters parsed before error:"} <<
273     getNumCharsParsed() << \textcolor{stringliteral}{". Header Content:"} << originalContent_.str();
274   \textcolor{keywordflow}{return} err;
275 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}!is\+Empty@{is\+Empty}}
\index{is\+Empty@{is\+Empty}!proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}}
\subsubsection[{is\+Empty()}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+Structured\+Headers\+Buffer\+::is\+Empty (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1StructuredHeadersBuffer_a1e0f7df48ddc2f356a1f224ca188dba4}


Definition at line 285 of file Structured\+Headers\+Buffer.\+cpp.


\begin{DoxyCode}
285                                       \{
286   \textcolor{keywordflow}{return} content_.begin() == content_.end();
287 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}!parse\+Binary\+Content@{parse\+Binary\+Content}}
\index{parse\+Binary\+Content@{parse\+Binary\+Content}!proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}}
\subsubsection[{parse\+Binary\+Content(\+Structured\+Header\+Item \&result)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decode\+Error} proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Binary\+Content (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Header\+Item} \&}]{result}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1StructuredHeadersBuffer_abb09e43bb12886e3f8e172e1c71de593}


Definition at line 97 of file Structured\+Headers\+Buffer.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::\+B\+I\+N\+A\+R\+Y\+C\+O\+N\+T\+E\+NT, proxygen\+::\+Structured\+Headers\+::decode\+Base64(), proxygen\+::\+Structured\+Headers\+::encode\+Base64(), proxygen\+::\+Structured\+Headers\+::\+I\+N\+V\+A\+L\+I\+D\+\_\+\+C\+H\+A\+R\+A\+C\+T\+ER, proxygen\+::\+Structured\+Headers\+::is\+Valid\+Encoded\+Binary\+Content(), proxygen\+::\+Structured\+Headers\+::is\+Valid\+Encoded\+Binary\+Content\+Char(), proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, proxygen\+::\+Structured\+Headers\+::\+U\+N\+D\+E\+C\+O\+D\+E\+A\+B\+L\+E\+\_\+\+B\+I\+N\+A\+R\+Y\+\_\+\+C\+O\+N\+T\+E\+NT, proxygen\+::\+Structured\+Headers\+::\+U\+N\+E\+X\+P\+E\+C\+T\+E\+D\+\_\+\+E\+N\+D\+\_\+\+O\+F\+\_\+\+B\+U\+F\+F\+ER, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
98                                 \{
99 
100   std::string outputString;
101   \textcolor{keywordflow}{if} (isEmpty()) \{
102     \textcolor{keywordflow}{return} handleDecodeError(DecodeError::UNEXPECTED\_END\_OF\_BUFFER);
103   \}
104 
105   \textcolor{keywordflow}{if} (peek() != \textcolor{charliteral}{'*'}) \{
106     \textcolor{keywordflow}{return} handleDecodeError(DecodeError::INVALID\_CHARACTER);
107   \}
108 
109   advanceCursor();
110 
111   \textcolor{keywordflow}{while} (!isEmpty()) \{
112     \textcolor{keywordtype}{char} current = peek();
113     advanceCursor();
114     \textcolor{keywordflow}{if} (current == \textcolor{charliteral}{'*'}) \{
115       \textcolor{keywordflow}{if} (!isValidEncodedBinaryContent(
116          outputString)) \{
117         \textcolor{keywordflow}{return} handleDecodeError(DecodeError::UNDECODEABLE\_BINARY\_CONTENT);
118       \}
119 
120       std::string decodedContent = decodeBase64(outputString);
121       \textcolor{keywordflow}{if} (encodeBase64(decodedContent) != outputString) \{
122         \textcolor{keywordflow}{return} handleDecodeError(DecodeError::UNDECODEABLE\_BINARY\_CONTENT);
123       \}
124 
125       result.value = std::move(decodedContent);
126       result.tag = StructuredHeaderItem::Type::BINARYCONTENT;
127       \textcolor{keywordflow}{return} DecodeError::OK;
128     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!isValidEncodedBinaryContentChar(
129         current)) \{
130       \textcolor{keywordflow}{return} handleDecodeError(DecodeError::INVALID\_CHARACTER);
131     \} \textcolor{keywordflow}{else} \{
132       outputString.push\_back(current);
133     \}
134   \}
135 
136   \textcolor{keywordflow}{return} handleDecodeError(DecodeError::UNEXPECTED\_END\_OF\_BUFFER);
137 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}!parse\+Float@{parse\+Float}}
\index{parse\+Float@{parse\+Float}!proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}}
\subsubsection[{parse\+Float(const std\+::string \&input, Structured\+Header\+Item \&result)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decode\+Error} proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Float (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{input, }
\item[{{\bf Structured\+Header\+Item} \&}]{result}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1StructuredHeadersBuffer_aa584c9fcb3e6c77ed9077cda20a1d717}


Definition at line 191 of file Structured\+Headers\+Buffer.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::\+D\+O\+U\+B\+LE, proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, proxygen\+::\+Structured\+Headers\+::\+U\+N\+P\+A\+R\+S\+E\+A\+B\+L\+E\+\_\+\+N\+U\+M\+E\+R\+I\+C\+\_\+\+T\+Y\+PE, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
192                                 \{
193 
194   \textcolor{keywordflow}{try} \{
195     result.value = boost::lexical\_cast<\textcolor{keywordtype}{double}>(input);
196     result.tag = StructuredHeaderItem::Type::DOUBLE;
197   \} \textcolor{keywordflow}{catch} (boost::bad\_lexical\_cast &) \{
198     \textcolor{keywordflow}{return} handleDecodeError(DecodeError::UNPARSEABLE\_NUMERIC\_TYPE);
199   \}
200   \textcolor{keywordflow}{return} DecodeError::OK;
201 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}!parse\+Identifier@{parse\+Identifier}}
\index{parse\+Identifier@{parse\+Identifier}!proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}}
\subsubsection[{parse\+Identifier(\+Structured\+Header\+Item \&result)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decode\+Error} proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Identifier (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Header\+Item} \&}]{result}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1StructuredHeadersBuffer_ac6b3cf28d25fcd64f6271343ab0e0c90}


Definition at line 139 of file Structured\+Headers\+Buffer.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::\+I\+D\+E\+N\+T\+I\+F\+I\+ER, proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.



Referenced by proxygen\+::\+T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
140                                 \{
141 
142   std::string outputString;
143 
144   \textcolor{keyword}{auto} err = parseIdentifier(outputString);
145   \textcolor{keywordflow}{if} (err != DecodeError::OK) \{
146     \textcolor{keywordflow}{return} err;
147   \}
148 
149   result.value = outputString;
150   result.tag = StructuredHeaderItem::Type::IDENTIFIER;
151 
152   \textcolor{keywordflow}{return} DecodeError::OK;
153 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}!parse\+Identifier@{parse\+Identifier}}
\index{parse\+Identifier@{parse\+Identifier}!proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}}
\subsubsection[{parse\+Identifier(std\+::string \&result)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decode\+Error} proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Identifier (
\begin{DoxyParamCaption}
\item[{std\+::string \&}]{result}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1StructuredHeadersBuffer_ac2cff27f69b8301ed1ac8b581fe6a27c}


Definition at line 155 of file Structured\+Headers\+Buffer.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+I\+N\+V\+A\+L\+I\+D\+\_\+\+C\+H\+A\+R\+A\+C\+T\+ER, proxygen\+::\+Structured\+Headers\+::is\+Lc\+Alpha(), proxygen\+::\+Structured\+Headers\+::is\+Valid\+Identifier\+Char(), proxygen\+::\+Structured\+Headers\+::\+OK, and proxygen\+::\+Structured\+Headers\+::\+U\+N\+E\+X\+P\+E\+C\+T\+E\+D\+\_\+\+E\+N\+D\+\_\+\+O\+F\+\_\+\+B\+U\+F\+F\+ER.


\begin{DoxyCode}
156                      \{
157 
158   \textcolor{keywordflow}{if} (isEmpty()) \{
159     \textcolor{keywordflow}{return} handleDecodeError(DecodeError::UNEXPECTED\_END\_OF\_BUFFER);
160   \}
161 
162   \textcolor{keywordflow}{if} (!isLcAlpha(peek())) \{
163     \textcolor{keywordflow}{return} handleDecodeError(DecodeError::INVALID\_CHARACTER);
164   \}
165 
166   \textcolor{keywordflow}{while} (!isEmpty()) \{
167     \textcolor{keywordtype}{char} current = peek();
168     \textcolor{keywordflow}{if} (!isValidIdentifierChar(current)) \{
169       \textcolor{keywordflow}{break};
170     \} \textcolor{keywordflow}{else} \{
171       advanceCursor();
172       result.push\_back(current);
173     \}
174   \}
175 
176   \textcolor{keywordflow}{return} DecodeError::OK;
177 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}!parse\+Integer@{parse\+Integer}}
\index{parse\+Integer@{parse\+Integer}!proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}}
\subsubsection[{parse\+Integer(const std\+::string \&input, Structured\+Header\+Item \&result)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decode\+Error} proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Integer (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{input, }
\item[{{\bf Structured\+Header\+Item} \&}]{result}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1StructuredHeadersBuffer_a6c9c8836431908cb5900f1dcb578e883}


Definition at line 179 of file Structured\+Headers\+Buffer.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::\+I\+N\+T64, proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, proxygen\+::\+Structured\+Headers\+::\+U\+N\+P\+A\+R\+S\+E\+A\+B\+L\+E\+\_\+\+N\+U\+M\+E\+R\+I\+C\+\_\+\+T\+Y\+PE, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
180                                 \{
181 
182   \textcolor{keywordflow}{try} \{
183     result.value = boost::lexical\_cast<int64\_t>(input);
184     result.tag = StructuredHeaderItem::Type::INT64;
185   \} \textcolor{keywordflow}{catch} (boost::bad\_lexical\_cast &) \{
186     \textcolor{keywordflow}{return} handleDecodeError(DecodeError::UNPARSEABLE\_NUMERIC\_TYPE);
187   \}
188   \textcolor{keywordflow}{return} DecodeError::OK;
189 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}!parse\+Item@{parse\+Item}}
\index{parse\+Item@{parse\+Item}!proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}}
\subsubsection[{parse\+Item(\+Structured\+Header\+Item \&result)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decode\+Error} proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Header\+Item} \&}]{result}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1StructuredHeadersBuffer_a391402cf83d1616d64fd695a981bc68e}


Definition at line 19 of file Structured\+Headers\+Buffer.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+I\+N\+V\+A\+L\+I\+D\+\_\+\+C\+H\+A\+R\+A\+C\+T\+ER, and proxygen\+::\+Structured\+Headers\+::\+U\+N\+E\+X\+P\+E\+C\+T\+E\+D\+\_\+\+E\+N\+D\+\_\+\+O\+F\+\_\+\+B\+U\+F\+F\+ER.



Referenced by proxygen\+::\+T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
19                                                                            \{
20 
21   removeOptionalWhitespace();
22 
23   \textcolor{keywordflow}{if} (isEmpty()) \{
24     \textcolor{keywordflow}{return} handleDecodeError(DecodeError::UNEXPECTED\_END\_OF\_BUFFER);
25   \} \textcolor{keywordflow}{else} \{
26     \textcolor{keywordtype}{char} firstCharacter = peek();
27     \textcolor{keywordflow}{if} (firstCharacter == \textcolor{charliteral}{'"'}) \{
28       \textcolor{keywordflow}{return} parseString(result);
29     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (firstCharacter == \textcolor{charliteral}{'*'}) \{
30       \textcolor{keywordflow}{return} parseBinaryContent(result);
31     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (std::isdigit(firstCharacter) || firstCharacter == \textcolor{charliteral}{'-'}) \{
32       \textcolor{keywordflow}{return} parseNumber(result);
33     \} \textcolor{keywordflow}{else} \{
34       \textcolor{keywordflow}{return} handleDecodeError(DecodeError::INVALID\_CHARACTER);
35     \}
36   \}
37 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}!parse\+Number@{parse\+Number}}
\index{parse\+Number@{parse\+Number}!proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}}
\subsubsection[{parse\+Number(\+Structured\+Header\+Item \&result)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decode\+Error} proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Number (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Header\+Item} \&}]{result}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1StructuredHeadersBuffer_acb70b0048ce2a75b2131101137b40640}


Definition at line 39 of file Structured\+Headers\+Buffer.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::\+D\+O\+U\+B\+LE, proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::\+I\+N\+T64, proxygen\+::\+Structured\+Headers\+::\+I\+N\+V\+A\+L\+I\+D\+\_\+\+C\+H\+A\+R\+A\+C\+T\+ER, proxygen\+::\+Structured\+Headers\+::k\+Max\+Valid\+Float\+Length, proxygen\+::\+Structured\+Headers\+::k\+Max\+Valid\+Integer\+Length, proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+::\+U\+N\+E\+X\+P\+E\+C\+T\+E\+D\+\_\+\+E\+N\+D\+\_\+\+O\+F\+\_\+\+B\+U\+F\+F\+ER, and proxygen\+::\+Structured\+Headers\+::\+V\+A\+L\+U\+E\+\_\+\+T\+O\+O\+\_\+\+L\+O\+NG.


\begin{DoxyCode}
39                                                                              \{
40   \textcolor{keyword}{auto} type = StructuredHeaderItem::Type::INT64;
41 
42   \textcolor{keywordtype}{bool} positive = \textcolor{keyword}{true};
43   std::string input;
44 
45   \textcolor{keywordflow}{if} (isEmpty()) \{
46     \textcolor{keywordflow}{return} handleDecodeError(DecodeError::UNEXPECTED\_END\_OF\_BUFFER);
47   \}
48 
49   \textcolor{keywordflow}{if} (peek() == \textcolor{charliteral}{'-'}) \{
50     advanceCursor();
51     positive = \textcolor{keyword}{false};
52     input.push\_back(\textcolor{charliteral}{'-'});
53   \}
54 
55   \textcolor{keywordflow}{if} (isEmpty()) \{
56     \textcolor{keywordflow}{return} handleDecodeError(DecodeError::UNEXPECTED\_END\_OF\_BUFFER);
57   \}
58 
59   \textcolor{keywordflow}{if} (!std::isdigit(peek())) \{
60     \textcolor{keywordflow}{return} handleDecodeError(DecodeError::INVALID\_CHARACTER);
61   \}
62 
63   \textcolor{keywordflow}{while} (!isEmpty()) \{
64     \textcolor{keywordtype}{char} current = peek();
65     \textcolor{keywordflow}{if} (std::isdigit(current)) \{
66       input.push\_back(current);
67       advanceCursor();
68     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type == StructuredHeaderItem::Type::INT64 && current == \textcolor{charliteral}{'.'}) \{
69       type = StructuredHeaderItem::Type::DOUBLE;
70       input.push\_back(current);
71       advanceCursor();
72     \} \textcolor{keywordflow}{else} \{
73       \textcolor{keywordflow}{break};
74     \}
75 
76     \textcolor{keywordtype}{int} numDigits = input.length() - (positive ? 0 : 1);
77     \textcolor{keywordflow}{if} (type == StructuredHeaderItem::Type::INT64 &&
78        numDigits > StructuredHeaders::kMaxValidIntegerLength) \{
79       \textcolor{keywordflow}{return} handleDecodeError(DecodeError::VALUE\_TOO\_LONG);
80     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (type == StructuredHeaderItem::Type::DOUBLE &&
81        numDigits > StructuredHeaders::kMaxValidFloatLength) \{
82       \textcolor{keywordflow}{return} handleDecodeError(DecodeError::VALUE\_TOO\_LONG);
83     \}
84   \}
85 
86   \textcolor{keywordflow}{if} (type == StructuredHeaderItem::Type::INT64) \{
87     \textcolor{keywordflow}{return} parseInteger(input, result);
88   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (input.back() == \textcolor{charliteral}{'.'}) \{
89     \textcolor{keywordflow}{return} handleDecodeError(DecodeError::INVALID\_CHARACTER);
90   \} \textcolor{keywordflow}{else} \{
91     \textcolor{keywordflow}{return} parseFloat(input, result);
92   \}
93 
94   \textcolor{keywordflow}{return} DecodeError::OK;
95 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}!parse\+String@{parse\+String}}
\index{parse\+String@{parse\+String}!proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}}
\subsubsection[{parse\+String(\+Structured\+Header\+Item \&result)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decode\+Error} proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+String (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Header\+Item} \&}]{result}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1StructuredHeadersBuffer_aedc382a7d3ae19045d2f3d7db90b31c0}


Definition at line 203 of file Structured\+Headers\+Buffer.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+I\+N\+V\+A\+L\+I\+D\+\_\+\+C\+H\+A\+R\+A\+C\+T\+ER, proxygen\+::\+Structured\+Headers\+::is\+Valid\+String\+Char(), proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::\+S\+T\+R\+I\+NG, proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, proxygen\+::\+Structured\+Headers\+::\+U\+N\+E\+X\+P\+E\+C\+T\+E\+D\+\_\+\+E\+N\+D\+\_\+\+O\+F\+\_\+\+B\+U\+F\+F\+ER, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
203                                                                              \{
204 
205   std::string outputString;
206 
207   \textcolor{keywordflow}{if} (isEmpty()) \{
208     \textcolor{keywordflow}{return} handleDecodeError(DecodeError::UNEXPECTED\_END\_OF\_BUFFER);
209   \}
210 
211   \textcolor{keywordflow}{if} (peek() != \textcolor{charliteral}{'"'}) \{
212     \textcolor{keywordflow}{return} handleDecodeError(DecodeError::INVALID\_CHARACTER);
213   \}
214 
215   advanceCursor();
216 
217   \textcolor{keywordflow}{while} (!isEmpty()) \{
218     \textcolor{keywordtype}{char} current = peek();
219     \textcolor{keywordflow}{if} (current == \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}) \{
220       advanceCursor();
221       \textcolor{keywordflow}{if} (isEmpty()) \{
222         \textcolor{keywordflow}{return} handleDecodeError(DecodeError::UNEXPECTED\_END\_OF\_BUFFER);
223       \} \textcolor{keywordflow}{else} \{
224         \textcolor{keywordtype}{char} nextChar = peek();
225         advanceCursor();
226         \textcolor{keywordflow}{if} (nextChar != \textcolor{charliteral}{'"'} && nextChar != \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}) \{
227           \textcolor{keywordflow}{return} handleDecodeError(DecodeError::INVALID\_CHARACTER);
228         \}
229         outputString.push\_back(nextChar);
230       \}
231     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (current == \textcolor{charliteral}{'"'}) \{
232       advanceCursor();
233       result.value = outputString;
234       result.tag = StructuredHeaderItem::Type::STRING;
235       \textcolor{keywordflow}{return} DecodeError::OK;
236     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!isValidStringChar(current)) \{
237       \textcolor{keywordflow}{return} handleDecodeError(DecodeError::INVALID\_CHARACTER);
238     \} \textcolor{keywordflow}{else} \{
239       advanceCursor();
240       outputString.push\_back(current);
241     \}
242   \}
243 
244   \textcolor{keywordflow}{return} handleDecodeError(DecodeError::UNEXPECTED\_END\_OF\_BUFFER);
245 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}!peek@{peek}}
\index{peek@{peek}!proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}}
\subsubsection[{peek()}]{\setlength{\rightskip}{0pt plus 5cm}char proxygen\+::\+Structured\+Headers\+Buffer\+::peek (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1StructuredHeadersBuffer_a4d8baea210b7d4215cc6026ee9af2d6b}


Definition at line 277 of file Structured\+Headers\+Buffer.\+cpp.


\begin{DoxyCode}
277                                    \{
278   \textcolor{keywordflow}{return} *content_.begin();
279 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}!remove\+Optional\+Whitespace@{remove\+Optional\+Whitespace}}
\index{remove\+Optional\+Whitespace@{remove\+Optional\+Whitespace}!proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}}
\subsubsection[{remove\+Optional\+Whitespace()}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decode\+Error} proxygen\+::\+Structured\+Headers\+Buffer\+::remove\+Optional\+Whitespace (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1StructuredHeadersBuffer_aaf73b4b6ead40c62408fce812d310097}


Definition at line 247 of file Structured\+Headers\+Buffer.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK.


\begin{DoxyCode}
247                                                               \{
248   \textcolor{keywordflow}{while} (peek() == \textcolor{charliteral}{' '} || peek() == \textcolor{charliteral}{'\(\backslash\)t'}) \{
249     advanceCursor();
250   \}
251   \textcolor{keywordflow}{return} DecodeError::OK;
252 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}!remove\+Symbol@{remove\+Symbol}}
\index{remove\+Symbol@{remove\+Symbol}!proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}}
\subsubsection[{remove\+Symbol(const std\+::string \&symbol, bool strict)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decode\+Error} proxygen\+::\+Structured\+Headers\+Buffer\+::remove\+Symbol (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{symbol, }
\item[{bool}]{strict}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1StructuredHeadersBuffer_acccbd01ee3b79d5977fc4731e975437a}


Definition at line 254 of file Structured\+Headers\+Buffer.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+I\+N\+V\+A\+L\+I\+D\+\_\+\+C\+H\+A\+R\+A\+C\+T\+ER, and proxygen\+::\+Structured\+Headers\+::\+OK.



Referenced by proxygen\+::\+T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
255                \{
256 
257   \textcolor{keywordflow}{if} (content_.startsWith(symbol)) \{
258     content_.advance(symbol.length());
259     \textcolor{keywordflow}{return} DecodeError::OK;
260   \} \textcolor{keywordflow}{else} \{
261     \textcolor{keywordflow}{if} (strict) \{
262       \textcolor{comment}{// Do some error logging}
263       \textcolor{keywordflow}{return} handleDecodeError(DecodeError::INVALID\_CHARACTER);
264     \}
265     \textcolor{keywordflow}{return} DecodeError::INVALID\_CHARACTER;
266   \}
267 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}!content\+\_\+@{content\+\_\+}}
\index{content\+\_\+@{content\+\_\+}!proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}}
\subsubsection[{content\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+String\+Piece proxygen\+::\+Structured\+Headers\+Buffer\+::content\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1StructuredHeadersBuffer_ad8382b8a906f988ab748a15a4c097908}


Definition at line 67 of file Structured\+Headers\+Buffer.\+h.

\index{proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}!original\+Content\+\_\+@{original\+Content\+\_\+}}
\index{original\+Content\+\_\+@{original\+Content\+\_\+}!proxygen\+::\+Structured\+Headers\+Buffer@{proxygen\+::\+Structured\+Headers\+Buffer}}
\subsubsection[{original\+Content\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+String\+Piece proxygen\+::\+Structured\+Headers\+Buffer\+::original\+Content\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1StructuredHeadersBuffer_ab8306a384ece4a4e16b08c3da9867ec7}


Definition at line 68 of file Structured\+Headers\+Buffer.\+h.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
proxygen/lib/http/structuredheaders/{\bf Structured\+Headers\+Buffer.\+h}\item 
proxygen/lib/http/structuredheaders/{\bf Structured\+Headers\+Buffer.\+cpp}\end{DoxyCompactItemize}
