\section{proxygen\+:\+:H\+P\+A\+C\+K\+Decoder Class Reference}
\label{classproxygen_1_1HPACKDecoder}\index{proxygen\+::\+H\+P\+A\+C\+K\+Decoder@{proxygen\+::\+H\+P\+A\+C\+K\+Decoder}}


{\ttfamily \#include $<$H\+P\+A\+C\+K\+Decoder.\+h$>$}

Inheritance diagram for proxygen\+:\+:H\+P\+A\+C\+K\+Decoder\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classproxygen_1_1HPACKDecoder}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf H\+P\+A\+C\+K\+Decoder} (uint32\+\_\+t table\+Size={\bf H\+P\+A\+C\+K\+::k\+Table\+Size}, uint32\+\_\+t max\+Uncompressed={\bf Header\+Codec\+::k\+Max\+Uncompressed})
\item 
void {\bf decode\+Streaming} (folly\+::io\+::\+Cursor \&cursor, uint32\+\_\+t total\+Bytes, {\bf H\+P\+A\+C\+K\+::\+Streaming\+Callback} $\ast$streaming\+Cb)
\item 
void {\bf set\+Header\+Table\+Max\+Size} (uint32\+\_\+t max\+Size)
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
bool {\bf is\+Valid} (uint32\+\_\+t index)
\item 
uint32\+\_\+t {\bf decode\+Indexed\+Header} ({\bf H\+P\+A\+C\+K\+Decode\+Buffer} \&dbuf, {\bf H\+P\+A\+C\+K\+::\+Streaming\+Callback} $\ast$streaming\+Cb, {\bf headers\+\_\+t} $\ast$emitted)
\item 
uint32\+\_\+t {\bf decode\+Literal\+Header} ({\bf H\+P\+A\+C\+K\+Decode\+Buffer} \&dbuf, {\bf H\+P\+A\+C\+K\+::\+Streaming\+Callback} $\ast$streaming\+Cb, {\bf headers\+\_\+t} $\ast$emitted)
\item 
uint32\+\_\+t {\bf decode\+Header} ({\bf H\+P\+A\+C\+K\+Decode\+Buffer} \&dbuf, {\bf H\+P\+A\+C\+K\+::\+Streaming\+Callback} $\ast$streaming\+Cb, {\bf headers\+\_\+t} $\ast$emitted)
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}


Definition at line 22 of file H\+P\+A\+C\+K\+Decoder.\+h.



\subsection{Constructor \& Destructor Documentation}
\index{proxygen\+::\+H\+P\+A\+C\+K\+Decoder@{proxygen\+::\+H\+P\+A\+C\+K\+Decoder}!H\+P\+A\+C\+K\+Decoder@{H\+P\+A\+C\+K\+Decoder}}
\index{H\+P\+A\+C\+K\+Decoder@{H\+P\+A\+C\+K\+Decoder}!proxygen\+::\+H\+P\+A\+C\+K\+Decoder@{proxygen\+::\+H\+P\+A\+C\+K\+Decoder}}
\subsubsection[{H\+P\+A\+C\+K\+Decoder(uint32\+\_\+t table\+Size=\+H\+P\+A\+C\+K\+::k\+Table\+Size, uint32\+\_\+t max\+Uncompressed=\+Header\+Codec\+::k\+Max\+Uncompressed)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+::\+H\+P\+A\+C\+K\+Decoder (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{table\+Size = {\ttfamily {\bf H\+P\+A\+C\+K\+::k\+Table\+Size}}, }
\item[{uint32\+\_\+t}]{max\+Uncompressed = {\ttfamily {\bf Header\+Codec\+::k\+Max\+Uncompressed}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}\label{classproxygen_1_1HPACKDecoder_ae3c13bcf1c64fba35387e6acf0aa8468}


Definition at line 25 of file H\+P\+A\+C\+K\+Decoder.\+h.



References decode\+Streaming().


\begin{DoxyCode}
28       : HPACKDecoderBase(tableSize, maxUncompressed),
29         HPACKContext(tableSize) \{\}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{proxygen\+::\+H\+P\+A\+C\+K\+Decoder@{proxygen\+::\+H\+P\+A\+C\+K\+Decoder}!decode\+Header@{decode\+Header}}
\index{decode\+Header@{decode\+Header}!proxygen\+::\+H\+P\+A\+C\+K\+Decoder@{proxygen\+::\+H\+P\+A\+C\+K\+Decoder}}
\subsubsection[{decode\+Header(\+H\+P\+A\+C\+K\+Decode\+Buffer \&dbuf, H\+P\+A\+C\+K\+::\+Streaming\+Callback $\ast$streaming\+Cb, headers\+\_\+t $\ast$emitted)}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+::decode\+Header (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Decode\+Buffer} \&}]{dbuf, }
\item[{{\bf H\+P\+A\+C\+K\+::\+Streaming\+Callback} $\ast$}]{streaming\+Cb, }
\item[{{\bf headers\+\_\+t} $\ast$}]{emitted}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HPACKDecoder_a271a569db5151a078f64d0efa417ee34}


Definition at line 130 of file H\+P\+A\+C\+K\+Decoder.\+cpp.



References decode\+Indexed\+Header(), decode\+Literal\+Header(), proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+Base\+::handle\+Table\+Size\+Update(), proxygen\+::\+H\+P\+A\+C\+K\+::\+I\+N\+D\+E\+X\+\_\+\+R\+EF, proxygen\+::\+H\+P\+A\+C\+K\+::\+L\+I\+T\+E\+R\+A\+L\+\_\+\+I\+N\+C\+\_\+\+I\+N\+D\+EX, proxygen\+::\+H\+P\+A\+C\+K\+Decode\+Buffer\+::peek(), proxygen\+::\+H\+P\+A\+C\+K\+Context\+::table\+\_\+, and proxygen\+::\+H\+P\+A\+C\+K\+::\+T\+A\+B\+L\+E\+\_\+\+S\+I\+Z\+E\+\_\+\+U\+P\+D\+A\+TE.



Referenced by decode\+Streaming(), and set\+Header\+Table\+Max\+Size().


\begin{DoxyCode}
133                         \{
134   uint8\_t byte = dbuf.peek();
135   \textcolor{keywordflow}{if} (byte & HPACK::INDEX_REF.code) \{
136     \textcolor{keywordflow}{return} decodeIndexedHeader(dbuf, streamingCb, emitted);
137   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (byte & HPACK::LITERAL_INC_INDEX.code) \{
138     \textcolor{comment}{// else it's fine, fall through to decodeLiteralHeader}
139   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (byte & HPACK::TABLE_SIZE_UPDATE.code) \{
140     handleTableSizeUpdate(dbuf, table_);
141     \textcolor{keywordflow}{return} 0;
142   \} \textcolor{comment}{// else LITERAL}
143   \textcolor{comment}{// LITERAL\_NO\_INDEXING or LITERAL\_INCR\_INDEXING}
144   \textcolor{keywordflow}{return} decodeLiteralHeader(dbuf, streamingCb, emitted);
145 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+P\+A\+C\+K\+Decoder@{proxygen\+::\+H\+P\+A\+C\+K\+Decoder}!decode\+Indexed\+Header@{decode\+Indexed\+Header}}
\index{decode\+Indexed\+Header@{decode\+Indexed\+Header}!proxygen\+::\+H\+P\+A\+C\+K\+Decoder@{proxygen\+::\+H\+P\+A\+C\+K\+Decoder}}
\subsubsection[{decode\+Indexed\+Header(\+H\+P\+A\+C\+K\+Decode\+Buffer \&dbuf, H\+P\+A\+C\+K\+::\+Streaming\+Callback $\ast$streaming\+Cb, headers\+\_\+t $\ast$emitted)}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+::decode\+Indexed\+Header (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Decode\+Buffer} \&}]{dbuf, }
\item[{{\bf H\+P\+A\+C\+K\+::\+Streaming\+Callback} $\ast$}]{streaming\+Cb, }
\item[{{\bf headers\+\_\+t} $\ast$}]{emitted}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HPACKDecoder_a60b39c6ec89f4f48e2c0edbc744582d7}


Definition at line 101 of file H\+P\+A\+C\+K\+Decoder.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Decode\+Buffer\+::decode\+Integer(), proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+Base\+::emit(), proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+Base\+::err\+\_\+, proxygen\+::\+E\+R\+R\+OR, proxygen\+::\+H\+P\+A\+C\+K\+Context\+::get\+Header(), proxygen\+::\+H\+P\+A\+C\+K\+::\+I\+N\+D\+E\+X\+\_\+\+R\+EF, proxygen\+::\+H\+P\+A\+C\+K\+::\+I\+N\+V\+A\+L\+I\+D\+\_\+\+I\+N\+D\+EX, is\+Valid(), and proxygen\+::\+H\+P\+A\+C\+K\+::\+N\+O\+NE.



Referenced by decode\+Header(), and set\+Header\+Table\+Max\+Size().


\begin{DoxyCode}
104                         \{
105   uint64\_t index;
106   err_ = dbuf.decodeInteger(HPACK::INDEX_REF.prefixLength, index);
107   \textcolor{keywordflow}{if} (err_ != HPACK::DecodeError::NONE) \{
108     LOG(ERROR) << \textcolor{stringliteral}{"Decode error decoding index err\_="} << err_;
109     \textcolor{keywordflow}{return} 0;
110   \}
111   \textcolor{comment}{// validate the index}
112   \textcolor{keywordflow}{if} (index == 0 || !isValid(index)) \{
113     LOG(ERROR) << \textcolor{stringliteral}{"received invalid index: "} << index;
114     err_ = HPACK::DecodeError::INVALID_INDEX;
115     \textcolor{keywordflow}{return} 0;
116   \}
117 
118   \textcolor{keyword}{auto}& header = getHeader(index);
119   \textcolor{keywordflow}{return} emit(header, streamingCb, emitted);
120 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+P\+A\+C\+K\+Decoder@{proxygen\+::\+H\+P\+A\+C\+K\+Decoder}!decode\+Literal\+Header@{decode\+Literal\+Header}}
\index{decode\+Literal\+Header@{decode\+Literal\+Header}!proxygen\+::\+H\+P\+A\+C\+K\+Decoder@{proxygen\+::\+H\+P\+A\+C\+K\+Decoder}}
\subsubsection[{decode\+Literal\+Header(\+H\+P\+A\+C\+K\+Decode\+Buffer \&dbuf, H\+P\+A\+C\+K\+::\+Streaming\+Callback $\ast$streaming\+Cb, headers\+\_\+t $\ast$emitted)}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+::decode\+Literal\+Header (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Decode\+Buffer} \&}]{dbuf, }
\item[{{\bf H\+P\+A\+C\+K\+::\+Streaming\+Callback} $\ast$}]{streaming\+Cb, }
\item[{{\bf headers\+\_\+t} $\ast$}]{emitted}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HPACKDecoder_a6dd81eec9220ab2d6b45edaed38c98cc}


Definition at line 44 of file H\+P\+A\+C\+K\+Decoder.\+cpp.



References proxygen\+::\+Header\+Table\+::add(), proxygen\+::\+H\+P\+A\+C\+K\+::\+Instruction\+::code, proxygen\+::\+H\+P\+A\+C\+K\+Decode\+Buffer\+::decode\+Integer(), proxygen\+::\+H\+P\+A\+C\+K\+Decode\+Buffer\+::decode\+Literal(), proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+Base\+::emit(), proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+Base\+::err\+\_\+, proxygen\+::\+E\+R\+R\+OR, proxygen\+::\+H\+P\+A\+C\+K\+Context\+::get\+Header(), proxygen\+::\+H\+P\+A\+C\+K\+::\+I\+N\+V\+A\+L\+I\+D\+\_\+\+I\+N\+D\+EX, is\+Valid(), proxygen\+::\+H\+P\+A\+C\+K\+::\+L\+I\+T\+E\+R\+AL, proxygen\+::\+H\+P\+A\+C\+K\+::\+L\+I\+T\+E\+R\+A\+L\+\_\+\+I\+N\+C\+\_\+\+I\+N\+D\+EX, proxygen\+::\+H\+P\+A\+C\+K\+Header\+::name, proxygen\+::\+H\+P\+A\+C\+K\+Decode\+Buffer\+::next(), proxygen\+::\+H\+P\+A\+C\+K\+::\+N\+O\+NE, proxygen\+::\+H\+P\+A\+C\+K\+Decode\+Buffer\+::peek(), proxygen\+::\+H\+P\+A\+C\+K\+::\+Instruction\+::prefix\+Length, proxygen\+::\+H\+P\+A\+C\+K\+Context\+::table\+\_\+, and proxygen\+::\+H\+P\+A\+C\+K\+Header\+::value.



Referenced by decode\+Header(), and set\+Header\+Table\+Max\+Size().


\begin{DoxyCode}
47                         \{
48   uint8\_t byte = dbuf.peek();
49   \textcolor{keywordtype}{bool} indexing = byte & HPACK::LITERAL_INC_INDEX.code;
50   HPACKHeader header;
51   uint8\_t indexMask = 0x3F;  \textcolor{comment}{// 0011 1111}
52   uint8\_t length = HPACK::LITERAL_INC_INDEX.prefixLength;
53   \textcolor{keywordflow}{if} (!indexing) \{
54     \textcolor{comment}{// bool neverIndex = byte & HPACK::LITERAL\_NEV\_INDEX.code;}
55     \textcolor{comment}{// TODO: we need to emit this flag with the headers}
56     indexMask = 0x0F; \textcolor{comment}{// 0000 1111}
57     length = HPACK::LITERAL.prefixLength;
58   \}
59   \textcolor{keywordflow}{if} (byte & indexMask) \{
60     uint64\_t index;
61     err_ = dbuf.decodeInteger(length, index);
62     \textcolor{keywordflow}{if} (err_ != HPACK::DecodeError::NONE) \{
63       LOG(ERROR) << \textcolor{stringliteral}{"Decode error decoding index err\_="} << err_;
64       \textcolor{keywordflow}{return} 0;
65     \}
66     \textcolor{comment}{// validate the index}
67     \textcolor{keywordflow}{if} (!isValid(index)) \{
68       LOG(ERROR) << \textcolor{stringliteral}{"received invalid index: "} << index;
69       err_ = HPACK::DecodeError::INVALID_INDEX;
70       \textcolor{keywordflow}{return} 0;
71     \}
72     header.name = getHeader(index).name;
73   \} \textcolor{keywordflow}{else} \{
74     \textcolor{comment}{// skip current byte}
75     dbuf.next();
76     folly::fbstring headerName;
77     err_ = dbuf.decodeLiteral(headerName);
78     header.name = headerName;
79     \textcolor{keywordflow}{if} (err_ != HPACK::DecodeError::NONE) \{
80       LOG(ERROR) << \textcolor{stringliteral}{"Error decoding header name err\_="} << err_;
81       \textcolor{keywordflow}{return} 0;
82     \}
83   \}
84   \textcolor{comment}{// value}
85   err_ = dbuf.decodeLiteral(header.value);
86   \textcolor{keywordflow}{if} (err_ != HPACK::DecodeError::NONE) \{
87     LOG(ERROR) << \textcolor{stringliteral}{"Error decoding header value name="} << header.name
88                << \textcolor{stringliteral}{" err\_="} << err_;
89     \textcolor{keywordflow}{return} 0;
90   \}
91 
92   uint32\_t emittedSize = emit(header, streamingCb, emitted);
93 
94   \textcolor{keywordflow}{if} (indexing) \{
95     table_.add(std::move(header));
96   \}
97 
98   \textcolor{keywordflow}{return} emittedSize;
99 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+P\+A\+C\+K\+Decoder@{proxygen\+::\+H\+P\+A\+C\+K\+Decoder}!decode\+Streaming@{decode\+Streaming}}
\index{decode\+Streaming@{decode\+Streaming}!proxygen\+::\+H\+P\+A\+C\+K\+Decoder@{proxygen\+::\+H\+P\+A\+C\+K\+Decoder}}
\subsubsection[{decode\+Streaming(folly\+::io\+::\+Cursor \&cursor, uint32\+\_\+t total\+Bytes, H\+P\+A\+C\+K\+::\+Streaming\+Callback $\ast$streaming\+Cb)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+::decode\+Streaming (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor, }
\item[{uint32\+\_\+t}]{total\+Bytes, }
\item[{{\bf H\+P\+A\+C\+K\+::\+Streaming\+Callback} $\ast$}]{streaming\+Cb}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HPACKDecoder_a20b292f927dd6f316b02491c5d08013c}
given a Cursor and a total amount of bytes we can consume from it, decode headers and invoke a callback. 

Definition at line 21 of file H\+P\+A\+C\+K\+Decoder.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+Base\+::complete\+Decode(), proxygen\+::\+H\+P\+A\+C\+K\+Decode\+Buffer\+::consumed\+Bytes(), decode\+Header(), proxygen\+::\+H\+P\+A\+C\+K\+Decode\+Buffer\+::empty(), proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+Base\+::err\+\_\+, proxygen\+::\+E\+R\+R\+OR, proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+Base\+::has\+Error(), proxygen\+::\+H\+P\+A\+C\+K\+::\+H\+E\+A\+D\+E\+R\+S\+\_\+\+T\+O\+O\+\_\+\+L\+A\+R\+GE, proxygen\+::\+Header\+Codec\+::\+H\+P\+A\+CK, and proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+Base\+::max\+Uncompressed\+\_\+.



Referenced by proxygen\+::hpack\+::decode(), proxygen\+::\+H\+P\+A\+C\+K\+Codec\+::decode\+Streaming(), encode\+Decode(), and H\+P\+A\+C\+K\+Decoder().


\begin{DoxyCode}
24                                          \{
25   HPACKDecodeBuffer dbuf(cursor, totalBytes, maxUncompressed_);
26   uint32\_t emittedSize = 0;
27 
28   \textcolor{keywordflow}{while} (!hasError() && !dbuf.empty()) \{
29     emittedSize += decodeHeader(dbuf, streamingCb, \textcolor{keyword}{nullptr});
30 
31     \textcolor{keywordflow}{if} (emittedSize > maxUncompressed_) \{
32       LOG(ERROR) << \textcolor{stringliteral}{"exceeded uncompressed size limit of "}
33                  << maxUncompressed_ << \textcolor{stringliteral}{" bytes"};
34       err_ = HPACK::DecodeError::HEADERS_TOO_LARGE;
35       \textcolor{keywordflow}{break};
36     \}
37     emittedSize += 2;
38   \}
39 
40   completeDecode(HeaderCodec::Type::HPACK, streamingCb, dbuf.consumedBytes(),
41                  emittedSize);
42 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+P\+A\+C\+K\+Decoder@{proxygen\+::\+H\+P\+A\+C\+K\+Decoder}!is\+Valid@{is\+Valid}}
\index{is\+Valid@{is\+Valid}!proxygen\+::\+H\+P\+A\+C\+K\+Decoder@{proxygen\+::\+H\+P\+A\+C\+K\+Decoder}}
\subsubsection[{is\+Valid(uint32\+\_\+t index)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+::is\+Valid (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HPACKDecoder_af5e24e9fc53cb7cedf99138d7c1c9822}


Definition at line 122 of file H\+P\+A\+C\+K\+Decoder.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Context\+::get\+Static\+Table(), proxygen\+::\+H\+P\+A\+C\+K\+Context\+::global\+To\+Dynamic\+Index(), proxygen\+::\+H\+P\+A\+C\+K\+Context\+::global\+To\+Static\+Index(), proxygen\+::\+H\+P\+A\+C\+K\+Context\+::is\+Static(), proxygen\+::\+Header\+Table\+::is\+Valid(), and proxygen\+::\+H\+P\+A\+C\+K\+Context\+::table\+\_\+.



Referenced by decode\+Indexed\+Header(), decode\+Literal\+Header(), and set\+Header\+Table\+Max\+Size().


\begin{DoxyCode}
122                                          \{
123   \textcolor{keywordflow}{if} (isStatic(index)) \{
124     \textcolor{keywordflow}{return} getStaticTable().isValid(globalToStaticIndex(index));
125   \} \textcolor{keywordflow}{else} \{
126     \textcolor{keywordflow}{return} table_.isValid(globalToDynamicIndex(index));
127   \}
128 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+P\+A\+C\+K\+Decoder@{proxygen\+::\+H\+P\+A\+C\+K\+Decoder}!set\+Header\+Table\+Max\+Size@{set\+Header\+Table\+Max\+Size}}
\index{set\+Header\+Table\+Max\+Size@{set\+Header\+Table\+Max\+Size}!proxygen\+::\+H\+P\+A\+C\+K\+Decoder@{proxygen\+::\+H\+P\+A\+C\+K\+Decoder}}
\subsubsection[{set\+Header\+Table\+Max\+Size(uint32\+\_\+t max\+Size)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+::set\+Header\+Table\+Max\+Size (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{max\+Size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HPACKDecoder_af6c3ec90eaafa94a8997ece4d95d1e3a}


Definition at line 40 of file H\+P\+A\+C\+K\+Decoder.\+h.



References decode\+Header(), decode\+Indexed\+Header(), decode\+Literal\+Header(), is\+Valid(), proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+Base\+::set\+Header\+Table\+Max\+Size(), and proxygen\+::\+H\+P\+A\+C\+K\+Context\+::table\+\_\+.



Referenced by T\+E\+S\+T\+\_\+\+P().


\begin{DoxyCode}
40                                                \{
41     HPACKDecoderBase::setHeaderTableMaxSize(table_, maxSize);
42   \}
\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
proxygen/lib/http/codec/compress/{\bf H\+P\+A\+C\+K\+Decoder.\+h}\item 
proxygen/lib/http/codec/compress/{\bf H\+P\+A\+C\+K\+Decoder.\+cpp}\end{DoxyCompactItemize}
