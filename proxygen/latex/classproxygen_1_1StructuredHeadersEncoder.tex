\section{proxygen\+:\+:Structured\+Headers\+Encoder Class Reference}
\label{classproxygen_1_1StructuredHeadersEncoder}\index{proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}}


{\ttfamily \#include $<$Structured\+Headers\+Encoder.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Structured\+Headers\+Encoder} ()
\item 
{\bf Encode\+Error} {\bf encode\+Parameterised\+List} (const {\bf Parameterised\+List} \&input)
\item 
{\bf Encode\+Error} {\bf encode\+Dictionary} (const {\bf Dictionary} \&input)
\item 
{\bf Encode\+Error} {\bf encode\+List} (const std\+::vector$<$ {\bf Structured\+Header\+Item} $>$ \&input)
\item 
{\bf Encode\+Error} {\bf encode\+Item} (const {\bf Structured\+Header\+Item} \&input)
\item 
{\bf Encode\+Error} {\bf encode\+Identifier} (const std\+::string \&input)
\item 
std\+::string {\bf get} ()
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Encode\+Error} {\bf encode\+Binary\+Content} (const std\+::string \&input)
\item 
{\bf Encode\+Error} {\bf encode\+String} (const std\+::string \&input)
\item 
{\bf Encode\+Error} {\bf encode\+Integer} (int64\+\_\+t input)
\item 
{\bf Encode\+Error} {\bf encode\+Float} (double input)
\item 
{\bf Encode\+Error} {\bf handle\+Encode\+Error} ({\bf Encode\+Error} err, const std\+::string \&bad\+Content)
\item 
{\bf Encode\+Error} {\bf handle\+Encode\+Error} ({\bf Encode\+Error} err)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::string {\bf output\+\_\+}
\item 
{\bf string\+\_\+buf} {\bf buf\+\_\+}
\item 
std\+::ostream {\bf output\+Stream\+\_\+}
\end{DoxyCompactItemize}


\subsection{Detailed Description}


Definition at line 28 of file Structured\+Headers\+Encoder.\+h.



\subsection{Constructor \& Destructor Documentation}
\index{proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}!Structured\+Headers\+Encoder@{Structured\+Headers\+Encoder}}
\index{Structured\+Headers\+Encoder@{Structured\+Headers\+Encoder}!proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}}
\subsubsection[{Structured\+Headers\+Encoder()}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+Structured\+Headers\+Encoder\+::\+Structured\+Headers\+Encoder (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1StructuredHeadersEncoder_ae71331cf939bf03d06ae5e3a40edb611}


Definition at line 111 of file Structured\+Headers\+Encoder.\+cpp.



References proxygen\+::\+Structured\+Headers\+::k\+Max\+Valid\+Float\+Length, and output\+Stream\+\_\+.


\begin{DoxyCode}
111                                                   :
112    output_(),
113    buf_(output_),
114    outputStream_(&buf_) \{
115   outputStream_.precision(kMaxValidFloatLength - 1);
116 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}!encode\+Binary\+Content@{encode\+Binary\+Content}}
\index{encode\+Binary\+Content@{encode\+Binary\+Content}!proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}}
\subsubsection[{encode\+Binary\+Content(const std\+::string \&input)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Encode\+Error} proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Binary\+Content (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{input}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1StructuredHeadersEncoder_a63f7391037ac636d720f21a919ce3fb5}


Definition at line 142 of file Structured\+Headers\+Encoder.\+cpp.



References proxygen\+::\+Structured\+Headers\+::encode\+Base64(), and output\+Stream\+\_\+.



Referenced by encode\+Item().


\begin{DoxyCode}
143                            \{
144 
145   outputStream_ << \textcolor{stringliteral}{"*"};
146   outputStream_ << encodeBase64(input);
147   outputStream_ << \textcolor{stringliteral}{"*"};
148 
149   \textcolor{keywordflow}{return} EncodeError::OK;
150 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}!encode\+Dictionary@{encode\+Dictionary}}
\index{encode\+Dictionary@{encode\+Dictionary}!proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}}
\subsubsection[{encode\+Dictionary(const Dictionary \&input)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Encode\+Error} proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Dictionary (
\begin{DoxyParamCaption}
\item[{const {\bf Dictionary} \&}]{input}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1StructuredHeadersEncoder_a04836624656270191623b1e29db59c33}


Definition at line 43 of file Structured\+Headers\+Encoder.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+E\+M\+P\+T\+Y\+\_\+\+D\+A\+T\+A\+\_\+\+S\+T\+R\+U\+C\+T\+U\+RE, and proxygen\+::\+Structured\+Headers\+::\+OK.



Referenced by proxygen\+::\+T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
44                            \{
45 
46   \textcolor{keywordflow}{if} (input.empty()) \{
47     \textcolor{keywordflow}{return} handleEncodeError(EncodeError::EMPTY\_DATA\_STRUCTURE);
48   \}
49 
50   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = input.begin(); it != input.end(); it++) \{
51     \textcolor{keyword}{auto} err = encodeIdentifier(it->first);
52     \textcolor{keywordflow}{if} (err != EncodeError::OK) \{
53       \textcolor{keywordflow}{return} err;
54     \}
55 
56     outputStream_ << \textcolor{stringliteral}{"="};
57 
58     err = encodeItem(it->second);
59     \textcolor{keywordflow}{if} (err != EncodeError::OK) \{
60       \textcolor{keywordflow}{return} err;
61     \}
62 
63     \textcolor{keywordflow}{if} (std::next(it, 1) != input.end()) \{
64       outputStream_ << \textcolor{stringliteral}{", "};
65     \}
66   \}
67 
68   \textcolor{keywordflow}{return} EncodeError::OK;
69 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}!encode\+Float@{encode\+Float}}
\index{encode\+Float@{encode\+Float}!proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}}
\subsubsection[{encode\+Float(double input)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Encode\+Error} proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Float (
\begin{DoxyParamCaption}
\item[{double}]{input}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1StructuredHeadersEncoder_ad91efbe5183d0535a88cd656b69b27f1}


Definition at line 178 of file Structured\+Headers\+Encoder.\+cpp.



References output\+Stream\+\_\+.



Referenced by encode\+Item().


\begin{DoxyCode}
178                                                               \{
179 
180   outputStream_ << input;
181 
182   \textcolor{keywordflow}{return} EncodeError::OK;
183 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}!encode\+Identifier@{encode\+Identifier}}
\index{encode\+Identifier@{encode\+Identifier}!proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}}
\subsubsection[{encode\+Identifier(const std\+::string \&input)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Encode\+Error} proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Identifier (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{input}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1StructuredHeadersEncoder_aa5d9e6d3f7f629176f632a61e9bc9ce7}


Definition at line 185 of file Structured\+Headers\+Encoder.\+cpp.



References handle\+Encode\+Error(), proxygen\+::\+Structured\+Headers\+::is\+Valid\+Identifier(), and output\+Stream\+\_\+.



Referenced by proxygen\+::\+T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
186                           \{
187 
188   \textcolor{keywordflow}{if} (!isValidIdentifier(input)) \{
189     \textcolor{keywordflow}{return} handleEncodeError(EncodeError::BAD\_IDENTIFIER, input);
190   \}
191   outputStream_ << input;
192   \textcolor{keywordflow}{return} EncodeError::OK;
193 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}!encode\+Integer@{encode\+Integer}}
\index{encode\+Integer@{encode\+Integer}!proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}}
\subsubsection[{encode\+Integer(int64\+\_\+t input)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Encode\+Error} proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Integer (
\begin{DoxyParamCaption}
\item[{int64\+\_\+t}]{input}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1StructuredHeadersEncoder_a1f5076193b061d6fff0dc29624627c3f}


Definition at line 171 of file Structured\+Headers\+Encoder.\+cpp.



References output\+Stream\+\_\+.



Referenced by encode\+Item().


\begin{DoxyCode}
171                                                                  \{
172 
173   outputStream_ << input;
174 
175   \textcolor{keywordflow}{return} EncodeError::OK;
176 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}!encode\+Item@{encode\+Item}}
\index{encode\+Item@{encode\+Item}!proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}}
\subsubsection[{encode\+Item(const Structured\+Header\+Item \&input)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Encode\+Error} proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Item (
\begin{DoxyParamCaption}
\item[{const {\bf Structured\+Header\+Item} \&}]{input}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1StructuredHeadersEncoder_a13892867b490627496cab77e47310ed5}


Definition at line 118 of file Structured\+Headers\+Encoder.\+cpp.



References encode\+Binary\+Content(), encode\+Float(), encode\+Integer(), encode\+String(), handle\+Encode\+Error(), proxygen\+::\+Structured\+Headers\+::item\+Type\+Matches\+Content(), proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.



Referenced by proxygen\+::\+T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
119                                      \{
120 
121   \textcolor{keywordflow}{if} (!itemTypeMatchesContent(input)) \{
122     \textcolor{keywordflow}{return} handleEncodeError(EncodeError::ITEM\_TYPE\_MISMATCH);
123   \}
124 
125   \textcolor{keywordflow}{switch} (input.tag) \{
126     \textcolor{keywordflow}{case} StructuredHeaderItem::Type::STRING:
127       \textcolor{keywordflow}{return} encodeString(boost::get<std::string>(input.value));
128     \textcolor{keywordflow}{case} StructuredHeaderItem::Type::INT64:
129       \textcolor{keywordflow}{return} encodeInteger(boost::get<int64\_t>(input.value));
130     \textcolor{keywordflow}{case} StructuredHeaderItem::Type::DOUBLE:
131       \textcolor{keywordflow}{return} encodeFloat(boost::get<double>(input.value));
132     \textcolor{keywordflow}{case} StructuredHeaderItem::Type::BINARYCONTENT:
133       \textcolor{keywordflow}{return} encodeBinaryContent(
134         boost::get<std::string>(input.value));
135     \textcolor{keywordflow}{default}:
136       \textcolor{keywordflow}{return} handleEncodeError(EncodeError::ENCODING\_NULL\_ITEM);
137   \}
138 
139   \textcolor{keywordflow}{return} EncodeError::OK;
140 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}!encode\+List@{encode\+List}}
\index{encode\+List@{encode\+List}!proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}}
\subsubsection[{encode\+List(const std\+::vector$<$ Structured\+Header\+Item $>$ \&input)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Encode\+Error} proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+List (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ {\bf Structured\+Header\+Item} $>$ \&}]{input}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1StructuredHeadersEncoder_a7303031ebda6fb084ee8c914c3eb2924}


Definition at line 22 of file Structured\+Headers\+Encoder.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+E\+M\+P\+T\+Y\+\_\+\+D\+A\+T\+A\+\_\+\+S\+T\+R\+U\+C\+T\+U\+RE, and proxygen\+::\+Structured\+Headers\+::\+OK.



Referenced by proxygen\+::\+T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
23                                                 \{
24 
25   \textcolor{keywordflow}{if} (input.empty()) \{
26     \textcolor{keywordflow}{return} handleEncodeError(EncodeError::EMPTY\_DATA\_STRUCTURE);
27   \}
28 
29   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = input.begin(); it != input.end(); it++) \{
30     \textcolor{keyword}{auto} err = encodeItem(*it);
31     \textcolor{keywordflow}{if} (err != EncodeError::OK) \{
32       \textcolor{keywordflow}{return} err;
33     \}
34 
35     \textcolor{keywordflow}{if} (std::next(it, 1)!= input.end()) \{
36       outputStream_ << \textcolor{stringliteral}{", "};
37     \}
38   \}
39 
40   \textcolor{keywordflow}{return} EncodeError::OK;
41 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}!encode\+Parameterised\+List@{encode\+Parameterised\+List}}
\index{encode\+Parameterised\+List@{encode\+Parameterised\+List}!proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}}
\subsubsection[{encode\+Parameterised\+List(const Parameterised\+List \&input)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Encode\+Error} proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Parameterised\+List (
\begin{DoxyParamCaption}
\item[{const {\bf Parameterised\+List} \&}]{input}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1StructuredHeadersEncoder_ac3ac426330e0df12fe1b7d30d925b8b0}


Definition at line 71 of file Structured\+Headers\+Encoder.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+E\+M\+P\+T\+Y\+\_\+\+D\+A\+T\+A\+\_\+\+S\+T\+R\+U\+C\+T\+U\+RE, proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::\+N\+O\+NE, and proxygen\+::\+Structured\+Headers\+::\+OK.



Referenced by proxygen\+::\+T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
72                                   \{
73 
74   \textcolor{keywordflow}{if} (input.empty()) \{
75     \textcolor{keywordflow}{return} handleEncodeError(EncodeError::EMPTY\_DATA\_STRUCTURE);
76   \}
77 
78   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it1 = input.begin(); it1 != input.end(); it1++) \{
79     \textcolor{keyword}{auto} err = encodeIdentifier(it1->identifier);
80     \textcolor{keywordflow}{if} (err != EncodeError::OK) \{
81       \textcolor{keywordflow}{return} err;
82     \}
83 
84     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it2 = it1->parameterMap.begin();
85       it2 != it1->parameterMap.end(); it2++) \{
86 
87       outputStream_ << \textcolor{stringliteral}{"; "};
88 
89       err = encodeIdentifier(it2->first);
90       \textcolor{keywordflow}{if} (err != EncodeError::OK) \{
91         \textcolor{keywordflow}{return} err;
92       \}
93 
94       \textcolor{keywordflow}{if} (it2->second.tag != StructuredHeaderItem::Type::NONE) \{
95         outputStream_ << \textcolor{stringliteral}{"="};
96         err = encodeItem(it2->second);
97         \textcolor{keywordflow}{if} (err != EncodeError::OK) \{
98           \textcolor{keywordflow}{return} err;
99         \}
100       \}
101     \}
102 
103     \textcolor{keywordflow}{if} (std::next(it1, 1) != input.end()) \{
104       outputStream_ << \textcolor{stringliteral}{", "};
105     \}
106   \}
107 
108   \textcolor{keywordflow}{return} EncodeError::OK;
109 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}!encode\+String@{encode\+String}}
\index{encode\+String@{encode\+String}!proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}}
\subsubsection[{encode\+String(const std\+::string \&input)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Encode\+Error} proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+String (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{input}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1StructuredHeadersEncoder_a0b676c8097488fd70e47a618c4c2c0f3}


Definition at line 152 of file Structured\+Headers\+Encoder.\+cpp.



References handle\+Encode\+Error(), proxygen\+::\+Structured\+Headers\+::is\+Valid\+String(), and output\+Stream\+\_\+.



Referenced by encode\+Item().


\begin{DoxyCode}
152                                                                          \{
153 
154   \textcolor{keywordflow}{if} (!isValidString(input)) \{
155     \textcolor{keywordflow}{return} handleEncodeError(EncodeError::BAD\_STRING, input);
156   \}
157 
158   outputStream_ << \textcolor{stringliteral}{"\(\backslash\)""};
159   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{char} c : input) \{
160     \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{'"'} || c == \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}) \{
161       outputStream_ << \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)"};
162     \}
163     outputStream_ << c;
164   \}
165 
166   outputStream_ << \textcolor{stringliteral}{"\(\backslash\)""};
167 
168   \textcolor{keywordflow}{return} EncodeError::OK;
169 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}!get@{get}}
\index{get@{get}!proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}}
\subsubsection[{get()}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string proxygen\+::\+Structured\+Headers\+Encoder\+::get (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1StructuredHeadersEncoder_a9885995adc938237421e0611946c7272}


Definition at line 212 of file Structured\+Headers\+Encoder.\+cpp.



References output\+\_\+, and output\+Stream\+\_\+.



Referenced by proxygen\+::\+T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
212                                         \{
213   outputStream_.flush();
214   \textcolor{keywordflow}{return} std::move(output_);
215 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}!handle\+Encode\+Error@{handle\+Encode\+Error}}
\index{handle\+Encode\+Error@{handle\+Encode\+Error}!proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}}
\subsubsection[{handle\+Encode\+Error(\+Encode\+Error err, const std\+::string \&bad\+Content)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Encode\+Error} proxygen\+::\+Structured\+Headers\+Encoder\+::handle\+Encode\+Error (
\begin{DoxyParamCaption}
\item[{{\bf Encode\+Error}}]{err, }
\item[{const std\+::string \&}]{bad\+Content}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1StructuredHeadersEncoder_a751e7c37cfcf960043a6b017ba114591}


Definition at line 197 of file Structured\+Headers\+Encoder.\+cpp.



References proxygen\+::\+Structured\+Headers\+::encode\+Error\+Description, and proxygen\+::\+E\+R\+R\+OR.



Referenced by encode\+Identifier(), encode\+Item(), and encode\+String().


\begin{DoxyCode}
198                             \{
199 
200   LOG\_EVERY\_N(ERROR, 1000) << \textcolor{stringliteral}{"Error message: "} <<
201     encodeErrorDescription.at(err) << \textcolor{stringliteral}{" .The culprit was: "} << culprit;
202   \textcolor{keywordflow}{return} err;
203 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}!handle\+Encode\+Error@{handle\+Encode\+Error}}
\index{handle\+Encode\+Error@{handle\+Encode\+Error}!proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}}
\subsubsection[{handle\+Encode\+Error(\+Encode\+Error err)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Encode\+Error} proxygen\+::\+Structured\+Headers\+Encoder\+::handle\+Encode\+Error (
\begin{DoxyParamCaption}
\item[{{\bf Encode\+Error}}]{err}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1StructuredHeadersEncoder_a95a97319fa81adaf8c771d092ea58ced}


Definition at line 206 of file Structured\+Headers\+Encoder.\+cpp.



References proxygen\+::\+Structured\+Headers\+::encode\+Error\+Description, and proxygen\+::\+E\+R\+R\+OR.


\begin{DoxyCode}
206                                                                        \{
207   LOG\_EVERY\_N(ERROR, 1000) << \textcolor{stringliteral}{"Error message: "} <<
208     encodeErrorDescription.at(err);
209   \textcolor{keywordflow}{return} err;
210 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}!buf\+\_\+@{buf\+\_\+}}
\index{buf\+\_\+@{buf\+\_\+}!proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}}
\subsubsection[{buf\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf string\+\_\+buf} proxygen\+::\+Structured\+Headers\+Encoder\+::buf\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1StructuredHeadersEncoder_a54a9d179ad13f459b21930829fc8dde7}


Definition at line 62 of file Structured\+Headers\+Encoder.\+h.

\index{proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}!output\+\_\+@{output\+\_\+}}
\index{output\+\_\+@{output\+\_\+}!proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}}
\subsubsection[{output\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string proxygen\+::\+Structured\+Headers\+Encoder\+::output\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1StructuredHeadersEncoder_a99e2a3bec82498f8429d2de9ddea3365}


Definition at line 61 of file Structured\+Headers\+Encoder.\+h.



Referenced by get().

\index{proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}!output\+Stream\+\_\+@{output\+Stream\+\_\+}}
\index{output\+Stream\+\_\+@{output\+Stream\+\_\+}!proxygen\+::\+Structured\+Headers\+Encoder@{proxygen\+::\+Structured\+Headers\+Encoder}}
\subsubsection[{output\+Stream\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream proxygen\+::\+Structured\+Headers\+Encoder\+::output\+Stream\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1StructuredHeadersEncoder_a27d4b8a79e37527016add546327e1212}


Definition at line 63 of file Structured\+Headers\+Encoder.\+h.



Referenced by encode\+Binary\+Content(), encode\+Float(), encode\+Identifier(), encode\+Integer(), encode\+String(), get(), and Structured\+Headers\+Encoder().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
proxygen/lib/http/structuredheaders/{\bf Structured\+Headers\+Encoder.\+h}\item 
proxygen/lib/http/structuredheaders/{\bf Structured\+Headers\+Encoder.\+cpp}\end{DoxyCompactItemize}
