\section{proxygen/lib/http/test/\+R\+F\+C2616\+Test.cpp File Reference}
\label{RFC2616Test_8cpp}\index{proxygen/lib/http/test/\+R\+F\+C2616\+Test.\+cpp@{proxygen/lib/http/test/\+R\+F\+C2616\+Test.\+cpp}}
{\ttfamily \#include $<$folly/portability/\+G\+Test.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/\+R\+F\+C2616.\+h$>$}\\*
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\bf T\+E\+ST} (Qvalue\+Test, Basic)
\item 
{\bf T\+E\+ST} (Qvalue\+Test, Extras)
\item 
{\bf T\+E\+ST} (Qvalue\+Test, Invalids)
\item 
{\bf T\+E\+ST} (Byte\+Range\+Spec\+Test, Valids)
\item 
{\bf T\+E\+ST} (Byte\+Range\+Spec\+Test, Invalids)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{R\+F\+C2616\+Test.\+cpp@{R\+F\+C2616\+Test.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!R\+F\+C2616\+Test.\+cpp@{R\+F\+C2616\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Qvalue\+Test, Basic)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Qvalue\+Test}]{, }
\item[{Basic}]{}
\end{DoxyParamCaption}
)}\label{RFC2616Test_8cpp_a76b47f639d712fc578b9f10d32ee7a41}


Definition at line 18 of file R\+F\+C2616\+Test.\+cpp.



References proxygen\+::\+R\+F\+C2616\+::parse\+Qvalues().


\begin{DoxyCode}
18                         \{
19 
20   std::vector<RFC2616::TokenQPair> output;
21 
22   \textcolor{keywordtype}{string} test1(\textcolor{stringliteral}{"iso-8859-5, unicode-1-1;q=0.8"});
23   EXPECT\_TRUE(RFC2616::parseQvalues(test1, output));
24   EXPECT\_EQ(output.size(), 2);
25   EXPECT\_EQ(output[0].first.compare(folly::StringPiece(\textcolor{stringliteral}{"iso-8859-5"})), 0);
26   EXPECT\_DOUBLE\_EQ(output[0].second, 1);
27   EXPECT\_EQ(output[1].first.compare(folly::StringPiece(\textcolor{stringliteral}{"unicode-1-1"})), 0);
28   EXPECT\_DOUBLE\_EQ(output[1].second, 0.8);
29   output.clear();
30 
31   \textcolor{keywordtype}{string} test2(\textcolor{stringliteral}{"compress, gzip"});
32   EXPECT\_TRUE(RFC2616::parseQvalues(test2, output));
33   EXPECT\_EQ(output.size(), 2);
34   EXPECT\_EQ(output[0].first.compare(folly::StringPiece(\textcolor{stringliteral}{"compress"})), 0);
35   EXPECT\_DOUBLE\_EQ(output[0].second, 1);
36   EXPECT\_EQ(output[1].first.compare(folly::StringPiece(\textcolor{stringliteral}{"gzip"})), 0);
37   EXPECT\_DOUBLE\_EQ(output[1].second, 1);
38   output.clear();
39 
40   \textcolor{keywordtype}{string} test3(\textcolor{stringliteral}{""});
41   \textcolor{comment}{// The spec says a blank one is ok but empty headers are disallowed in SPDY?}
42   EXPECT\_FALSE(RFC2616::parseQvalues(test3, output));
43   EXPECT\_EQ(output.size(), 0);
44 
45   \textcolor{keywordtype}{string} test4(\textcolor{stringliteral}{"compress;q=0.5, gzip;q=1.0"});
46   EXPECT\_TRUE(RFC2616::parseQvalues(test4, output));
47   EXPECT\_EQ(output.size(), 2);
48   EXPECT\_EQ(output[0].first.compare(folly::StringPiece(\textcolor{stringliteral}{"compress"})), 0);
49   EXPECT\_DOUBLE\_EQ(output[0].second, 0.5);
50   EXPECT\_EQ(output[1].first.compare(folly::StringPiece(\textcolor{stringliteral}{"gzip"})), 0);
51   EXPECT\_DOUBLE\_EQ(output[1].second, 1.0);
52   output.clear();
53 
54   \textcolor{keywordtype}{string} test5(\textcolor{stringliteral}{"gzip;q=1.0, identity; q=0.5, *;q=0"});
55   EXPECT\_TRUE(RFC2616::parseQvalues(test5, output));
56   EXPECT\_EQ(output.size(), 3);
57   EXPECT\_EQ(output[0].first.compare(folly::StringPiece(\textcolor{stringliteral}{"gzip"})), 0);
58   EXPECT\_DOUBLE\_EQ(output[0].second, 1);
59   EXPECT\_EQ(output[1].first.compare(folly::StringPiece(\textcolor{stringliteral}{"identity"})), 0);
60   EXPECT\_DOUBLE\_EQ(output[1].second, 0.5);
61   EXPECT\_EQ(output[2].first.compare(folly::StringPiece(\textcolor{stringliteral}{"*"})), 0);
62   EXPECT\_DOUBLE\_EQ(output[2].second, 0);
63   output.clear();
64 
65   \textcolor{keywordtype}{string} test6(\textcolor{stringliteral}{"da, en-gb;q=0.8, en;q=0.7"});
66   EXPECT\_TRUE(RFC2616::parseQvalues(test6, output));
67   EXPECT\_EQ(output.size(), 3);
68   EXPECT\_EQ(output[0].first.compare(folly::StringPiece(\textcolor{stringliteral}{"da"})), 0);
69   EXPECT\_DOUBLE\_EQ(output[0].second, 1);
70   EXPECT\_EQ(output[1].first.compare(folly::StringPiece(\textcolor{stringliteral}{"en-gb"})), 0);
71   EXPECT\_DOUBLE\_EQ(output[1].second, 0.8);
72   EXPECT\_EQ(output[2].first.compare(folly::StringPiece(\textcolor{stringliteral}{"en"})), 0);
73   EXPECT\_DOUBLE\_EQ(output[2].second, 0.7);
74   output.clear();
75 \}
\end{DoxyCode}
\index{R\+F\+C2616\+Test.\+cpp@{R\+F\+C2616\+Test.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!R\+F\+C2616\+Test.\+cpp@{R\+F\+C2616\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Qvalue\+Test, Extras)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Qvalue\+Test}]{, }
\item[{Extras}]{}
\end{DoxyParamCaption}
)}\label{RFC2616Test_8cpp_a500619eec04c1e588791d5501c7b0a1a}


Definition at line 77 of file R\+F\+C2616\+Test.\+cpp.



References proxygen\+::\+R\+F\+C2616\+::parse\+Qvalues().


\begin{DoxyCode}
77                          \{
78 
79   std::vector<RFC2616::TokenQPair> output;
80 
81   \textcolor{keywordtype}{string} test1(\textcolor{stringliteral}{"  iso-8859-5,    unicode-1-1;  q=0.8  hi mom!"});
82   EXPECT\_TRUE(RFC2616::parseQvalues(test1, output));
83   EXPECT\_EQ(output.size(), 2);
84   EXPECT\_EQ(output[0].first.compare(folly::StringPiece(\textcolor{stringliteral}{"iso-8859-5"})), 0);
85   EXPECT\_DOUBLE\_EQ(output[0].second, 1);
86   EXPECT\_EQ(output[1].first.compare(folly::StringPiece(\textcolor{stringliteral}{"unicode-1-1"})), 0);
87   EXPECT\_DOUBLE\_EQ(output[1].second, 0.8);
88   output.clear();
89 
90   \textcolor{keywordtype}{string} test2(\textcolor{stringliteral}{"gzip"});
91   EXPECT\_TRUE(RFC2616::parseQvalues(test2, output));
92   EXPECT\_EQ(output.size(), 1);
93   EXPECT\_EQ(output[0].first.compare(folly::StringPiece(\textcolor{stringliteral}{"gzip"})), 0);
94   EXPECT\_DOUBLE\_EQ(output[0].second, 1);
95   output.clear();
96 \}
\end{DoxyCode}
\index{R\+F\+C2616\+Test.\+cpp@{R\+F\+C2616\+Test.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!R\+F\+C2616\+Test.\+cpp@{R\+F\+C2616\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Qvalue\+Test, Invalids)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Qvalue\+Test}]{, }
\item[{Invalids}]{}
\end{DoxyParamCaption}
)}\label{RFC2616Test_8cpp_ad3444d917f4310d37426eafaf69e46f7}


Definition at line 98 of file R\+F\+C2616\+Test.\+cpp.



References proxygen\+::\+R\+F\+C2616\+::parse\+Qvalues().


\begin{DoxyCode}
98                            \{
99 
100   std::vector<RFC2616::TokenQPair> output;
101 
102   \textcolor{keywordtype}{string} test1(\textcolor{stringliteral}{",,,"});
103   EXPECT\_FALSE(RFC2616::parseQvalues(test1, output));
104   EXPECT\_EQ(output.size(), 0);
105   output.clear();
106 
107   \textcolor{keywordtype}{string} test2(\textcolor{stringliteral}{"  ; q=0.1"});
108   EXPECT\_FALSE(RFC2616::parseQvalues(test2, output));
109   EXPECT\_EQ(output.size(), 0);
110   output.clear();
111 
112   \textcolor{keywordtype}{string} test3(\textcolor{stringliteral}{"gzip; q=uietplease"});
113   EXPECT\_FALSE(RFC2616::parseQvalues(test3, output));
114   EXPECT\_EQ(output.size(), 1);
115   EXPECT\_EQ(output[0].first.compare(folly::StringPiece(\textcolor{stringliteral}{"gzip"})), 0);
116   EXPECT\_DOUBLE\_EQ(output[0].second, 1);
117   output.clear();
118 
119   \textcolor{keywordtype}{string} test4(\textcolor{stringliteral}{"gzip; whoohoo, defalte"});
120   EXPECT\_FALSE(RFC2616::parseQvalues(test4, output));
121   EXPECT\_EQ(output.size(), 2);
122   EXPECT\_EQ(output[0].first.compare(folly::StringPiece(\textcolor{stringliteral}{"gzip"})), 0);
123   EXPECT\_DOUBLE\_EQ(output[0].second, 1);
124   EXPECT\_EQ(output[1].first.compare(folly::StringPiece(\textcolor{stringliteral}{"defalte"})), 0);
125   EXPECT\_DOUBLE\_EQ(output[1].second, 1);
126   output.clear();
127 
128 \}
\end{DoxyCode}
\index{R\+F\+C2616\+Test.\+cpp@{R\+F\+C2616\+Test.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!R\+F\+C2616\+Test.\+cpp@{R\+F\+C2616\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Byte\+Range\+Spec\+Test, Valids)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Byte\+Range\+Spec\+Test}]{, }
\item[{Valids}]{}
\end{DoxyParamCaption}
)}\label{RFC2616Test_8cpp_a7ea43f1a4f52d3f8234a258fb4eb4931}


Definition at line 130 of file R\+F\+C2616\+Test.\+cpp.



References proxygen\+::\+R\+F\+C2616\+::parse\+Byte\+Range\+Spec().


\begin{DoxyCode}
130                                 \{
131   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} firstByte = ULONG\_MAX;
132   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} lastByte = ULONG\_MAX;
133   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} instanceLength = ULONG\_MAX;
134 
135   ASSERT\_TRUE(
136       parseByteRangeSpec(
137         \textcolor{stringliteral}{"bytes 0-10/100"},
138         firstByte, lastByte, instanceLength));
139   EXPECT\_EQ(0, firstByte);
140   EXPECT\_EQ(10, lastByte);
141   EXPECT\_EQ(100, instanceLength);
142 
143   ASSERT\_TRUE(
144       parseByteRangeSpec(
145         \textcolor{stringliteral}{"bytes */100"},
146         firstByte, lastByte, instanceLength));
147   EXPECT\_EQ(0, firstByte);
148   EXPECT\_EQ(ULONG\_MAX, lastByte);
149   EXPECT\_EQ(100, instanceLength);
150 
151   ASSERT\_TRUE(
152       parseByteRangeSpec(
153         \textcolor{stringliteral}{"bytes 0-10/*"},
154         firstByte, lastByte, instanceLength));
155   EXPECT\_EQ(0, firstByte);
156   EXPECT\_EQ(10, lastByte);
157   EXPECT\_EQ(ULONG\_MAX, instanceLength);
158 \}
\end{DoxyCode}
\index{R\+F\+C2616\+Test.\+cpp@{R\+F\+C2616\+Test.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!R\+F\+C2616\+Test.\+cpp@{R\+F\+C2616\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Byte\+Range\+Spec\+Test, Invalids)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Byte\+Range\+Spec\+Test}]{, }
\item[{Invalids}]{}
\end{DoxyParamCaption}
)}\label{RFC2616Test_8cpp_ae7421ba2177bf93aad9bf8b721540a24}


Definition at line 160 of file R\+F\+C2616\+Test.\+cpp.



References proxygen\+::\+R\+F\+C2616\+::parse\+Byte\+Range\+Spec().


\begin{DoxyCode}
160                                   \{
161   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} dummy;
162 
163   EXPECT\_FALSE(parseByteRangeSpec(\textcolor{stringliteral}{"0-10/100"}, dummy, dummy, dummy)) <<
164     \textcolor{stringliteral}{"Spec must start with 'bytes '"};
165   EXPECT\_FALSE(parseByteRangeSpec(\textcolor{stringliteral}{"bytes 10/100"}, dummy, dummy, dummy)) <<
166     \textcolor{stringliteral}{"Spec missing initial range"};
167   EXPECT\_FALSE(parseByteRangeSpec(\textcolor{stringliteral}{"bytes 10-/100"}, dummy, dummy, dummy)) <<
168     \textcolor{stringliteral}{"Spec missing last byte in initial range"};
169   EXPECT\_FALSE(parseByteRangeSpec(\textcolor{stringliteral}{"bytes 0-10 100"}, dummy, dummy, dummy)) <<
170     \textcolor{stringliteral}{"Spec missing '/' separator"};
171   EXPECT\_FALSE(parseByteRangeSpec(\textcolor{stringliteral}{"bytes 0-10/100Q"}, dummy, dummy, dummy)) <<
172     \textcolor{stringliteral}{"Spec has trailing garbage"};
173   EXPECT\_FALSE(parseByteRangeSpec(\textcolor{stringliteral}{"bytes 10-1/100"}, dummy, dummy, dummy)) <<
174     \textcolor{stringliteral}{"Spec initial range is invalid"};
175   EXPECT\_FALSE(parseByteRangeSpec(\textcolor{stringliteral}{"bytes 10-90/50"}, dummy, dummy, dummy)) <<
176     \textcolor{stringliteral}{"Spec initial range is invalid too large"};
177   EXPECT\_FALSE(parseByteRangeSpec(\textcolor{stringliteral}{"bytes x/100"}, dummy, dummy, dummy)) <<
178     \textcolor{stringliteral}{"Spec initial range has invalid first byte"};
179   EXPECT\_FALSE(parseByteRangeSpec(\textcolor{stringliteral}{"bytes 0-x/100"}, dummy, dummy, dummy)) <<
180     \textcolor{stringliteral}{"Spec initial range has invalid last bytek"};
181   EXPECT\_FALSE(parseByteRangeSpec(\textcolor{stringliteral}{"bytes *-10/100"}, dummy, dummy, dummy)) <<
182     \textcolor{stringliteral}{"Spec cannot contain wildcard in initial range"};
183   EXPECT\_FALSE(parseByteRangeSpec(\textcolor{stringliteral}{"bytes 0-*/100"}, dummy, dummy, dummy)) <<
184     \textcolor{stringliteral}{"Spec cannot contain wildcard in initial range"};
185 
186   folly::StringPiece sp(\textcolor{stringliteral}{"bytes 0-10/100"});
187   sp.subtract(3);
188   EXPECT\_FALSE(parseByteRangeSpec(sp, dummy, dummy, dummy)) <<
189     \textcolor{stringliteral}{"Spec StringPiece ends before instance length"};
190   sp.subtract(1);
191   EXPECT\_FALSE(parseByteRangeSpec(sp, dummy, dummy, dummy)) <<
192     \textcolor{stringliteral}{"Spec StringPiece ends before '/' character"};
193   sp.subtract(2);
194   EXPECT\_FALSE(parseByteRangeSpec(sp, dummy, dummy, dummy)) <<
195     \textcolor{stringliteral}{"Spec StringPiece ends before last byte in initial byte range"};
196   sp.subtract(1);
197   EXPECT\_FALSE(parseByteRangeSpec(sp, dummy, dummy, dummy)) <<
198     \textcolor{stringliteral}{"Spec StringPiece ends before '-' in initial byte range"};
199   sp.subtract(2);
200   EXPECT\_FALSE(parseByteRangeSpec(sp, dummy, dummy, dummy)) <<
201     \textcolor{stringliteral}{"Spec StringPiece ends before first byte in initial byte range"};
202 \}
\end{DoxyCode}
