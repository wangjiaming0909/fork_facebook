\section{proxygen\+:\+:H\+T\+T\+P\+Downstream\+Session Class Reference}
\label{classproxygen_1_1HTTPDownstreamSession}\index{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}}


{\ttfamily \#include $<$H\+T\+T\+P\+Downstream\+Session.\+h$>$}

Inheritance diagram for proxygen\+:\+:H\+T\+T\+P\+Downstream\+Session\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=12.000000cm]{classproxygen_1_1HTTPDownstreamSession}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf H\+T\+T\+P\+Downstream\+Session} (const {\bf Wheel\+Timer\+Instance} \&timeout, folly\+::\+Async\+Transport\+Wrapper\+::\+Unique\+Ptr \&\&sock, const folly\+::\+Socket\+Address \&{\bf local\+Addr}, const folly\+::\+Socket\+Address \&{\bf peer\+Addr}, {\bf H\+T\+T\+P\+Session\+Controller} $\ast$controller, std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Codec} $>$ codec, const wangle\+::\+Transport\+Info \&tinfo, {\bf Info\+Callback} $\ast$info\+Callback)
\item 
{\bf H\+T\+T\+P\+Downstream\+Session} (folly\+::\+H\+H\+Wheel\+Timer $\ast$timer, folly\+::\+Async\+Transport\+Wrapper\+::\+Unique\+Ptr \&\&sock, const folly\+::\+Socket\+Address \&{\bf local\+Addr}, const folly\+::\+Socket\+Address \&{\bf peer\+Addr}, {\bf H\+T\+T\+P\+Session\+Controller} $\ast$controller, std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Codec} $>$ codec, const wangle\+::\+Transport\+Info \&tinfo, {\bf Info\+Callback} $\ast$info\+Callback)
\item 
void {\bf start\+Now} () override
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf $\sim$\+H\+T\+T\+P\+Downstream\+Session} () override
\item 
void {\bf setup\+On\+Headers\+Complete} ({\bf H\+T\+T\+P\+Transaction} $\ast$txn, {\bf H\+T\+T\+P\+Message} $\ast$msg) override
\item 
{\bf H\+T\+T\+P\+Transaction\+::\+Handler} $\ast$ {\bf get\+Transaction\+Timeout\+Handler} ({\bf H\+T\+T\+P\+Transaction} $\ast$txn) override
\item 
void {\bf on\+Headers\+Sent} (const {\bf H\+T\+T\+P\+Message} \&headers, bool codec\+Was\+Reusable) override
\item 
bool {\bf all\+Transactions\+Started} () const override
\item 
bool {\bf on\+Native\+Protocol\+Upgrade} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} {\bf stream\+ID}, {\bf Codec\+Protocol} protocol, const std\+::string \&protocol\+String, {\bf H\+T\+T\+P\+Message} \&msg) override
\item 
bool {\bf is\+Detachable} (bool) const override
\item 
void {\bf attach\+Thread\+Locals} (folly\+::\+Event\+Base $\ast$, folly\+::\+S\+S\+L\+Context\+Ptr, const {\bf Wheel\+Timer\+Instance} \&, {\bf H\+T\+T\+P\+Session\+Stats} $\ast$, {\bf Filter\+Iterator\+Fn}, {\bf Header\+Codec\+::\+Stats} $\ast$, {\bf H\+T\+T\+P\+Session\+Controller} $\ast$) override
\item 
void {\bf detach\+Thread\+Locals} (bool) override
\item 
{\bf H\+T\+T\+P\+Transaction} $\ast$ {\bf new\+Transaction} ({\bf H\+T\+T\+P\+Transaction\+::\+Handler} $\ast$) override
\item 
bool {\bf is\+Replay\+Safe} () const override
\item 
bool {\bf is\+Reusable} () const override
\item 
bool {\bf is\+Closing} () const override
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}


Definition at line 18 of file H\+T\+T\+P\+Downstream\+Session.\+h.



\subsection{Constructor \& Destructor Documentation}
\index{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}!H\+T\+T\+P\+Downstream\+Session@{H\+T\+T\+P\+Downstream\+Session}}
\index{H\+T\+T\+P\+Downstream\+Session@{H\+T\+T\+P\+Downstream\+Session}!proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}}
\subsubsection[{H\+T\+T\+P\+Downstream\+Session(const Wheel\+Timer\+Instance \&timeout, folly\+::\+Async\+Transport\+Wrapper\+::\+Unique\+Ptr \&\&sock, const folly\+::\+Socket\+Address \&local\+Addr, const folly\+::\+Socket\+Address \&peer\+Addr, H\+T\+T\+P\+Session\+Controller $\ast$controller, std\+::unique\+\_\+ptr$<$ H\+T\+T\+P\+Codec $>$ codec, const wangle\+::\+Transport\+Info \&tinfo, Info\+Callback $\ast$info\+Callback)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::\+H\+T\+T\+P\+Downstream\+Session (
\begin{DoxyParamCaption}
\item[{const {\bf Wheel\+Timer\+Instance} \&}]{timeout, }
\item[{folly\+::\+Async\+Transport\+Wrapper\+::\+Unique\+Ptr \&\&}]{sock, }
\item[{const folly\+::\+Socket\+Address \&}]{local\+Addr, }
\item[{const folly\+::\+Socket\+Address \&}]{peer\+Addr, }
\item[{{\bf H\+T\+T\+P\+Session\+Controller} $\ast$}]{controller, }
\item[{std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Codec} $>$}]{codec, }
\item[{const wangle\+::\+Transport\+Info \&}]{tinfo, }
\item[{{\bf Info\+Callback} $\ast$}]{info\+Callback}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HTTPDownstreamSession_ae1279f9860a9a60a9c0a8167db9d2c98}

\begin{DoxyParams}{Parameters}
{\em sock} & An open socket on which any applicable T\+LS handshaking has been completed already. \\
\hline
{\em local\+Addr} & Address and port of the local end of the socket. \\
\hline
{\em peer\+Addr} & Address and port of the remote end of the socket. \\
\hline
{\em codec} & A codec with which to parse/generate messages in whatever H\+T\+T\+P-\/like wire format this session needs. \\
\hline
\end{DoxyParams}


Definition at line 28 of file H\+T\+T\+P\+Downstream\+Session.\+h.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, and proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Transport\+Direction().


\begin{DoxyCode}
36                                  :
37     HTTPSession(timeout, std::move(sock), localAddr, peerAddr,
38                 CHECK\_NOTNULL(controller), std::move(codec), tinfo,
39                 infoCallback) \{
40       CHECK\_EQ(codec_->getTransportDirection(), TransportDirection::DOWNSTREAM);
41   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}!H\+T\+T\+P\+Downstream\+Session@{H\+T\+T\+P\+Downstream\+Session}}
\index{H\+T\+T\+P\+Downstream\+Session@{H\+T\+T\+P\+Downstream\+Session}!proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}}
\subsubsection[{H\+T\+T\+P\+Downstream\+Session(folly\+::\+H\+H\+Wheel\+Timer $\ast$timer, folly\+::\+Async\+Transport\+Wrapper\+::\+Unique\+Ptr \&\&sock, const folly\+::\+Socket\+Address \&local\+Addr, const folly\+::\+Socket\+Address \&peer\+Addr, H\+T\+T\+P\+Session\+Controller $\ast$controller, std\+::unique\+\_\+ptr$<$ H\+T\+T\+P\+Codec $>$ codec, const wangle\+::\+Transport\+Info \&tinfo, Info\+Callback $\ast$info\+Callback)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::\+H\+T\+T\+P\+Downstream\+Session (
\begin{DoxyParamCaption}
\item[{folly\+::\+H\+H\+Wheel\+Timer $\ast$}]{timer, }
\item[{folly\+::\+Async\+Transport\+Wrapper\+::\+Unique\+Ptr \&\&}]{sock, }
\item[{const folly\+::\+Socket\+Address \&}]{local\+Addr, }
\item[{const folly\+::\+Socket\+Address \&}]{peer\+Addr, }
\item[{{\bf H\+T\+T\+P\+Session\+Controller} $\ast$}]{controller, }
\item[{std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Codec} $>$}]{codec, }
\item[{const wangle\+::\+Transport\+Info \&}]{tinfo, }
\item[{{\bf Info\+Callback} $\ast$}]{info\+Callback}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HTTPDownstreamSession_ae6c0b003c3c94ee9488f022a01ca2f7d}


Definition at line 44 of file H\+T\+T\+P\+Downstream\+Session.\+h.



References all\+Transactions\+Started(), get\+Transaction\+Timeout\+Handler(), on\+Headers\+Sent(), on\+Native\+Protocol\+Upgrade(), setup\+On\+Headers\+Complete(), start\+Now(), stream\+ID, and $\sim$\+H\+T\+T\+P\+Downstream\+Session().


\begin{DoxyCode}
52                                  :
53     HTTPDownstreamSession(WheelTimerInstance(timer), std::move(sock), localAddr,
54         peerAddr,CHECK\_NOTNULL(controller), std::move(codec), tinfo,
55         infoCallback) \{
56   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}!````~H\+T\+T\+P\+Downstream\+Session@{$\sim$\+H\+T\+T\+P\+Downstream\+Session}}
\index{````~H\+T\+T\+P\+Downstream\+Session@{$\sim$\+H\+T\+T\+P\+Downstream\+Session}!proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}}
\subsubsection[{$\sim$\+H\+T\+T\+P\+Downstream\+Session() override}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::$\sim$\+H\+T\+T\+P\+Downstream\+Session (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTPDownstreamSession_a3450e20b817f8394ff919c8cf77b34a5}


Definition at line 20 of file H\+T\+T\+P\+Downstream\+Session.\+cpp.



Referenced by H\+T\+T\+P\+Downstream\+Session().


\begin{DoxyCode}
20                                               \{
21 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}!all\+Transactions\+Started@{all\+Transactions\+Started}}
\index{all\+Transactions\+Started@{all\+Transactions\+Started}!proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}}
\subsubsection[{all\+Transactions\+Started() const override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::all\+Transactions\+Started (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPDownstreamSession_ac4df02bf0fd27a6526aee299cee857e5}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session} \doxyref{}{p.}{classproxygen_1_1HTTPSession_a5353997f3caf71049568ad2c460424c5}.



Definition at line 96 of file H\+T\+T\+P\+Downstream\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+::transactions\+\_\+.



Referenced by H\+T\+T\+P\+Downstream\+Session().


\begin{DoxyCode}
96                                                          \{
97   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& txn: transactions_) \{
98     \textcolor{keywordflow}{if} (txn.second.isPushed() && !txn.second.isEgressStarted()) \{
99       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
100     \}
101   \}
102   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
103 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}!attach\+Thread\+Locals@{attach\+Thread\+Locals}}
\index{attach\+Thread\+Locals@{attach\+Thread\+Locals}!proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}}
\subsubsection[{attach\+Thread\+Locals(folly\+::\+Event\+Base $\ast$, folly\+::\+S\+S\+L\+Context\+Ptr, const Wheel\+Timer\+Instance \&, H\+T\+T\+P\+Session\+Stats $\ast$, Filter\+Iterator\+Fn, Header\+Codec\+::\+Stats $\ast$, H\+T\+T\+P\+Session\+Controller $\ast$) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::attach\+Thread\+Locals (
\begin{DoxyParamCaption}
\item[{folly\+::\+Event\+Base $\ast$}]{, }
\item[{folly\+::\+S\+S\+L\+Context\+Ptr}]{, }
\item[{const {\bf Wheel\+Timer\+Instance} \&}]{, }
\item[{{\bf H\+T\+T\+P\+Session\+Stats} $\ast$}]{, }
\item[{{\bf Filter\+Iterator\+Fn}}]{, }
\item[{{\bf Header\+Codec\+::\+Stats} $\ast$}]{, }
\item[{{\bf H\+T\+T\+P\+Session\+Controller} $\ast$}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPDownstreamSession_a6d2cc844677f65cf164b4eed7606752b}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_a4e810a1d803e52061964419128fc7fc5}.



Definition at line 95 of file H\+T\+T\+P\+Downstream\+Session.\+h.


\begin{DoxyCode}
101                                                            \{
102     LOG(FATAL) << \_\_func\_\_ << \textcolor{stringliteral}{" is an upstream interface"};
103   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}!detach\+Thread\+Locals@{detach\+Thread\+Locals}}
\index{detach\+Thread\+Locals@{detach\+Thread\+Locals}!proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}}
\subsubsection[{detach\+Thread\+Locals(bool) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::detach\+Thread\+Locals (
\begin{DoxyParamCaption}
\item[{bool}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPDownstreamSession_af8ac6b4b7a324b290b292988c78befca}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_a6c0ea565697840e3cceab93c8eb28462}.



Definition at line 105 of file H\+T\+T\+P\+Downstream\+Session.\+h.


\begin{DoxyCode}
105                                          \{
106     LOG(FATAL) << \_\_func\_\_ << \textcolor{stringliteral}{" is an upstream interface"};
107   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}!get\+Transaction\+Timeout\+Handler@{get\+Transaction\+Timeout\+Handler}}
\index{get\+Transaction\+Timeout\+Handler@{get\+Transaction\+Timeout\+Handler}!proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}}
\subsubsection[{get\+Transaction\+Timeout\+Handler(\+H\+T\+T\+P\+Transaction $\ast$txn) override}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Transaction\+::\+Handler} $\ast$ proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::get\+Transaction\+Timeout\+Handler (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Transaction} $\ast$}]{txn}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPDownstreamSession_a771c925d1b689f25408bb90a1f2144d4}
Called by \doxyref{transaction\+Timeout()}{p.}{classproxygen_1_1HTTPSession_a27a75b63b2d5d2e397fbf482209e6188} in the downstream case. This function ensures that a handler is set for the transaction. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session} \doxyref{}{p.}{classproxygen_1_1HTTPSession_af9a8e7884bf77f9c5831f652ff803616}.



Definition at line 65 of file H\+T\+T\+P\+Downstream\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::get\+Controller(), proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Local\+Address(), and proxygen\+::\+H\+T\+T\+P\+Session\+Controller\+::get\+Transaction\+Timeout\+Handler().



Referenced by H\+T\+T\+P\+Downstream\+Session().


\begin{DoxyCode}
66                         \{
67   \textcolor{keywordflow}{return} getController()->getTransactionTimeoutHandler(txn, getLocalAddress());
68 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}!is\+Closing@{is\+Closing}}
\index{is\+Closing@{is\+Closing}!proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}}
\subsubsection[{is\+Closing() const override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::is\+Closing (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPDownstreamSession_a8077893d0cff2926bbb4e9370f47a497}
Returns true if the session is shutting down 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_af525d1c596f37b737bfa80603ce0c22d}.



Definition at line 124 of file H\+T\+T\+P\+Downstream\+Session.\+h.


\begin{DoxyCode}
124                                   \{
125     LOG(FATAL) << \_\_func\_\_ << \textcolor{stringliteral}{" is an upstream interface"};
126     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
127   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}!is\+Detachable@{is\+Detachable}}
\index{is\+Detachable@{is\+Detachable}!proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}}
\subsubsection[{is\+Detachable(bool) const override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::is\+Detachable (
\begin{DoxyParamCaption}
\item[{bool}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPDownstreamSession_a2beb6f3dfd8249d0bcc751c95a909716}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_ac388822ab6bddae72234d11aaf661796}.



Definition at line 90 of file H\+T\+T\+P\+Downstream\+Session.\+h.


\begin{DoxyCode}
90                                          \{
91     LOG(FATAL) << \_\_func\_\_ << \textcolor{stringliteral}{" is an upstream interface"};
92     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
93   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}!is\+Replay\+Safe@{is\+Replay\+Safe}}
\index{is\+Replay\+Safe@{is\+Replay\+Safe}!proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}}
\subsubsection[{is\+Replay\+Safe() const override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::is\+Replay\+Safe (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPDownstreamSession_a404d39dbef6a9aba6fd20d9b742cb4c7}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_aef267ab2932aab69bf25e86c1cfb72ca}.



Definition at line 114 of file H\+T\+T\+P\+Downstream\+Session.\+h.


\begin{DoxyCode}
114                                      \{
115     LOG(FATAL) << \_\_func\_\_ << \textcolor{stringliteral}{" is an upstream interface"};
116     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
117   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}!is\+Reusable@{is\+Reusable}}
\index{is\+Reusable@{is\+Reusable}!proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}}
\subsubsection[{is\+Reusable() const override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::is\+Reusable (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPDownstreamSession_a42617632c08a98ebb7c2fc683225c226}
Returns true if the underlying transport can be used again in a new request. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_a0569fef3ef7600b314ae7598164c38a9}.



Definition at line 119 of file H\+T\+T\+P\+Downstream\+Session.\+h.


\begin{DoxyCode}
119                                    \{
120     LOG(FATAL) << \_\_func\_\_ << \textcolor{stringliteral}{" is an upstream interface"};
121     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
122   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}!new\+Transaction@{new\+Transaction}}
\index{new\+Transaction@{new\+Transaction}!proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}}
\subsubsection[{new\+Transaction(\+H\+T\+T\+P\+Transaction\+::\+Handler $\ast$) override}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Transaction}$\ast$ proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::new\+Transaction (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Transaction\+::\+Handler} $\ast$}]{handler}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPDownstreamSession_ac4f1622f52e102b9365272a3955bcba6}
Creates a new transaction on this upstream session. Invoking this function also has the side-\/affect of starting reads after this event loop completes.


\begin{DoxyParams}{Parameters}
{\em handler} & The request handler to attach to this transaction. It must not be null. \\
\hline
\end{DoxyParams}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_a1cd2bf610fd13e24dd2698329730ef61}.



Definition at line 109 of file H\+T\+T\+P\+Downstream\+Session.\+h.


\begin{DoxyCode}
109                                                                     \{
110     LOG(FATAL) << \_\_func\_\_ << \textcolor{stringliteral}{" is an upstream interface"};
111     \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};
112   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}!on\+Headers\+Sent@{on\+Headers\+Sent}}
\index{on\+Headers\+Sent@{on\+Headers\+Sent}!proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}}
\subsubsection[{on\+Headers\+Sent(const H\+T\+T\+P\+Message \&headers, bool codec\+Was\+Reusable) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::on\+Headers\+Sent (
\begin{DoxyParamCaption}
\item[{const {\bf H\+T\+T\+P\+Message} \&}]{headers, }
\item[{bool}]{codec\+Was\+Reusable}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPDownstreamSession_a31074b29a9d0287158c721de87b5ba58}
Invoked when headers have been sent. 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Session} \doxyref{}{p.}{classproxygen_1_1HTTPSession_af9ed177276be468c39890fd444d3b38c}.



Definition at line 71 of file H\+T\+T\+P\+Downstream\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+E\+R\+R\+\_\+\+R\+E\+SP, proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Status\+Code(), proxygen\+::\+H\+T\+T\+P\+Codec\+::is\+Reusable(), proxygen\+::\+R\+E\+M\+O\+T\+E\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::set\+Close\+Reason(), status\+Code, and proxygen\+::\+U\+N\+K\+N\+O\+WN.



Referenced by H\+T\+T\+P\+Downstream\+Session().


\begin{DoxyCode}
72                                                             \{
73   \textcolor{keywordflow}{if} (!codec_->isReusable()) \{
74     \textcolor{comment}{// If the codec turned unreusable, some thing wrong must have happened.}
75     \textcolor{comment}{// Basically, the proxy decides the connection is not reusable.}
76     \textcolor{comment}{// e.g, an error message is being sent with Connection: close}
77     \textcolor{keywordflow}{if} (codecWasReusable) \{
78       uint32\_t statusCode = headers.getStatusCode();
79       \textcolor{keywordflow}{if} (statusCode >= 500) \{
80         setCloseReason(ConnectionCloseReason::REMOTE_ERROR);
81       \} \textcolor{keywordflow}{else} \{
82         \textcolor{keywordflow}{if} (statusCode >= 400) \{
83           setCloseReason(ConnectionCloseReason::ERR_RESP);
84         \} \textcolor{keywordflow}{else} \{
85           \textcolor{comment}{// should not be here}
86           setCloseReason(ConnectionCloseReason::UNKNOWN);
87         \}
88       \}
89     \} \textcolor{keywordflow}{else} \{
90       \textcolor{comment}{// shouldn't happen... this case is detected by REQ\_NOTREUSABLE}
91       setCloseReason(ConnectionCloseReason::UNKNOWN);
92     \}
93   \}
94 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}!on\+Native\+Protocol\+Upgrade@{on\+Native\+Protocol\+Upgrade}}
\index{on\+Native\+Protocol\+Upgrade@{on\+Native\+Protocol\+Upgrade}!proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}}
\subsubsection[{on\+Native\+Protocol\+Upgrade(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D stream\+I\+D, Codec\+Protocol protocol, const std\+::string \&protocol\+String, H\+T\+T\+P\+Message \&msg) override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::on\+Native\+Protocol\+Upgrade (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{, }
\item[{{\bf Codec\+Protocol}}]{, }
\item[{const std\+::string \&}]{, }
\item[{{\bf H\+T\+T\+P\+Message} \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPDownstreamSession_a1c526ad7c5af7bc309bfb4f1a9a4ea9b}
Called upon receipt of a valid protocol switch. Return false if protocol switch could not be completed. 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_a862f51146984af8fbb64d32d1d27f094}.



Definition at line 106 of file H\+T\+T\+P\+Downstream\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Codec\+::add\+Priority\+Nodes(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, proxygen\+::\+H\+T\+T\+P\+Session\+::find\+Transaction(), proxygen\+::\+H\+T\+T\+P\+Codec\+Factory\+::get\+Codec(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Native\+Protocol\+Upgrade\+Impl(), proxygen\+::\+H\+T\+T\+P\+Headers\+::set(), proxygen\+::\+H\+T\+T\+P\+Message\+::set\+H\+T\+T\+P\+Version(), proxygen\+::\+H\+T\+T\+P\+Message\+::set\+Status\+Code(), proxygen\+::\+H\+T\+T\+P\+Message\+::set\+Status\+Message(), proxygen\+::\+H\+T\+T\+P\+Session\+::txn\+Egress\+Queue\+\_\+, and proxygen\+::\+H\+T\+T\+P\+Session\+::write\+Buf\+\_\+.



Referenced by H\+T\+T\+P\+Downstream\+Session().


\begin{DoxyCode}
109                     \{
110   VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" onNativeProtocolUpgrade streamID="} << streamID <<
111     \textcolor{stringliteral}{" protocol="} << protocolString;
112   \textcolor{keyword}{auto} txn = findTransaction(streamID);
113   CHECK(txn);
114   \textcolor{keywordflow}{if} (txn->canSendHeaders()) \{
115     \textcolor{comment}{// Create the new Codec}
116     \textcolor{keyword}{auto} codec = HTTPCodecFactory::getCodec(protocol,
117                                             TransportDirection::DOWNSTREAM);
118     CHECK(codec);
119     \textcolor{keywordflow}{if} (!codec->onIngressUpgradeMessage(msg)) \{
120       VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" codec rejected upgrade"};
121       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
122     \}
123 
124     \textcolor{comment}{// Send a 101 Switching Protocols message while we still have HTTP codec}
125     \textcolor{comment}{// Note: it's possible that the client timed out waiting for a}
126     \textcolor{comment}{// 100-continue and ended up here first.  In this case the 100 may go}
127     \textcolor{comment}{// out in the new protocol}
128     HTTPMessage switchingProtos;
129     switchingProtos.setHTTPVersion(1, 1);
130     switchingProtos.setStatusCode(101);
131     switchingProtos.setStatusMessage(\textcolor{stringliteral}{"Switching Protocols"});
132     switchingProtos.getHeaders().set(HTTP\_HEADER\_UPGRADE, protocolString);
133     switchingProtos.getHeaders().set(HTTP\_HEADER\_CONNECTION, \textcolor{stringliteral}{"Upgrade"});
134     txn->sendHeaders(switchingProtos);
135     \textcolor{comment}{// no sendEOM for 1xx}
136 
137     \textcolor{comment}{// This will actually switch the protocol}
138     \textcolor{keywordtype}{bool} ret = HTTPSession::onNativeProtocolUpgradeImpl(
139       streamID, std::move(codec), protocolString);
140     \textcolor{keywordflow}{if} (ret) \{
141       codec_->addPriorityNodes(txnEgressQueue_, writeBuf_, 0);
142     \}
143     \textcolor{keywordflow}{return} ret;
144   \} \textcolor{keywordflow}{else} \{
145     VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" plaintext upgrade failed due to early response"};
146     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
147   \}
148 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}!setup\+On\+Headers\+Complete@{setup\+On\+Headers\+Complete}}
\index{setup\+On\+Headers\+Complete@{setup\+On\+Headers\+Complete}!proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}}
\subsubsection[{setup\+On\+Headers\+Complete(\+H\+T\+T\+P\+Transaction $\ast$txn, H\+T\+T\+P\+Message $\ast$msg) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::setup\+On\+Headers\+Complete (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Transaction} $\ast$}]{txn, }
\item[{{\bf H\+T\+T\+P\+Message} $\ast$}]{msg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPDownstreamSession_a93c34ca69d797f3e31b11da08bd64a91}
Called by \doxyref{on\+Headers\+Complete()}{p.}{classproxygen_1_1HTTPSession_a01cf2e4876e0d44c1b7974833bef3272}. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session} \doxyref{}{p.}{classproxygen_1_1HTTPSession_ae180c928b2d55c4e227a1629d8b8a511}.



Definition at line 33 of file H\+T\+T\+P\+Downstream\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+E\+N\+A\+B\+L\+E\+\_\+\+E\+X\+\_\+\+H\+E\+A\+D\+E\+RS, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::get\+Controller(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+Control\+Stream(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+Handler(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+I\+D(), proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Ingress\+Settings(), proxygen\+::\+H\+T\+T\+P\+Session\+Controller\+::get\+Request\+Handler(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::set\+Handler(), proxygen\+::\+H\+T\+T\+P\+Session\+::set\+New\+Transaction\+Pause\+State(), and settings.



Referenced by H\+T\+T\+P\+Downstream\+Session().


\begin{DoxyCode}
34                                                                 \{
35   VLOG(5) << \textcolor{stringliteral}{"setupOnHeadersComplete txn="} << txn << \textcolor{stringliteral}{", id="} << txn->getID()
36           << \textcolor{stringliteral}{", handlder="} << txn->getHandler() << \textcolor{stringliteral}{", msg="} << msg;
37   \textcolor{keywordflow}{if} (txn->getHandler()) \{
38     \textcolor{comment}{// handler is installed before setupOnHeadersComplete callback. It must be}
39     \textcolor{comment}{// an EX\_HEADERS from client side, and ENABLE\_EX\_HEADERS == 1}
40     \textcolor{keyword}{const} \textcolor{keyword}{auto}* settings = codec_->getIngressSettings();
41     CHECK(settings && settings->getSetting(SettingsId::ENABLE_EX_HEADERS, 0));
42     CHECK(txn->getControlStream());
43     \textcolor{keywordflow}{return};
44   \}
45 
46   \textcolor{comment}{// We need to find a Handler to process the transaction.}
47   \textcolor{comment}{// Note: The handler is responsible for freeing itself}
48   \textcolor{comment}{// when it has finished processing the transaction.  The}
49   \textcolor{comment}{// transaction is responsible for freeing itself when both the}
50   \textcolor{comment}{// ingress and egress messages have completed (or failed).}
51   HTTPTransaction::Handler* handler = \textcolor{keyword}{nullptr};
52 
53   \textcolor{comment}{// In the general case, delegate to the handler factory to generate}
54   \textcolor{comment}{// a handler for the transaction.}
55   handler = getController()->getRequestHandler(*txn, msg);
56   CHECK(handler);
57 
58   DestructorGuard dg(\textcolor{keyword}{this});
59   \textcolor{keyword}{auto} txnID = txn->getID();
60   txn->setHandler(handler);
61   setNewTransactionPauseState(txnID);
62 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}!start\+Now@{start\+Now}}
\index{start\+Now@{start\+Now}!proxygen\+::\+H\+T\+T\+P\+Downstream\+Session@{proxygen\+::\+H\+T\+T\+P\+Downstream\+Session}}
\subsubsection[{start\+Now() override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::start\+Now (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPDownstreamSession_a3a03b89e4be6f8d06df0b770eeab06ed}
Start reading from the transport and send any introductory messages to the remote side. This function must be called once per session to begin reads. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_afb0355245a0beec339f0e493870a6114}.



Definition at line 24 of file H\+T\+T\+P\+Downstream\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Codec\+::add\+Priority\+Nodes(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+::start\+Now(), proxygen\+::\+H\+T\+T\+P\+Session\+::txn\+Egress\+Queue\+\_\+, and proxygen\+::\+H\+T\+T\+P\+Session\+::write\+Buf\+\_\+.



Referenced by H\+T\+T\+P\+Downstream\+Session(), proxygen\+::\+H\+T\+T\+P\+Session\+Acceptor\+::on\+New\+Connection(), and T\+E\+S\+T().


\begin{DoxyCode}
24                                 \{
25   \textcolor{comment}{// Create virtual nodes should happen before startNow since ingress may come}
26   \textcolor{comment}{// before we can finish startNow. Since maxLevel = 0, this is a no-op unless}
27   \textcolor{comment}{// SPDY is used. And no frame will be sent to peer, so ignore returned value.}
28   codec_->addPriorityNodes(txnEgressQueue_, writeBuf_, 0);
29   HTTPSession::startNow();
30 \}
\end{DoxyCode}


The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
proxygen/lib/http/session/{\bf H\+T\+T\+P\+Downstream\+Session.\+h}\item 
proxygen/lib/http/session/{\bf H\+T\+T\+P\+Downstream\+Session.\+cpp}\end{DoxyCompactItemize}
