\section{proxygen/lib/http/codec/compress/test/\+Q\+P\+A\+C\+K\+Context\+Tests.cpp File Reference}
\label{QPACKContextTests_8cpp}\index{proxygen/lib/http/codec/compress/test/\+Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{proxygen/lib/http/codec/compress/test/\+Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
{\ttfamily \#include $<$folly/\+Conv.\+h$>$}\\*
{\ttfamily \#include $<$glog/logging.\+h$>$}\\*
{\ttfamily \#include $<$folly/portability/\+G\+Test.\+h$>$}\\*
{\ttfamily \#include $<$folly/\+Format.\+h$>$}\\*
{\ttfamily \#include $<$memory$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/compress/\+Q\+P\+A\+C\+K\+Decoder.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/compress/\+Q\+P\+A\+C\+K\+Encoder.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/compress/\+Logging.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/compress/test/\+Test\+Streaming\+Callback.\+h$>$}\\*
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\bf T\+E\+ST} (Q\+P\+A\+C\+K\+Context\+Tests, Static\+Only)
\item 
{\bf T\+E\+ST} (Q\+P\+A\+C\+K\+Context\+Tests, Static\+Name\+Index)
\item 
{\bf T\+E\+ST} (Q\+P\+A\+C\+K\+Context\+Tests, Indexed)
\item 
{\bf T\+E\+ST} (Q\+P\+A\+C\+K\+Context\+Tests, Name\+Indexed)
\item 
{\bf T\+E\+ST} (Q\+P\+A\+C\+K\+Context\+Tests, Name\+Indexed\+Insert)
\item 
{\bf T\+E\+ST} (Q\+P\+A\+C\+K\+Context\+Tests, Post\+Base\+Name\+Indexed\+Literal)
\item 
{\bf T\+E\+ST} (Q\+P\+A\+C\+K\+Context\+Tests, Unacknowledged)
\item 
{\bf T\+E\+ST} (Q\+P\+A\+C\+K\+Context\+Tests, Test\+Draining)
\item 
{\bf T\+E\+ST} (Q\+P\+A\+C\+K\+Context\+Tests, Test\+Duplicate)
\item 
{\bf T\+E\+ST} (Q\+P\+A\+C\+K\+Context\+Tests, Test\+Table\+Size\+Update)
\item 
{\bf T\+E\+ST} (Q\+P\+A\+C\+K\+Context\+Tests, Test\+Table\+Size\+Update\+Max)
\item 
{\bf T\+E\+ST} (Q\+P\+A\+C\+K\+Context\+Tests, Test\+Encoder\+Flow\+Control)
\item 
{\bf T\+E\+ST} (Q\+P\+A\+C\+K\+Context\+Tests, Test\+Acks)
\item 
{\bf T\+E\+ST} (Q\+P\+A\+C\+K\+Context\+Tests, Test\+Implicit\+Acks)
\item 
{\bf T\+E\+ST} (Q\+P\+A\+C\+K\+Context\+Tests, Test\+Decode\+Queue)
\item 
{\bf T\+E\+ST} (Q\+P\+A\+C\+K\+Context\+Tests, Test\+Decode\+Queue\+Delete)
\item 
{\bf T\+E\+ST} (Q\+P\+A\+C\+K\+Context\+Tests, Test\+Decode\+Queue\+Reset\+Self)
\item 
{\bf T\+E\+ST} (Q\+P\+A\+C\+K\+Context\+Tests, Test\+Decode\+Max\+Uncompressed)
\item 
{\bf T\+E\+ST} (Q\+P\+A\+C\+K\+Context\+Tests, Test\+Decoder\+Stream\+Chunked)
\item 
{\bf T\+E\+ST} (Q\+P\+A\+C\+K\+Context\+Tests, Test\+Decode\+Partial\+Control)
\item 
{\bf T\+E\+ST} (Q\+P\+A\+C\+K\+Context\+Tests, Wrap\+L\+R\+Behind)
\item 
{\bf T\+E\+ST} (Q\+P\+A\+C\+K\+Context\+Tests, Wrap\+L\+R\+Ahead)
\item 
void {\bf check\+Q\+Error} ({\bf Q\+P\+A\+C\+K\+Decoder} \&decoder, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ buf, const {\bf H\+P\+A\+C\+K\+::\+Decode\+Error} err)
\item 
{\bf T\+E\+ST} (Q\+P\+A\+C\+K\+Context\+Tests, Decode\+Errors)
\item 
{\bf T\+E\+ST} (Q\+P\+A\+C\+K\+Context\+Tests, Test\+Evicted\+Name\+Reference)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!check\+Q\+Error@{check\+Q\+Error}}
\index{check\+Q\+Error@{check\+Q\+Error}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{check\+Q\+Error(\+Q\+P\+A\+C\+K\+Decoder \&decoder, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ buf, const H\+P\+A\+C\+K\+::\+Decode\+Error err)}]{\setlength{\rightskip}{0pt plus 5cm}void check\+Q\+Error (
\begin{DoxyParamCaption}
\item[{{\bf Q\+P\+A\+C\+K\+Decoder} \&}]{decoder, }
\item[{std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$}]{buf, }
\item[{const {\bf H\+P\+A\+C\+K\+::\+Decode\+Error}}]{err}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_a87cce80f5c61b87bdd388b5bf5965d0c}


Definition at line 669 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Decoder\+::decode\+Streaming().



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
670                                              \{
671   \textcolor{keyword}{auto} cb = std::make\_unique<TestStreamingCallback>();
672   \textcolor{keyword}{auto} len = buf->computeChainDataLength();
673   \textcolor{comment}{// streamID only matters for cancellation}
674   decoder.decodeStreaming(0, std::move(buf), len, cb.get());
675   EXPECT\_EQ(cb->error, err);
676 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Q\+P\+A\+C\+K\+Context\+Tests, Static\+Only)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Q\+P\+A\+C\+K\+Context\+Tests}]{, }
\item[{Static\+Only}]{}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_a4cefcbd04b67754ce437923472046ba4}


Definition at line 81 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result\+::control, proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode(), proxygen\+::\+Q\+P\+A\+C\+K\+Decoder\+::encode\+Table\+State\+Sync(), and proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result\+::stream.


\begin{DoxyCode}
81                                     \{
82   QPACKEncoder encoder(\textcolor{keyword}{true}, 128);
83   QPACKDecoder decoder(128);
84   vector<HPACKHeader> req;
85   \textcolor{comment}{// testing static indexes on request streams (6 bits)}
86   req.emplace\_back(\textcolor{stringliteral}{":authority"}, \textcolor{stringliteral}{""}); \textcolor{comment}{// qpack idx=0}
87   req.emplace\_back(\textcolor{stringliteral}{"x-xss-protection"}, \textcolor{stringliteral}{"1; mode=block"}); \textcolor{comment}{// idx=62}
88   req.emplace\_back(\textcolor{stringliteral}{":status"}, \textcolor{stringliteral}{"100"}); \textcolor{comment}{// idx=63}
89   req.emplace\_back(\textcolor{stringliteral}{"x-frame-options"}, \textcolor{stringliteral}{"sameorigin"}); \textcolor{comment}{// idx=last}
90   \textcolor{keyword}{auto} result = encoder.encode(req, 10, 1);
91   EXPECT\_EQ(result.control, \textcolor{keyword}{nullptr});
92   \textcolor{comment}{// prefix(2) + instr(1) + instr(1) + instr(2) + instr(2)}
93   EXPECT\_EQ(result.stream->computeChainDataLength(), 8);
94   EXPECT\_EQ(result.stream->data()[0], 0);
95   EXPECT\_EQ(result.stream->data()[1], 0);
96   verifyDecode(decoder, std::move(result), req);
97   \textcolor{comment}{// nothing to ack}
98   EXPECT\_EQ(decoder.encodeTableStateSync(), \textcolor{keyword}{nullptr});
99 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Q\+P\+A\+C\+K\+Context\+Tests, Static\+Name\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Q\+P\+A\+C\+K\+Context\+Tests}]{, }
\item[{Static\+Name\+Index}]{}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_aaf5370cebb5731f4c7c9a596949b6889}


Definition at line 101 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result\+::control, proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::on\+Header\+Ack(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::set\+Header\+Table\+Size(), and proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result\+::stream.


\begin{DoxyCode}
101                                          \{
102   QPACKEncoder encoder(\textcolor{keyword}{false}, 210);
103   QPACKDecoder decoder(210);
104   vector<HPACKHeader> req;
105 
106   \textcolor{comment}{// testing static name indexes on the control stream (6 bits)}
107   req.emplace\_back(\textcolor{stringliteral}{":authority"}, \textcolor{stringliteral}{"foo.com"}); \textcolor{comment}{// qpack idx=0}
108   req.emplace\_back(\textcolor{stringliteral}{"x-xss-protection"}, \textcolor{stringliteral}{"maximum"}); \textcolor{comment}{// idx=62}
109   \textcolor{comment}{// :status at index 63 won't be used by our encoder, it will prefer idx=24}
110   req.emplace\_back(\textcolor{stringliteral}{"accept-language"}, \textcolor{stringliteral}{"c++"}); \textcolor{comment}{// idx=72}
111   req.emplace\_back(\textcolor{stringliteral}{"x-frame-options"}, \textcolor{stringliteral}{"zzz"}); \textcolor{comment}{// idx=last}
112   \textcolor{keyword}{auto} result = encoder.encode(req, 10, 1);
113   \textcolor{comment}{// instr(1) + len(1) + foo.com(7) + instr(1) + len(1) + maximum(7) +}
114   \textcolor{comment}{// instr(2) + len(1) + c++(3) + instr(2) + len(1) + zzz(3) = 30}
115   EXPECT\_EQ(result.control->computeChainDataLength(), 30);
116   EXPECT\_EQ(result.stream->computeChainDataLength(), 6);
117   verifyDecode(decoder, std::move(result), req);
118 
119   req.clear();
120   \textcolor{comment}{// testing static name indexes in literals (4 bits)}
121   encoder.onHeaderAck(1, \textcolor{keyword}{false});
122   encoder.setHeaderTableSize(0);
123   req.emplace\_back(\textcolor{stringliteral}{"set-cookie"}, \textcolor{stringliteral}{"abc"}); \textcolor{comment}{// idx=14}
124   req.emplace\_back(\textcolor{stringliteral}{":method"}, \textcolor{stringliteral}{"DUDE"}); \textcolor{comment}{// idx=15}
125   result = encoder.encode(req, 10, 1);
126   \textcolor{comment}{// prefix(2) + instr(1) + len(1) + abc(3) + instr(2) + len(1) + DUDE(4) = 14}
127   EXPECT\_EQ(result.stream->computeChainDataLength(), 14);
128   verifyDecode(decoder, std::move(result), req);
129 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Q\+P\+A\+C\+K\+Context\+Tests, Indexed)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Q\+P\+A\+C\+K\+Context\+Tests}]{, }
\item[{Indexed}]{}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_abd93aed895ccf2808a6a2bcaf4dafffe}


Definition at line 131 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode().


\begin{DoxyCode}
131                                  \{
132   QPACKEncoder encoder(\textcolor{keyword}{true}, 128);
133   QPACKDecoder decoder(128);
134   vector<HPACKHeader> req;
135   \textcolor{comment}{// Encodes "Post Base"}
136   req.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"Blah"});
137   \textcolor{keyword}{auto} result = encoder.encode(req, 10, 1);
138   verifyDecode(decoder, std::move(result), req);
139   \textcolor{comment}{// Encodes "Normal"}
140   result = encoder.encode(req, 10, 2);
141   verifyDecode(decoder, std::move(result), req);
142 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Q\+P\+A\+C\+K\+Context\+Tests, Name\+Indexed)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Q\+P\+A\+C\+K\+Context\+Tests}]{, }
\item[{Name\+Indexed}]{}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_a4f326d792edeb9034b7169697509e8c9}


Definition at line 144 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode().


\begin{DoxyCode}
144                                      \{
145   QPACKEncoder encoder(\textcolor{keyword}{true}, 64);
146   QPACKDecoder decoder(64);
147   vector<HPACKHeader> req;
148 
149   \textcolor{comment}{// Encodes a "Post Base" name index since the table is full}
150   req.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"Blah"});
151   req.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"Blerg"});
152   \textcolor{keyword}{auto} result = encoder.encode(req, 10, 1);
153   verifyDecode(decoder, std::move(result), req);
154   \textcolor{comment}{// Encodes "Normal" name index}
155   result = encoder.encode(req, 10, 2);
156   verifyDecode(decoder, std::move(result), req);
157 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Q\+P\+A\+C\+K\+Context\+Tests, Name\+Indexed\+Insert)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Q\+P\+A\+C\+K\+Context\+Tests}]{, }
\item[{Name\+Indexed\+Insert}]{}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_aa81e9945f933c7b415637117f905d580}


Definition at line 159 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result\+::control, and proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode().


\begin{DoxyCode}
159                                            \{
160   QPACKEncoder encoder(\textcolor{keyword}{false}, 128);
161   QPACKDecoder decoder(128);
162   vector<HPACKHeader> req;
163 
164   req.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"Blah"});
165   \textcolor{keyword}{auto} result = encoder.encode(req, 10, 1);
166   verifyDecode(decoder, std::move(result), req);
167 
168   \textcolor{comment}{// Encodes an insert using a dynamic name reference}
169   req.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"Blerg"});
170   result = encoder.encode(req, 10, 2);
171   EXPECT\_FALSE(stringInOutput(result.control.get(), \textcolor{stringliteral}{"blarf"}));
172   verifyDecode(decoder, std::move(result), req);
173 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Q\+P\+A\+C\+K\+Context\+Tests, Post\+Base\+Name\+Indexed\+Literal)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Q\+P\+A\+C\+K\+Context\+Tests}]{, }
\item[{Post\+Base\+Name\+Indexed\+Literal}]{}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_a5301af922c3bf2231b1420d7c5680c4a}


Definition at line 175 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::set\+Max\+Vulnerable(), and proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result\+::stream.


\begin{DoxyCode}
175                                                     \{
176   QPACKEncoder encoder(\textcolor{keyword}{false}, 360);
177   QPACKDecoder decoder(360);
178   vector<HPACKHeader> req;
179 
180   encoder.setMaxVulnerable(1);
181   \textcolor{comment}{// Fills the table with exacty minFree (48) empty}
182   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = 0; i < 8; i++) \{
183     req.emplace\_back(folly::to<std::string>(\textcolor{stringliteral}{"Blarf"}, i), \textcolor{stringliteral}{"0"});
184   \}
185   \textcolor{comment}{// Too big to put in the table without evicting, perfect}
186   \textcolor{comment}{// for Post-Base Name-Indexed literal with idx=7}
187   req.emplace\_back(\textcolor{stringliteral}{"Blarf7"}, \textcolor{stringliteral}{"blergblergblerg"});
188   \textcolor{keyword}{auto} result = encoder.encode(req, 10, 1);
189   EXPECT\_EQ(result.stream->computeChainDataLength(),
190             2 \textcolor{comment}{/*prefix*/} + 8 \textcolor{comment}{/*pb indexed*/} + 2 \textcolor{comment}{/*name idx len*/} +
191             1 \textcolor{comment}{/*val len*/} + 15 \textcolor{comment}{/* value */});
192   verifyDecode(decoder, std::move(result), req);
193 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Q\+P\+A\+C\+K\+Context\+Tests, Unacknowledged)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Q\+P\+A\+C\+K\+Context\+Tests}]{, }
\item[{Unacknowledged}]{}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_a7e8886bd1ae313efc8623aedc7c7e22e}


Definition at line 196 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::set\+Max\+Vulnerable(), and proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result\+::stream.


\begin{DoxyCode}
196                                         \{
197   QPACKEncoder encoder(\textcolor{keyword}{true}, 128);
198   QPACKDecoder decoder(128);
199   \textcolor{comment}{// Disallow unack'd headers}
200   encoder.setMaxVulnerable(0);
201   vector<HPACKHeader> req;
202   req.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"Blah"});
203   \textcolor{keyword}{auto} result = encoder.encode(req, 10, 1);
204 
205   \textcolor{comment}{// Stream will encode a literal: prefix(2) + <more than 1>}
206   EXPECT\_GT(result.stream->computeChainDataLength(), 3);
207   verifyDecode(decoder, std::move(result), req);
208 
209   req.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"Blerg"});
210   result = encoder.encode(req, 10, 2);
211   EXPECT\_GT(result.stream->computeChainDataLength(), 4);
212   verifyDecode(decoder, std::move(result), req);
213 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Q\+P\+A\+C\+K\+Context\+Tests, Test\+Draining)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Q\+P\+A\+C\+K\+Context\+Tests}]{, }
\item[{Test\+Draining}]{}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_a6e3cbc9e06f666911362efe5f023cb39}


Definition at line 215 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode(), and proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result\+::stream.


\begin{DoxyCode}
215                                       \{
216   QPACKEncoder encoder(\textcolor{keyword}{false}, 128);
217   vector<HPACKHeader> req;
218   req.emplace\_back(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"gzip,deflate"});
219   \textcolor{keyword}{auto} result = encoder.encode(req, 0, 1);
220 
221   \textcolor{comment}{// This will result in the first header being drained in the middle}
222   \textcolor{comment}{// of encoding the new control channel, and force a literal.}
223   req.clear();
224   req.emplace\_back(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"sdch,gzip"});
225   req.emplace\_back(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"gzip,deflate"});
226   result = encoder.encode(req, 0, 2);
227   EXPECT\_GT(result.stream->computeChainDataLength(), 4);
228   EXPECT\_TRUE(stringInOutput(result.stream.get(), \textcolor{stringliteral}{"gzip,deflate"}));
229 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Q\+P\+A\+C\+K\+Context\+Tests, Test\+Duplicate)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Q\+P\+A\+C\+K\+Context\+Tests}]{, }
\item[{Test\+Duplicate}]{}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_a012e059b90f77f43b1fa7ddeee88c655}


Definition at line 231 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result\+::control, proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::on\+Table\+State\+Sync(), and proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result\+::stream.


\begin{DoxyCode}
231                                        \{
232   QPACKEncoder encoder(\textcolor{keyword}{false}, 200);
233   QPACKDecoder decoder(200);
234   vector<HPACKHeader> req;
235   \textcolor{comment}{// 5 inserts and one literal}
236   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = 0; i < 6; i++) \{
237     req.emplace\_back(folly::to<string>(\textcolor{charliteral}{'a'} + i), folly::to<string>(i));
238   \}
239   \textcolor{comment}{// a=0 should now be draining}
240   \textcolor{keyword}{auto} result = encoder.encode(req, 0, 1);
241   verifyDecode(decoder, std::move(result), req);
242   EXPECT\_EQ(encoder.onTableStateSync(5), HPACK::DecodeError::NONE);
243   EXPECT\_EQ(headerAck(decoder, encoder, 1), HPACK::DecodeError::NONE);
244   req.erase(req.begin() + 1, req.end());
245   result = encoder.encode(req, 0, 2);
246   \textcolor{comment}{// Control contains one-byte duplicate instruction, stream prefix + 1}
247   EXPECT\_EQ(result.control->computeChainDataLength(), 1);
248   EXPECT\_EQ(result.stream->computeChainDataLength(), 3);
249   verifyDecode(decoder, std::move(result), req);
250 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Q\+P\+A\+C\+K\+Context\+Tests, Test\+Table\+Size\+Update)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Q\+P\+A\+C\+K\+Context\+Tests}]{, }
\item[{Test\+Table\+Size\+Update}]{}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_adceda5b179b4a2c971ad64a98e03a5e3}


Definition at line 252 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode(), proxygen\+::\+Q\+P\+A\+C\+K\+Context\+::get\+Headers\+Stored(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::on\+Table\+State\+Sync(), and proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::set\+Header\+Table\+Size().


\begin{DoxyCode}
252                                              \{
253   QPACKEncoder encoder(\textcolor{keyword}{false}, 100);
254   QPACKDecoder decoder(200);
255   vector<HPACKHeader> req;
256   req.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"Blah"});
257   req.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"Blerg"});
258   \textcolor{keyword}{auto} result = encoder.encode(req, 0, 1);
259   verifyDecode(decoder, std::move(result), req);
260   EXPECT\_EQ(encoder.onTableStateSync(2), HPACK::DecodeError::NONE);
261   EXPECT\_EQ(headerAck(decoder, encoder, 1), HPACK::DecodeError::NONE);
262   encoder.setHeaderTableSize(64); \textcolor{comment}{// This will evict the oldest header}
263   EXPECT\_EQ(encoder.getHeadersStored(), 1);
264   result = encoder.encode(req, 0, 2);
265   verifyDecode(decoder, std::move(result), req);
266   EXPECT\_EQ(decoder.getHeadersStored(), 1);
267   EXPECT\_EQ(headerAck(decoder, encoder, 2), HPACK::DecodeError::NONE);
268 
269   encoder.setHeaderTableSize(100);
270   result = encoder.encode(req, 0, 3);
271   EXPECT\_EQ(encoder.getHeadersStored(), 2);
272   verifyDecode(decoder, std::move(result), req);
273   EXPECT\_EQ(decoder.getHeadersStored(), 2);
274 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Q\+P\+A\+C\+K\+Context\+Tests, Test\+Table\+Size\+Update\+Max)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Q\+P\+A\+C\+K\+Context\+Tests}]{, }
\item[{Test\+Table\+Size\+Update\+Max}]{}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_a7a1de6a65fa25f4ecd380f037303141c}


Definition at line 276 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode(), proxygen\+::\+Q\+P\+A\+C\+K\+Context\+::get\+Headers\+Stored(), and proxygen\+::\+Q\+P\+A\+C\+K\+Decoder\+::set\+Header\+Table\+Max\+Size().


\begin{DoxyCode}
276                                                 \{
277   \textcolor{comment}{// Encoder has table size 200 but decoder has 100.}
278   \textcolor{comment}{// Encoder never sends a TSU, and overflows the table.}
279   \textcolor{comment}{// Decoder fails}
280   QPACKEncoder encoder(\textcolor{keyword}{false}, 200);
281   QPACKDecoder decoder(200);
282   vector<HPACKHeader> req;
283   req.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"Blah"});
284   req.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"Blerg"});
285   req.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"Blingo"});
286   decoder.setHeaderTableMaxSize(100); \textcolor{comment}{// lower limit, should also shrink table}
287   \textcolor{keyword}{auto} result = encoder.encode(req, 0, 1);
288   verifyDecode(decoder, std::move(result), req,
289                HPACK::DecodeError::INVALID\_INDEX);
290   EXPECT\_EQ(decoder.getHeadersStored(), 2);
291 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Q\+P\+A\+C\+K\+Context\+Tests, Test\+Encoder\+Flow\+Control)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Q\+P\+A\+C\+K\+Context\+Tests}]{, }
\item[{Test\+Encoder\+Flow\+Control}]{}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_a5f7d9fe4b9fdceb104eac00874a5331a}


Definition at line 293 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result\+::control, proxygen\+::\+Q\+P\+A\+C\+K\+Decoder\+::decode\+Encoder\+Stream(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode(), and proxygen\+::\+Q\+P\+A\+C\+K\+Context\+::get\+Headers\+Stored().


\begin{DoxyCode}
293                                                 \{
294   QPACKEncoder encoder(\textcolor{keyword}{false}, 170);
295   QPACKDecoder decoder(170);
296   vector<HPACKHeader> req;
297   req.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"Blah"});
298   req.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"Blerg"});
299   req.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"Blingo"});
300   \textcolor{keyword}{auto} result = encoder.encode(req, 0, 1, 0);
301   EXPECT\_EQ(result.control, \textcolor{keyword}{nullptr});
302   verifyDecode(decoder, std::move(result), req,
303                HPACK::DecodeError::NONE);
304   EXPECT\_EQ(decoder.getHeadersStored(), 0);
305 
306   \textcolor{comment}{// There is enough room for the first header only}
307   result = encoder.encode(req, 0, 1, 11);
308   EXPECT\_EQ(result.control->computeChainDataLength(), 11);
309   EXPECT\_FALSE(stringInOutput(result.stream.get(), \textcolor{stringliteral}{"Blah"}));
310   EXPECT\_TRUE(stringInOutput(result.stream.get(), \textcolor{stringliteral}{"Blerg"}));
311   EXPECT\_TRUE(stringInOutput(result.stream.get(), \textcolor{stringliteral}{"Blingo"}));
312   verifyDecode(decoder, std::move(result), req,
313                HPACK::DecodeError::NONE);
314   EXPECT\_EQ(decoder.getHeadersStored(), 1);
315 
316   \textcolor{comment}{// Blarf is name indexed, Blah is indexed, Blerg fits, Blingo is encoded but}
317   \textcolor{comment}{// doesn't get used because it only half-fits}
318   result = encoder.encode(req, 0, 1, 10);
319   EXPECT\_EQ(result.control->computeChainDataLength(), 15);
320   EXPECT\_FALSE(stringInOutput(result.stream.get(), \textcolor{stringliteral}{"Blah"}));
321   EXPECT\_FALSE(stringInOutput(result.stream.get(), \textcolor{stringliteral}{"Blerg"}));
322   EXPECT\_TRUE(stringInOutput(result.control.get(), \textcolor{stringliteral}{"Blingo"}));
323   EXPECT\_TRUE(stringInOutput(result.stream.get(), \textcolor{stringliteral}{"Blingo"}));
324   \textcolor{keyword}{auto} controlTail = result.control->clone();
325   controlTail->trimStart(10);
326   result.control->trimEnd(5);
327   verifyDecode(decoder, std::move(result), req,
328                HPACK::DecodeError::NONE);
329   EXPECT\_EQ(decoder.getHeadersStored(), 2);
330   EXPECT\_EQ(decoder.decodeEncoderStream(std::move(controlTail)),
331             HPACK::DecodeError::NONE);
332   EXPECT\_EQ(decoder.getHeadersStored(), 3);
333 
334   \textcolor{comment}{// Blah is now drained, so the next encode should produce a duplicate we}
335   \textcolor{comment}{// can't use}
336   req.erase(req.begin() + 1, req.end());
337   result = encoder.encode(req, 0, 1, 0);
338   EXPECT\_EQ(result.control->computeChainDataLength(), 1);
339   EXPECT\_TRUE(stringInOutput(result.stream.get(), \textcolor{stringliteral}{"Blah"}));
340   verifyDecode(decoder, std::move(result), req,
341                HPACK::DecodeError::NONE);
342 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Q\+P\+A\+C\+K\+Context\+Tests, Test\+Acks)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Q\+P\+A\+C\+K\+Context\+Tests}]{, }
\item[{Test\+Acks}]{}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_a34fe242aea3018f7a48807973f99cd15}


Definition at line 344 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result\+::control, proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::on\+Table\+State\+Sync(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::set\+Max\+Vulnerable(), and proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result\+::stream.


\begin{DoxyCode}
344                                   \{
345   QPACKEncoder encoder(\textcolor{keyword}{false}, 100);
346   QPACKDecoder decoder(100);
347   encoder.setMaxVulnerable(1);
348   EXPECT\_EQ(encoder.onTableStateSync(1), HPACK::DecodeError::INVALID\_ACK);
349   EXPECT\_EQ(headerAck(decoder, encoder, 1), HPACK::DecodeError::INVALID\_ACK);
350 
351   vector<HPACKHeader> req;
352   req.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"BlahBlahBlah"});
353   \textcolor{keyword}{auto} result = encoder.encode(req, 0, 1);
354   verifyDecode(decoder, std::move(result), req);
355   req.clear();
356   req.emplace\_back(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"gzip, deflate"});
357   result = encoder.encode(req, 0, 1);
358   verifyDecode(decoder, std::move(result), req);
359   req.clear();
360   req.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"BlahBlahBlah"});
361   result = encoder.encode(req, 0, 1);
362   verifyDecode(decoder, std::move(result), req);
363 
364   \textcolor{comment}{// Blarf: Blah is unacknowledged and maxVulnerable is 1 -> literal}
365   result = encoder.encode(req, 0, 2);
366   EXPECT\_EQ(result.control, \textcolor{keyword}{nullptr});
367   EXPECT\_TRUE(stringInOutput(result.stream.get(), \textcolor{stringliteral}{"blarf"}));
368   verifyDecode(decoder, std::move(result), req);
369 
370   \textcolor{comment}{// Table is full and Blarf: BlahBlahBlah cannot be evicted -> literal}
371   req.clear();
372   req.emplace\_back(\textcolor{stringliteral}{"Foo"}, \textcolor{stringliteral}{"BlahBlahBlahBlah!"});
373   result = encoder.encode(req, 0, 3);
374   EXPECT\_EQ(result.control, \textcolor{keyword}{nullptr});
375   EXPECT\_TRUE(stringInOutput(result.stream.get(), \textcolor{stringliteral}{"foo"}));
376   verifyDecode(decoder, std::move(result), req);
377   \textcolor{comment}{// ack is invalid because it's a pure literal}
378   EXPECT\_EQ(headerAck(decoder, encoder, 3), HPACK::DecodeError::INVALID\_ACK);
379 
380   \textcolor{comment}{// Should remove all encoder state.  Blarf: BlahBlahBlah can now be evicted}
381   \textcolor{comment}{// and a new vulnerable reference can be made.}
382   \textcolor{comment}{// stream 2 block was pure literals}
383   EXPECT\_EQ(headerAck(decoder, encoder, 2), HPACK::DecodeError::INVALID\_ACK);
384   EXPECT\_EQ(cancelStream(decoder, encoder, 1), HPACK::DecodeError::NONE);
385   EXPECT\_EQ(encoder.onTableStateSync(1), HPACK::DecodeError::NONE);
386 
387   result = encoder.encode(req, 0, 2);
388   \textcolor{comment}{// Encodes an insert}
389   EXPECT\_GT(result.control->computeChainDataLength(), 1);
390   EXPECT\_EQ(result.stream->computeChainDataLength(), 3);
391   EXPECT\_FALSE(stringInOutput(result.stream.get(), \textcolor{stringliteral}{"foo"}));
392   verifyDecode(decoder, std::move(result), req);
393 
394   EXPECT\_EQ(encoder.onTableStateSync(0), HPACK::DecodeError::INVALID\_ACK);
395 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Q\+P\+A\+C\+K\+Context\+Tests, Test\+Implicit\+Acks)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Q\+P\+A\+C\+K\+Context\+Tests}]{, }
\item[{Test\+Implicit\+Acks}]{}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_a29f711129df6c51b1670906444125dab}


Definition at line 397 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::on\+Header\+Ack(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::set\+Max\+Vulnerable(), and proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result\+::stream.


\begin{DoxyCode}
397                                           \{
398   QPACKEncoder encoder(\textcolor{keyword}{false}, 1024);
399   QPACKDecoder decoder(1024);
400   encoder.setMaxVulnerable(2);
401 
402   vector<HPACKHeader> req;
403   req.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"Blah"});
404   \textcolor{keyword}{auto} result = encoder.encode(req, 0, 1);
405   verifyDecode(decoder, std::move(result), req);
406   req.emplace\_back(\textcolor{stringliteral}{"Foo"}, \textcolor{stringliteral}{"Blah"});
407   result = encoder.encode(req, 0, 2);
408   verifyDecode(decoder, std::move(result), req);
409   EXPECT\_EQ(encoder.onHeaderAck(2, \textcolor{keyword}{false}), HPACK::DecodeError::NONE);
410   \textcolor{comment}{// both headers are now acknowledged, 1 unacked header allowed}
411   req.clear();
412   req.emplace\_back(\textcolor{stringliteral}{"Bar"}, \textcolor{stringliteral}{"Binky"});
413   result = encoder.encode(req, 0, 3);
414 
415   \textcolor{comment}{// No unacked headers allowed}
416   req.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"Blah"});
417   req.emplace\_back(\textcolor{stringliteral}{"Foo"}, \textcolor{stringliteral}{"Blah"});
418   result = encoder.encode(req, 0, 4);
419   EXPECT\_FALSE(stringInOutput(result.stream.get(), \textcolor{stringliteral}{"Blah"}));
420   verifyDecode(decoder, std::move(result), req);
421 
422   \textcolor{comment}{// cancel}
423   EXPECT\_EQ(encoder.onHeaderAck(2, \textcolor{keyword}{true}), HPACK::DecodeError::NONE);
424   EXPECT\_EQ(encoder.onHeaderAck(4, \textcolor{keyword}{true}), HPACK::DecodeError::NONE);
425 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Q\+P\+A\+C\+K\+Context\+Tests, Test\+Decode\+Queue)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Q\+P\+A\+C\+K\+Context\+Tests}]{, }
\item[{Test\+Decode\+Queue}]{}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_a3cce93c66cb7a84885d57d6717d3772a}


Definition at line 427 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode().


\begin{DoxyCode}
427                                          \{
428   QPACKEncoder encoder(\textcolor{keyword}{false}, 64);
429   QPACKDecoder decoder(64);
430 
431   vector<HPACKHeader> req1;
432   req1.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"Blah"});
433   \textcolor{keyword}{auto} result1 = encoder.encode(req1, 0, 1);
434 
435   vector<HPACKHeader> req2;
436   req2.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"Blerg"});
437   \textcolor{keyword}{auto} result2 = encoder.encode(req2, 0, 2);
438   verifyDecode(decoder, std::move(result2), req2);
439   verifyDecode(decoder, std::move(result1), req1);
440 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Q\+P\+A\+C\+K\+Context\+Tests, Test\+Decode\+Queue\+Delete)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Q\+P\+A\+C\+K\+Context\+Tests}]{, }
\item[{Test\+Decode\+Queue\+Delete}]{}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_a49e3b251c3c27f1a70a8b7939949e950}


Definition at line 442 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Decoder\+::decode\+Streaming(), and proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode().


\begin{DoxyCode}
442                                                \{
443   \textcolor{comment}{// This test deletes the decoder from a callback while there are items in}
444   \textcolor{comment}{// the queue}
445   QPACKEncoder encoder(\textcolor{keyword}{true}, 100);
446   \textcolor{keyword}{auto} decoder = std::make\_unique<QPACKDecoder>(100);
447 
448   vector<HPACKHeader> req1;
449   req1.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"Blah"});
450   \textcolor{keyword}{auto} result1 = encoder.encode(req1, 0, 1);
451 
452   vector<HPACKHeader> req2;
453   req2.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"Blerg"});
454   \textcolor{keyword}{auto} result2 = encoder.encode(req2, 0, 2);
455 
456 
457   \textcolor{comment}{// Decode #1, no control stream, queued}
458   \textcolor{keyword}{auto} cb1 = std::make\_unique<TestStreamingCallback>();
459   \textcolor{keyword}{auto} rawCb1 = cb1.get();
460   \textcolor{keyword}{auto} rawDecoder = decoder.get();
461   cb1->headersCompleteCb = [decoder=std::move(decoder)] () \textcolor{keyword}{mutable} \{
462     \textcolor{comment}{// Delete decoder from callback}
463     decoder.reset();
464   \};
465   \textcolor{keyword}{auto} length = result1.stream->computeChainDataLength();
466   rawDecoder->decodeStreaming(1, std::move(result1.stream), length, rawCb1);
467 
468   \textcolor{comment}{// Decode #2, no control stream, queued}
469   \textcolor{keyword}{auto} cb2 = std::make\_unique<TestStreamingCallback>();
470   length = result2.stream->computeChainDataLength();
471   rawDecoder->decodeStreaming(2, std::move(result2.stream), length, cb2.get());
472 
473   \textcolor{comment}{// Decode control stream #1, will unblock 1 and delete decoder}
474   EXPECT\_EQ(rawDecoder->decodeEncoderStream(std::move(result1.control)),
475             HPACK::DecodeError::NONE);
476 
477   \textcolor{comment}{// cb2 doesn't execute because the decoder was destroyed from cb1}
478   EXPECT\_EQ(cb2->error, HPACK::DecodeError::NONE);
479   EXPECT\_EQ(cb2->headers.size(), 0);
480 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Q\+P\+A\+C\+K\+Context\+Tests, Test\+Decode\+Queue\+Reset\+Self)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Q\+P\+A\+C\+K\+Context\+Tests}]{, }
\item[{Test\+Decode\+Queue\+Reset\+Self}]{}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_a5b908069913f2a19aba0151e4e562a8a}


Definition at line 482 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Decoder\+::decode\+Encoder\+Stream(), proxygen\+::\+Q\+P\+A\+C\+K\+Decoder\+::decode\+Streaming(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode(), proxygen\+::\+Q\+P\+A\+C\+K\+Decoder\+::encode\+Cancel\+Stream(), and proxygen\+::\+Test\+Streaming\+Callback\+::headers\+Complete\+Cb.


\begin{DoxyCode}
482                                                   \{
483   \textcolor{comment}{// This test calls cancelStream from inside the callback from drainQueue}
484   QPACKEncoder encoder(\textcolor{keyword}{true}, 100);
485   QPACKDecoder decoder(100);
486 
487   vector<HPACKHeader> req1;
488   req1.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"Blah"});
489   \textcolor{keyword}{auto} result1 = encoder.encode(req1, 0, 1);
490 
491   \textcolor{comment}{// Decode #1, no control stream, queued}
492   TestStreamingCallback cb1;
493   cb1.headersCompleteCb = [&] \{
494     decoder.encodeCancelStream(1);
495   \};
496   \textcolor{keyword}{auto} length = result1.stream->computeChainDataLength();
497   decoder.decodeStreaming(1, std::move(result1.stream), length, &cb1);
498 
499   \textcolor{comment}{// Decode control stream #1, will unblock 1 and reset it}
500   EXPECT\_EQ(decoder.decodeEncoderStream(std::move(result1.control)),
501             HPACK::DecodeError::NONE);
502 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Q\+P\+A\+C\+K\+Context\+Tests, Test\+Decode\+Max\+Uncompressed)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Q\+P\+A\+C\+K\+Context\+Tests}]{, }
\item[{Test\+Decode\+Max\+Uncompressed}]{}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_afc5a32780328b048bf7122f4ad46588e}


Definition at line 504 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode(), and proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+Base\+::set\+Max\+Uncompressed().


\begin{DoxyCode}
504                                                    \{
505   QPACKEncoder encoder(\textcolor{keyword}{false}, 64);
506   QPACKDecoder decoder(64);
507   decoder.setMaxUncompressed(5);
508 
509   vector<HPACKHeader> req;
510   req.emplace\_back(\textcolor{stringliteral}{"Blarf"}, \textcolor{stringliteral}{"Blah"});
511   \textcolor{keyword}{auto} result = encoder.encode(req, 0, 1);
512   verifyDecode(decoder, std::move(result), req,
513                HPACK::DecodeError::HEADERS\_TOO\_LARGE);
514 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Q\+P\+A\+C\+K\+Context\+Tests, Test\+Decoder\+Stream\+Chunked)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Q\+P\+A\+C\+K\+Context\+Tests}]{, }
\item[{Test\+Decoder\+Stream\+Chunked}]{}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_a8cca3626c6ad7437ead1be192a6ce80f}


Definition at line 516 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result\+::control, proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::decode\+Decoder\+Stream(), proxygen\+::\+Q\+P\+A\+C\+K\+Decoder\+::decode\+Encoder\+Stream(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode(), proxygen\+::\+Q\+P\+A\+C\+K\+Decoder\+::encode\+Table\+State\+Sync(), proxygen\+::\+Q\+P\+A\+C\+K\+Context\+::get\+Table(), and proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::is\+Vulnerable().


\begin{DoxyCode}
516                                                   \{
517   QPACKEncoder encoder(\textcolor{keyword}{false}, 5000);
518   QPACKDecoder decoder(5000);
519 
520   vector<HPACKHeader> req;
521   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = 0; i < 128; i++) \{
522     req.emplace\_back(\textcolor{stringliteral}{"a"}, folly::to<string>(i));
523   \}
524   \textcolor{keyword}{auto} result = encoder.encode(req, 0, 1);
525   EXPECT\_EQ(decoder.decodeEncoderStream(std::move(result.control)),
526             HPACK::DecodeError::NONE);
527   \textcolor{keyword}{auto} ack = decoder.encodeTableStateSync();
528   EXPECT\_EQ(ack->computeChainDataLength(), 2);
529   \textcolor{keyword}{auto} ackPart = ack->clone();
530   ackPart->trimEnd(1);
531   ack->trimStart(1);
532   EXPECT\_EQ(encoder.decodeDecoderStream(std::move(ackPart)),
533             HPACK::DecodeError::NONE);
534   EXPECT\_EQ(encoder.decodeDecoderStream(std::move(ack)),
535             HPACK::DecodeError::NONE);
536   EXPECT\_FALSE(encoder.getTable().isVulnerable(128));
537   EXPECT\_TRUE(encoder.getTable().isVulnerable(129));
538 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Q\+P\+A\+C\+K\+Context\+Tests, Test\+Decode\+Partial\+Control)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Q\+P\+A\+C\+K\+Context\+Tests}]{, }
\item[{Test\+Decode\+Partial\+Control}]{}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_afc0c689a72851501a0699b6289c5fb8b}


Definition at line 540 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result\+::control, proxygen\+::\+Q\+P\+A\+C\+K\+Decoder\+::decode\+Encoder\+Stream(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode(), proxygen\+::\+Q\+P\+A\+C\+K\+Context\+::get\+Header(), and proxygen\+::\+Q\+P\+A\+C\+K\+Context\+::get\+Headers\+Stored().


\begin{DoxyCode}
540                                                   \{
541   QPACKEncoder encoder(\textcolor{keyword}{false}, 1000);
542   QPACKDecoder decoder(1000);
543 
544   vector<HPACKHeader> req;
545   req.emplace\_back(\textcolor{stringliteral}{"abcdeabcdeabcdeabcdeabcdeabcdeabcde"},
546                    \textcolor{stringliteral}{"vwxyzvwxyzvwxyzvwxyzvwxyzvwxyzvwxyz"});
547   \textcolor{keyword}{auto} result = encoder.encode(req, 0, 1);
548   folly::io::Cursor c(result.control.get());
549   \textcolor{keywordflow}{while} (!c.isAtEnd()) \{
550     std::unique\_ptr<folly::IOBuf> buf;
551     c.clone(buf, 1);
552     EXPECT\_EQ(decoder.decodeEncoderStream(std::move(buf)),
553               HPACK::DecodeError::NONE);
554   \}
555   EXPECT\_EQ(decoder.getHeadersStored(), 1);
556   EXPECT\_EQ(decoder.getHeader(\textcolor{keyword}{false}, 1, 1, \textcolor{keyword}{false}), req[0]);
557 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Q\+P\+A\+C\+K\+Context\+Tests, Wrap\+L\+R\+Behind)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Q\+P\+A\+C\+K\+Context\+Tests}]{, }
\item[{Wrap\+L\+R\+Behind}]{}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_a1fc3c6cb9cc141b9b5d1807e3bbe7a72}


Definition at line 559 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result\+::control, proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::decode\+Decoder\+Stream(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode(), proxygen\+::\+Q\+P\+A\+C\+K\+Decoder\+::encode\+Header\+Ack(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::set\+Min\+Free\+For\+Testing(), and proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result\+::stream.


\begin{DoxyCode}
559                                       \{
560   \textcolor{comment}{// This tests how LR wraps when the encoder and decoder have the same state}
561   uint32\_t tableSize = 1024;
562   uint32\_t maxEntries = tableSize / 32;
563   uint32\_t realMaxEntries = tableSize / (32 + \textcolor{keyword}{sizeof}(\textcolor{stringliteral}{"999"}));
564 
565   QPACKEncoder encoder(\textcolor{keyword}{true}, tableSize);
566   QPACKDecoder decoder(tableSize);
567   encoder.setMinFreeForTesting(0);
568   \textcolor{keywordflow}{for} (uint32\_t decoderBase = 0; decoderBase < maxEntries * 3; decoderBase++) \{
569     \textcolor{keywordflow}{if} (decoderBase > 0) \{
570       \textcolor{comment}{// add one more header to decoder}
571       vector<HPACKHeader> req;
572       VLOG(5) << \textcolor{stringliteral}{"priming decoder with h="} << decoderBase
573               << \textcolor{stringliteral}{" decoderBase="} << decoderBase;
574       req.emplace\_back(toFixedLengthString(decoderBase), \textcolor{stringliteral}{""});
575       \textcolor{keyword}{auto} result = encoder.encode(req, 10, 1);
576       EXPECT\_NE(result.control, \textcolor{keyword}{nullptr})
577         << \textcolor{stringliteral}{"Every encode should produce an insert"};
578       EXPECT\_TRUE(*verifyDecode(decoder, std::move(result), req));
579       EXPECT\_EQ(encoder.decodeDecoderStream(decoder.encodeHeaderAck(1)),
580                 HPACK::DecodeError::NONE);
581     \}
582     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} largestRef =
583            std::max<int64\_t>(0, int64\_t(decoderBase) - realMaxEntries + 1);
584          largestRef <= decoderBase; largestRef++) \{
585       VLOG(5) << \textcolor{stringliteral}{"WrapLR test decoderBase="} << decoderBase
586               << \textcolor{stringliteral}{" largestRef="} << largestRef;
587 
588       \textcolor{comment}{// Now send encode a request for the given largest reference.}
589       vector<HPACKHeader> req;
590       \textcolor{keywordflow}{if} (largestRef > 0) \{
591         req.emplace\_back(toFixedLengthString(largestRef), \textcolor{stringliteral}{""});
592       \} \textcolor{keywordflow}{else} \{
593         req.emplace\_back(\textcolor{stringliteral}{":scheme"}, \textcolor{stringliteral}{"https"});
594       \}
595       \textcolor{keyword}{auto} result = encoder.encode(req, 10, 2);
596       EXPECT\_EQ(result.control, \textcolor{keyword}{nullptr}); \textcolor{comment}{// no inserts}
597       CHECK\_EQ(result.stream->computeChainDataLength(), 3); \textcolor{comment}{// prefix + 1}
598       \textcolor{comment}{// the decoder should be able to immediately decode it}
599       EXPECT\_TRUE(*verifyDecode(decoder, std::move(result), req));
600       encoder.decodeDecoderStream(decoder.encodeHeaderAck(2));
601     \}
602   \}
603 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Q\+P\+A\+C\+K\+Context\+Tests, Wrap\+L\+R\+Ahead)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Q\+P\+A\+C\+K\+Context\+Tests}]{, }
\item[{Wrap\+L\+R\+Ahead}]{}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_a3e434f5f8a562afbd257d88a84c0fedd}


Definition at line 605 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result\+::control, proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::decode\+Decoder\+Stream(), proxygen\+::\+Q\+P\+A\+C\+K\+Decoder\+::decode\+Encoder\+Stream(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode(), proxygen\+::\+Q\+P\+A\+C\+K\+Decoder\+::encode\+Header\+Ack(), proxygen\+::\+Q\+P\+A\+C\+K\+Decoder\+::set\+Max\+Blocking(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::set\+Max\+Vulnerable(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::set\+Min\+Free\+For\+Testing(), and proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result\+::stream.


\begin{DoxyCode}
605                                      \{
606   \textcolor{comment}{// This tests how LR wraps when the encoder is up to a full table ahead of the}
607   \textcolor{comment}{// decoder.  tableSize is set such that realMaxEntries=64, which prevents}
608   \textcolor{comment}{// LR from being too far from base index as to expand the prefix.}
609   uint32\_t tableSize = 4064;
610   uint32\_t maxEntries = tableSize / 32;
611   uint32\_t realMaxEntries = tableSize / (32 + \textcolor{keyword}{sizeof}(\textcolor{stringliteral}{"999"}));
612 
613   \textcolor{comment}{// With QPACK-02, this would have produced an encoded stream buffer of 4}
614   \textcolor{comment}{// bytes.  Each loop of decoderBase is expensive, so start it at maxEntries,}
615   \textcolor{comment}{// and only run it until it actually would have made a difference in}
616   \textcolor{comment}{// the encoded size of largest reference.}
617   CHECK\_LE(realMaxEntries, 256);
618   \textcolor{keywordflow}{for} (uint32\_t decoderBase = maxEntries;
619        decoderBase < (256 - realMaxEntries);
620        decoderBase++) \{
621     QPACKEncoder encoder(\textcolor{keyword}{true}, tableSize);
622     QPACKDecoder decoder(tableSize);
623     encoder.setMaxVulnerable(realMaxEntries);
624     decoder.setMaxBlocking(realMaxEntries);
625     encoder.setMinFreeForTesting(0);
626     \textcolor{keywordflow}{for} (uint32\_t i = 1; i <= decoderBase; i++) \{
627       vector<HPACKHeader> req;
628       \textcolor{comment}{// populate the encoder and decode table to decoderBase.}
629       VLOG(5) << \textcolor{stringliteral}{"priming decoder with h="} << i
630               << \textcolor{stringliteral}{" decoderBase="} << decoderBase;
631       req.emplace\_back(toFixedLengthString(i), \textcolor{stringliteral}{""});
632       \textcolor{keyword}{auto} result = encoder.encode(req, 10, 1);
633       EXPECT\_NE(result.control, \textcolor{keyword}{nullptr})
634         << \textcolor{stringliteral}{"Every encode should produce an insert"};
635       EXPECT\_TRUE(*verifyDecode(decoder, std::move(result), req));
636       EXPECT\_EQ(encoder.decodeDecoderStream(decoder.encodeHeaderAck(1)),
637                 HPACK::DecodeError::NONE);
638     \}
639     folly::IOBufQueue controlQueue\{folly::IOBufQueue::cacheChainLength()\};
640     std::list<std::shared\_ptr<bool>> allDone;
641     vector<vector<HPACKHeader>> reqs;
642     reqs.reserve(2 * realMaxEntries);
643     \textcolor{comment}{// encode realMaxEntries requests past decoderBase, and queue the decodes}
644     \textcolor{comment}{// but don't process the inserts}
645     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} largestRef = decoderBase + 1;
646          largestRef <= decoderBase + realMaxEntries; largestRef++) \{
647       VLOG(5) << \textcolor{stringliteral}{"WrapLR test decoderBase="} << decoderBase
648               << \textcolor{stringliteral}{" largestRef="} << largestRef;
649       reqs.emplace\_back();
650       \textcolor{keyword}{auto}& req = reqs.back();
651       req.emplace\_back(toFixedLengthString(largestRef), \textcolor{stringliteral}{""});
652       \textcolor{keyword}{auto} result = encoder.encode(req, 10, largestRef);
653       EXPECT\_NE(result.control, \textcolor{keyword}{nullptr})
654         << \textcolor{stringliteral}{"Every encode should produce an insert"};
655       controlQueue.append(std::move(result.control));
656       CHECK\_EQ(result.stream->computeChainDataLength(), 3); \textcolor{comment}{// prefix + 1}
657       \textcolor{comment}{// the decoder has to block because the control stream is pending.}
658       \textcolor{comment}{// This verifies the whole batch of encodes against the same decoderBase}
659       allDone.emplace\_back(verifyDecode(decoder, std::move(result), req));
660     \}
661     \textcolor{comment}{// control block should unblock all requests}
662     decoder.decodeEncoderStream(controlQueue.move());
663     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& done: allDone) \{
664       EXPECT\_TRUE(*done);
665     \}
666   \}
667 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Q\+P\+A\+C\+K\+Context\+Tests, Decode\+Errors)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Q\+P\+A\+C\+K\+Context\+Tests}]{, }
\item[{Decode\+Errors}]{}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_ae309fa55bf03fb46c50bdea1ac37703a}


Definition at line 678 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References check\+Q\+Error(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::decode\+Decoder\+Stream(), proxygen\+::\+Q\+P\+A\+C\+K\+Decoder\+::decode\+Encoder\+Stream(), and proxygen\+::\+Q\+P\+A\+C\+K\+Decoder\+::set\+Max\+Blocking().


\begin{DoxyCode}
678                                       \{
679   QPACKDecoder decoder(128);
680   unique\_ptr<IOBuf> buf = IOBuf::create(128);
681 
682   VLOG(10) << \textcolor{stringliteral}{"Largest ref invalid"};
683   buf->writableData()[0] = 0xFF;
684   buf->append(1);
685   checkQError(decoder, buf->clone(), HPACK::DecodeError::BUFFER\_UNDERFLOW);
686 
687   VLOG(10) << \textcolor{stringliteral}{"Base delta missing"};
688   buf->writableData()[0] = 0x01;
689   checkQError(decoder, buf->clone(), HPACK::DecodeError::BUFFER\_UNDERFLOW);
690 
691   VLOG(10) << \textcolor{stringliteral}{"Base delta invalid"};
692   buf->writableData()[1] = 0xFF;
693   buf->append(1);
694   checkQError(decoder, buf->clone(), HPACK::DecodeError::BUFFER\_UNDERFLOW);
695 
696   VLOG(10) << \textcolor{stringliteral}{"Base delta too negative"};
697   buf->writableData()[0] = 0x01;
698   buf->writableData()[1] = 0x82;
699   checkQError(decoder, buf->clone(), HPACK::DecodeError::INVALID\_INDEX);
700 
701   VLOG(10) << \textcolor{stringliteral}{"Exceeds blocking max"};
702   decoder.setMaxBlocking(0);
703   buf->writableData()[0] = 0x02;
704   buf->writableData()[1] = 0x00;
705   checkQError(decoder, buf->clone(), HPACK::DecodeError::TOO\_MANY\_BLOCKING);
706 
707   \textcolor{comment}{// valid prefix}
708   buf->writableData()[0] = 0x00;
709   buf->writableData()[1] = 0x00;
710 
711   VLOG(10) << \textcolor{stringliteral}{"Literal bad name index"};
712   buf->writableData()[2] = 0x4F;
713   buf->append(1);
714   checkQError(decoder, buf->clone(), HPACK::DecodeError::BUFFER\_UNDERFLOW);
715 
716   VLOG(10) << \textcolor{stringliteral}{"Literal index name index"};
717   buf->writableData()[2] = 0x41;
718   checkQError(decoder, buf->clone(), HPACK::DecodeError::INVALID\_INDEX);
719 
720   VLOG(10) << \textcolor{stringliteral}{"Literal bad name length"};
721   buf->writableData()[2] = 0x27;
722   checkQError(decoder, buf->clone(), HPACK::DecodeError::BUFFER\_UNDERFLOW);
723 
724   VLOG(10) << \textcolor{stringliteral}{"Literal invalid value length"};
725   buf->writableData()[2] = 0x51;
726   buf->writableData()[3] = 0xFF;
727   buf->append(1);
728   checkQError(decoder, buf->clone(), HPACK::DecodeError::BUFFER\_UNDERFLOW);
729 
730   buf->trimEnd(1);
731   VLOG(10) << \textcolor{stringliteral}{"Bad Index"};
732   buf->writableData()[2] = 0xBF;
733   checkQError(decoder, buf->clone(), HPACK::DecodeError::BUFFER\_UNDERFLOW);
734 
735   VLOG(10) << \textcolor{stringliteral}{"Index static index"};
736   buf->writableData()[2] = 0xFF;
737   buf->writableData()[3] = 0x7E;
738   buf->append(1);
739   checkQError(decoder, buf->clone(), HPACK::DecodeError::INVALID\_INDEX);
740 
741   VLOG(10) << \textcolor{stringliteral}{"No error after previous error"};
742   buf->writableData()[0] = 0xC1;
743   buf->writableData()[1] = 0x01;
744   buf->writableData()[2] = 0x41;
745   buf->trimEnd(1);
746   EXPECT\_EQ(decoder.decodeEncoderStream(buf->clone()),
747             HPACK::DecodeError::NONE);
748 
749   VLOG(10) << \textcolor{stringliteral}{"Control decode error"};
750   QPACKDecoder decoder2(64);
751   buf->writableData()[0] = 0x01; \textcolor{comment}{// duplicate dynamic index 1}
752   buf->trimEnd(2);
753   EXPECT\_EQ(decoder2.decodeEncoderStream(buf->clone()),
754             HPACK::DecodeError::INVALID\_INDEX);
755 
756   QPACKEncoder encoder(\textcolor{keyword}{true}, 128);
757   buf->writableData()[0] = 0xFF;
758   buf->writableData()[1] = 0x80;
759   buf->writableData()[2] = 0xFF;
760   buf->writableData()[3] = 0xFF;
761   buf->writableData()[4] = 0xFF;
762   buf->writableData()[5] = 0xFF;
763   buf->writableData()[6] = 0xFF;
764   buf->writableData()[7] = 0xFF;
765   buf->writableData()[8] = 0xFF;
766   buf->writableData()[9] = 0xFF;
767   buf->writableData()[10] = 0xFF;
768   buf->writableData()[11] = 0x01;
769   buf->append(11);
770 
771   VLOG(10) << \textcolor{stringliteral}{"Bad header ack"};
772   EXPECT\_EQ(encoder.decodeDecoderStream(buf->clone()),
773             HPACK::DecodeError::INTEGER\_OVERFLOW);
774 
775   VLOG(10) << \textcolor{stringliteral}{"Bad cancel"};
776   buf->writableData()[0] = 0x7F;
777   EXPECT\_EQ(encoder.decodeDecoderStream(buf->clone()),
778             HPACK::DecodeError::INTEGER\_OVERFLOW);
779 
780   VLOG(10) << \textcolor{stringliteral}{"Bad table state sync"};
781   buf->writableData()[0] = 0x3F;
782   EXPECT\_EQ(encoder.decodeDecoderStream(buf->clone()),
783             HPACK::DecodeError::INTEGER\_OVERFLOW);
784 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!Q\+P\+A\+C\+K\+Context\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+Q\+P\+A\+C\+K\+Context\+Tests, Test\+Evicted\+Name\+Reference)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{Q\+P\+A\+C\+K\+Context\+Tests}]{, }
\item[{Test\+Evicted\+Name\+Reference}]{}
\end{DoxyParamCaption}
)}\label{QPACKContextTests_8cpp_a077245bb80dfb62a86ab36f0f18323b5}


Definition at line 786 of file Q\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result\+::control, proxygen\+::\+Q\+P\+A\+C\+K\+Decoder\+::decode\+Encoder\+Stream(), proxygen\+::\+Q\+P\+A\+C\+K\+Decoder\+::decode\+Streaming(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode(), proxygen\+::\+Test\+Streaming\+Callback\+::has\+Error(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::on\+Table\+State\+Sync(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::set\+Max\+Vulnerable(), and proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result\+::stream.


\begin{DoxyCode}
786                                                   \{
787   QPACKEncoder encoder(\textcolor{keyword}{false}, 109);
788   QPACKDecoder decoder(109);
789   encoder.setMaxVulnerable(0);
790   vector<HPACKHeader> req;
791   req.emplace\_back(\textcolor{stringliteral}{"x-accept-encoding"}, \textcolor{stringliteral}{"foobarfoobar"});
792   \textcolor{keyword}{auto} result = encoder.encode(req, 0, 1);
793   decoder.decodeEncoderStream(std::move(result.control));
794   decoder.decodeStreaming(1, result.stream->clone(),
795                           result.stream->computeChainDataLength(), \textcolor{keyword}{nullptr});
796   encoder.onTableStateSync(1);
797   req.clear();
798   req.emplace\_back(\textcolor{stringliteral}{"x-accept-encoding"}, \textcolor{stringliteral}{"barfoobarfoo"});
799   result = encoder.encode(req, 0, 2);
800   EXPECT\_TRUE(stringInOutput(result.stream.get(), \textcolor{stringliteral}{"x-accept-encoding"}));
801   TestStreamingCallback cb;
802   decoder.decodeEncoderStream(std::move(result.control));
803   decoder.decodeStreaming(2, result.stream->clone(),
804                           result.stream->computeChainDataLength(), &cb);
805   EXPECT\_FALSE(cb.hasError());
806 \}
\end{DoxyCode}
