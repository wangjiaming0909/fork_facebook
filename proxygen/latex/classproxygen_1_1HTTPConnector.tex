\section{proxygen\+:\+:H\+T\+T\+P\+Connector Class Reference}
\label{classproxygen_1_1HTTPConnector}\index{proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}}


{\ttfamily \#include $<$H\+T\+T\+P\+Connector.\+h$>$}

Inheritance diagram for proxygen\+:\+:H\+T\+T\+P\+Connector\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classproxygen_1_1HTTPConnector}
\end{center}
\end{figure}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class {\bf Callback}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf H\+T\+T\+P\+Connector} ({\bf Callback} $\ast$callback, folly\+::\+H\+H\+Wheel\+Timer $\ast$timeout\+Set)
\item 
{\bf H\+T\+T\+P\+Connector} ({\bf Callback} $\ast$callback, const {\bf Wheel\+Timer\+Instance} \&timeout)
\item 
{\bf $\sim$\+H\+T\+T\+P\+Connector} () override
\item 
void {\bf reset} ()
\item 
void {\bf set\+Plaintext\+Protocol} (const std\+::string \&plaintext\+Proto)
\item 
void {\bf set\+H\+T\+T\+P\+Version\+Override} (bool enabled)
\item 
void {\bf connect} (folly\+::\+Event\+Base $\ast$event\+Base, const folly\+::\+Socket\+Address \&connect\+Addr, std\+::chrono\+::milliseconds timeout\+Ms=std\+::chrono\+::milliseconds(0), const folly\+::\+Async\+Socket\+::\+Option\+Map \&socket\+Options=folly\+::\+Async\+Socket\+::empty\+Option\+Map, const folly\+::\+Socket\+Address \&bind\+Addr=folly\+::\+Async\+Socket\+::any\+Address())
\item 
void {\bf connect\+S\+SL} (folly\+::\+Event\+Base $\ast$event\+Base, const folly\+::\+Socket\+Address \&connect\+Addr, const std\+::shared\+\_\+ptr$<$ folly\+::\+S\+S\+L\+Context $>$ \&ctx, S\+S\+L\+\_\+\+S\+E\+S\+S\+I\+ON $\ast$session={\bf nullptr}, std\+::chrono\+::milliseconds timeout\+Ms=std\+::chrono\+::milliseconds(0), const folly\+::\+Async\+Socket\+::\+Option\+Map \&socket\+Options=folly\+::\+Async\+Socket\+::empty\+Option\+Map, const folly\+::\+Socket\+Address \&bind\+Addr=folly\+::\+Async\+Socket\+::any\+Address(), const std\+::string \&server\+Name={\bf empty\+\_\+string})
\item 
std\+::chrono\+::milliseconds {\bf time\+Elapsed} ()
\item 
bool {\bf is\+Busy} () const 
\item 
void {\bf set\+H\+T\+T\+P\+Codec\+Factory} (std\+::unique\+\_\+ptr$<$ {\bf Default\+H\+T\+T\+P\+Codec\+Factory} $>$ factory)
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
void {\bf connect\+Success} () noexceptoverride
\item 
void {\bf connect\+Err} (const folly\+::\+Async\+Socket\+Exception \&ex) noexceptoverride
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
{\bf Callback} $\ast$ {\bf cb\+\_\+}
\item 
{\bf Wheel\+Timer\+Instance} {\bf timeout\+\_\+}
\item 
folly\+::\+Async\+Transport\+Wrapper\+::\+Unique\+Ptr {\bf socket\+\_\+}
\item 
wangle\+::\+Transport\+Info {\bf transport\+Info\+\_\+}
\item 
std\+::string {\bf plaintext\+Protocol\+\_\+}
\item 
{\bf Time\+Point} {\bf connect\+Start\+\_\+}
\item 
std\+::unique\+\_\+ptr$<$ {\bf Default\+H\+T\+T\+P\+Codec\+Factory} $>$ {\bf http\+Codec\+Factory\+\_\+}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
This class establishes new connections to H\+T\+TP or H\+T\+T\+PS servers. It can be reused, even to connect to different addresses, but it can only service setting up one connection at a time. 

Definition at line 31 of file H\+T\+T\+P\+Connector.\+h.



\subsection{Constructor \& Destructor Documentation}
\index{proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}!H\+T\+T\+P\+Connector@{H\+T\+T\+P\+Connector}}
\index{H\+T\+T\+P\+Connector@{H\+T\+T\+P\+Connector}!proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}}
\subsubsection[{H\+T\+T\+P\+Connector(\+Callback $\ast$callback, folly\+::\+H\+H\+Wheel\+Timer $\ast$timeout\+Set)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+H\+T\+T\+P\+Connector\+::\+H\+T\+T\+P\+Connector (
\begin{DoxyParamCaption}
\item[{{\bf Callback} $\ast$}]{callback, }
\item[{folly\+::\+H\+H\+Wheel\+Timer $\ast$}]{timeout\+Set}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPConnector_a9b71b8cda280d59626800066066335e4}
Construct a \doxyref{H\+T\+T\+P\+Connector}{p.}{classproxygen_1_1HTTPConnector}. The constructor arguments are those parameters \doxyref{H\+T\+T\+P\+Connector}{p.}{classproxygen_1_1HTTPConnector} needs to keep a copy of through the connection process.


\begin{DoxyParams}{Parameters}
{\em callback} & The interface on which to receive the result. Whatever object is passed here M\+U\+ST outlive this connector and M\+U\+ST N\+OT be null. \\
\hline
{\em timeout\+Set} & The timeout set to be used for the transactions that are opened on the session. \\
\hline
\end{DoxyParams}


Definition at line 27 of file H\+T\+T\+P\+Connector.\+cpp.



Referenced by proxygen\+::\+H\+T\+T\+P\+Connector\+::\+Callback\+::$\sim$\+Callback().


\begin{DoxyCode}
29     : HTTPConnector(callback, WheelTimerInstance(timeoutSet)) \{
30 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}!H\+T\+T\+P\+Connector@{H\+T\+T\+P\+Connector}}
\index{H\+T\+T\+P\+Connector@{H\+T\+T\+P\+Connector}!proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}}
\subsubsection[{H\+T\+T\+P\+Connector(\+Callback $\ast$callback, const Wheel\+Timer\+Instance \&timeout)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+H\+T\+T\+P\+Connector\+::\+H\+T\+T\+P\+Connector (
\begin{DoxyParamCaption}
\item[{{\bf Callback} $\ast$}]{callback, }
\item[{const {\bf Wheel\+Timer\+Instance} \&}]{timeout}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPConnector_a21cc477f0704c2d60a67fa8d30b8c521}


Definition at line 32 of file H\+T\+T\+P\+Connector.\+cpp.


\begin{DoxyCode}
34     : cb_(CHECK\_NOTNULL(callback))
35     , timeout_(timeout)
36     , httpCodecFactory_(std::make\_unique<DefaultHTTPCodecFactory>(\textcolor{keyword}{false})) \{\}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}!````~H\+T\+T\+P\+Connector@{$\sim$\+H\+T\+T\+P\+Connector}}
\index{````~H\+T\+T\+P\+Connector@{$\sim$\+H\+T\+T\+P\+Connector}!proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}}
\subsubsection[{$\sim$\+H\+T\+T\+P\+Connector() override}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+H\+T\+T\+P\+Connector\+::$\sim$\+H\+T\+T\+P\+Connector (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}}\label{classproxygen_1_1HTTPConnector_aab64ec6ab074a4a5018583bd7537c2a1}
Clients may delete the connector at any time to cancel it. No callbacks will be received. 

Definition at line 38 of file H\+T\+T\+P\+Connector.\+cpp.



References reset().



Referenced by proxygen\+::\+H\+T\+T\+P\+Connector\+::\+Callback\+::$\sim$\+Callback().


\begin{DoxyCode}
38                               \{
39   reset();
40 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}!connect@{connect}}
\index{connect@{connect}!proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}}
\subsubsection[{connect(folly\+::\+Event\+Base $\ast$event\+Base, const folly\+::\+Socket\+Address \&connect\+Addr, std\+::chrono\+::milliseconds timeout\+Ms=std\+::chrono\+::milliseconds(0), const folly\+::\+Async\+Socket\+::\+Option\+Map \&socket\+Options=folly\+::\+Async\+Socket\+::empty\+Option\+Map, const folly\+::\+Socket\+Address \&bind\+Addr=folly\+::\+Async\+Socket\+::any\+Address())}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Connector\+::connect (
\begin{DoxyParamCaption}
\item[{folly\+::\+Event\+Base $\ast$}]{event\+Base, }
\item[{const folly\+::\+Socket\+Address \&}]{connect\+Addr, }
\item[{std\+::chrono\+::milliseconds}]{timeout\+Ms = {\ttfamily std\+:\+:chrono\+:\+:milliseconds(0)}, }
\item[{const folly\+::\+Async\+Socket\+::\+Option\+Map \&}]{socket\+Options = {\ttfamily folly\+:\+:AsyncSocket\+:\+:emptyOptionMap}, }
\item[{const folly\+::\+Socket\+Address \&}]{bind\+Addr = {\ttfamily folly\+:\+:AsyncSocket\+:\+:anyAddress()}}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPConnector_aa388aeef08ccf04ed37b08df505ed407}
Begin the process of getting a plaintext connection to the server specified by \textquotesingle{}connect\+Addr\textquotesingle{}. This function immediately starts async work and may invoke functions on \doxyref{Callback}{p.}{classproxygen_1_1HTTPConnector_1_1Callback} immediately.


\begin{DoxyParams}{Parameters}
{\em event\+Base} & The event base to put events on. \\
\hline
{\em connect\+Addr} & The address to connect to. \\
\hline
{\em timeout\+Ms} & Optional. If this value is greater than zero, then a connect error will be given if no connection is established within this amount of time. \\
\hline
{\em socket\+Options} & Optional socket options to set on the connection. \\
\hline
{\em bind\+Addr} & Optional address to bind to locally. \\
\hline
\end{DoxyParams}


Definition at line 59 of file H\+T\+T\+P\+Connector.\+cpp.



References connect\+Start\+\_\+, proxygen\+::get\+Current\+Time(), is\+Busy(), socket\+\_\+, and transport\+Info\+\_\+.



Referenced by Scoped\+Server\+Test\+::connect\+Plain\+Text(), Proxy\+Service\+::\+Proxy\+Handler\+::on\+Request(), T\+E\+S\+T(), and proxygen\+::\+H\+T\+T\+P\+Connector\+::\+Callback\+::$\sim$\+Callback().


\begin{DoxyCode}
64                                       \{
65 
66   DCHECK(!isBusy());
67   transportInfo_ = wangle::TransportInfo();
68   transportInfo_.secure = \textcolor{keyword}{false};
69   \textcolor{keyword}{auto} sock = \textcolor{keyword}{new} AsyncSocket(eventBase);
70   socket_.reset(sock);
71   connectStart_ = getCurrentTime();
72   sock->connect(\textcolor{keyword}{this}, connectAddr, timeoutMs.count(),
73                    socketOptions, bindAddr);
74 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}!connect\+Err@{connect\+Err}}
\index{connect\+Err@{connect\+Err}!proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}}
\subsubsection[{connect\+Err(const folly\+::\+Async\+Socket\+Exception \&ex) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Connector\+::connect\+Err (
\begin{DoxyParamCaption}
\item[{const folly\+::\+Async\+Socket\+Exception \&}]{ex}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPConnector_a71533a826400a944c290fee2c1cc4138}


Definition at line 151 of file H\+T\+T\+P\+Connector.\+cpp.



References cb\+\_\+, proxygen\+::\+H\+T\+T\+P\+Connector\+::\+Callback\+::connect\+Error(), and socket\+\_\+.



Referenced by set\+H\+T\+T\+P\+Codec\+Factory().


\begin{DoxyCode}
151                                                                       \{
152   socket_.reset();
153   \textcolor{keywordflow}{if} (cb_) \{
154     cb_->connectError(ex);
155   \}
156 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}!connect\+S\+SL@{connect\+S\+SL}}
\index{connect\+S\+SL@{connect\+S\+SL}!proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}}
\subsubsection[{connect\+S\+S\+L(folly\+::\+Event\+Base $\ast$event\+Base, const folly\+::\+Socket\+Address \&connect\+Addr, const std\+::shared\+\_\+ptr$<$ folly\+::\+S\+S\+L\+Context $>$ \&ctx, S\+S\+L\+\_\+\+S\+E\+S\+S\+I\+O\+N $\ast$session=nullptr, std\+::chrono\+::milliseconds timeout\+Ms=std\+::chrono\+::milliseconds(0), const folly\+::\+Async\+Socket\+::\+Option\+Map \&socket\+Options=folly\+::\+Async\+Socket\+::empty\+Option\+Map, const folly\+::\+Socket\+Address \&bind\+Addr=folly\+::\+Async\+Socket\+::any\+Address(), const std\+::string \&server\+Name=empty\+\_\+string)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Connector\+::connect\+S\+SL (
\begin{DoxyParamCaption}
\item[{folly\+::\+Event\+Base $\ast$}]{event\+Base, }
\item[{const folly\+::\+Socket\+Address \&}]{connect\+Addr, }
\item[{const std\+::shared\+\_\+ptr$<$ folly\+::\+S\+S\+L\+Context $>$ \&}]{ctx, }
\item[{S\+S\+L\+\_\+\+S\+E\+S\+S\+I\+ON $\ast$}]{session = {\ttfamily {\bf nullptr}}, }
\item[{std\+::chrono\+::milliseconds}]{timeout\+Ms = {\ttfamily std\+:\+:chrono\+:\+:milliseconds(0)}, }
\item[{const folly\+::\+Async\+Socket\+::\+Option\+Map \&}]{socket\+Options = {\ttfamily folly\+:\+:AsyncSocket\+:\+:emptyOptionMap}, }
\item[{const folly\+::\+Socket\+Address \&}]{bind\+Addr = {\ttfamily folly\+:\+:AsyncSocket\+:\+:anyAddress()}, }
\item[{const std\+::string \&}]{server\+Name = {\ttfamily {\bf empty\+\_\+string}}}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPConnector_a873a57e81dc0074ae8ffbb9edacd7074}
Begin the process of getting a secure connection to the server specified by \textquotesingle{}connect\+Addr\textquotesingle{}. This function immediately starts async work and may invoke functions on \doxyref{Callback}{p.}{classproxygen_1_1HTTPConnector_1_1Callback} immediately.


\begin{DoxyParams}{Parameters}
{\em event\+Base} & The event base to put events on. \\
\hline
{\em connect\+Addr} & The address to connect to. \\
\hline
{\em ctx} & S\+SL context to use. Must not be null. \\
\hline
{\em session} & Optional ssl session to use. \\
\hline
{\em timeout\+Ms} & Optional. If this value is greater than zero, then a connect error will be given if no connection is established within this amount of time. \\
\hline
{\em socket\+Options} & Optional socket options to set on the connection. \\
\hline
{\em bind\+Addr} & Optional address to bind to locally. \\
\hline
\end{DoxyParams}


Definition at line 76 of file H\+T\+T\+P\+Connector.\+cpp.



References connect\+Start\+\_\+, proxygen\+::get\+Current\+Time(), is\+Busy(), socket\+\_\+, and transport\+Info\+\_\+.



Referenced by Scoped\+Server\+Test\+::connect\+S\+S\+L(), and proxygen\+::\+H\+T\+T\+P\+Connector\+::\+Callback\+::$\sim$\+Callback().


\begin{DoxyCode}
84                                \{
85 
86   DCHECK(!isBusy());
87   transportInfo_ = wangle::TransportInfo();
88   transportInfo_.secure = \textcolor{keyword}{true};
89   \textcolor{keyword}{auto} sslSock = \textcolor{keyword}{new} AsyncSSLSocket(context, eventBase);
90   \textcolor{keywordflow}{if} (session) \{
91     sslSock->setSSLSession(session, \textcolor{keyword}{true} \textcolor{comment}{/* take ownership */});
92   \}
93   sslSock->setServerName(serverName);
94   sslSock->forceCacheAddrOnFailure(\textcolor{keyword}{true});
95   socket_.reset(sslSock);
96   connectStart_ = getCurrentTime();
97   sslSock->connect(\textcolor{keyword}{this}, connectAddr, timeoutMs.count(),
98                    socketOptions, bindAddr);
99 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}!connect\+Success@{connect\+Success}}
\index{connect\+Success@{connect\+Success}!proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}}
\subsubsection[{connect\+Success() noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Connector\+::connect\+Success (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPConnector_aa8a2d4230f1a52c46c1a0fc5bcc051cd}


Definition at line 110 of file H\+T\+T\+P\+Connector.\+cpp.



References cb\+\_\+, connect\+Start\+\_\+, proxygen\+::\+H\+T\+T\+P\+Connector\+::\+Callback\+::connect\+Success(), proxygen\+::get\+Current\+Time(), http\+Codec\+Factory\+\_\+, proxygen\+::milliseconds\+Since(), plaintext\+Protocol\+\_\+, socket\+\_\+, timeout\+\_\+, transport\+Info\+\_\+, and proxygen\+::\+U\+P\+S\+T\+R\+E\+AM.


\begin{DoxyCode}
110                                             \{
111   \textcolor{keywordflow}{if} (!cb_) \{
112     \textcolor{keywordflow}{return};
113   \}
114 
115   folly::SocketAddress localAddress;
116   folly::SocketAddress peerAddress;
117   socket_->getLocalAddress(&localAddress);
118   socket_->getPeerAddress(&peerAddress);
119 
120   std::unique\_ptr<HTTPCodec> codec;
121 
122   transportInfo_.acceptTime = getCurrentTime();
123   \textcolor{keywordflow}{if} (transportInfo_.secure) \{
124     AsyncSSLSocket* sslSocket = socket_->getUnderlyingTransport<AsyncSSLSocket>();
125 
126     \textcolor{keywordflow}{if} (sslSocket) \{
127       transportInfo_.appProtocol =
128           std::make\_shared<std::string>(socket_->getApplicationProtocol());
129       transportInfo_.sslSetupTime = millisecondsSince(connectStart_);
130       transportInfo_.sslCipher = sslSocket->getNegotiatedCipherName() ?
131         std::make\_shared<std::string>(sslSocket->getNegotiatedCipherName()) :
132         \textcolor{keyword}{nullptr};
133       transportInfo_.sslVersion = sslSocket->getSSLVersion();
134       transportInfo_.sslResume = wangle::SSLUtil::getResumeState(sslSocket);
135     \}
136     codec = httpCodecFactory_->getCodec(socket_->getApplicationProtocol(),
137                                         TransportDirection::UPSTREAM, \textcolor{keyword}{true});
138   \} \textcolor{keywordflow}{else} \{
139     codec = httpCodecFactory_->getCodec(plaintextProtocol_,
140                                         TransportDirection::UPSTREAM, \textcolor{keyword}{false});
141   \}
142 
143   HTTPUpstreamSession* session = \textcolor{keyword}{new} HTTPUpstreamSession(
144     timeout_,
145     std::move(socket_), localAddress, peerAddress,
146     std::move(codec), transportInfo_, \textcolor{keyword}{nullptr});
147 
148   cb_->connectSuccess(session);
149 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}!is\+Busy@{is\+Busy}}
\index{is\+Busy@{is\+Busy}!proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}}
\subsubsection[{is\+Busy() const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Connector\+::is\+Busy (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HTTPConnector_a9e4e63f497947654f54427676c4e8536}
\begin{DoxyReturn}{Returns}
true iff this connector is busy setting up a connection. If this is false, it is safe to call \doxyref{connect()}{p.}{classproxygen_1_1HTTPConnector_aa388aeef08ccf04ed37b08df505ed407} or \doxyref{connect\+S\+S\+L()}{p.}{classproxygen_1_1HTTPConnector_a873a57e81dc0074ae8ffbb9edacd7074} on it again. 
\end{DoxyReturn}


Definition at line 145 of file H\+T\+T\+P\+Connector.\+h.



References socket\+\_\+.



Referenced by connect(), and connect\+S\+S\+L().


\begin{DoxyCode}
145 \{ \textcolor{keywordflow}{return} socket_.get(); \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}!reset@{reset}}
\index{reset@{reset}!proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}}
\subsubsection[{reset()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Connector\+::reset (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPConnector_aebb4ed730ef6be25d6e25484ef4c5101}
Reset the object so that it can begin a new connection. No callbacks will be invoked as a result of executing this function. After this function returns, \doxyref{is\+Busy()}{p.}{classproxygen_1_1HTTPConnector_a9e4e63f497947654f54427676c4e8536} will return false. 

Definition at line 42 of file H\+T\+T\+P\+Connector.\+cpp.



References cb\+\_\+, and socket\+\_\+.



Referenced by proxygen\+::\+H\+T\+T\+P\+Connector\+::\+Callback\+::$\sim$\+Callback(), and $\sim$\+H\+T\+T\+P\+Connector().


\begin{DoxyCode}
42                           \{
43   \textcolor{keywordflow}{if} (socket_) \{
44     \textcolor{keyword}{auto} cb = cb_;
45     cb_ = \textcolor{keyword}{nullptr};
46     socket_.reset(); \textcolor{comment}{// This invokes connectError() but will be ignored}
47     cb_ = cb;
48   \}
49 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}!set\+H\+T\+T\+P\+Codec\+Factory@{set\+H\+T\+T\+P\+Codec\+Factory}}
\index{set\+H\+T\+T\+P\+Codec\+Factory@{set\+H\+T\+T\+P\+Codec\+Factory}!proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}}
\subsubsection[{set\+H\+T\+T\+P\+Codec\+Factory(std\+::unique\+\_\+ptr$<$ Default\+H\+T\+T\+P\+Codec\+Factory $>$ factory)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Connector\+::set\+H\+T\+T\+P\+Codec\+Factory (
\begin{DoxyParamCaption}
\item[{std\+::unique\+\_\+ptr$<$ {\bf Default\+H\+T\+T\+P\+Codec\+Factory} $>$}]{factory}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HTTPConnector_ad07a08ab9d5a29ca7c2bb93522542bba}


Definition at line 147 of file H\+T\+T\+P\+Connector.\+h.



References connect\+Err(), proxygen\+::\+H\+T\+T\+P\+Connector\+::\+Callback\+::connect\+Success(), and http\+Codec\+Factory\+\_\+.


\begin{DoxyCode}
147                                                                            \{
148     httpCodecFactory_ = std::move(factory);
149   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}!set\+H\+T\+T\+P\+Version\+Override@{set\+H\+T\+T\+P\+Version\+Override}}
\index{set\+H\+T\+T\+P\+Version\+Override@{set\+H\+T\+T\+P\+Version\+Override}!proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}}
\subsubsection[{set\+H\+T\+T\+P\+Version\+Override(bool enabled)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Connector\+::set\+H\+T\+T\+P\+Version\+Override (
\begin{DoxyParamCaption}
\item[{bool}]{enabled}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPConnector_a95173e3d81c24dec141f61de88caf7a4}
Overrides the H\+T\+TP version to always use the latest and greatest version we support. 

Definition at line 55 of file H\+T\+T\+P\+Connector.\+cpp.



References http\+Codec\+Factory\+\_\+.



Referenced by proxygen\+::\+H\+T\+T\+P\+Connector\+::\+Callback\+::$\sim$\+Callback().


\begin{DoxyCode}
55                                                        \{
56   httpCodecFactory_->setForceHTTP1xCodecTo1\_1(enabled);
57 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}!set\+Plaintext\+Protocol@{set\+Plaintext\+Protocol}}
\index{set\+Plaintext\+Protocol@{set\+Plaintext\+Protocol}!proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}}
\subsubsection[{set\+Plaintext\+Protocol(const std\+::string \&plaintext\+Proto)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Connector\+::set\+Plaintext\+Protocol (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{plaintext\+Proto}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPConnector_a64cf8f6d003dd0e2de03dde077669d32}
Sets the plain text protocol to use after the connection is established. 

Definition at line 51 of file H\+T\+T\+P\+Connector.\+cpp.



References plaintext\+Protocol\+\_\+.



Referenced by main(), and proxygen\+::\+H\+T\+T\+P\+Connector\+::\+Callback\+::$\sim$\+Callback().


\begin{DoxyCode}
51                                                                         \{
52   plaintextProtocol_ = plaintextProto;
53 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}!time\+Elapsed@{time\+Elapsed}}
\index{time\+Elapsed@{time\+Elapsed}!proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}}
\subsubsection[{time\+Elapsed()}]{\setlength{\rightskip}{0pt plus 5cm}std\+::chrono\+::milliseconds proxygen\+::\+H\+T\+T\+P\+Connector\+::time\+Elapsed (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPConnector_aabfb09f532b988bac9a688baf31af91a}
\begin{DoxyReturn}{Returns}
the number of milliseconds since connecting began, or zero if connecting hasn\textquotesingle{}t started yet. 
\end{DoxyReturn}


Definition at line 101 of file H\+T\+T\+P\+Connector.\+cpp.



References connect\+Start\+\_\+, proxygen\+::milliseconds\+Since(), and proxygen\+::time\+Point\+Initialized().



Referenced by proxygen\+::\+H\+T\+T\+P\+Connector\+::\+Callback\+::$\sim$\+Callback().


\begin{DoxyCode}
101                                                  \{
102   \textcolor{keywordflow}{if} (timePointInitialized(connectStart_)) \{
103     \textcolor{keywordflow}{return} millisecondsSince(connectStart_);
104   \}
105   \textcolor{keywordflow}{return} std::chrono::milliseconds(0);
106 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}!cb\+\_\+@{cb\+\_\+}}
\index{cb\+\_\+@{cb\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}}
\subsubsection[{cb\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Callback}$\ast$ proxygen\+::\+H\+T\+T\+P\+Connector\+::cb\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPConnector_a39f820952dcda9ba3f1fed1d2528e762}


Definition at line 157 of file H\+T\+T\+P\+Connector.\+h.



Referenced by connect\+Err(), connect\+Success(), and reset().

\index{proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}!connect\+Start\+\_\+@{connect\+Start\+\_\+}}
\index{connect\+Start\+\_\+@{connect\+Start\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}}
\subsubsection[{connect\+Start\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Time\+Point} proxygen\+::\+H\+T\+T\+P\+Connector\+::connect\+Start\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPConnector_abe97039a5b09e5064cb609785bb5271b}


Definition at line 162 of file H\+T\+T\+P\+Connector.\+h.



Referenced by connect(), connect\+S\+S\+L(), connect\+Success(), and time\+Elapsed().

\index{proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}!http\+Codec\+Factory\+\_\+@{http\+Codec\+Factory\+\_\+}}
\index{http\+Codec\+Factory\+\_\+@{http\+Codec\+Factory\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}}
\subsubsection[{http\+Codec\+Factory\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<${\bf Default\+H\+T\+T\+P\+Codec\+Factory}$>$ proxygen\+::\+H\+T\+T\+P\+Connector\+::http\+Codec\+Factory\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPConnector_a23b3b42f72a9a0b67ba5e890b7ba59e7}


Definition at line 163 of file H\+T\+T\+P\+Connector.\+h.



Referenced by connect\+Success(), set\+H\+T\+T\+P\+Codec\+Factory(), and set\+H\+T\+T\+P\+Version\+Override().

\index{proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}!plaintext\+Protocol\+\_\+@{plaintext\+Protocol\+\_\+}}
\index{plaintext\+Protocol\+\_\+@{plaintext\+Protocol\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}}
\subsubsection[{plaintext\+Protocol\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string proxygen\+::\+H\+T\+T\+P\+Connector\+::plaintext\+Protocol\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPConnector_ae0c66b0ab65f6bcf487e6ccb6ed2040e}


Definition at line 161 of file H\+T\+T\+P\+Connector.\+h.



Referenced by connect\+Success(), and set\+Plaintext\+Protocol().

\index{proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}!socket\+\_\+@{socket\+\_\+}}
\index{socket\+\_\+@{socket\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}}
\subsubsection[{socket\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+Async\+Transport\+Wrapper\+::\+Unique\+Ptr proxygen\+::\+H\+T\+T\+P\+Connector\+::socket\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPConnector_af5e7d70a9b3d8093deb6420fe50db925}


Definition at line 159 of file H\+T\+T\+P\+Connector.\+h.



Referenced by connect(), connect\+Err(), connect\+S\+S\+L(), connect\+Success(), is\+Busy(), and reset().

\index{proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}!timeout\+\_\+@{timeout\+\_\+}}
\index{timeout\+\_\+@{timeout\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}}
\subsubsection[{timeout\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Wheel\+Timer\+Instance} proxygen\+::\+H\+T\+T\+P\+Connector\+::timeout\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPConnector_a1523e11968c2f923d5d0a3a43fe88722}


Definition at line 158 of file H\+T\+T\+P\+Connector.\+h.



Referenced by connect\+Success().

\index{proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}!transport\+Info\+\_\+@{transport\+Info\+\_\+}}
\index{transport\+Info\+\_\+@{transport\+Info\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Connector@{proxygen\+::\+H\+T\+T\+P\+Connector}}
\subsubsection[{transport\+Info\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}wangle\+::\+Transport\+Info proxygen\+::\+H\+T\+T\+P\+Connector\+::transport\+Info\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPConnector_af81bd0169c1dafdf41918931a2bac9b9}


Definition at line 160 of file H\+T\+T\+P\+Connector.\+h.



Referenced by connect(), connect\+S\+S\+L(), and connect\+Success().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
proxygen/lib/http/{\bf H\+T\+T\+P\+Connector.\+h}\item 
proxygen/lib/http/{\bf H\+T\+T\+P\+Connector.\+cpp}\end{DoxyCompactItemize}
