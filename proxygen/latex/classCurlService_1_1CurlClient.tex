\section{Curl\+Service\+:\+:Curl\+Client Class Reference}
\label{classCurlService_1_1CurlClient}\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}


{\ttfamily \#include $<$Curl\+Client.\+h$>$}

Inheritance diagram for Curl\+Service\+:\+:Curl\+Client\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classCurlService_1_1CurlClient}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Curl\+Client} (folly\+::\+Event\+Base $\ast$evb, {\bf proxygen\+::\+H\+T\+T\+P\+Method} http\+Method, const {\bf proxygen\+::\+U\+RL} \&url, const {\bf proxygen\+::\+U\+RL} $\ast$proxy, const {\bf proxygen\+::\+H\+T\+T\+P\+Headers} \&headers, const std\+::string \&input\+Filename, bool h2c=false, unsigned short http\+Major=1, unsigned short http\+Minor=1)
\item 
virtual {\bf $\sim$\+Curl\+Client} ()=default
\item 
void {\bf initialize\+Ssl} (const std\+::string \&ca\+Path, const std\+::string \&next\+Protos, const std\+::string \&cert\+Path=\char`\"{}\char`\"{}, const std\+::string \&key\+Path=\char`\"{}\char`\"{})
\item 
void {\bf ssl\+Handshake\+Followup} ({\bf proxygen\+::\+H\+T\+T\+P\+Upstream\+Session} $\ast$session) noexcept
\item 
void {\bf connect\+Success} ({\bf proxygen\+::\+H\+T\+T\+P\+Upstream\+Session} $\ast$session) override
\item 
void {\bf connect\+Error} (const folly\+::\+Async\+Socket\+Exception \&ex) override
\item 
void {\bf set\+Transaction} ({\bf proxygen\+::\+H\+T\+T\+P\+Transaction} $\ast$txn) noexceptoverride
\item 
void {\bf detach\+Transaction} () noexceptoverride
\item 
void {\bf on\+Headers\+Complete} (std\+::unique\+\_\+ptr$<$ {\bf proxygen\+::\+H\+T\+T\+P\+Message} $>$ msg) noexceptoverride
\item 
void {\bf on\+Body} (std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ chain) noexceptoverride
\item 
void {\bf on\+Trailers} (std\+::unique\+\_\+ptr$<$ {\bf proxygen\+::\+H\+T\+T\+P\+Headers} $>$ trailers) noexceptoverride
\item 
void {\bf on\+E\+OM} () noexceptoverride
\item 
void {\bf on\+Upgrade} ({\bf proxygen\+::\+Upgrade\+Protocol} protocol) noexceptoverride
\item 
void {\bf on\+Error} (const {\bf proxygen\+::\+H\+T\+T\+P\+Exception} \&error) noexceptoverride
\item 
void {\bf on\+Egress\+Paused} () noexceptoverride
\item 
void {\bf on\+Egress\+Resumed} () noexceptoverride
\item 
void {\bf send\+Request} ({\bf proxygen\+::\+H\+T\+T\+P\+Transaction} $\ast$txn)
\item 
folly\+::\+S\+S\+L\+Context\+Ptr {\bf get\+S\+S\+L\+Context} ()
\item 
const std\+::string \& {\bf get\+Server\+Name} () const 
\item 
void {\bf set\+Flow\+Control\+Settings} (int32\+\_\+t recv\+Window)
\item 
const {\bf proxygen\+::\+H\+T\+T\+P\+Message} $\ast$ {\bf get\+Response} () const 
\item 
void {\bf set\+Logging} (bool enabled)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static {\bf proxygen\+::\+H\+T\+T\+P\+Headers} {\bf parse\+Headers} (const std\+::string \&headers\+String)
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
{\bf proxygen\+::\+H\+T\+T\+P\+Transaction} $\ast$ {\bf txn\+\_\+} \{{\bf nullptr}\}
\item 
folly\+::\+Event\+Base $\ast$ {\bf evb\+\_\+} \{{\bf nullptr}\}
\item 
{\bf proxygen\+::\+H\+T\+T\+P\+Method} {\bf http\+Method\+\_\+}
\item 
{\bf proxygen\+::\+U\+RL} {\bf url\+\_\+}
\item 
std\+::unique\+\_\+ptr$<$ {\bf proxygen\+::\+U\+RL} $>$ {\bf proxy\+\_\+}
\item 
{\bf proxygen\+::\+H\+T\+T\+P\+Message} {\bf request\+\_\+}
\item 
const std\+::string {\bf input\+Filename\+\_\+}
\item 
folly\+::\+S\+S\+L\+Context\+Ptr {\bf ssl\+Context\+\_\+}
\item 
int32\+\_\+t {\bf recv\+Window\+\_\+} \{0\}
\item 
bool {\bf logging\+Enabled\+\_\+} \{true\}
\item 
bool {\bf h2c\+\_\+} \{false\}
\item 
unsigned short {\bf http\+Major\+\_\+}
\item 
unsigned short {\bf http\+Minor\+\_\+}
\item 
std\+::unique\+\_\+ptr$<$ {\bf proxygen\+::\+H\+T\+T\+P\+Message} $>$ {\bf response\+\_\+}
\end{DoxyCompactItemize}


\subsection{Detailed Description}


Definition at line 20 of file Curl\+Client.\+h.



\subsection{Constructor \& Destructor Documentation}
\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!Curl\+Client@{Curl\+Client}}
\index{Curl\+Client@{Curl\+Client}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{Curl\+Client(folly\+::\+Event\+Base $\ast$evb, proxygen\+::\+H\+T\+T\+P\+Method http\+Method, const proxygen\+::\+U\+R\+L \&url, const proxygen\+::\+U\+R\+L $\ast$proxy, const proxygen\+::\+H\+T\+T\+P\+Headers \&headers, const std\+::string \&input\+Filename, bool h2c=false, unsigned short http\+Major=1, unsigned short http\+Minor=1)}]{\setlength{\rightskip}{0pt plus 5cm}Curl\+Service\+::\+Curl\+Client\+::\+Curl\+Client (
\begin{DoxyParamCaption}
\item[{folly\+::\+Event\+Base $\ast$}]{evb, }
\item[{{\bf proxygen\+::\+H\+T\+T\+P\+Method}}]{http\+Method, }
\item[{const {\bf proxygen\+::\+U\+RL} \&}]{url, }
\item[{const {\bf proxygen\+::\+U\+RL} $\ast$}]{proxy, }
\item[{const {\bf proxygen\+::\+H\+T\+T\+P\+Headers} \&}]{headers, }
\item[{const std\+::string \&}]{input\+Filename, }
\item[{bool}]{h2c = {\ttfamily false}, }
\item[{unsigned short}]{http\+Major = {\ttfamily 1}, }
\item[{unsigned short}]{http\+Minor = {\ttfamily 1}}
\end{DoxyParamCaption}
)}\label{classCurlService_1_1CurlClient_a42a858be5737f3e0abd4aa416a4aae31}


Definition at line 32 of file Curl\+Client.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Headers\+::add(), proxygen\+::\+H\+T\+T\+P\+Headers\+::for\+Each(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), proxygen\+::\+U\+R\+L\+::get\+Url(), proxy\+\_\+, and request\+\_\+.


\begin{DoxyCode}
41     : evb_(evb),
42       httpMethod_(httpMethod),
43       url_(url),
44       inputFilename_(inputFilename),
45       h2c_(h2c),
46       httpMajor_(httpMajor),
47       httpMinor_(httpMinor) \{
48   \textcolor{keywordflow}{if} (proxy != \textcolor{keyword}{nullptr}) \{
49     proxy_ = std::make\_unique<URL>(proxy->getUrl());
50   \}
51 
52   headers.forEach([\textcolor{keyword}{this}] (\textcolor{keyword}{const} \textcolor{keywordtype}{string}& header, \textcolor{keyword}{const} \textcolor{keywordtype}{string}& val) \{
53       request_.getHeaders().add(header, val);
54     \});
55 \}
\end{DoxyCode}
\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!````~Curl\+Client@{$\sim$\+Curl\+Client}}
\index{````~Curl\+Client@{$\sim$\+Curl\+Client}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{$\sim$\+Curl\+Client()=default}]{\setlength{\rightskip}{0pt plus 5cm}virtual Curl\+Service\+::\+Curl\+Client\+::$\sim$\+Curl\+Client (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}, {\ttfamily [default]}}\label{classCurlService_1_1CurlClient_a9043bca3122091124eb61baabcc4d4e5}


\subsection{Member Function Documentation}
\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!connect\+Error@{connect\+Error}}
\index{connect\+Error@{connect\+Error}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{connect\+Error(const folly\+::\+Async\+Socket\+Exception \&ex) override}]{\setlength{\rightskip}{0pt plus 5cm}void Curl\+Service\+::\+Curl\+Client\+::connect\+Error (
\begin{DoxyParamCaption}
\item[{const folly\+::\+Async\+Socket\+Exception \&}]{ex}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classCurlService_1_1CurlClient_af37e3647eb96eda96323787207c33e80}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Connector\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPConnector_1_1Callback_a4f01da41ef58437eeb47c1dee4a5bc47}.



Definition at line 187 of file Curl\+Client.\+cpp.



References proxygen\+::\+E\+R\+R\+OR, proxygen\+::\+U\+R\+L\+::get\+Host\+And\+Port(), logging\+Enabled\+\_\+, and url\+\_\+.


\begin{DoxyCode}
187                                                                  \{
188   LOG\_IF(ERROR, loggingEnabled_) << \textcolor{stringliteral}{"Coudln't connect to "}
189                                  << url_.getHostAndPort() << \textcolor{stringliteral}{":"} << ex.what();
190 \}
\end{DoxyCode}
\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!connect\+Success@{connect\+Success}}
\index{connect\+Success@{connect\+Success}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{connect\+Success(proxygen\+::\+H\+T\+T\+P\+Upstream\+Session $\ast$session) override}]{\setlength{\rightskip}{0pt plus 5cm}void Curl\+Service\+::\+Curl\+Client\+::connect\+Success (
\begin{DoxyParamCaption}
\item[{{\bf proxygen\+::\+H\+T\+T\+P\+Upstream\+Session} $\ast$}]{session}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classCurlService_1_1CurlClient_a8e0166bd540cf4a16b0ef1dd3accf882}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Connector\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPConnector_1_1Callback_aae878d2da74442ffc19ecb3bbbee7d9e}.



Definition at line 121 of file Curl\+Client.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+::close\+When\+Idle(), proxygen\+::\+U\+R\+L\+::is\+Secure(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::new\+Transaction(), recv\+Window\+\_\+, send\+Request(), proxygen\+::\+H\+T\+T\+P\+Session\+::set\+Flow\+Control(), ssl\+Handshake\+Followup(), and url\+\_\+.


\begin{DoxyCode}
121                                                             \{
122 
123   \textcolor{keywordflow}{if} (url_.isSecure()) \{
124     sslHandshakeFollowup(session);
125   \}
126 
127   session->setFlowControl(recvWindow_, recvWindow_, recvWindow_);
128   sendRequest(session->newTransaction(\textcolor{keyword}{this}));
129   session->closeWhenIdle();
130 \}
\end{DoxyCode}
\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!detach\+Transaction@{detach\+Transaction}}
\index{detach\+Transaction@{detach\+Transaction}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{detach\+Transaction() noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void Curl\+Service\+::\+Curl\+Client\+::detach\+Transaction (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classCurlService_1_1CurlClient_acdae4e65f5bdf0126630dcb03ec4a7fb}
Called once after a transaction successfully completes. It will be called even if a read or write error happened earlier. This is a terminal callback, which means that the H\+T\+T\+P\+Transaction object that gives this call will be invalid after this function completes. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+Handler} \doxyref{}{p.}{classproxygen_1_1HTTPTransactionHandler_a67eb253d121a26772f4caa56847ed7cd}.



Definition at line 195 of file Curl\+Client.\+cpp.


\begin{DoxyCode}
195                                             \{
196 \}
\end{DoxyCode}
\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!get\+Response@{get\+Response}}
\index{get\+Response@{get\+Response}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{get\+Response() const }]{\setlength{\rightskip}{0pt plus 5cm}const {\bf proxygen\+::\+H\+T\+T\+P\+Message}$\ast$ Curl\+Service\+::\+Curl\+Client\+::get\+Response (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classCurlService_1_1CurlClient_a1b2bb369d3320c6704ef5c3624e24d6f}


Definition at line 72 of file Curl\+Client.\+h.



References response\+\_\+.



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
72                                                  \{
73     \textcolor{keywordflow}{return} response_.get();
74   \}
\end{DoxyCode}
\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!get\+Server\+Name@{get\+Server\+Name}}
\index{get\+Server\+Name@{get\+Server\+Name}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{get\+Server\+Name() const }]{\setlength{\rightskip}{0pt plus 5cm}const string \& Curl\+Service\+::\+Curl\+Client\+::get\+Server\+Name (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classCurlService_1_1CurlClient_ad67c27bfa1474add9e1ec31b66641f1c}


Definition at line 248 of file Curl\+Client.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), proxygen\+::\+U\+R\+L\+::get\+Host(), proxygen\+::\+H\+T\+T\+P\+Headers\+::get\+Single\+Or\+Empty(), request\+\_\+, and url\+\_\+.



Referenced by get\+S\+S\+L\+Context().


\begin{DoxyCode}
248                                               \{
249   \textcolor{keyword}{const} \textcolor{keywordtype}{string}& res = request_.getHeaders().getSingleOrEmpty(HTTP\_HEADER\_HOST);
250   \textcolor{keywordflow}{if} (res.empty()) \{
251     \textcolor{keywordflow}{return} url_.getHost();
252   \}
253   \textcolor{keywordflow}{return} res;
254 \}
\end{DoxyCode}
\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!get\+S\+S\+L\+Context@{get\+S\+S\+L\+Context}}
\index{get\+S\+S\+L\+Context@{get\+S\+S\+L\+Context}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{get\+S\+S\+L\+Context()}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+S\+S\+L\+Context\+Ptr Curl\+Service\+::\+Curl\+Client\+::get\+S\+S\+L\+Context (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classCurlService_1_1CurlClient_adb219d4719c50b886776d3e17c6d3554}


Definition at line 66 of file Curl\+Client.\+h.



References get\+Server\+Name(), set\+Flow\+Control\+Settings(), and ssl\+Context\+\_\+.


\begin{DoxyCode}
66 \{ \textcolor{keywordflow}{return} sslContext_; \}
\end{DoxyCode}
\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!initialize\+Ssl@{initialize\+Ssl}}
\index{initialize\+Ssl@{initialize\+Ssl}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{initialize\+Ssl(const std\+::string \&ca\+Path, const std\+::string \&next\+Protos, const std\+::string \&cert\+Path="""", const std\+::string \&key\+Path="""")}]{\setlength{\rightskip}{0pt plus 5cm}void Curl\+Service\+::\+Curl\+Client\+::initialize\+Ssl (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{ca\+Path, }
\item[{const std\+::string \&}]{next\+Protos, }
\item[{const std\+::string \&}]{cert\+Path = {\ttfamily \char`\"{}\char`\"{}}, }
\item[{const std\+::string \&}]{key\+Path = {\ttfamily \char`\"{}\char`\"{}}}
\end{DoxyParamCaption}
)}\label{classCurlService_1_1CurlClient_a17d9333f43833c56ec41d9852db58067}


Definition at line 78 of file Curl\+Client.\+cpp.



References h2c\+\_\+, and ssl\+Context\+\_\+.


\begin{DoxyCode}
81                                                       \{
82   sslContext_ = std::make\_shared<folly::SSLContext>();
83   sslContext_->setOptions(SSL\_OP\_NO\_COMPRESSION);
84   sslContext_->setCipherList(folly::ssl::SSLCommonOptions::kCipherList);
85   \textcolor{keywordflow}{if} (!caPath.empty()) \{
86     sslContext_->loadTrustedCertificates(caPath.c\_str());
87   \}
88   \textcolor{keywordflow}{if} (!certPath.empty() && !keyPath.empty()) \{
89     sslContext_->loadCertKeyPairFromFiles(certPath.c\_str(), keyPath.c\_str());
90   \}
91   list<string> nextProtoList;
92   folly::splitTo<string>(\textcolor{charliteral}{','}, nextProtos, std::inserter(nextProtoList,
93                                                         nextProtoList.begin()));
94   sslContext_->setAdvertisedNextProtocols(nextProtoList);
95   h2c_ = \textcolor{keyword}{false};
96 \}
\end{DoxyCode}
\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!on\+Body@{on\+Body}}
\index{on\+Body@{on\+Body}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{on\+Body(std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ chain) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void Curl\+Service\+::\+Curl\+Client\+::on\+Body (
\begin{DoxyParamCaption}
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{chain}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classCurlService_1_1CurlClient_a347b9f1409c93387bfaf2ff88a400138}
Can be called multiple times per transaction. If you had previously called pause\+Ingress(), this callback will be delayed until you call resume\+Ingress(). 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+Handler} \doxyref{}{p.}{classproxygen_1_1HTTPTransactionHandler_a56a25d7fb8ac5ddf1ed5b16eaca3c5df}.



Definition at line 210 of file Curl\+Client.\+cpp.



References logging\+Enabled\+\_\+.


\begin{DoxyCode}
210                                                                 \{
211   \textcolor{keywordflow}{if} (!loggingEnabled_) \{
212     \textcolor{keywordflow}{return};
213   \}
214   \textcolor{keywordflow}{if} (chain) \{
215     \textcolor{keyword}{const} IOBuf* p = chain.get();
216     \textcolor{keywordflow}{do} \{
217       cout.write((\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)p->data(), p->length());
218       cout.flush();
219       p = p->next();
220     \} \textcolor{keywordflow}{while} (p != chain.get());
221   \}
222 \}
\end{DoxyCode}
\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!on\+Egress\+Paused@{on\+Egress\+Paused}}
\index{on\+Egress\+Paused@{on\+Egress\+Paused}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{on\+Egress\+Paused() noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void Curl\+Service\+::\+Curl\+Client\+::on\+Egress\+Paused (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classCurlService_1_1CurlClient_a26480fe7beb7f338dcf2dd1f6be11628}
If the remote side\textquotesingle{}s receive buffer fills up, this callback will be invoked so you can attempt to stop sending to the remote side. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+Handler} \doxyref{}{p.}{classproxygen_1_1HTTPTransactionHandler_a0a50acdb32cb51ecbf6a72730053a36b}.



Definition at line 240 of file Curl\+Client.\+cpp.



References logging\+Enabled\+\_\+.


\begin{DoxyCode}
240                                          \{
241   LOG\_IF(INFO, loggingEnabled_) << \textcolor{stringliteral}{"Egress paused"};
242 \}
\end{DoxyCode}
\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!on\+Egress\+Resumed@{on\+Egress\+Resumed}}
\index{on\+Egress\+Resumed@{on\+Egress\+Resumed}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{on\+Egress\+Resumed() noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void Curl\+Service\+::\+Curl\+Client\+::on\+Egress\+Resumed (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classCurlService_1_1CurlClient_a40fc8dafd3a048f5311b84e68a9495a3}
This callback lets you know that the remote side has resumed reading and you can now continue to send data. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+Handler} \doxyref{}{p.}{classproxygen_1_1HTTPTransactionHandler_a7715b02e413859c26426adbbde7e53d8}.



Definition at line 244 of file Curl\+Client.\+cpp.



References logging\+Enabled\+\_\+.


\begin{DoxyCode}
244                                           \{
245   LOG\_IF(INFO, loggingEnabled_) << \textcolor{stringliteral}{"Egress resumed"};
246 \}
\end{DoxyCode}
\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!on\+E\+OM@{on\+E\+OM}}
\index{on\+E\+OM@{on\+E\+OM}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{on\+E\+O\+M() noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void Curl\+Service\+::\+Curl\+Client\+::on\+E\+OM (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classCurlService_1_1CurlClient_a7c4b2f28e543ff77e626745c0917ae42}
Can be called once per transaction. If you had previously called pause\+Ingress(), this callback will be delayed until you call resume\+Ingress(). After this callback is received, there will be no more normal ingress callbacks received (on\+Egress$\ast$() and \doxyref{on\+Error()}{p.}{classCurlService_1_1CurlClient_ac58be91bdc9ec7fb485e343263d59678} may still be invoked). The Handler should consider ingress complete after receiving this message. This Transaction is still valid, and work may still occur on it until detach\+Transaction is called. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+Handler} \doxyref{}{p.}{classproxygen_1_1HTTPTransactionHandler_afdc4d4dec715841ba0c5bb5e58b1d53c}.



Definition at line 228 of file Curl\+Client.\+cpp.



References logging\+Enabled\+\_\+.


\begin{DoxyCode}
228                                 \{
229   LOG\_IF(INFO, loggingEnabled_) << \textcolor{stringliteral}{"Got EOM"};
230 \}
\end{DoxyCode}
\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!on\+Error@{on\+Error}}
\index{on\+Error@{on\+Error}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{on\+Error(const proxygen\+::\+H\+T\+T\+P\+Exception \&error) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void Curl\+Service\+::\+Curl\+Client\+::on\+Error (
\begin{DoxyParamCaption}
\item[{const {\bf proxygen\+::\+H\+T\+T\+P\+Exception} \&}]{error}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classCurlService_1_1CurlClient_ac58be91bdc9ec7fb485e343263d59678}
Can be called at any time before \doxyref{detach\+Transaction()}{p.}{classCurlService_1_1CurlClient_acdae4e65f5bdf0126630dcb03ec4a7fb}. This callback implies that an error has occurred. To determine if ingress or egress is affected, check the direciont on the H\+T\+T\+P\+Exception. If the direction is I\+N\+G\+R\+E\+SS, it M\+AY still be possible to send egress. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+Handler} \doxyref{}{p.}{classproxygen_1_1HTTPTransactionHandler_a585c21327eb30ab85ebdb84f663dab3b}.



Definition at line 236 of file Curl\+Client.\+cpp.



References proxygen\+::\+E\+R\+R\+OR, and logging\+Enabled\+\_\+.


\begin{DoxyCode}
236                                                             \{
237   LOG\_IF(ERROR, loggingEnabled_) << \textcolor{stringliteral}{"An error occurred: "} << error.what();
238 \}
\end{DoxyCode}
\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!on\+Headers\+Complete@{on\+Headers\+Complete}}
\index{on\+Headers\+Complete@{on\+Headers\+Complete}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{on\+Headers\+Complete(std\+::unique\+\_\+ptr$<$ proxygen\+::\+H\+T\+T\+P\+Message $>$ msg) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void Curl\+Service\+::\+Curl\+Client\+::on\+Headers\+Complete (
\begin{DoxyParamCaption}
\item[{std\+::unique\+\_\+ptr$<$ {\bf proxygen\+::\+H\+T\+T\+P\+Message} $>$}]{msg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classCurlService_1_1CurlClient_abfa6047eebf33dae96acd69f3f072956}
Called at most once per transaction. This is usually the first ingress callback. It is possible to get a read error before this however. If you had previously called pause\+Ingress(), this callback will be delayed until you call resume\+Ingress(). 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+Handler} \doxyref{}{p.}{classproxygen_1_1HTTPTransactionHandler_a5e431cbb4c065285c5ad65acaceb0b22}.



Definition at line 198 of file Curl\+Client.\+cpp.



References logging\+Enabled\+\_\+, and response\+\_\+.


\begin{DoxyCode}
198                                                                        \{
199   response_ = std::move(msg);
200   \textcolor{keywordflow}{if} (!loggingEnabled_) \{
201     \textcolor{keywordflow}{return};
202   \}
203   cout << response_->getStatusCode() << \textcolor{stringliteral}{" "}
204        << response_->getStatusMessage() << endl;
205   response_->getHeaders().forEach([&](\textcolor{keyword}{const} \textcolor{keywordtype}{string}& header, \textcolor{keyword}{const} \textcolor{keywordtype}{string}& val) \{
206     cout << header << \textcolor{stringliteral}{": "} << val << endl;
207   \});
208 \}
\end{DoxyCode}
\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!on\+Trailers@{on\+Trailers}}
\index{on\+Trailers@{on\+Trailers}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{on\+Trailers(std\+::unique\+\_\+ptr$<$ proxygen\+::\+H\+T\+T\+P\+Headers $>$ trailers) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void Curl\+Service\+::\+Curl\+Client\+::on\+Trailers (
\begin{DoxyParamCaption}
\item[{std\+::unique\+\_\+ptr$<$ {\bf proxygen\+::\+H\+T\+T\+P\+Headers} $>$}]{trailers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classCurlService_1_1CurlClient_a13f4e9d8894fba072798f6909f8f740b}
Can be called any number of times per transaction. If you had previously called pause\+Ingress(), this callback will be delayed until you call resume\+Ingress(). Trailers can be received once right before the E\+OM of a chunked H\+T\+T\+P/1.\+1 reponse or multiple times per transaction from S\+P\+DY and H\+T\+T\+P/2.\+0 H\+E\+A\+D\+E\+RS frames. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+Handler} \doxyref{}{p.}{classproxygen_1_1HTTPTransactionHandler_a219de67110f915deda30d18327f26393}.



Definition at line 224 of file Curl\+Client.\+cpp.



References logging\+Enabled\+\_\+.


\begin{DoxyCode}
224                                                                \{
225   LOG\_IF(INFO, loggingEnabled_) << \textcolor{stringliteral}{"Discarding trailers"};
226 \}
\end{DoxyCode}
\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!on\+Upgrade@{on\+Upgrade}}
\index{on\+Upgrade@{on\+Upgrade}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{on\+Upgrade(proxygen\+::\+Upgrade\+Protocol protocol) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void Curl\+Service\+::\+Curl\+Client\+::on\+Upgrade (
\begin{DoxyParamCaption}
\item[{{\bf proxygen\+::\+Upgrade\+Protocol}}]{protocol}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classCurlService_1_1CurlClient_ae64a3832725897be431f2473cf3abd8b}
Can be called once per transaction. If you had previously called pause\+Ingress(), this callback will be delayed until you call resume\+Ingress(). After this callback is invoked, further data will be forwarded using the \doxyref{on\+Body()}{p.}{classCurlService_1_1CurlClient_a347b9f1409c93387bfaf2ff88a400138} callback. Once the data transfer is completed (E\+OF recevied in case of C\+O\+N\+N\+E\+CT), \doxyref{on\+E\+O\+M()}{p.}{classCurlService_1_1CurlClient_a7c4b2f28e543ff77e626745c0917ae42} callback will be invoked. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+Handler} \doxyref{}{p.}{classproxygen_1_1HTTPTransactionHandler_acda954bf78c4d2aad951698e78c40a0f}.



Definition at line 232 of file Curl\+Client.\+cpp.



References logging\+Enabled\+\_\+.


\begin{DoxyCode}
232                                                    \{
233   LOG\_IF(INFO, loggingEnabled_) << \textcolor{stringliteral}{"Discarding upgrade protocol"};
234 \}
\end{DoxyCode}
\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!parse\+Headers@{parse\+Headers}}
\index{parse\+Headers@{parse\+Headers}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{parse\+Headers(const std\+::string \&headers\+String)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Headers} Curl\+Service\+::\+Curl\+Client\+::parse\+Headers (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{headers\+String}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classCurlService_1_1CurlClient_ab60fb767ca6e21620c56baf65c1b6a24}


Definition at line 57 of file Curl\+Client.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Headers\+::add().



Referenced by main().


\begin{DoxyCode}
57                                                                    \{
58   vector<StringPiece> headersList;
59   HTTPHeaders headers;
60   folly::split(\textcolor{stringliteral}{","}, headersString, headersList);
61   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& headerPair: headersList) \{
62     vector<StringPiece> nv;
63     folly::split(\textcolor{charliteral}{'='}, headerPair, nv);
64     \textcolor{keywordflow}{if} (nv.size() > 0) \{
65       \textcolor{keywordflow}{if} (nv[0].empty()) \{
66         \textcolor{keywordflow}{continue};
67       \}
68       StringPiece value(\textcolor{stringliteral}{""});
69       \textcolor{keywordflow}{if} (nv.size() > 1) \{
70         value = nv[1];
71       \} \textcolor{comment}{// trim anything else}
72       headers.add(nv[0], value);
73     \}
74   \}
75   \textcolor{keywordflow}{return} headers;
76 \}
\end{DoxyCode}
\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!send\+Request@{send\+Request}}
\index{send\+Request@{send\+Request}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{send\+Request(proxygen\+::\+H\+T\+T\+P\+Transaction $\ast$txn)}]{\setlength{\rightskip}{0pt plus 5cm}void Curl\+Service\+::\+Curl\+Client\+::send\+Request (
\begin{DoxyParamCaption}
\item[{{\bf proxygen\+::\+H\+T\+T\+P\+Transaction} $\ast$}]{txn}
\end{DoxyParamCaption}
)}\label{classCurlService_1_1CurlClient_a0bf80217808cd85fcaf8b548c4f3c5c9}


Definition at line 132 of file Curl\+Client.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Headers\+::add(), proxygen\+::\+H\+T\+T\+P\+Message\+::dump\+Message(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), proxygen\+::\+U\+R\+L\+::get\+Host\+And\+Port(), proxygen\+::\+H\+T\+T\+P\+Headers\+::get\+Number\+Of\+Values(), proxygen\+::\+U\+R\+L\+::get\+Url(), h2c\+\_\+, http\+Major\+\_\+, http\+Method\+\_\+, http\+Minor\+\_\+, input\+Filename\+\_\+, proxygen\+::\+U\+R\+L\+::is\+Secure(), logging\+Enabled\+\_\+, proxygen\+::\+U\+R\+L\+::make\+Relative\+U\+R\+L(), proxy\+\_\+, request\+\_\+, proxygen\+::\+H\+T\+T\+P\+Transaction\+::send\+Body(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::send\+E\+O\+M(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::send\+Headers(), proxygen\+::\+H\+T\+T\+P\+Message\+::set\+H\+T\+T\+P\+Version(), proxygen\+::\+H\+T\+T\+P\+Message\+::set\+Method(), proxygen\+::\+H\+T\+T\+P\+Message\+::set\+Secure(), proxygen\+::\+H\+T\+T\+P\+Message\+::set\+U\+R\+L(), txn\+\_\+, and url\+\_\+.



Referenced by connect\+Success().


\begin{DoxyCode}
132                                                  \{
133   txn_ = txn;
134   request_.setMethod(httpMethod_);
135   request_.setHTTPVersion(httpMajor_, httpMinor_);
136   \textcolor{keywordflow}{if} (proxy_) \{
137     request_.setURL(url_.getUrl());
138   \} \textcolor{keywordflow}{else} \{
139     request_.setURL(url_.makeRelativeURL());
140   \}
141   request_.setSecure(url_.isSecure());
142   \textcolor{keywordflow}{if} (h2c_) \{
143     HTTP2Codec::requestUpgrade(request_);
144   \}
145 
146   \textcolor{keywordflow}{if} (!request_.getHeaders().getNumberOfValues(HTTP\_HEADER\_USER\_AGENT)) \{
147     request_.getHeaders().add(HTTP\_HEADER\_USER\_AGENT, \textcolor{stringliteral}{"proxygen\_curl"});
148   \}
149   \textcolor{keywordflow}{if} (!request_.getHeaders().getNumberOfValues(HTTP\_HEADER\_HOST)) \{
150     request_.getHeaders().add(HTTP\_HEADER\_HOST, url_.getHostAndPort());
151   \}
152   \textcolor{keywordflow}{if} (!request_.getHeaders().getNumberOfValues(HTTP\_HEADER\_ACCEPT)) \{
153     request_.getHeaders().add(\textcolor{stringliteral}{"Accept"}, \textcolor{stringliteral}{"*/*"});
154   \}
155   \textcolor{keywordflow}{if} (loggingEnabled_) \{
156     request_.dumpMessage(4);
157   \}
158 
159   txn_->sendHeaders(request_);
160 
161   unique\_ptr<IOBuf> buf;
162   \textcolor{keywordflow}{if} (httpMethod_ == HTTPMethod::POST) \{
163 
164     \textcolor{keyword}{const} uint16\_t kReadSize = 4096;
165     ifstream inputFile(inputFilename_, ios::in | ios::binary);
166 
167     \textcolor{comment}{// Reading from the file by chunks}
168     \textcolor{comment}{// Important note: It's pretty bad to call a blocking i/o function like}
169     \textcolor{comment}{// ifstream::read() in an eventloop - but for the sake of this simple}
170     \textcolor{comment}{// example, we'll do it.}
171     \textcolor{comment}{// An alternative would be to put this into some folly::AsyncReader}
172     \textcolor{comment}{// object.}
173     \textcolor{keywordflow}{while} (inputFile.good()) \{
174       buf = IOBuf::createCombined(kReadSize);
175       inputFile.read((\textcolor{keywordtype}{char}*)buf->writableData(), kReadSize);
176       buf->append(inputFile.gcount());
177       txn_->sendBody(move(buf));
178     \}
179   \}
180 
181   \textcolor{comment}{// note that sendBody() is called only for POST. It's fine not to call it}
182   \textcolor{comment}{// at all.}
183 
184   txn_->sendEOM();
185 \}
\end{DoxyCode}
\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!set\+Flow\+Control\+Settings@{set\+Flow\+Control\+Settings}}
\index{set\+Flow\+Control\+Settings@{set\+Flow\+Control\+Settings}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{set\+Flow\+Control\+Settings(int32\+\_\+t recv\+Window)}]{\setlength{\rightskip}{0pt plus 5cm}void Curl\+Service\+::\+Curl\+Client\+::set\+Flow\+Control\+Settings (
\begin{DoxyParamCaption}
\item[{int32\+\_\+t}]{recv\+Window}
\end{DoxyParamCaption}
)}\label{classCurlService_1_1CurlClient_a46a8ed5b2fa85873c95c4a99cc3edf7a}


Definition at line 117 of file Curl\+Client.\+cpp.



References recv\+Window\+\_\+.



Referenced by get\+S\+S\+L\+Context(), main(), and T\+E\+S\+T().


\begin{DoxyCode}
117                                                           \{
118   recvWindow_ = recvWindow;
119 \}
\end{DoxyCode}
\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!set\+Logging@{set\+Logging}}
\index{set\+Logging@{set\+Logging}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{set\+Logging(bool enabled)}]{\setlength{\rightskip}{0pt plus 5cm}void Curl\+Service\+::\+Curl\+Client\+::set\+Logging (
\begin{DoxyParamCaption}
\item[{bool}]{enabled}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classCurlService_1_1CurlClient_a57c03c0e1d1a9e03a77c694e8cea0df1}


Definition at line 76 of file Curl\+Client.\+h.



References logging\+Enabled\+\_\+.



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
76                                 \{
77     loggingEnabled_ = enabled;
78   \}
\end{DoxyCode}
\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!set\+Transaction@{set\+Transaction}}
\index{set\+Transaction@{set\+Transaction}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{set\+Transaction(proxygen\+::\+H\+T\+T\+P\+Transaction $\ast$txn) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void Curl\+Service\+::\+Curl\+Client\+::set\+Transaction (
\begin{DoxyParamCaption}
\item[{{\bf proxygen\+::\+H\+T\+T\+P\+Transaction} $\ast$}]{txn}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classCurlService_1_1CurlClient_a3b1e05c84ebfc6691f2f80f299018070}
Called once per transaction. This notifies the handler of which transaction it should talk to and will receive callbacks from. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+Handler} \doxyref{}{p.}{classproxygen_1_1HTTPTransactionHandler_a4eb50d5627d26f6ca0d8e8283259d8a4}.



Definition at line 192 of file Curl\+Client.\+cpp.


\begin{DoxyCode}
192                                                          \{
193 \}
\end{DoxyCode}
\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!ssl\+Handshake\+Followup@{ssl\+Handshake\+Followup}}
\index{ssl\+Handshake\+Followup@{ssl\+Handshake\+Followup}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{ssl\+Handshake\+Followup(proxygen\+::\+H\+T\+T\+P\+Upstream\+Session $\ast$session) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}void Curl\+Service\+::\+Curl\+Client\+::ssl\+Handshake\+Followup (
\begin{DoxyParamCaption}
\item[{{\bf proxygen\+::\+H\+T\+T\+P\+Upstream\+Session} $\ast$}]{session}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{classCurlService_1_1CurlClient_a820a2acdfc59a2c487ee69232b4817e2}


Definition at line 98 of file Curl\+Client.\+cpp.



Referenced by connect\+Success().


\begin{DoxyCode}
98                                                                            \{
99   AsyncSSLSocket* sslSocket = \textcolor{keyword}{dynamic\_cast<}AsyncSSLSocket*\textcolor{keyword}{>}(
100     session->getTransport());
101 
102   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}* nextProto = \textcolor{keyword}{nullptr};
103   \textcolor{keywordtype}{unsigned} nextProtoLength = 0;
104   sslSocket->getSelectedNextProtocol(&nextProto, &nextProtoLength);
105   \textcolor{keywordflow}{if} (nextProto) \{
106     VLOG(1) << \textcolor{stringliteral}{"Client selected next protocol "} <<
107       string((\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)nextProto, nextProtoLength);
108   \} \textcolor{keywordflow}{else} \{
109     VLOG(1) << \textcolor{stringliteral}{"Client did not select a next protocol"};
110   \}
111 
112   \textcolor{comment}{// Note: This ssl session can be used by defining a member and setting}
113   \textcolor{comment}{// something like sslSession\_ = sslSocket->getSSLSession() and then}
114   \textcolor{comment}{// passing it to the connector::connectSSL() method}
115 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!evb\+\_\+@{evb\+\_\+}}
\index{evb\+\_\+@{evb\+\_\+}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{evb\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+Event\+Base$\ast$ Curl\+Service\+::\+Curl\+Client\+::evb\+\_\+ \{{\bf nullptr}\}\hspace{0.3cm}{\ttfamily [protected]}}\label{classCurlService_1_1CurlClient_add03a72b093bd952987612c742462c9d}


Definition at line 82 of file Curl\+Client.\+h.

\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!h2c\+\_\+@{h2c\+\_\+}}
\index{h2c\+\_\+@{h2c\+\_\+}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{h2c\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool Curl\+Service\+::\+Curl\+Client\+::h2c\+\_\+ \{false\}\hspace{0.3cm}{\ttfamily [protected]}}\label{classCurlService_1_1CurlClient_a83c32795a4ac77fd19b60c6793ce82f6}


Definition at line 91 of file Curl\+Client.\+h.



Referenced by initialize\+Ssl(), and send\+Request().

\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!http\+Major\+\_\+@{http\+Major\+\_\+}}
\index{http\+Major\+\_\+@{http\+Major\+\_\+}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{http\+Major\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}unsigned short Curl\+Service\+::\+Curl\+Client\+::http\+Major\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classCurlService_1_1CurlClient_a6ad850835a00fdbb7ff9d88b73c83f3e}


Definition at line 92 of file Curl\+Client.\+h.



Referenced by send\+Request().

\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!http\+Method\+\_\+@{http\+Method\+\_\+}}
\index{http\+Method\+\_\+@{http\+Method\+\_\+}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{http\+Method\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf proxygen\+::\+H\+T\+T\+P\+Method} Curl\+Service\+::\+Curl\+Client\+::http\+Method\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classCurlService_1_1CurlClient_a7e6a024d9a0159edc3c796b7a570539c}


Definition at line 83 of file Curl\+Client.\+h.



Referenced by send\+Request().

\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!http\+Minor\+\_\+@{http\+Minor\+\_\+}}
\index{http\+Minor\+\_\+@{http\+Minor\+\_\+}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{http\+Minor\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}unsigned short Curl\+Service\+::\+Curl\+Client\+::http\+Minor\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classCurlService_1_1CurlClient_afe0b40335518327d0c9226850a2ec43b}


Definition at line 93 of file Curl\+Client.\+h.



Referenced by send\+Request().

\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!input\+Filename\+\_\+@{input\+Filename\+\_\+}}
\index{input\+Filename\+\_\+@{input\+Filename\+\_\+}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{input\+Filename\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string Curl\+Service\+::\+Curl\+Client\+::input\+Filename\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classCurlService_1_1CurlClient_a7cf2fbc7b54de14175683846f9da95cd}


Definition at line 87 of file Curl\+Client.\+h.



Referenced by send\+Request().

\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!logging\+Enabled\+\_\+@{logging\+Enabled\+\_\+}}
\index{logging\+Enabled\+\_\+@{logging\+Enabled\+\_\+}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{logging\+Enabled\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool Curl\+Service\+::\+Curl\+Client\+::logging\+Enabled\+\_\+ \{true\}\hspace{0.3cm}{\ttfamily [protected]}}\label{classCurlService_1_1CurlClient_af267d43fb03388037838600dfdd5c212}


Definition at line 90 of file Curl\+Client.\+h.



Referenced by connect\+Error(), on\+Body(), on\+Egress\+Paused(), on\+Egress\+Resumed(), on\+E\+O\+M(), on\+Error(), on\+Headers\+Complete(), on\+Trailers(), on\+Upgrade(), send\+Request(), and set\+Logging().

\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!proxy\+\_\+@{proxy\+\_\+}}
\index{proxy\+\_\+@{proxy\+\_\+}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{proxy\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<${\bf proxygen\+::\+U\+RL}$>$ Curl\+Service\+::\+Curl\+Client\+::proxy\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classCurlService_1_1CurlClient_aec0d5fe3dad7195993a2a6174b17e968}


Definition at line 85 of file Curl\+Client.\+h.



Referenced by Curl\+Client(), and send\+Request().

\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!recv\+Window\+\_\+@{recv\+Window\+\_\+}}
\index{recv\+Window\+\_\+@{recv\+Window\+\_\+}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{recv\+Window\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}int32\+\_\+t Curl\+Service\+::\+Curl\+Client\+::recv\+Window\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [protected]}}\label{classCurlService_1_1CurlClient_abc1cfd2c1cf55a60a2bdeaaa33f4e0a7}


Definition at line 89 of file Curl\+Client.\+h.



Referenced by connect\+Success(), and set\+Flow\+Control\+Settings().

\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!request\+\_\+@{request\+\_\+}}
\index{request\+\_\+@{request\+\_\+}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{request\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf proxygen\+::\+H\+T\+T\+P\+Message} Curl\+Service\+::\+Curl\+Client\+::request\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classCurlService_1_1CurlClient_a42da130e62922ad8f814f42d27fc5716}


Definition at line 86 of file Curl\+Client.\+h.



Referenced by Curl\+Client(), get\+Server\+Name(), and send\+Request().

\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!response\+\_\+@{response\+\_\+}}
\index{response\+\_\+@{response\+\_\+}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{response\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<${\bf proxygen\+::\+H\+T\+T\+P\+Message}$>$ Curl\+Service\+::\+Curl\+Client\+::response\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classCurlService_1_1CurlClient_ad319715a8c8b23199c0f5296c454b367}


Definition at line 95 of file Curl\+Client.\+h.



Referenced by get\+Response(), and on\+Headers\+Complete().

\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!ssl\+Context\+\_\+@{ssl\+Context\+\_\+}}
\index{ssl\+Context\+\_\+@{ssl\+Context\+\_\+}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{ssl\+Context\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+S\+S\+L\+Context\+Ptr Curl\+Service\+::\+Curl\+Client\+::ssl\+Context\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classCurlService_1_1CurlClient_a3510965f9140bbb53307b66767f1bd21}


Definition at line 88 of file Curl\+Client.\+h.



Referenced by get\+S\+S\+L\+Context(), and initialize\+Ssl().

\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!txn\+\_\+@{txn\+\_\+}}
\index{txn\+\_\+@{txn\+\_\+}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{txn\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf proxygen\+::\+H\+T\+T\+P\+Transaction}$\ast$ Curl\+Service\+::\+Curl\+Client\+::txn\+\_\+ \{{\bf nullptr}\}\hspace{0.3cm}{\ttfamily [protected]}}\label{classCurlService_1_1CurlClient_a9c065d01d8910b7b917ac5c5c949ef4b}


Definition at line 81 of file Curl\+Client.\+h.



Referenced by send\+Request().

\index{Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}!url\+\_\+@{url\+\_\+}}
\index{url\+\_\+@{url\+\_\+}!Curl\+Service\+::\+Curl\+Client@{Curl\+Service\+::\+Curl\+Client}}
\subsubsection[{url\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf proxygen\+::\+U\+RL} Curl\+Service\+::\+Curl\+Client\+::url\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classCurlService_1_1CurlClient_ad2a7108b00bd71800979d6834061d01c}


Definition at line 84 of file Curl\+Client.\+h.



Referenced by connect\+Error(), connect\+Success(), get\+Server\+Name(), and send\+Request().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
proxygen/httpclient/samples/curl/{\bf Curl\+Client.\+h}\item 
proxygen/httpclient/samples/curl/{\bf Curl\+Client.\+cpp}\end{DoxyCompactItemize}
