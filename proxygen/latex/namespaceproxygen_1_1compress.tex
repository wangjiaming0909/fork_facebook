\section{proxygen\+:\+:compress Namespace Reference}
\label{namespaceproxygen_1_1compress}\index{proxygen\+::compress@{proxygen\+::compress}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class {\bf Compression\+Scheme}
\item 
class {\bf Compression\+Simulator}
\item 
struct {\bf Frame\+Flags}
\item 
struct {\bf Header}
\item 
class {\bf Header\+Piece}
\item 
class {\bf H\+P\+A\+C\+K\+Scheme}
\item 
class {\bf Q\+M\+I\+N\+Scheme}
\item 
class {\bf Q\+P\+A\+C\+K\+Scheme}
\item 
struct {\bf Sim\+Params}
\item 
struct {\bf Sim\+Stats}
\item 
class {\bf Sim\+Streaming\+Callback}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using {\bf Header\+Piece\+List} = std\+::deque$<$ {\bf Header\+Piece} $>$
\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum {\bf Scheme\+Type} \{ {\bf Scheme\+Type\+::\+Q\+P\+A\+CK}, 
{\bf Scheme\+Type\+::\+Q\+M\+IN}, 
{\bf Scheme\+Type\+::\+H\+P\+A\+CK}
 \}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
std\+::vector$<$ {\bf compress\+::\+Header} $>$ {\bf prepare\+Message\+For\+Compression} (const {\bf H\+T\+T\+P\+Message} \&msg, std\+::vector$<$ string $>$ \&cookies)
\item 
std\+::pair$<$ vector$<$ {\bf H\+P\+A\+C\+K\+Header} $>$, uint32\+\_\+t $>$ {\bf prepare\+Headers} (vector$<$ {\bf Header} $>$ \&headers)
\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\index{proxygen\+::compress@{proxygen\+::compress}!Header\+Piece\+List@{Header\+Piece\+List}}
\index{Header\+Piece\+List@{Header\+Piece\+List}!proxygen\+::compress@{proxygen\+::compress}}
\subsubsection[{Header\+Piece\+List}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::compress\+::\+Header\+Piece\+List} = typedef std\+::deque$<${\bf Header\+Piece}$>$}\label{namespaceproxygen_1_1compress_a67fbb975128128544dede33c0c9d273d}


Definition at line 59 of file Header\+Piece.\+h.



\subsection{Enumeration Type Documentation}
\index{proxygen\+::compress@{proxygen\+::compress}!Scheme\+Type@{Scheme\+Type}}
\index{Scheme\+Type@{Scheme\+Type}!proxygen\+::compress@{proxygen\+::compress}}
\subsubsection[{Scheme\+Type}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::compress\+::\+Scheme\+Type}\hspace{0.3cm}{\ttfamily [strong]}}\label{namespaceproxygen_1_1compress_adb2f38c607bc534e811b122dbed14ef2}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{Q\+P\+A\+CK@{Q\+P\+A\+CK}!proxygen\+::compress@{proxygen\+::compress}}\index{proxygen\+::compress@{proxygen\+::compress}!Q\+P\+A\+CK@{Q\+P\+A\+CK}}\item[{\em 
Q\+P\+A\+CK\label{namespaceproxygen_1_1compress_adb2f38c607bc534e811b122dbed14ef2a722622dacf22345d7f65d96d10d5d1ae}
}]\index{Q\+M\+IN@{Q\+M\+IN}!proxygen\+::compress@{proxygen\+::compress}}\index{proxygen\+::compress@{proxygen\+::compress}!Q\+M\+IN@{Q\+M\+IN}}\item[{\em 
Q\+M\+IN\label{namespaceproxygen_1_1compress_adb2f38c607bc534e811b122dbed14ef2a3b78b53f7b985978b86a572e04bb4f9c}
}]\index{H\+P\+A\+CK@{H\+P\+A\+CK}!proxygen\+::compress@{proxygen\+::compress}}\index{proxygen\+::compress@{proxygen\+::compress}!H\+P\+A\+CK@{H\+P\+A\+CK}}\item[{\em 
H\+P\+A\+CK\label{namespaceproxygen_1_1compress_adb2f38c607bc534e811b122dbed14ef2abeeb357da92a0c9056f9e9f91fc48938}
}]\end{description}
\end{Desc}


Definition at line 15 of file Compression\+Types.\+h.


\begin{DoxyCode}
15 \{ QPACK, QMIN, HPACK \};
\end{DoxyCode}


\subsection{Function Documentation}
\index{proxygen\+::compress@{proxygen\+::compress}!prepare\+Headers@{prepare\+Headers}}
\index{prepare\+Headers@{prepare\+Headers}!proxygen\+::compress@{proxygen\+::compress}}
\subsubsection[{prepare\+Headers(vector$<$ Header $>$ \&headers)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::pair$<$ std\+::vector$<$ {\bf H\+P\+A\+C\+K\+Header} $>$, uint32\+\_\+t $>$ proxygen\+::compress\+::prepare\+Headers (
\begin{DoxyParamCaption}
\item[{vector$<$ {\bf Header} $>$ \&}]{headers}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1compress_a3a44970641d37b7eb15b6b079c6ccde9}


Definition at line 29 of file H\+P\+A\+C\+K\+Codec.\+cpp.



Referenced by proxygen\+::\+Q\+P\+A\+C\+K\+Codec\+::encode(), and proxygen\+::\+H\+P\+A\+C\+K\+Codec\+::encode().


\begin{DoxyCode}
30                                \{
31   \textcolor{comment}{// convert to HPACK API format}
32   std::pair<vector<HPACKHeader>, uint32\_t> converted;
33   converted.first.reserve(headers.size());
34   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& h : headers) \{
35     \textcolor{comment}{// HPACKHeader automatically lowercases}
36     converted.first.emplace\_back(*h.name, *h.value);
37     \textcolor{keyword}{auto}& header = converted.first.back();
38     converted.second += header.name.size() + header.value.size() + 2;
39   \}
40   \textcolor{keywordflow}{return} converted;
41 \}
\end{DoxyCode}
\index{proxygen\+::compress@{proxygen\+::compress}!prepare\+Message\+For\+Compression@{prepare\+Message\+For\+Compression}}
\index{prepare\+Message\+For\+Compression@{prepare\+Message\+For\+Compression}!proxygen\+::compress@{proxygen\+::compress}}
\subsubsection[{prepare\+Message\+For\+Compression(const H\+T\+T\+P\+Message \&msg, std\+::vector$<$ string $>$ \&cookies)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$ {\bf Header} $>$ proxygen\+::compress\+::prepare\+Message\+For\+Compression (
\begin{DoxyParamCaption}
\item[{const {\bf H\+T\+T\+P\+Message} \&}]{msg, }
\item[{std\+::vector$<$ string $>$ \&}]{cookies}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1compress_a87be4e4c674336304ac9c82b0e244685}


Definition at line 83 of file Compression\+Utils.\+cpp.



References proxygen\+::\+C\+O\+N\+N\+E\+CT, proxygen\+::\+H\+T\+T\+P\+Headers\+::for\+Each\+With\+Code(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Method(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Method\+String(), proxygen\+::\+H\+T\+T\+P\+Headers\+::get\+Single\+Or\+Empty(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+U\+R\+L(), proxygen\+::\+H\+T\+T\+P\+Message\+::is\+Secure(), proxygen\+::headers\+::k\+Authority, proxygen\+::headers\+::k\+Http, proxygen\+::headers\+::k\+Https, proxygen\+::headers\+::k\+Method, proxygen\+::headers\+::k\+Path, and proxygen\+::headers\+::k\+Scheme.



Referenced by proxygen\+::compress\+::\+Compression\+Simulator\+::encode().


\begin{DoxyCode}
85                                 \{
86   std::vector<compress::Header> allHeaders;
87   \textcolor{comment}{// The encode API is pretty bad.  We should just let HPACK directly encode}
88   \textcolor{comment}{// HTTP messages}
89   \textcolor{keyword}{const} HTTPHeaders& headers = msg.getHeaders();
90   \textcolor{keyword}{const} \textcolor{keywordtype}{string}& host = headers.getSingleOrEmpty(HTTP\_HEADER\_HOST);
91   \textcolor{keywordtype}{bool} isPublic = msg.getMethodString().empty();
92   \textcolor{keywordflow}{if} (!isPublic) \{
93     allHeaders.emplace\_back(HTTP\_HEADER\_COLON\_METHOD, headers::kMethod,
94                             msg.getMethodString());
95     \textcolor{keywordflow}{if} (msg.getMethod() != HTTPMethod::CONNECT) \{
96       allHeaders.emplace\_back(
97           HTTP\_HEADER\_COLON\_SCHEME, headers::kScheme,
98           (msg.isSecure() ? headers::kHttps : headers::kHttp));
99       allHeaders.emplace\_back(HTTP\_HEADER\_COLON\_PATH, headers::kPath,
100                               msg.getURL());
101     \}
102 
103     \textcolor{keywordflow}{if} (!host.empty()) \{
104       allHeaders.emplace\_back(
105           HTTP\_HEADER\_COLON\_AUTHORITY, headers::kAuthority, host);
106     \}
107   \}
108   \textcolor{comment}{// Cookies are coalesced in the HAR file but need to be added as separate}
109   \textcolor{comment}{// headers to optimize compression ratio}
110   headers.forEachWithCode(
111       [&](HTTPHeaderCode code, \textcolor{keyword}{const} \textcolor{keywordtype}{string}& name, \textcolor{keyword}{const} \textcolor{keywordtype}{string}& value) \{
112         \textcolor{keywordflow}{if} (code == HTTP\_HEADER\_COOKIE) \{
113           vector<folly::StringPiece> cookiePieces;
114           folly::split(\textcolor{charliteral}{';'}, value, cookiePieces);
115           cookies.reserve(cookies.size() + cookiePieces.size());
116           \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} cookie : cookiePieces) \{
117             cookies.push\_back(ltrimWhitespace(cookie).str());
118             allHeaders.emplace\_back(code, name, cookies.back());
119           \}
120         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (code != HTTP\_HEADER\_HOST && (isPublic || name[0] != \textcolor{charliteral}{':'})) \{
121           \textcolor{comment}{// HAR files contain actual serialized headers protocol headers like}
122           \textcolor{comment}{// :authority, which we are re-adding above.  Strip them so our}
123           \textcolor{comment}{// equality test works}
124           allHeaders.emplace\_back(code, name, value);
125         \}
126       \});
127   \textcolor{keywordflow}{return} allHeaders;
128 \}
\end{DoxyCode}
