\section{proxygen/lib/http/session/test/\+Mock\+Codec\+Downstream\+Test.cpp File Reference}
\label{MockCodecDownstreamTest_8cpp}\index{proxygen/lib/http/session/test/\+Mock\+Codec\+Downstream\+Test.\+cpp@{proxygen/lib/http/session/test/\+Mock\+Codec\+Downstream\+Test.\+cpp}}
{\ttfamily \#include $<$wangle/acceptor/\+Connection\+Manager.\+h$>$}\\*
{\ttfamily \#include $<$folly/io/\+Cursor.\+h$>$}\\*
{\ttfamily \#include $<$folly/io/async/\+Event\+Base.\+h$>$}\\*
{\ttfamily \#include $<$folly/io/async/\+Timeout\+Manager.\+h$>$}\\*
{\ttfamily \#include $<$folly/portability/\+G\+Test.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/test/\+Mock\+H\+T\+T\+P\+Codec.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/test/\+Test\+Utils.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/session/\+H\+T\+T\+P\+Direct\+Response\+Handler.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/session/\+H\+T\+T\+P\+Downstream\+Session.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/session/\+H\+T\+T\+P\+Session.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/session/test/\+H\+T\+T\+P\+Session\+Mocks.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/session/test/\+H\+T\+T\+P\+Session\+Test.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/session/test/\+Mock\+Secondary\+Auth\+Manager.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/session/test/\+Test\+Utils.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/test/\+Test\+Async\+Transport.\+h$>$}\\*
{\ttfamily \#include $<$sstream$>$}\\*
{\ttfamily \#include $<$string$>$}\\*
{\ttfamily \#include $<$folly/io/async/test/\+Mock\+Async\+Transport.\+h$>$}\\*
{\ttfamily \#include $<$vector$>$}\\*
{\ttfamily \#include $<$boost/optional/optional\+\_\+io.\+hpp$>$}\\*
{\ttfamily \#include $<$fizz/record/\+Extensions.\+h$>$}\\*
{\ttfamily \#include $<$fizz/record/\+Types.\+h$>$}\\*
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class {\bf Mock\+Codec\+Downstream\+Test}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, On\+Abort\+Then\+Timeouts)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Server\+Push)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Server\+Push\+After\+Goaway)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Server\+Push\+Abort)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Server\+Push\+Abort\+Assoc)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Server\+Push\+Client\+Message)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Read\+Timeout)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Ping)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Flow\+Control\+Abort)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Buffering)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Spdy\+Window)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Double\+Resume)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Conn\+Flow\+Control\+Blocked)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Conn\+Flow\+Control\+Timeout)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Unpaused\+Large\+Post)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Ingress\+Paused\+Window\+Update)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Shutdown\+Then\+Send\+Push\+Headers)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Read\+Iobuf\+Chain\+Shutdown)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Send\+Double\+Goaway\+Timeout)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Send\+Double\+Goaway\+Idle)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Send\+Goaway\+Timeout)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Send\+Goaway\+Idle)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Drop\+Connection)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Drop\+Connection\+Nogoaway)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Shutdown\+Then\+Error)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Ping\+During\+Shutdown)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Settings\+Ack)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+Codec\+Downstream\+Test}, Test\+Send\+Certificate\+Request)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const {\bf H\+T\+T\+P\+Settings} {\bf k\+Default\+Ingress\+Settings}
\item 
const {\bf H\+T\+T\+P\+Settings} {\bf k\+Ingress\+Cert\+Auth\+Settings}
\item 
{\bf H\+T\+T\+P\+Settings} {\bf k\+Egress\+Cert\+Auth\+Settings}
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, On\+Abort\+Then\+Timeouts)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{On\+Abort\+Then\+Timeouts}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_a7a7ad1bd220be00ca1a518009006ecbf}


Definition at line 210 of file Mock\+Codec\+Downstream\+Test.\+cpp.



References proxygen\+::fake\+Mock\+Codec(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+I\+D(), proxygen\+::\+Exception\+::get\+Proxygen\+Error(), proxygen\+::k\+Error\+Write\+Timeout, make\+Buf(), proxygen\+::make\+Get\+Request(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::send\+Body(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::send\+Headers(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::timeout\+Expired(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::txn\+\_\+, and proxygen\+::\+Exception\+::what().


\begin{DoxyCode}
210                                                      \{
211   \textcolor{comment}{// Test what happens when txn1 (out of many transactions) gets an abort}
212   \textcolor{comment}{// followed by a transaction timeout followed by a write timeout}
213   MockHTTPHandler handler1;
214   MockHTTPHandler handler2;
215   \textcolor{keyword}{auto} req1 = makeGetRequest();
216   \textcolor{keyword}{auto} req2 = makeGetRequest();
217 
218   fakeMockCodec(*codec\_);
219 
220   EXPECT\_CALL(mockController\_, getRequestHandler(\_, \_))
221     .WillOnce(Return(&handler1))
222     .WillOnce(Return(&handler2));
223 
224   EXPECT\_CALL(handler1, setTransaction(\_))
225     .WillOnce(Invoke([&handler1] (HTTPTransaction* txn) \{
226           handler1.txn_ = txn; \}));
227   EXPECT\_CALL(handler1, onHeadersComplete(\_))
228     .WillOnce(Invoke([&handler1] (std::shared\_ptr<HTTPMessage>) \{
229           handler1.sendHeaders(200, 100);
230           handler1.sendBody(100);
231         \}));
232   EXPECT\_CALL(handler1, onError(\_));
233   EXPECT\_CALL(handler1, detachTransaction());
234   EXPECT\_CALL(handler2, setTransaction(\_))
235     .WillOnce(Invoke([&handler2] (HTTPTransaction* txn) \{
236           handler2.txn_ = txn; \}));
237   EXPECT\_CALL(handler2, onHeadersComplete(\_))
238     .WillOnce(Invoke([&handler2] (std::shared\_ptr<HTTPMessage>) \{
239           handler2.sendHeaders(200, 100);
240           handler2.sendBody(100);
241         \}));
242   EXPECT\_CALL(handler2, onBody(\_));
243   EXPECT\_CALL(handler2, onError(\_))
244     .WillOnce(Invoke([&] (\textcolor{keyword}{const} HTTPException& ex) \{
245           ASSERT\_EQ(ex.getProxygenError(), kErrorWriteTimeout);
246           ASSERT\_EQ(
247             folly::to<std::string>(\textcolor{stringliteral}{"WriteTimeout on transaction id: "},
248               handler2.txn_->getID()),
249             std::string(ex.what()));
250         \}));
251   EXPECT\_CALL(handler2, detachTransaction());
252 
253   EXPECT\_CALL(mockController\_, detachSession(\_));
254 
255   codecCallback\_->onMessageBegin(HTTPCodec::StreamID(1), req1.get());
256   codecCallback\_->onHeadersComplete(HTTPCodec::StreamID(1), std::move(req1));
257   codecCallback\_->onMessageBegin(HTTPCodec::StreamID(3), req2.get());
258   codecCallback\_->onHeadersComplete(HTTPCodec::StreamID(3), std::move(req2));
259   \textcolor{comment}{// do the write, enqeue byte event}
260   eventBase\_.loop();
261 
262   \textcolor{comment}{// recv an abort, detach the handler from txn1 (txn1 stays around due to the}
263   \textcolor{comment}{// enqueued byte event)}
264   codecCallback\_->onAbort(HTTPCodec::StreamID(1), ErrorCode::PROTOCOL\_ERROR);
265   \textcolor{comment}{// recv a transaction timeout on txn1 (used to erroneously create a direct}
266   \textcolor{comment}{// response handler)}
267   handler1.txn_->timeoutExpired();
268 
269   \textcolor{comment}{// have a write timeout expire (used to cause the direct response handler to}
270   \textcolor{comment}{// write out data, messing up the state machine)}
271   eventBase\_.runAfterDelay(
272     [\textcolor{keyword}{this}] \{
273       \textcolor{comment}{// refresh ingress timeout}
274       codecCallback\_->onBody(HTTPCodec::StreamID(3), makeBuf(10), 0);
275     \}, transactionTimeouts\_->getDefaultTimeout().count() / 2);
276   \textcolor{comment}{// hold evb open long enough to fire write timeout (since transactionTimeouts\_}
277   \textcolor{comment}{// is internal}
278   eventBase\_.runAfterDelay(
279     [] \{\}, transactionTimeouts\_->getDefaultTimeout().count() + 100);
280   eventBase\_.loop();
281 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Server\+Push)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Server\+Push}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_a6486787369ae9105f0dff71e14b72f78}


Definition at line 283 of file Mock\+Codec\+Downstream\+Test.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+Priority(), proxygen\+::make\+Get\+Request(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::new\+Pushed\+Transaction(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::send\+Body(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::send\+E\+O\+M(), proxygen\+::\+Mock\+H\+T\+T\+P\+Push\+Handler\+::send\+Push\+Headers(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::send\+Reply\+With\+Body(), and proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::txn\+\_\+.


\begin{DoxyCode}
283                                             \{
284   MockHTTPHandler handler;
285   MockHTTPPushHandler pushHandler;
286   \textcolor{keyword}{auto} req = makeGetRequest();
287   HTTPTransaction* pushTxn = \textcolor{keyword}{nullptr};
288 
289   InSequence enforceOrder;
290 
291   EXPECT\_CALL(mockController\_, getRequestHandler(\_, \_))
292     .WillOnce(Return(&handler));
293   EXPECT\_CALL(handler, setTransaction(\_))
294     .WillOnce(SaveArg<0>(&handler.txn_));
295 
296   EXPECT\_CALL(handler, onHeadersComplete(\_))
297     .WillOnce(Invoke([&] (std::shared\_ptr<HTTPMessage>) \{
298           pushTxn = handler.txn_->newPushedTransaction(&pushHandler);
299           pushHandler.sendPushHeaders(\textcolor{stringliteral}{"/foo"}, \textcolor{stringliteral}{"www.foo.com"}, 100,
300                                       handler.txn_->getPriority());
301           pushHandler.sendBody(100);
302           pushTxn->sendEOM();
303           eventBase\_.loop(); \textcolor{comment}{// flush the push txn's body}
304         \}));
305   EXPECT\_CALL(pushHandler, setTransaction(\_))
306     .WillOnce(Invoke([&pushHandler] (HTTPTransaction* txn) \{
307           pushHandler.txn_ = txn; \}));
308 
309   EXPECT\_CALL(*codec\_, generatePushPromise(\_, 2, \_, \_, \_, \_));
310   EXPECT\_CALL(*codec\_, generateBody(\_, 2, PtrBufHasLen(uint64\_t(100)),
311                                     \_, \textcolor{keyword}{true}));
312   EXPECT\_CALL(pushHandler, detachTransaction());
313 
314   EXPECT\_CALL(handler, onEOM())
315     .WillOnce(Invoke([&] \{
316           handler.sendReplyWithBody(200, 100);
317           eventBase\_.loop(); \textcolor{comment}{// flush the response to the normal request}
318         \}));
319 
320   EXPECT\_CALL(*codec\_, generateHeader(\_, 1, \_, \_, \_));
321   EXPECT\_CALL(*codec\_, generateBody(\_, 1, PtrBufHasLen(uint64\_t(100)),
322                                     \_, \textcolor{keyword}{true}));
323   EXPECT\_CALL(handler, detachTransaction());
324 
325   codecCallback\_->onMessageBegin(HTTPCodec::StreamID(1), req.get());
326   codecCallback\_->onHeadersComplete(HTTPCodec::StreamID(1), std::move(req));
327   codecCallback\_->onMessageComplete(HTTPCodec::StreamID(1), \textcolor{keyword}{false});
328 
329   EXPECT\_CALL(*codec\_, onIngressEOF());
330   EXPECT\_CALL(mockController\_, detachSession(\_));
331   httpSession\_->dropConnection();
332 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Server\+Push\+After\+Goaway)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Server\+Push\+After\+Goaway}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_a9381915c0e0b293e1437d2a39459dfe0}


Definition at line 334 of file Mock\+Codec\+Downstream\+Test.\+cpp.



References proxygen\+::fake\+Mock\+Codec(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+I\+D(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+Priority(), proxygen\+::\+Exception\+::get\+Proxygen\+Error(), proxygen\+::\+Exception\+::has\+Proxygen\+Error(), proxygen\+::k\+Error\+Stream\+Unacknowledged, proxygen\+::make\+Get\+Request(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::new\+Pushed\+Transaction(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::send\+Body(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::send\+E\+O\+M(), proxygen\+::\+Mock\+H\+T\+T\+P\+Push\+Handler\+::send\+Push\+Headers(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::send\+Reply\+With\+Body(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::txn\+\_\+, and proxygen\+::\+Exception\+::what().


\begin{DoxyCode}
334                                                        \{
335   \textcolor{comment}{// Tests if goaway}
336   \textcolor{comment}{//   - drains acknowledged server push transactions}
337   \textcolor{comment}{//   - aborts server pushed transactions not created at the client}
338   \textcolor{comment}{//   - prevents new transactions from being created.}
339   MockHTTPHandler handler;
340   MockHTTPPushHandler pushHandler1;
341   MockHTTPPushHandler pushHandler2;
342   HTTPTransaction* pushTxn = \textcolor{keyword}{nullptr};
343 
344   fakeMockCodec(*codec\_);
345 
346   EXPECT\_CALL(mockController\_, getRequestHandler(\_, \_))
347     .WillOnce(Return(&handler));
348 
349   EXPECT\_CALL(handler, setTransaction(\_))
350     .WillOnce(Invoke([&handler] (HTTPTransaction* txn) \{
351           handler.txn_ = txn; \}));
352   EXPECT\_CALL(handler, onHeadersComplete(\_))
353     .WillOnce(Invoke([&] (std::shared\_ptr<HTTPMessage>) \{
354           \textcolor{comment}{// Initiate server push transactions.}
355           pushTxn = handler.txn_->newPushedTransaction(&pushHandler1);
356           CHECK\_EQ(pushTxn->getID(), HTTPCodec::StreamID(2));
357           pushHandler1.sendPushHeaders(\textcolor{stringliteral}{"/foo"}, \textcolor{stringliteral}{"www.foo.com"}, 100,
358                                        handler.txn_->getPriority());
359           pushHandler1.sendBody(100);
360           pushTxn->sendEOM();
361           \textcolor{comment}{// Initiate the second push transaction which will be aborted}
362           pushTxn = handler.txn_->newPushedTransaction(&pushHandler2);
363           CHECK\_EQ(pushTxn->getID(), HTTPCodec::StreamID(4));
364           pushHandler2.sendPushHeaders(\textcolor{stringliteral}{"/foo"}, \textcolor{stringliteral}{"www.foo.com"}, 100,
365                                        handler.txn_->getPriority());
366           pushHandler2.sendBody(100);
367           pushTxn->sendEOM();
368         \}));
369   \textcolor{comment}{// Push transaction 1 - drained}
370   EXPECT\_CALL(pushHandler1, setTransaction(\_))
371     .WillOnce(Invoke([&pushHandler1] (HTTPTransaction* txn) \{
372           pushHandler1.txn_ = txn; \}));
373   EXPECT\_CALL(pushHandler1, detachTransaction());
374   \textcolor{comment}{// Push transaction 2 - aborted by onError after goaway}
375   EXPECT\_CALL(pushHandler2, setTransaction(\_))
376     .WillOnce(Invoke([&pushHandler2] (HTTPTransaction* txn) \{
377           pushHandler2.txn_ = txn; \}));
378   EXPECT\_CALL(pushHandler2, onError(\_))
379     .WillOnce(Invoke([&] (\textcolor{keyword}{const} HTTPException& err) \{
380           EXPECT\_TRUE(err.hasProxygenError());
381           EXPECT\_EQ(err.getProxygenError(), kErrorStreamUnacknowledged);
382           ASSERT\_EQ(
383             folly::to<std::string>(\textcolor{stringliteral}{"StreamUnacknowledged on transaction id: "},
384               pushHandler2.txn_->getID()),
385             std::string(err.what()));
386         \}));
387   EXPECT\_CALL(pushHandler2, detachTransaction());
388 
389   EXPECT\_CALL(handler, onEOM());
390   EXPECT\_CALL(handler, detachTransaction());
391 
392   \textcolor{comment}{// Receive client request}
393   \textcolor{keyword}{auto} req = makeGetRequest();
394   codecCallback\_->onMessageBegin(HTTPCodec::StreamID(1), req.get());
395   codecCallback\_->onHeadersComplete(HTTPCodec::StreamID(1), std::move(req));
396   codecCallback\_->onMessageComplete(HTTPCodec::StreamID(1), \textcolor{keyword}{false});
397 
398   \textcolor{comment}{// Receive goaway acknowledging only the first pushed transactions with id 2.}
399   codecCallback\_->onGoaway(2, ErrorCode::NO\_ERROR);
400 
401   \textcolor{comment}{// New server pushed transaction cannot be created after goaway}
402   MockHTTPPushHandler pushHandler3;
403   EXPECT\_EQ(handler.txn_->newPushedTransaction(&pushHandler3), \textcolor{keyword}{nullptr});
404 
405   \textcolor{comment}{// Send response to the initial client request and this destroys the session}
406   handler.sendReplyWithBody(200, 100);
407 
408   eventBase\_.loop();
409 
410   EXPECT\_CALL(mockController\_, detachSession(\_));
411   httpSession\_->dropConnection();
412 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Server\+Push\+Abort)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Server\+Push\+Abort}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_a1d8b09156b39938a06a946d69cf05e09}


Definition at line 414 of file Mock\+Codec\+Downstream\+Test.\+cpp.



References proxygen\+::fake\+Mock\+Codec(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+I\+D(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+Priority(), proxygen\+::\+Exception\+::get\+Proxygen\+Error(), proxygen\+::\+Exception\+::has\+Proxygen\+Error(), proxygen\+::k\+Error\+Stream\+Abort, proxygen\+::make\+Get\+Request(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::new\+Pushed\+Transaction(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::send\+Body(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::send\+E\+O\+M(), proxygen\+::\+Mock\+H\+T\+T\+P\+Push\+Handler\+::send\+Push\+Headers(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::send\+Reply\+With\+Body(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::txn\+\_\+, and proxygen\+::\+Exception\+::what().


\begin{DoxyCode}
414                                                  \{
415   \textcolor{comment}{// Test that assoc txn and other push txns are not affected when client aborts}
416   \textcolor{comment}{// a push txn}
417   MockHTTPHandler handler;
418   MockHTTPPushHandler pushHandler1;
419   MockHTTPPushHandler pushHandler2;
420   HTTPTransaction* pushTxn1 = \textcolor{keyword}{nullptr};
421   HTTPTransaction* pushTxn2 = \textcolor{keyword}{nullptr};
422 
423   fakeMockCodec(*codec\_);
424 
425   EXPECT\_CALL(mockController\_, getRequestHandler(\_, \_))
426     .WillOnce(Return(&handler));
427 
428   EXPECT\_CALL(handler, setTransaction(\_))
429     .WillOnce(Invoke([&handler] (HTTPTransaction* txn) \{
430           handler.txn_ = txn; \}));
431   EXPECT\_CALL(handler, onHeadersComplete(\_))
432     .WillOnce(Invoke([&] (std::shared\_ptr<HTTPMessage>) \{
433           \textcolor{comment}{// Initiate server push transactions}
434           pushTxn1 = handler.txn_->newPushedTransaction(&pushHandler1);
435           CHECK\_EQ(pushTxn1->getID(), HTTPCodec::StreamID(2));
436           pushHandler1.sendPushHeaders(\textcolor{stringliteral}{"/foo"}, \textcolor{stringliteral}{"www.foo.com"}, 100,
437                                       handler.txn_->getPriority());
438           pushHandler1.sendBody(100);
439 
440           pushTxn2 = handler.txn_->newPushedTransaction(&pushHandler2);
441           CHECK\_EQ(pushTxn2->getID(), HTTPCodec::StreamID(4));
442           pushHandler2.sendPushHeaders(\textcolor{stringliteral}{"/bar"}, \textcolor{stringliteral}{"www.bar.com"}, 200,
443                                        handler.txn_->getPriority());
444           pushHandler2.sendBody(200);
445           pushTxn2->sendEOM();
446         \}));
447 
448   \textcolor{comment}{// pushTxn1 should be aborted}
449   EXPECT\_CALL(pushHandler1, setTransaction(\_))
450     .WillOnce(Invoke([&pushHandler1] (HTTPTransaction* txn) \{
451           pushHandler1.txn_ = txn; \}));
452   EXPECT\_CALL(pushHandler1, onError(\_))
453     .WillOnce(Invoke([&] (\textcolor{keyword}{const} HTTPException& err) \{
454           EXPECT\_TRUE(err.hasProxygenError());
455           EXPECT\_EQ(err.getProxygenError(), kErrorStreamAbort);
456           ASSERT\_EQ(
457             \textcolor{stringliteral}{"Stream aborted, streamID=2, code=CANCEL"},
458             std::string(err.what()));
459         \}));
460   EXPECT\_CALL(pushHandler1, detachTransaction());
461 
462   EXPECT\_CALL(pushHandler2, setTransaction(\_))
463     .WillOnce(Invoke([&pushHandler2] (HTTPTransaction* txn) \{
464           pushHandler2.txn_ = txn; \}));
465   EXPECT\_CALL(pushHandler2, detachTransaction());
466 
467   EXPECT\_CALL(handler, onEOM());
468   EXPECT\_CALL(handler, detachTransaction());
469 
470   \textcolor{comment}{// Receive client request}
471   \textcolor{keyword}{auto} req = makeGetRequest();
472   codecCallback\_->onMessageBegin(HTTPCodec::StreamID(1), req.get());
473   codecCallback\_->onHeadersComplete(HTTPCodec::StreamID(1), std::move(req));
474   codecCallback\_->onMessageComplete(HTTPCodec::StreamID(1), \textcolor{keyword}{false});
475 
476   \textcolor{comment}{// Send client abort on one push txn}
477   codecCallback\_->onAbort(HTTPCodec::StreamID(2), ErrorCode::CANCEL);
478 
479   handler.sendReplyWithBody(200, 100);
480 
481   eventBase\_.loop();
482 
483   EXPECT\_CALL(mockController\_, detachSession(\_));
484   httpSession\_->dropConnection();
485 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Server\+Push\+Abort\+Assoc)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Server\+Push\+Abort\+Assoc}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_ac44c0130d0f5cef9e728e9983c3c7cd6}


Definition at line 487 of file Mock\+Codec\+Downstream\+Test.\+cpp.



References proxygen\+::fake\+Mock\+Codec(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+Priority(), proxygen\+::\+Exception\+::get\+Proxygen\+Error(), proxygen\+::\+Exception\+::has\+Proxygen\+Error(), proxygen\+::k\+Error\+Stream\+Abort, proxygen\+::make\+Get\+Request(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::new\+Pushed\+Transaction(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::send\+Body(), proxygen\+::\+Mock\+H\+T\+T\+P\+Push\+Handler\+::send\+Push\+Headers(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::txn\+\_\+, and proxygen\+::\+Exception\+::what().


\begin{DoxyCode}
487                                                       \{
488   \textcolor{comment}{// Test that all associated push transactions are aborted when client aborts}
489   \textcolor{comment}{// the assoc stream}
490   MockHTTPHandler handler;
491   MockHTTPPushHandler pushHandler1;
492   MockHTTPPushHandler pushHandler2;
493 
494   fakeMockCodec(*codec\_);
495 
496   EXPECT\_CALL(mockController\_, getRequestHandler(\_, \_))
497     .WillOnce(Return(&handler));
498 
499   EXPECT\_CALL(handler, setTransaction(\_))
500     .WillOnce(Invoke([&handler] (HTTPTransaction* txn) \{
501           handler.txn_ = txn; \}));
502   EXPECT\_CALL(handler, onHeadersComplete(\_))
503     .WillOnce(Invoke([&] (std::shared\_ptr<HTTPMessage>) \{
504           \textcolor{comment}{// Initiate server push transactions}
505           \textcolor{keyword}{auto} pushTxn = handler.txn_->newPushedTransaction(&pushHandler1);
506           CHECK\_EQ(pushTxn->getID(), HTTPCodec::StreamID(2));
507           pushHandler1.sendPushHeaders(\textcolor{stringliteral}{"/foo"}, \textcolor{stringliteral}{"www.foo.com"}, 100,
508                                        handler.txn_->getPriority());
509           pushHandler1.sendBody(100);
510           eventBase\_.loop();
511 
512           pushTxn = handler.txn_->newPushedTransaction(&pushHandler2);
513           CHECK\_EQ(pushTxn->getID(), HTTPCodec::StreamID(4));
514           pushHandler2.sendPushHeaders(\textcolor{stringliteral}{"/foo"}, \textcolor{stringliteral}{"www.foo.com"}, 100,
515                                        handler.txn_->getPriority());
516           pushHandler2.sendBody(100);
517           eventBase\_.loop();
518         \}));
519 
520   \textcolor{comment}{// Both push txns and the assoc txn should be aborted}
521   EXPECT\_CALL(pushHandler1, setTransaction(\_))
522     .WillOnce(Invoke([&pushHandler1] (HTTPTransaction* txn) \{
523           pushHandler1.txn_ = txn; \}));
524   EXPECT\_CALL(pushHandler1, onError(\_))
525     .WillOnce(Invoke([&] (\textcolor{keyword}{const} HTTPException& err) \{
526           EXPECT\_TRUE(err.hasProxygenError());
527           EXPECT\_EQ(err.getProxygenError(), kErrorStreamAbort);
528           ASSERT\_EQ(
529             \textcolor{stringliteral}{"Stream aborted, streamID=1, code=CANCEL"},
530             std::string(err.what()));
531         \}));
532   EXPECT\_CALL(pushHandler1, detachTransaction());
533 
534   EXPECT\_CALL(pushHandler2, setTransaction(\_))
535     .WillOnce(Invoke([&pushHandler2] (HTTPTransaction* txn) \{
536           pushHandler2.txn_ = txn; \}));
537   EXPECT\_CALL(pushHandler2, onError(\_))
538     .WillOnce(Invoke([&] (\textcolor{keyword}{const} HTTPException& err) \{
539           EXPECT\_TRUE(err.hasProxygenError());
540           EXPECT\_EQ(err.getProxygenError(), kErrorStreamAbort);
541           ASSERT\_EQ(
542             \textcolor{stringliteral}{"Stream aborted, streamID=1, code=CANCEL"},
543             std::string(err.what()));
544         \}));
545   EXPECT\_CALL(pushHandler2, detachTransaction());
546 
547   EXPECT\_CALL(handler, onError(\_))
548     .WillOnce(Invoke([&] (\textcolor{keyword}{const} HTTPException& err) \{
549           EXPECT\_TRUE(err.hasProxygenError());
550           EXPECT\_EQ(err.getProxygenError(), kErrorStreamAbort);
551           ASSERT\_EQ(
552             \textcolor{stringliteral}{"Stream aborted, streamID=1, code=CANCEL"},
553             std::string(err.what()));
554         \}));
555   EXPECT\_CALL(handler, detachTransaction());
556 
557   \textcolor{comment}{// Receive client request}
558   \textcolor{keyword}{auto} req = makeGetRequest();
559   codecCallback\_->onMessageBegin(HTTPCodec::StreamID(1), req.get());
560   codecCallback\_->onHeadersComplete(HTTPCodec::StreamID(1), std::move(req));
561 
562   \textcolor{comment}{// Send client abort on assoc stream}
563   codecCallback\_->onAbort(HTTPCodec::StreamID(1), ErrorCode::CANCEL);
564 
565   eventBase\_.loop();
566 
567   EXPECT\_CALL(mockController\_, detachSession(\_));
568   httpSession\_->dropConnection();
569 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Server\+Push\+Client\+Message)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Server\+Push\+Client\+Message}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_aabecab5a2d799f60ffb94eea86b2b20d}


Definition at line 571 of file Mock\+Codec\+Downstream\+Test.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Exception\+::get\+Codec\+Status\+Code(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+Priority(), proxygen\+::\+H\+T\+T\+P\+Exception\+::has\+Codec\+Status\+Code(), proxygen\+::make\+Get\+Request(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::new\+Pushed\+Transaction(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::send\+Reply\+With\+Body(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::txn\+\_\+, and proxygen\+::\+Exception\+::what().


\begin{DoxyCode}
571                                                          \{
572   \textcolor{comment}{// Test that error is generated when client sends data on a pushed stream}
573   MockHTTPHandler handler;
574   MockHTTPPushHandler pushHandler;
575   \textcolor{keyword}{auto} req = makeGetRequest();
576   HTTPTransaction* pushTxn = \textcolor{keyword}{nullptr};
577 
578   InSequence enforceOrder;
579 
580   EXPECT\_CALL(mockController\_, getRequestHandler(\_, \_))
581     .WillOnce(Return(&handler));
582   EXPECT\_CALL(handler, setTransaction(\_))
583     .WillOnce(SaveArg<0>(&handler.txn_));
584 
585   EXPECT\_CALL(handler, onHeadersComplete(\_))
586     .WillOnce(Invoke([&] (std::shared\_ptr<HTTPMessage> msg) \{
587           pushTxn = handler.txn_->newPushedTransaction(&pushHandler);
588           \textcolor{keyword}{auto} pri = handler.txn_->getPriority();
589           msg->setHTTP2Priority(std::make\_tuple(pri.streamDependency,
590                                                 pri.exclusive, pri.weight));
591         \}));
592   EXPECT\_CALL(pushHandler, setTransaction(\_))
593     .WillOnce(Invoke([&pushHandler] (HTTPTransaction* txn) \{
594           pushHandler.txn_ = txn; \}));
595 
596   codecCallback\_->onMessageBegin(HTTPCodec::StreamID(1), req.get());
597   codecCallback\_->onHeadersComplete(HTTPCodec::StreamID(1), std::move(req));
598 
599   EXPECT\_CALL(*codec\_, generateRstStream(\_, 2, ErrorCode::STREAM\_CLOSED))
600     .WillRepeatedly(Return(1));
601   EXPECT\_CALL(pushHandler, onError(\_))
602     .WillOnce(Invoke([&] (\textcolor{keyword}{const} HTTPException& ex) \{
603           EXPECT\_TRUE(ex.hasCodecStatusCode());
604           EXPECT\_EQ(ex.getCodecStatusCode(), ErrorCode::STREAM\_CLOSED);
605           ASSERT\_EQ(
606             \textcolor{stringliteral}{"Downstream attempts to send ingress, abort."},
607             std::string(ex.what()));
608         \}));
609   EXPECT\_CALL(pushHandler, detachTransaction());
610 
611   \textcolor{comment}{// While the assoc stream is open and pushHandler has been initialized, send}
612   \textcolor{comment}{// an upstream message on the push stream causing a RST\_STREAM.}
613   req = makeGetRequest();
614   codecCallback\_->onMessageBegin(HTTPCodec::StreamID(2), req.get());
615 
616   EXPECT\_CALL(handler, onEOM())
617     .WillOnce(InvokeWithoutArgs([&] \{
618           handler.sendReplyWithBody(200, 100);
619           eventBase\_.loop(); \textcolor{comment}{// flush the response to the assoc request}
620         \}));
621   EXPECT\_CALL(*codec\_, generateHeader(\_, 1, \_, \_, \_));
622   EXPECT\_CALL(*codec\_, generateBody(\_, 1, PtrBufHasLen(uint64\_t(100)),
623                                     \_, \textcolor{keyword}{true}));
624   EXPECT\_CALL(handler, detachTransaction());
625 
626   \textcolor{comment}{// Complete the assoc request/response}
627   codecCallback\_->onMessageComplete(HTTPCodec::StreamID(1), \textcolor{keyword}{false});
628 
629   eventBase\_.loop();
630 
631   EXPECT\_CALL(*codec\_, onIngressEOF());
632   EXPECT\_CALL(mockController\_, detachSession(\_));
633   httpSession\_->dropConnection();
634 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Read\+Timeout)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Read\+Timeout}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_a9593b4f547dce5add56dc36bf7d551ea}


Definition at line 636 of file Mock\+Codec\+Downstream\+Test.\+cpp.



References proxygen\+::fake\+Mock\+Codec(), proxygen\+::make\+Get\+Request(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::pause\+Ingress(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::resume\+Ingress(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::send\+Reply\+With\+Body(), and proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::txn\+\_\+.


\begin{DoxyCode}
636                                              \{
637   \textcolor{comment}{// Test read timeout path}
638   MockHTTPHandler handler1;
639   \textcolor{keyword}{auto} req1 = makeGetRequest();
640 
641   fakeMockCodec(*codec\_);
642   EXPECT\_CALL(*codec\_, onIngressEOF())
643     .WillRepeatedly(Return());
644 
645   EXPECT\_CALL(mockController\_, getRequestHandler(\_, \_))
646     .WillOnce(Return(&handler1));
647 
648   EXPECT\_CALL(handler1, setTransaction(\_))
649     .WillOnce(Invoke([&handler1] (HTTPTransaction* txn) \{
650           handler1.txn_ = txn; \}));
651   EXPECT\_CALL(handler1, onHeadersComplete(\_));
652 
653   codecCallback\_->onMessageBegin(HTTPCodec::StreamID(1), req1.get());
654   codecCallback\_->onHeadersComplete(HTTPCodec::StreamID(1), std::move(req1));
655   \textcolor{comment}{// force the read timeout to expire, should be a no-op because the txn is}
656   \textcolor{comment}{// still expecting EOM and has its own timer.}
657   httpSession\_->timeoutExpired();
658   EXPECT\_EQ(httpSession\_->getConnectionCloseReason(),
659             ConnectionCloseReason::kMAX\_REASON);
660 
661   EXPECT\_CALL(handler1, onEOM())
662     .WillOnce(Invoke([&handler1] () \{
663           handler1.txn_->pauseIngress();
664         \}));
665 
666   \textcolor{comment}{// send the EOM, then another timeout.  Still no-op since it's waiting}
667   \textcolor{comment}{// upstream}
668   codecCallback\_->onMessageComplete(HTTPCodec::StreamID(1), \textcolor{keyword}{false});
669   httpSession\_->timeoutExpired();
670   EXPECT\_EQ(httpSession\_->getConnectionCloseReason(),
671             ConnectionCloseReason::kMAX\_REASON);
672 
673   EXPECT\_CALL(*transport\_, writeChain(\_, \_, \_))
674     .WillRepeatedly(Invoke([] (
675             folly::AsyncTransportWrapper::WriteCallback* callback,
676             std::shared\_ptr<folly::IOBuf>,
677             folly::WriteFlags) \{
678           callback->writeSuccess();
679           \}));
680 
681   EXPECT\_CALL(handler1, detachTransaction());
682 
683   \textcolor{comment}{// Send the response, timeout.  Now it's idle and should close.}
684   handler1.txn_->resumeIngress();
685   handler1.sendReplyWithBody(200, 100);
686   eventBase\_.loop();
687 
688   httpSession\_->timeoutExpired();
689   EXPECT\_EQ(httpSession\_->getConnectionCloseReason(),
690             ConnectionCloseReason::TIMEOUT);
691 
692   \textcolor{comment}{// tear down the test}
693   EXPECT\_CALL(mockController\_, detachSession(\_));
694   httpSession\_->dropConnection();
695 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Ping)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Ping}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_a06d391fb2ee5d5dbd9731e354a0aa10a}


Definition at line 697 of file Mock\+Codec\+Downstream\+Test.\+cpp.



References proxygen\+::make\+Get\+Request(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::send\+Reply\+With\+Body(), and proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::txn\+\_\+.


\begin{DoxyCode}
697                                       \{
698   \textcolor{comment}{// Test ping mechanism and that we prioritize the ping reply}
699   MockHTTPHandler handler1;
700   \textcolor{keyword}{auto} req1 = makeGetRequest();
701 
702   InSequence enforceOrder;
703 
704   EXPECT\_CALL(mockController\_, getRequestHandler(\_, \_))
705     .WillOnce(Return(&handler1));
706 
707   EXPECT\_CALL(handler1, setTransaction(\_))
708     .WillOnce(Invoke([&handler1] (HTTPTransaction* txn) \{
709           handler1.txn_ = txn; \}));
710   EXPECT\_CALL(handler1, onHeadersComplete(\_));
711   EXPECT\_CALL(handler1, onEOM())
712     .WillOnce(InvokeWithoutArgs([&handler1] () \{
713           handler1.sendReplyWithBody(200, 100);
714         \}));
715 
716   \textcolor{comment}{// Header egresses immediately}
717   EXPECT\_CALL(*codec\_, generateHeader(\_, \_, \_, \_, \_));
718   \textcolor{comment}{// Ping jumps ahead of queued body in the loop callback}
719   EXPECT\_CALL(*codec\_, generatePingReply(\_, \_));
720   EXPECT\_CALL(*codec\_, generateBody(\_, \_, \_, \_, \textcolor{keyword}{true}));
721   EXPECT\_CALL(handler1, detachTransaction());
722 
723   codecCallback\_->onMessageBegin(HTTPCodec::StreamID(1), req1.get());
724   codecCallback\_->onHeadersComplete(HTTPCodec::StreamID(1), std::move(req1));
725   codecCallback\_->onMessageComplete(HTTPCodec::StreamID(1), \textcolor{keyword}{false});
726   codecCallback\_->onPingRequest(1);
727 
728   eventBase\_.loop();
729 
730   EXPECT\_CALL(*codec\_, onIngressEOF());
731   EXPECT\_CALL(mockController\_, detachSession(\_));
732   httpSession\_->dropConnection();
733 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Flow\+Control\+Abort)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Flow\+Control\+Abort}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_ae8df65811bec800ebb3da5f3924bc0bb}


Definition at line 735 of file Mock\+Codec\+Downstream\+Test.\+cpp.



References proxygen\+::http2\+::k\+Initial\+Window, make\+Buf(), proxygen\+::make\+Post\+Request(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::send\+Abort(), and proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::txn\+\_\+.


\begin{DoxyCode}
735                                                   \{
736   MockHTTPHandler handler1;
737   \textcolor{keyword}{auto} req1 = makePostRequest();
738 
739   InSequence enforceOrder;
740 
741   EXPECT\_CALL(mockController\_, getRequestHandler(\_, \_))
742     .WillOnce(Return(&handler1));
743 
744   EXPECT\_CALL(handler1, setTransaction(\_))
745     .WillOnce(Invoke([&handler1] (HTTPTransaction* txn) \{
746           handler1.txn_ = txn; \}));
747   EXPECT\_CALL(handler1, onHeadersComplete(\_))
748     .WillOnce(InvokeWithoutArgs([&handler1] () \{
749           handler1.txn_->sendAbort();
750         \}));
751 
752   \textcolor{comment}{// Header egresses immediately}
753   EXPECT\_CALL(handler1, detachTransaction());
754 
755   codecCallback\_->onMessageBegin(HTTPCodec::StreamID(1), req1.get());
756   codecCallback\_->onHeadersComplete(HTTPCodec::StreamID(1), std::move(req1));
757   EXPECT\_CALL(*codec\_, generateWindowUpdate(\_, 0, spdy::kInitialWindow));
758   codecCallback\_->onBody(HTTPCodec::StreamID(1),
759                          makeBuf(spdy::kInitialWindow), 0);
760   EXPECT\_CALL(*codec\_, generateWindowUpdate(\_, 0, spdy::kInitialWindow));
761   codecCallback\_->onBody(HTTPCodec::StreamID(1),
762                          makeBuf(spdy::kInitialWindow), 0);
763 
764   eventBase\_.loop();
765 
766   EXPECT\_CALL(*codec\_, onIngressEOF());
767   EXPECT\_CALL(mockController\_, detachSession(\_));
768   httpSession\_->dropConnection();
769 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Buffering)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Buffering}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_ab39817a81647a964d175fd105d0159ee}


Definition at line 771 of file Mock\+Codec\+Downstream\+Test.\+cpp.



References proxygen\+::fake\+Mock\+Codec(), make\+Buf(), and proxygen\+::make\+Post\+Request().


\begin{DoxyCode}
771                                            \{
772   StrictMock<MockHTTPHandler> handler;
773   \textcolor{keyword}{auto} req1 = makePostRequest(20);
774   \textcolor{keyword}{auto} chunk = makeBuf(10);
775   \textcolor{keyword}{auto} chunkStr = chunk->clone()->moveToFbString();
776 
777   fakeMockCodec(*codec\_);
778 
779   httpSession\_->setDefaultReadBufferLimit(10);
780 
781   EXPECT\_CALL(mockController\_, getRequestHandler(\_, \_))
782     .WillOnce(Return(&handler));
783 
784   EXPECT\_CALL(handler, setTransaction(\_))
785     .WillOnce(Invoke([&handler] (HTTPTransaction* txn) \{
786           handler.txn\_ = txn; \}));
787   EXPECT\_CALL(handler, onHeadersComplete(\_))
788     .WillOnce(InvokeWithoutArgs([&handler] () \{
789           handler.txn\_->pauseIngress();
790         \}));
791 
792   EXPECT\_CALL(*transport\_, writeChain(\_, \_, \_))
793     .WillRepeatedly(Invoke([&] (
794             folly::AsyncTransportWrapper::WriteCallback* callback,
795             \textcolor{keyword}{const} shared\_ptr<IOBuf>&,
796             WriteFlags) \{
797           callback->writeSuccess();
798           \}));
799 
800   codecCallback\_->onMessageBegin(HTTPCodec::StreamID(1), req1.get());
801   codecCallback\_->onHeadersComplete(HTTPCodec::StreamID(1), std::move(req1));
802   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 2; i++) \{
803     codecCallback\_->onBody(HTTPCodec::StreamID(1), chunk->clone(), 0);
804   \}
805   codecCallback\_->onMessageComplete(HTTPCodec::StreamID(1), \textcolor{keyword}{false});
806 
807   EXPECT\_CALL(handler, onBody(\_))
808     .WillOnce(ExpectString(chunkStr))
809     .WillOnce(ExpectString(chunkStr));
810 
811   EXPECT\_CALL(handler, onEOM());
812 
813   EXPECT\_CALL(handler, detachTransaction());
814 
815   eventBase\_.tryRunAfterDelay([&handler, \textcolor{keyword}{this}] \{
816       handler.txn\_->resumeIngress();
817       handler.sendReplyWithBody(200, 100);
818       eventBase\_.runInLoop([\textcolor{keyword}{this}] \{ httpSession\_->dropConnection(); \});
819     \}, 30);
820 
821   EXPECT\_CALL(*codec\_, onIngressEOF());
822   EXPECT\_CALL(mockController\_, detachSession(\_));
823   eventBase\_.loop();
824 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Spdy\+Window)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Spdy\+Window}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_a994a3418689d6472932c9f4f73e44d5a}


Definition at line 826 of file Mock\+Codec\+Downstream\+Test.\+cpp.



References proxygen\+::fake\+Mock\+Codec(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+Local\+Address(), proxygen\+::make\+Get\+Request(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::send\+Body(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::send\+E\+O\+M(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::send\+Headers(), and proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::txn\+\_\+.


\begin{DoxyCode}
826                                             \{
827   \textcolor{comment}{// Test window updates}
828   MockHTTPHandler handler1;
829   \textcolor{keyword}{auto} req1 = makeGetRequest();
830 
831   fakeMockCodec(*codec\_);
832 
833   \{
834     InSequence enforceOrder;
835     EXPECT\_CALL(mockController\_, getRequestHandler(\_, \_))
836       .WillOnce(Return(&handler1));
837 
838     EXPECT\_CALL(handler1, setTransaction(\_))
839       .WillOnce(Invoke([&handler1] (HTTPTransaction* txn) \{
840             handler1.txn_ = txn; \}));
841     EXPECT\_CALL(handler1, onHeadersComplete(\_))
842       .WillOnce(InvokeWithoutArgs([\textcolor{keyword}{this}] () \{
843             codecCallback\_->onSettings(
844               \{\{SettingsId::INITIAL\_WINDOW\_SIZE, 4000\}\});
845           \}));
846     EXPECT\_CALL(*codec\_, generateSettingsAck(\_));
847     EXPECT\_CALL(handler1, onEOM())
848       .WillOnce(InvokeWithoutArgs([&handler1] () \{
849             handler1.sendHeaders(200, 16000);
850             handler1.sendBody(12000);
851             \textcolor{comment}{// 12kb buffered -> pause upstream}
852           \}));
853     EXPECT\_CALL(handler1, onEgressPaused())
854       .WillOnce(InvokeWithoutArgs([\textcolor{keyword}{this}] () \{
855             eventBase\_.runInLoop([\textcolor{keyword}{this}] \{
856                 \textcolor{comment}{// triggers 4k send, 8kb buffered, handler still paused}
857                 codecCallback\_->onWindowUpdate(1, 4000);
858               \});
859             eventBase\_.runAfterDelay([\textcolor{keyword}{this}] \{
860                 \textcolor{comment}{// triggers 6k send, 2kb buffered, handler still paused}
861                 codecCallback\_->onWindowUpdate(1, 6000);
862               \}, 10);
863             eventBase\_.runAfterDelay([\textcolor{keyword}{this}] \{
864                 \textcolor{comment}{// triggers 2kb send, 0 buffered, 2k window => resume}
865                 codecCallback\_->onWindowUpdate(1, 4000);
866               \}, 20);
867           \}));
868     EXPECT\_CALL(handler1, onEgressResumed())
869       .WillOnce(InvokeWithoutArgs([&handler1] () \{
870             handler1.sendBody(4000);
871             \textcolor{comment}{// 2kb send, 2kb buffered => pause upstream}
872           \}));
873     EXPECT\_CALL(handler1, onEgressPaused())
874       .WillOnce(InvokeWithoutArgs([\textcolor{keyword}{this}] () \{
875             eventBase\_.runInLoop([\textcolor{keyword}{this}] \{
876                 \textcolor{comment}{// triggers 2kb send, resume}
877                 codecCallback\_->onWindowUpdate(1, 4000);
878               \});
879           \}));
880     EXPECT\_CALL(handler1, onEgressResumed())
881       .WillOnce(InvokeWithoutArgs([&handler1] () \{
882             handler1.txn_->sendEOM();
883           \}));
884 
885     EXPECT\_CALL(handler1, detachTransaction());
886 
887     codecCallback\_->onMessageBegin(HTTPCodec::StreamID(1), req1.get());
888     codecCallback\_->onHeadersComplete(HTTPCodec::StreamID(1), std::move(req1));
889     codecCallback\_->onMessageComplete(HTTPCodec::StreamID(1), \textcolor{keyword}{false});
890     \textcolor{comment}{// Pad coverage numbers}
891     std::ostringstream stream;
892     stream << *handler1.txn_ << *httpSession\_
893            << httpSession\_->getLocalAddress()
894            << httpSession\_->getPeerAddress();
895     EXPECT\_TRUE(httpSession\_->isBusy());
896 
897     EXPECT\_CALL(*codec\_, onIngressEOF());
898     EXPECT\_CALL(mockController\_, detachSession(\_));
899   \}
900 
901   EXPECT\_CALL(*transport\_, writeChain(\_, \_, \_))
902     .WillRepeatedly(Invoke([] (
903             folly::AsyncTransportWrapper::WriteCallback* callback,
904             std::shared\_ptr<folly::IOBuf>,
905             folly::WriteFlags) \{
906           callback->writeSuccess();
907           \}));
908   eventBase\_.loop();
909   httpSession\_->dropConnection();
910 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Double\+Resume)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Double\+Resume}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_a34ace07831b38a914f10d46c5826eb28}


Definition at line 912 of file Mock\+Codec\+Downstream\+Test.\+cpp.



References proxygen\+::fake\+Mock\+Codec(), make\+Buf(), proxygen\+::make\+Post\+Request(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::pause\+Ingress(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::resume\+Ingress(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::send\+Reply\+With\+Body(), and proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::txn\+\_\+.


\begin{DoxyCode}
912                                               \{
913   \textcolor{comment}{// Test spdy ping mechanism and egress re-ordering}
914   MockHTTPHandler handler1;
915   \textcolor{keyword}{auto} req1 = makePostRequest(5);
916   \textcolor{keyword}{auto} buf = makeBuf(5);
917   \textcolor{keyword}{auto} bufStr = buf->clone()->moveToFbString();
918 
919   fakeMockCodec(*codec\_);
920 
921   EXPECT\_CALL(mockController\_, getRequestHandler(\_, \_))
922     .WillOnce(Return(&handler1));
923 
924   EXPECT\_CALL(handler1, setTransaction(\_))
925     .WillOnce(Invoke([&handler1] (HTTPTransaction* txn) \{
926           handler1.txn_ = txn; \}));
927   EXPECT\_CALL(handler1, onHeadersComplete(\_))
928     .WillOnce(InvokeWithoutArgs([&handler1, \textcolor{keyword}{this}] \{
929           handler1.txn_->pauseIngress();
930           eventBase\_.tryRunAfterDelay([&handler1] \{
931               handler1.txn_->resumeIngress();
932             \}, 50);
933         \}));
934   EXPECT\_CALL(handler1, onBody(\_))
935     .WillOnce(Invoke([&handler1, &bufStr] (
936                        std::shared\_ptr<folly::IOBuf> chain) \{
937           EXPECT\_EQ(bufStr, chain->moveToFbString());
938           handler1.txn_->pauseIngress();
939           handler1.txn_->resumeIngress();
940         \}));
941 
942   EXPECT\_CALL(handler1, onEOM())
943     .WillOnce(InvokeWithoutArgs([&handler1] () \{
944           handler1.sendReplyWithBody(200, 100, \textcolor{keyword}{false});
945         \}));
946   EXPECT\_CALL(handler1, detachTransaction());
947 
948   codecCallback\_->onMessageBegin(HTTPCodec::StreamID(1), req1.get());
949   codecCallback\_->onHeadersComplete(HTTPCodec::StreamID(1), std::move(req1));
950   codecCallback\_->onBody(HTTPCodec::StreamID(1), std::move(buf), 0);
951   codecCallback\_->onMessageComplete(HTTPCodec::StreamID(1), \textcolor{keyword}{false});
952 
953   EXPECT\_CALL(*codec\_, onIngressEOF());
954   EXPECT\_CALL(mockController\_, detachSession(\_));
955 
956   EXPECT\_CALL(*transport\_, writeChain(\_, \_, \_))
957     .WillRepeatedly(Invoke([] (
958             folly::AsyncTransportWrapper::WriteCallback* callback,
959             std::shared\_ptr<folly::IOBuf>,
960             folly::WriteFlags) \{
961           callback->writeSuccess();
962           \}));
963 
964   eventBase\_.loop();
965   httpSession\_->dropConnection();
966 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Conn\+Flow\+Control\+Blocked)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Conn\+Flow\+Control\+Blocked}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_a4b068d376a30fe5bfca26c341a65e141}


Definition at line 1083 of file Mock\+Codec\+Downstream\+Test.\+cpp.


\begin{DoxyCode}
1083                                                         \{
1084   testConnFlowControlBlocked(\textcolor{keyword}{false});
1085 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Conn\+Flow\+Control\+Timeout)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Conn\+Flow\+Control\+Timeout}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_ab5a0e0462d538d5274aebc37e27c91d4}


Definition at line 1087 of file Mock\+Codec\+Downstream\+Test.\+cpp.


\begin{DoxyCode}
1087                                                         \{
1088   testConnFlowControlBlocked(\textcolor{keyword}{true});
1089 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Unpaused\+Large\+Post)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Unpaused\+Large\+Post}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_abb47953c4e24c0184c8cc28e3499fa67}


Definition at line 1091 of file Mock\+Codec\+Downstream\+Test.\+cpp.



References proxygen\+::http2\+::k\+Initial\+Window, make\+Buf(), and proxygen\+::make\+Post\+Request().


\begin{DoxyCode}
1091                                                    \{
1092   \textcolor{comment}{// Make sure that a large POST that streams into the handler generates}
1093   \textcolor{comment}{// connection level flow control so that the entire POST can be received.}
1094   InSequence enforceOrder;
1095   NiceMock<MockHTTPHandler> handler1;
1096   \textcolor{keywordtype}{unsigned} kNumChunks = 10;
1097   \textcolor{keyword}{auto} wantToWrite = spdy::kInitialWindow * kNumChunks;
1098   \textcolor{keyword}{auto} wantToWriteStr = folly::to<string>(wantToWrite);
1099   \textcolor{keyword}{auto} req1 = makePostRequest(wantToWrite);
1100   \textcolor{keyword}{auto} req1Body = makeBuf(wantToWrite);
1101 
1102   EXPECT\_CALL(mockController\_, getRequestHandler(\_, \_))
1103     .WillOnce(Return(&handler1));
1104   EXPECT\_CALL(handler1, setTransaction(\_))
1105     .WillOnce(SaveArg<0>(&handler1.txn\_));
1106 
1107   EXPECT\_CALL(handler1, onHeadersComplete(\_));
1108   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i = 0; i < kNumChunks; ++i) \{
1109     EXPECT\_CALL(*codec\_, generateWindowUpdate(\_, 0, spdy::kInitialWindow));
1110     EXPECT\_CALL(handler1, onBody(PtrBufHasLen(spdy::kInitialWindow)));
1111     EXPECT\_CALL(*codec\_, generateWindowUpdate(\_, 1, spdy::kInitialWindow));
1112   \}
1113   EXPECT\_CALL(handler1, onEOM());
1114 
1115   codecCallback\_->onMessageBegin(1, req1.get());
1116   codecCallback\_->onHeadersComplete(1, std::move(req1));
1117   \textcolor{comment}{// Give kNumChunks chunks, each of the maximum window size. We should generate}
1118   \textcolor{comment}{// window update for each chunk}
1119   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i = 0; i < kNumChunks; ++i) \{
1120     codecCallback\_->onBody(1, makeBuf(spdy::kInitialWindow), 0);
1121   \}
1122   codecCallback\_->onMessageComplete(1, \textcolor{keyword}{false});
1123 
1124   \textcolor{comment}{// Just tear everything down now.}
1125   EXPECT\_CALL(mockController\_, detachSession(\_));
1126   httpSession\_->dropConnection();
1127 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Ingress\+Paused\+Window\+Update)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Ingress\+Paused\+Window\+Update}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_ac812c818a7cce9e4f2a8bc97a4ffe206}


Definition at line 1129 of file Mock\+Codec\+Downstream\+Test.\+cpp.



References proxygen\+::http2\+::k\+Initial\+Window, proxygen\+::make\+Get\+Request(), and proxygen\+::make\+Response().


\begin{DoxyCode}
1129                                                            \{
1130   \textcolor{comment}{// Test sending a large response body while the handler has ingress paused. We}
1131   \textcolor{comment}{// should process the ingress window\_updates and deliver the full body}
1132   InSequence enforceOrder;
1133   NiceMock<MockHTTPHandler> handler1;
1134   \textcolor{keyword}{auto} req = makeGetRequest();
1135   \textcolor{keywordtype}{size\_t} respSize = spdy::kInitialWindow * 10;
1136   unique\_ptr<HTTPMessage> resp;
1137   unique\_ptr<folly::IOBuf> respBody;
1138   tie(resp, respBody) = makeResponse(200, respSize);
1139   \textcolor{keywordtype}{size\_t} written = 0;
1140 
1141   EXPECT\_CALL(mockController\_, getRequestHandler(\_, \_))
1142     .WillOnce(Return(&handler1));
1143   EXPECT\_CALL(handler1, setTransaction(\_))
1144     .WillOnce(SaveArg<0>(&handler1.txn\_));
1145 
1146   EXPECT\_CALL(handler1, onHeadersComplete(\_))
1147     .WillOnce(InvokeWithoutArgs([&] () \{
1148           \textcolor{comment}{// Pause ingress. Make sure we process the window updates anyway}
1149           handler1.txn\_->pauseIngress();
1150         \}));
1151   EXPECT\_CALL(*codec\_, generateHeader(\_, \_, \_, \_, \_));
1152   EXPECT\_CALL(*codec\_, generateBody(\_, \_, \_, \_, \_))
1153       .WillRepeatedly(Invoke([&](folly::IOBufQueue&,
1154                                  HTTPCodec::StreamID,
1155                                  std::shared\_ptr<folly::IOBuf> chain,
1156                                  folly::Optional<uint8\_t>,
1157                                  \textcolor{keywordtype}{bool} \textcolor{comment}{/*eom*/}) \{
1158         \textcolor{keyword}{auto} len = chain->computeChainDataLength();
1159         written += len;
1160         \textcolor{keywordflow}{return} len;
1161       \}));
1162 
1163   codecCallback\_->onWindowUpdate(0, respSize); \textcolor{comment}{// open conn-level window}
1164   codecCallback\_->onMessageBegin(1, req.get());
1165   codecCallback\_->onHeadersComplete(1, std::move(req));
1166   EXPECT\_TRUE(handler1.txn\_->isIngressPaused());
1167 
1168   \textcolor{comment}{// Unblock txn-level flow control and try to egress the body}
1169   codecCallback\_->onWindowUpdate(1, respSize);
1170   handler1.txn\_->sendHeaders(*resp);
1171   handler1.txn\_->sendBody(std::move(respBody));
1172 
1173   eventBase\_.loop();
1174   EXPECT\_EQ(written, respSize);
1175 
1176   \textcolor{comment}{// Just tear everything down now.}
1177   EXPECT\_CALL(mockController\_, detachSession(\_));
1178   httpSession\_->dropConnection();
1179 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Shutdown\+Then\+Send\+Push\+Headers)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Shutdown\+Then\+Send\+Push\+Headers}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_a85e731fa90ea5d5bfbc1efbf575f7afd}


Definition at line 1181 of file Mock\+Codec\+Downstream\+Test.\+cpp.



References proxygen\+::make\+Get\+Request(), proxygen\+::\+Mock\+H\+T\+T\+P\+Push\+Handler\+::send\+Push\+Headers(), and proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::txn\+\_\+.


\begin{DoxyCode}
1181                                                              \{
1182   \textcolor{comment}{// Test that notifying session of shutdown before sendHeaders() called on a}
1183   \textcolor{comment}{// pushed txn lets that push txn finish.}
1184   EXPECT\_CALL(*codec\_, supportsPushTransactions())
1185     .WillRepeatedly(Return(\textcolor{keyword}{true}));
1186 
1187   InSequence enforceOrder;
1188   NiceMock<MockHTTPHandler> handler;
1189   MockHTTPPushHandler pushHandler;
1190   \textcolor{keyword}{auto} req = makeGetRequest();
1191 
1192   EXPECT\_CALL(mockController\_, getRequestHandler(\_, \_))
1193     .WillOnce(Return(&handler));
1194   EXPECT\_CALL(handler, setTransaction(\_))
1195     .WillOnce(SaveArg<0>(&handler.txn\_));
1196 
1197   EXPECT\_CALL(handler, onHeadersComplete(\_))
1198     .WillOnce(Invoke([&] (std::shared\_ptr<HTTPMessage>) \{
1199           \textcolor{keyword}{auto} pushTxn = handler.txn\_->newPushedTransaction(&pushHandler);
1200           \textcolor{comment}{// start shutdown process}
1201           httpSession\_->notifyPendingShutdown();
1202           \textcolor{comment}{// we should be able to process new requests}
1203           EXPECT\_TRUE(codec\_->isReusable());
1204           pushHandler.sendPushHeaders(\textcolor{stringliteral}{"/foo"}, \textcolor{stringliteral}{"www.foo.com"}, 0,
1205                                       handler.txn\_->getPriority());
1206           \textcolor{comment}{// we should* still* be able to process new requests}
1207           EXPECT\_TRUE(codec\_->isReusable());
1208           pushTxn->sendEOM();
1209         \}));
1210   EXPECT\_CALL(pushHandler, setTransaction(\_))
1211     .WillOnce(SaveArg<0>(&pushHandler.txn_));
1212   EXPECT\_CALL(*codec\_, generatePushPromise(\_, 2, \_, \_, \_, \_));
1213   EXPECT\_CALL(*codec\_, generateEOM(\_, 2));
1214   EXPECT\_CALL(pushHandler, detachTransaction());
1215   EXPECT\_CALL(handler, onEOM())
1216     .WillOnce(Invoke([&] \{
1217           handler.sendReply();
1218         \}));
1219   EXPECT\_CALL(*codec\_, generateHeader(\_, 1, \_, \_, \_));
1220   EXPECT\_CALL(*codec\_, generateEOM(\_, 1));
1221   EXPECT\_CALL(handler, detachTransaction());
1222 
1223   codecCallback\_->onMessageBegin(1, req.get());
1224   codecCallback\_->onHeadersComplete(1, std::move(req));
1225   codecCallback\_->onMessageComplete(1, \textcolor{keyword}{false});
1226 
1227   \textcolor{comment}{// finish shutdown}
1228   EXPECT\_CALL(*codec\_, onIngressEOF());
1229   EXPECT\_CALL(mockController\_, detachSession(\_));
1230   httpSession\_->dropConnection();
1231 
1232   eventBase\_.loop();
1233 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Read\+Iobuf\+Chain\+Shutdown)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Read\+Iobuf\+Chain\+Shutdown}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_a7066254dd642048094f057dbe90e371d}


Definition at line 1235 of file Mock\+Codec\+Downstream\+Test.\+cpp.


\begin{DoxyCode}
1235                                                         \{
1236   \textcolor{comment}{// Given an ingress IOBuf chain of 2 parts, if we shutdown after reading the}
1237   \textcolor{comment}{// first part of the chain, we shouldn't read the second part.  One way to}
1238   \textcolor{comment}{// simulate a 2 part chain is to put more ingress in readBuf while we are}
1239   \textcolor{comment}{// inside HTTPCodec::onIngress()}
1240 
1241   InSequence enforceOrder;
1242 
1243   \textcolor{keyword}{auto} f = [&] () \{
1244     \textcolor{keywordtype}{void}* buf;
1245     \textcolor{keywordtype}{size\_t} bufSize;
1246     transportCb\_->getReadBuffer(&buf, &bufSize);
1247     transportCb\_->readDataAvailable(bufSize);
1248   \};
1249 
1250   EXPECT\_CALL(*codec\_, onIngress(\_))
1251     .WillOnce(Invoke([&] (\textcolor{keyword}{const} IOBuf& buf) \{
1252           \textcolor{comment}{// This first time, don't process any data. This will cause the}
1253           \textcolor{comment}{// ingress chain to grow in size later.}
1254           EXPECT\_FALSE(buf.isChained());
1255           \textcolor{keywordflow}{return} 0;
1256         \}))
1257     .WillOnce(Invoke([&] (\textcolor{keyword}{const} IOBuf& buf) \{
1258           \textcolor{comment}{// Now there should be a second buffer in the chain.}
1259           EXPECT\_TRUE(buf.isChained());
1260           \textcolor{comment}{// Shutdown writes. This enough to destroy the session.}
1261           httpSession\_->closeWhenIdle();
1262           \textcolor{keywordflow}{return} buf.length();
1263         \}));
1264   \textcolor{comment}{// We shouldn't get a third onIngress() callback. This will be enforced by the}
1265   \textcolor{comment}{// test framework since the codec is a strict mock.}
1266   EXPECT\_CALL(*codec\_, isBusy());
1267   EXPECT\_CALL(*codec\_, onIngressEOF());
1268   EXPECT\_CALL(mockController\_, detachSession(\_));
1269 
1270   f();
1271   f(); \textcolor{comment}{// The first time wasn't processed, so this should make a len=2 chain.}
1272   eventBase\_.loop();
1273 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Send\+Double\+Goaway\+Timeout)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Send\+Double\+Goaway\+Timeout}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_a9461aa5fe1998598821c1489600b55f6}


Definition at line 1349 of file Mock\+Codec\+Downstream\+Test.\+cpp.


\begin{DoxyCode}
1349                                                          \{
1350   testGoaway(\textcolor{keyword}{true}, \textcolor{keyword}{true});
1351 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Send\+Double\+Goaway\+Idle)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Send\+Double\+Goaway\+Idle}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_ad824ac50ecf075ce228fabda501f20eb}


Definition at line 1352 of file Mock\+Codec\+Downstream\+Test.\+cpp.


\begin{DoxyCode}
1352                                                       \{
1353   testGoaway(\textcolor{keyword}{true}, \textcolor{keyword}{false});
1354 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Send\+Goaway\+Timeout)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Send\+Goaway\+Timeout}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_af7a90165ae5d623e249311603707b525}


Definition at line 1355 of file Mock\+Codec\+Downstream\+Test.\+cpp.


\begin{DoxyCode}
1355                                                    \{
1356   testGoaway(\textcolor{keyword}{false}, \textcolor{keyword}{true});
1357 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Send\+Goaway\+Idle)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Send\+Goaway\+Idle}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_af9ca1882a789e9e7538c9c66d951b847}


Definition at line 1358 of file Mock\+Codec\+Downstream\+Test.\+cpp.


\begin{DoxyCode}
1358                                                 \{
1359   testGoaway(\textcolor{keyword}{false}, \textcolor{keyword}{false});
1360 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Drop\+Connection)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Drop\+Connection}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_a36f0bc46d0ea23215a315c9176788778}


Definition at line 1362 of file Mock\+Codec\+Downstream\+Test.\+cpp.


\begin{DoxyCode}
1362                                                 \{
1363   NiceMock<MockHTTPHandler> handler;
1364   MockHTTPHandler pushHandler;
1365 
1366   liveGoaways\_ = \textcolor{keyword}{true};
1367 
1368   EXPECT\_CALL(*codec\_, onIngressEOF());
1369   EXPECT\_CALL(mockController\_, detachSession(\_));
1370   EXPECT\_CALL(*transport\_, closeWithReset())
1371     .Times(AtLeast(1))
1372     .WillOnce(Assign(&transportGood\_, \textcolor{keyword}{false}));
1373   httpSession\_->dropConnection();
1374 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Drop\+Connection\+Nogoaway)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Drop\+Connection\+Nogoaway}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_a6db3fb60c8b68b0a89f9c91f4d5a6f66}


Definition at line 1376 of file Mock\+Codec\+Downstream\+Test.\+cpp.


\begin{DoxyCode}
1376                                                         \{
1377   NiceMock<MockHTTPHandler> handler;
1378   MockHTTPHandler pushHandler;
1379 
1380   liveGoaways\_ = \textcolor{keyword}{false};
1381 
1382   EXPECT\_CALL(*codec\_, onIngressEOF());
1383   EXPECT\_CALL(mockController\_, detachSession(\_));
1384   EXPECT\_CALL(*transport\_, closeNow())
1385     .Times(AtLeast(1))
1386     .WillOnce(Assign(&transportGood\_, \textcolor{keyword}{false}));
1387   httpSession\_->dropConnection();
1388 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Shutdown\+Then\+Error)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Shutdown\+Then\+Error}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_ae9df523f7c75a1c5dbe46fc5f2b0178a}


Definition at line 1390 of file Mock\+Codec\+Downstream\+Test.\+cpp.



References proxygen\+::get\+Get\+Request(), and proxygen\+::\+H\+T\+T\+P\+Exception\+::set\+Http\+Status\+Code().


\begin{DoxyCode}
1390                                                    \{
1391   \textcolor{comment}{// Test that we ignore any errors after we shutdown the socket in HTTPSession.}
1392   onIngressImpl([&] \{
1393       \textcolor{comment}{// This executes as the implementation of HTTPCodec::onIngress()}
1394       InSequence dummy;
1395 
1396       HTTPException err(HTTPException::Direction::INGRESS, \textcolor{stringliteral}{"foo"});
1397       err.setHttpStatusCode(400);
1398       HTTPMessage req = getGetRequest();
1399       EXPECT\_CALL(mockController\_, getParseErrorHandler(\_, \_, \_))
1400         .WillOnce(Return(\textcolor{keyword}{nullptr}));
1401 
1402       \textcolor{comment}{// Creates and adds a txn to the session}
1403       codecCallback\_->onMessageBegin(1, &req);
1404 
1405       httpSession\_->closeWhenIdle();
1406 
1407       codecCallback\_->onError(1, err, \textcolor{keyword}{false});
1408     \});
1409   \textcolor{comment}{// flush the shutdown callback}
1410   EXPECT\_CALL(mockController\_, detachSession(\_));
1411   eventBase\_.loopOnce();
1412 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Ping\+During\+Shutdown)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Ping\+During\+Shutdown}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_a3e5e513109122afb04c13f88bb3146d7}


Definition at line 1414 of file Mock\+Codec\+Downstream\+Test.\+cpp.


\begin{DoxyCode}
1414                                                     \{
1415   onIngressImpl([&] \{
1416       InSequence dummy;
1417 
1418       \textcolor{comment}{// Shutdown writes only. Since the session is empty, this normally}
1419       \textcolor{comment}{// causes the session to close, but it is held open since we are in}
1420       \textcolor{comment}{// the middle of parsing ingress.}
1421       EXPECT\_CALL(*codec\_, isBusy());
1422       EXPECT\_CALL(*codec\_, onIngressEOF());
1423       httpSession\_->closeWhenIdle();
1424 
1425       \textcolor{comment}{// We read a ping off the wire, which makes us enqueue a ping reply}
1426       EXPECT\_CALL(*codec\_, generatePingReply(\_, \_))
1427         .WillOnce(Return(10));
1428       codecCallback\_->onPingRequest(1);
1429 
1430       \textcolor{comment}{// When this function returns, the controller gets detachSession()}
1431       EXPECT\_CALL(mockController\_, detachSession(\_));
1432     \});
1433 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Settings\+Ack)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Settings\+Ack}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_a7840aabd755bb7a598bca06c271c5b92}


Definition at line 1435 of file Mock\+Codec\+Downstream\+Test.\+cpp.


\begin{DoxyCode}
1435                                              \{
1436   EXPECT\_CALL(*codec\_, generateSettingsAck(\_));
1437   codecCallback\_->onSettings(
1438     \{\{SettingsId::INITIAL\_WINDOW\_SIZE, 4000\}\});
1439   EXPECT\_CALL(*codec\_, onIngressEOF());
1440   EXPECT\_CALL(mockController\_, detachSession(\_));
1441   httpSession\_->dropConnection();
1442 \}
\end{DoxyCode}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+Codec\+Downstream\+Test, Test\+Send\+Certificate\+Request)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+Codec\+Downstream\+Test}}]{, }
\item[{Test\+Send\+Certificate\+Request}]{}
\end{DoxyParamCaption}
)}\label{MockCodecDownstreamTest_8cpp_ae2a04d1a4117034c188f290aae437f78}


Definition at line 1444 of file Mock\+Codec\+Downstream\+Test.\+cpp.



References k\+Egress\+Cert\+Auth\+Settings, and k\+Ingress\+Cert\+Auth\+Settings.


\begin{DoxyCode}
1444                                                             \{
1445   \textcolor{keyword}{auto} certRequestContext = folly::IOBuf::copyBuffer(\textcolor{stringliteral}{"0123456789abcdef"});
1446   fizz::SignatureAlgorithms sigAlgs;
1447   sigAlgs.supported\_signature\_algorithms.push\_back(
1448       SignatureScheme::ecdsa\_secp256r1\_sha256);
1449   std::vector<fizz::Extension> extensions;
1450   extensions.push\_back(encodeExtension(std::move(sigAlgs)));
1451 
1452   std::unique\_ptr<StrictMock<MockSecondaryAuthManager>> secondAuthManager\_(
1453       \textcolor{keyword}{new} StrictMock<MockSecondaryAuthManager>());
1454   httpSession\_->setSecondAuthManager(std::move(secondAuthManager\_));
1455   \textcolor{keyword}{auto} authManager = \textcolor{keyword}{dynamic\_cast<}MockSecondaryAuthManager*\textcolor{keyword}{>}(
1456       httpSession\_->getSecondAuthManager());
1457   EXPECT\_CALL(*codec\_, getIngressSettings())
1458       .WillOnce(Return(&kIngressCertAuthSettings));
1459   EXPECT\_CALL(*codec\_, getEgressSettings())
1460       .WillOnce(Return(&kEgressCertAuthSettings));
1461   EXPECT\_CALL(*authManager, createAuthRequest(\_, \_))
1462       .WillOnce(InvokeWithoutArgs([]() \{
1463         \textcolor{keywordflow}{return} std::make\_pair(120, IOBuf::copyBuffer(\textcolor{stringliteral}{"authenticatorrequest"}));
1464       \}));
1465   EXPECT\_CALL(*codec\_, generateCertificateRequest(\_, \_, \_))
1466       .WillOnce(Return(20));
1467   \textcolor{keyword}{auto} encodedSize = httpSession\_->sendCertificateRequest(
1468       std::move(certRequestContext), std::move(extensions));
1469   EXPECT\_EQ(encodedSize, 20);
1470 
1471   EXPECT\_CALL(*codec\_, onIngressEOF());
1472   EXPECT\_CALL(mockController\_, detachSession(\_));
1473   httpSession\_->dropConnection();
1474 \}
\end{DoxyCode}


\subsection{Variable Documentation}
\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!k\+Default\+Ingress\+Settings@{k\+Default\+Ingress\+Settings}}
\index{k\+Default\+Ingress\+Settings@{k\+Default\+Ingress\+Settings}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{k\+Default\+Ingress\+Settings}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf H\+T\+T\+P\+Settings} k\+Default\+Ingress\+Settings}\label{MockCodecDownstreamTest_8cpp_a64324b20d1f8dfc93849b1cd02dc31df}
{\bfseries Initial value\+:}
\begin{DoxyCode}
\{
  \{ SettingsId::INITIAL\_WINDOW\_SIZE, 65536 \}
\}
\end{DoxyCode}


Definition at line 42 of file Mock\+Codec\+Downstream\+Test.\+cpp.



Referenced by proxygen\+::make\+Mock\+Parallel\+Codec(), and Mock\+Codec\+Downstream\+Test\+::\+Mock\+Codec\+Downstream\+Test().

\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!k\+Egress\+Cert\+Auth\+Settings@{k\+Egress\+Cert\+Auth\+Settings}}
\index{k\+Egress\+Cert\+Auth\+Settings@{k\+Egress\+Cert\+Auth\+Settings}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{k\+Egress\+Cert\+Auth\+Settings}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Settings} k\+Egress\+Cert\+Auth\+Settings}\label{MockCodecDownstreamTest_8cpp_a5a20137773697ef5dce49c6248873f6c}
{\bfseries Initial value\+:}
\begin{DoxyCode}
\{
  \{ SettingsId::SETTINGS\_HTTP\_CERT\_AUTH, 128\}
\}
\end{DoxyCode}


Definition at line 48 of file Mock\+Codec\+Downstream\+Test.\+cpp.



Referenced by T\+E\+S\+T\+\_\+\+F().

\index{Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}!k\+Ingress\+Cert\+Auth\+Settings@{k\+Ingress\+Cert\+Auth\+Settings}}
\index{k\+Ingress\+Cert\+Auth\+Settings@{k\+Ingress\+Cert\+Auth\+Settings}!Mock\+Codec\+Downstream\+Test.\+cpp@{Mock\+Codec\+Downstream\+Test.\+cpp}}
\subsubsection[{k\+Ingress\+Cert\+Auth\+Settings}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf H\+T\+T\+P\+Settings} k\+Ingress\+Cert\+Auth\+Settings}\label{MockCodecDownstreamTest_8cpp_a4b280fc87dc15de3c2c3846e575271ce}
{\bfseries Initial value\+:}
\begin{DoxyCode}
\{
  \{ SettingsId::SETTINGS\_HTTP\_CERT\_AUTH, 128\}
\}
\end{DoxyCode}


Definition at line 45 of file Mock\+Codec\+Downstream\+Test.\+cpp.



Referenced by T\+E\+S\+T\+\_\+\+F().

