\section{proxygen/lib/http/codec/compress/test/\+Q\+P\+A\+C\+K\+Codec\+Tests.cpp File Reference}
\label{QPACKCodecTests_8cpp}\index{proxygen/lib/http/codec/compress/test/\+Q\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{proxygen/lib/http/codec/compress/test/\+Q\+P\+A\+C\+K\+Codec\+Tests.\+cpp}}
{\ttfamily \#include $<$folly/\+Range.\+h$>$}\\*
{\ttfamily \#include $<$folly/io/\+Cursor.\+h$>$}\\*
{\ttfamily \#include $<$folly/io/\+I\+O\+Buf.\+h$>$}\\*
{\ttfamily \#include $<$glog/logging.\+h$>$}\\*
{\ttfamily \#include $<$folly/portability/\+G\+Test.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/compress/\+Header.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/compress/\+Header\+Codec.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/compress/\+Q\+P\+A\+C\+K\+Codec.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/compress/test/\+Test\+Streaming\+Callback.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/compress/test/\+Test\+Util.\+h$>$}\\*
{\ttfamily \#include $<$vector$>$}\\*
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class {\bf Q\+P\+A\+C\+K\+Tests}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Q\+P\+A\+C\+K\+Tests}, Test\+Simple)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Q\+P\+A\+C\+K\+Tests}, Test\+Absolute\+Index)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Q\+P\+A\+C\+K\+Tests}, Test\+With\+Queue)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Q\+P\+A\+C\+K\+Tests}, Header\+Codec\+Stats)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{Q\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Codec\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Q\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Codec\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Q\+P\+A\+C\+K\+Tests, Test\+Simple)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Q\+P\+A\+C\+K\+Tests}}]{, }
\item[{Test\+Simple}]{}
\end{DoxyParamCaption}
)}\label{QPACKCodecTests_8cpp_a3df23ea96403b5fefae40323c801c99b}


Definition at line 64 of file Q\+P\+A\+C\+K\+Codec\+Tests.\+cpp.



References proxygen\+::hpack\+::basic\+Headers().


\begin{DoxyCode}
64                                \{
65   vector<Header> req = basicHeaders();
66   \textcolor{keyword}{auto} encodeResult = client.encode(req, 1);
67   ASSERT\_NE(encodeResult.control.get(), \textcolor{keyword}{nullptr});
68   EXPECT\_EQ(server.decodeEncoderStream(std::move(encodeResult.control)),
69             HPACK::DecodeError::NONE);
70   TestStreamingCallback cb;
71   \textcolor{keyword}{auto} length = encodeResult.stream->computeChainDataLength();
72   server.decodeStreaming(1, std::move(encodeResult.stream), length, &cb);
73   headerAck(1);
74   \textcolor{keyword}{auto} result = cb.getResult();
75   EXPECT\_TRUE(!result.hasError());
76   headersEq(req, result->headers);
77 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Codec\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Q\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Codec\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Q\+P\+A\+C\+K\+Tests, Test\+Absolute\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Q\+P\+A\+C\+K\+Tests}}]{, }
\item[{Test\+Absolute\+Index}]{}
\end{DoxyParamCaption}
)}\label{QPACKCodecTests_8cpp_a8d2bd49f0ed7e3f8faea252f230f620f}


Definition at line 79 of file Q\+P\+A\+C\+K\+Codec\+Tests.\+cpp.



References proxygen\+::hpack\+::headers\+From\+Array().


\begin{DoxyCode}
79                                       \{
80   \textcolor{keywordtype}{int} flights = 10;
81   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < flights; i++) \{
82     vector<vector<string>> headers;
83     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < 32; j++) \{
84       \textcolor{keywordtype}{int} value = (i >> 1) * 32 + j; \textcolor{comment}{// duplicate the last flight}
85       headers.emplace\_back(
86         vector<string>(\{string(\textcolor{stringliteral}{"foomonkey"}), folly::to<string>(value)\}));
87     \}
88     \textcolor{keyword}{auto} req = headersFromArray(headers);
89     \textcolor{keyword}{auto} encodeResult = client.encode(req, i + 1);
90     \textcolor{keywordflow}{if} (i % 2 == 1) \{
91       EXPECT\_EQ(encodeResult.control.get(), \textcolor{keyword}{nullptr});
92     \} \textcolor{keywordflow}{else} \{
93       ASSERT\_NE(encodeResult.control.get(), \textcolor{keyword}{nullptr});
94       CHECK\_EQ(server.decodeEncoderStream(std::move(encodeResult.control)),
95                HPACK::DecodeError::NONE);
96     \}
97     TestStreamingCallback cb;
98     \textcolor{keyword}{auto} length = encodeResult.stream->computeChainDataLength();
99     server.decodeStreaming(i + 1, std::move(encodeResult.stream), length, &cb);
100     headerAck(i + 1);
101     \textcolor{keyword}{auto} result = cb.getResult();
102     EXPECT\_TRUE(!result.hasError());
103     headersEq(req, result->headers);
104   \}
105 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Codec\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Q\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Codec\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Q\+P\+A\+C\+K\+Tests, Test\+With\+Queue)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Q\+P\+A\+C\+K\+Tests}}]{, }
\item[{Test\+With\+Queue}]{}
\end{DoxyParamCaption}
)}\label{QPACKCodecTests_8cpp_acb34b1e1602257771f209668017549ee}


Definition at line 107 of file Q\+P\+A\+C\+K\+Codec\+Tests.\+cpp.



References proxygen\+::hpack\+::basic\+Headers().


\begin{DoxyCode}
107                                   \{
108   \textcolor{comment}{// Sends 10 flights of 4 requests each}
109   \textcolor{comment}{// Each request contains two 'connection' headers, one with the current}
110   \textcolor{comment}{// index, and current index - 8.}
111   \textcolor{comment}{// Each flight is processed in the order 0, 3, 2, 1, unless an eviction}
112   \textcolor{comment}{// happens on 2 or 3, in which case we force an blocking event.}
113   vector<Header> req = basicHeaders();
114   vector<string> values;
115   \textcolor{keywordtype}{int} flights = 10;
116   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = 0; i < flights * 4; i++) \{
117     values.push\_back(folly::to<string>(i));
118   \}
119   client.setEncoderHeaderTableSize(1024);
120   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} f = 0; f < flights; f++) \{
121     vector<std::pair<unique\_ptr<IOBuf>, TestStreamingCallback>> data;
122     list<unique\_ptr<IOBuf>> controlFrames;
123     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 4; i++) \{
124       \textcolor{keyword}{auto} reqI = req;
125       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < 2; j++) \{
126         reqI.emplace\_back(HTTP\_HEADER\_CONNECTION, values[
127                             std::max(f * 4 + i - j * 8, 0)]);
128       \}
129       VLOG(4) << \textcolor{stringliteral}{"Encoding req="} << f * 4 + i;
130       \textcolor{keyword}{auto} res = client.encode(reqI, f * 4 + i);
131       \textcolor{keywordflow}{if} (res.control && res.control->computeChainDataLength() > 0) \{
132         controlFrames.emplace\_back(std::move(res.control));
133       \}
134       data.emplace\_back(std::move(res.stream), TestStreamingCallback());
135     \}
136 
137     std::vector<int> insertOrder\{0, 3, 2, 1\};
138     \textcolor{keywordflow}{if} (!controlFrames.empty()) \{
139       \textcolor{keyword}{auto} control = std::move(controlFrames.front());
140       controlFrames.pop\_front();
141       server.decodeEncoderStream(std::move(control));
142     \}
143     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i: insertOrder) \{
144       \textcolor{keyword}{auto}& encodedReq = data[i].first;
145       \textcolor{keyword}{auto} len = encodedReq->computeChainDataLength();
146       server.decodeStreaming(i, std::move(encodedReq), len, &data[i].second);
147     \}
148     \textcolor{keywordflow}{while} (!controlFrames.empty()) \{
149       \textcolor{keyword}{auto} control = std::move(controlFrames.front());
150       controlFrames.pop\_front();
151       server.decodeEncoderStream(std::move(control));
152     \}
153     \textcolor{keywordtype}{int} i = 0;
154     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}& d: data) \{
155       \textcolor{keyword}{auto} result = d.second.getResult();
156       EXPECT\_TRUE(!result.hasError());
157       \textcolor{keyword}{auto} reqI = req;
158       \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} j = 0; j < 2; j++) \{
159         reqI.emplace\_back(HTTP\_HEADER\_CONNECTION,
160                           values[std::max(f * 4 + i - j * 8, 0)]);
161       \}
162       headersEq(reqI, result->headers);
163       headerAck(f * 4 + i);
164       i++;
165     \}
166     VLOG(4) << \textcolor{stringliteral}{"getHolBlockCount="} << server.getHolBlockCount();
167   \}
168   \textcolor{comment}{// Skipping redundant table adds reduces the HOL block count}
169   EXPECT\_EQ(server.getHolBlockCount(), 30);
170 
171 \}
\end{DoxyCode}
\index{Q\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Codec\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Q\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{Q\+P\+A\+C\+K\+Codec\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Q\+P\+A\+C\+K\+Tests, Header\+Codec\+Stats)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Q\+P\+A\+C\+K\+Tests}}]{, }
\item[{Header\+Codec\+Stats}]{}
\end{DoxyParamCaption}
)}\label{QPACKCodecTests_8cpp_afa0decba406d478efc982a52d629e035}


Definition at line 173 of file Q\+P\+A\+C\+K\+Codec\+Tests.\+cpp.



References proxygen\+::hpack\+::\+Test\+Header\+Codec\+Stats\+::decoded\+Bytes\+Compr, proxygen\+::hpack\+::\+Test\+Header\+Codec\+Stats\+::decoded\+Bytes\+Uncompr, proxygen\+::hpack\+::\+Test\+Header\+Codec\+Stats\+::decodes, proxygen\+::hpack\+::\+Test\+Header\+Codec\+Stats\+::encoded\+Bytes\+Compr, proxygen\+::hpack\+::\+Test\+Header\+Codec\+Stats\+::encoded\+Bytes\+Uncompr, proxygen\+::hpack\+::\+Test\+Header\+Codec\+Stats\+::encodes, proxygen\+::hpack\+::\+Test\+Header\+Codec\+Stats\+::errors, proxygen\+::\+Test\+Streaming\+Callback\+::get\+Result(), proxygen\+::hpack\+::headers\+From\+Array(), and proxygen\+::hpack\+::\+Test\+Header\+Codec\+Stats\+::reset().


\begin{DoxyCode}
173                                      \{
174   vector<vector<string>> headers = \{
175     \{\textcolor{stringliteral}{"Content-Length"}, \textcolor{stringliteral}{"80"}\},
176     \{\textcolor{stringliteral}{"Content-Encoding"}, \textcolor{stringliteral}{"gzip"}\},
177     \{\textcolor{stringliteral}{"X-FB-Debug"}, \textcolor{stringliteral}{"eirtijvdgtccffkutnbttcgbfieghgev"}\}
178   \};
179   vector<Header> resp = headersFromArray(headers);
180 
181   TestHeaderCodecStats stats(HeaderCodec::Type::QPACK);
182   \textcolor{comment}{// encode}
183   server.setStats(&stats);
184   \textcolor{keyword}{auto} encResult = server.encode(resp, 1);
185   EXPECT\_EQ(stats.encodes, 1);
186   EXPECT\_EQ(stats.decodes, 0);
187   EXPECT\_EQ(stats.errors, 0);
188   EXPECT\_TRUE(stats.encodedBytesCompr > 0);
189   EXPECT\_TRUE(stats.encodedBytesUncompr > 0);
190   EXPECT\_EQ(stats.decodedBytesCompr, 0);
191   EXPECT\_EQ(stats.decodedBytesUncompr, 0);
192   server.setStats(\textcolor{keyword}{nullptr});
193 
194   \textcolor{comment}{// decode}
195   stats.reset();
196   client.setStats(&stats);
197   TestStreamingCallback cb;
198   \textcolor{keyword}{auto} len = encResult.stream->computeChainDataLength();
199   client.decodeEncoderStream(std::move(encResult.control));
200   client.decodeStreaming(1, std::move(encResult.stream), len, &cb);
201   \textcolor{keyword}{auto} result = cb.getResult();
202   EXPECT\_TRUE(!result.hasError());
203   \textcolor{keyword}{auto}& decoded = result->headers;
204   CHECK\_EQ(decoded.size(), 3 * 2);
205   EXPECT\_EQ(stats.decodes, 1);
206   EXPECT\_EQ(stats.encodes, 0);
207   EXPECT\_GT(stats.decodedBytesCompr, 0);
208   EXPECT\_GT(stats.decodedBytesUncompr, 0);
209   EXPECT\_EQ(stats.encodedBytesCompr, 0);
210   EXPECT\_EQ(stats.encodedBytesUncompr, 0);
211   client.setStats(\textcolor{keyword}{nullptr});
212 \}
\end{DoxyCode}
