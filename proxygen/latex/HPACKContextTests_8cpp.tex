\section{proxygen/lib/http/codec/compress/test/\+H\+P\+A\+C\+K\+Context\+Tests.cpp File Reference}
\label{HPACKContextTests_8cpp}\index{proxygen/lib/http/codec/compress/test/\+H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{proxygen/lib/http/codec/compress/test/\+H\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
{\ttfamily \#include $<$folly/\+Conv.\+h$>$}\\*
{\ttfamily \#include $<$glog/logging.\+h$>$}\\*
{\ttfamily \#include $<$folly/portability/\+G\+Test.\+h$>$}\\*
{\ttfamily \#include $<$memory$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/compress/\+H\+P\+A\+C\+K\+Context.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/compress/\+H\+P\+A\+C\+K\+Decoder.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/compress/\+H\+P\+A\+C\+K\+Encoder.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/compress/\+Q\+P\+A\+C\+K\+Decoder.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/compress/\+Q\+P\+A\+C\+K\+Encoder.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/compress/\+Logging.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/compress/test/\+Test\+Util.\+h$>$}\\*
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class {\bf H\+P\+A\+C\+K\+Context\+Tests}
\item 
class {\bf Test\+Context}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Context\+Tests}, Get\+Index)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Context\+Tests}, Is\+Static)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Context\+Tests}, Static\+Table)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Context\+Tests}, Static\+Table\+Header\+Names\+Are\+Common)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Context\+Tests}, static\+\_\+table\+\_\+is\+\_\+header\+\_\+code\+\_\+in\+\_\+table\+\_\+with\+\_\+non\+\_\+empty\+\_\+value)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Context\+Tests}, Static\+Index)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Context\+Tests}, Encoder\+Multiple\+Values)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Context\+Tests}, Decoder\+Large\+Header)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Context\+Tests}, Decoder\+Invalid\+Peek)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Context\+Tests}, Decoder\+Invalid\+Literal\+Peek)
\item 
void {\bf check\+Error} (const I\+O\+Buf $\ast$buf, const {\bf H\+P\+A\+C\+K\+::\+Decode\+Error} err)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Context\+Tests}, Decode\+Errors)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Context\+Tests}, Exclude\+Headers\+Larger\+Than\+Table)
\item 
{\bf T\+E\+S\+T\+\_\+P} ({\bf H\+P\+A\+C\+K\+Context\+Tests}, Context\+Update)
\item 
{\bf I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P} (Context, {\bf H\+P\+A\+C\+K\+Context\+Tests},\+::testing\+::\+Values(true, false))
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}!check\+Error@{check\+Error}}
\index{check\+Error@{check\+Error}!H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{check\+Error(const I\+O\+Buf $\ast$buf, const H\+P\+A\+C\+K\+::\+Decode\+Error err)}]{\setlength{\rightskip}{0pt plus 5cm}void check\+Error (
\begin{DoxyParamCaption}
\item[{const I\+O\+Buf $\ast$}]{buf, }
\item[{const {\bf H\+P\+A\+C\+K\+::\+Decode\+Error}}]{err}
\end{DoxyParamCaption}
)}\label{HPACKContextTests_8cpp_a3c6c5a80af6ad3c485c7d8458b2c083f}
testing various error cases in H\+P\+A\+C\+K\+Decoder\+::decode\+Liter\+Header() 

Definition at line 187 of file H\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::hpack\+::decode(), proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+Base\+::get\+Error(), and proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+Base\+::has\+Error().



Referenced by T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
187                                                               \{
188   HPACKDecoder decoder;
189   \textcolor{keyword}{auto} decoded = proxygen::hpack::decode(decoder, buf);
190   EXPECT\_TRUE(decoder.hasError());
191   EXPECT\_EQ(decoder.getError(), err);
192 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}!I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P@{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P}}
\index{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P@{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P}!H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+P(\+Context, H\+P\+A\+C\+K\+Context\+Tests,\+::testing\+::\+Values(true, false))}]{\setlength{\rightskip}{0pt plus 5cm}I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P (
\begin{DoxyParamCaption}
\item[{Context}]{, }
\item[{{\bf H\+P\+A\+C\+K\+Context\+Tests}}]{, }
\item[{\+::testing\+::\+Values(true, false)}]{}
\end{DoxyParamCaption}
)}\label{HPACKContextTests_8cpp_aa86f5919b45186af46e181fdf17b71d8}


Referenced by T\+E\+S\+T\+\_\+\+P().

\index{H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Context\+Tests, Get\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Context\+Tests}}]{, }
\item[{Get\+Index}]{}
\end{DoxyParamCaption}
)}\label{HPACKContextTests_8cpp_a4ba3e0a2201235324755e76c78717ae0}


Definition at line 41 of file H\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Context\+::get\+Index(), and proxygen\+::\+H\+P\+A\+C\+K\+::k\+Table\+Size.


\begin{DoxyCode}
41                                     \{
42   HPACKContext context(HPACK::kTableSize);
43   HPACKHeader method(\textcolor{stringliteral}{":method"}, \textcolor{stringliteral}{"POST"});
44 
45   \textcolor{comment}{// this will get it from the static table}
46   CHECK\_EQ(context.getIndex(method), 3);
47 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Context\+Tests, Is\+Static)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Context\+Tests}}]{, }
\item[{Is\+Static}]{}
\end{DoxyParamCaption}
)}\label{HPACKContextTests_8cpp_aedb3d9272d3e7e2b977735f903a5de77}


Definition at line 49 of file H\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References Test\+Context\+::add(), proxygen\+::\+H\+P\+A\+C\+K\+Context\+::get\+Table(), proxygen\+::\+H\+P\+A\+C\+K\+Context\+::is\+Static(), proxygen\+::\+H\+P\+A\+C\+K\+::k\+Table\+Size, and proxygen\+::\+Header\+Table\+::size().


\begin{DoxyCode}
49                                     \{
50   TestContext context(HPACK::kTableSize);
51   \textcolor{comment}{// add 10 headers to the table}
52   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 1; i <= 10; i++) \{
53     HPACKHeader header(\textcolor{stringliteral}{"name"} + folly::to<string>(i),
54                       \textcolor{stringliteral}{"value"} + folly::to<string>(i));
55     context.add(std::move(header));
56   \}
57   EXPECT\_EQ(context.getTable().size(), 10);
58 
59 
60   EXPECT\_EQ(context.isStatic(1), \textcolor{keyword}{true});
61   EXPECT\_EQ(context.isStatic(10), \textcolor{keyword}{true});
62   EXPECT\_EQ(context.isStatic(40), \textcolor{keyword}{true});
63   EXPECT\_EQ(context.isStatic(60), \textcolor{keyword}{true});
64   EXPECT\_EQ(context.isStatic(69), \textcolor{keyword}{false});
65 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Context\+Tests, Static\+Table)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Context\+Tests}}]{, }
\item[{Static\+Table}]{}
\end{DoxyParamCaption}
)}\label{HPACKContextTests_8cpp_a689776686f8375c955c44d941cbc7f66}


Definition at line 67 of file H\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Header\+Name\+::get(), and proxygen\+::\+H\+P\+A\+C\+K\+Header\+::name.


\begin{DoxyCode}
67                                        \{
68   \textcolor{keyword}{auto}& table = StaticHeaderTable::get();
69   \textcolor{keyword}{const} HPACKHeader& first = table.getHeader(1);
70   \textcolor{keyword}{const} HPACKHeader& methodPost = table.getHeader(3);
71   \textcolor{keyword}{const} HPACKHeader& last = table.getHeader(table.size());
72 
73   \textcolor{comment}{// there are 61 entries in the spec}
74   CHECK\_EQ(table.size(), 61);
75   CHECK\_EQ(methodPost, HPACKHeader(\textcolor{stringliteral}{":method"}, \textcolor{stringliteral}{"POST"}));
76   CHECK\_EQ(first.name.get(), \textcolor{stringliteral}{":authority"});
77   CHECK\_EQ(last.name.get(), \textcolor{stringliteral}{"www-authenticate"});
78 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Context\+Tests, Static\+Table\+Header\+Names\+Are\+Common)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Context\+Tests}}]{, }
\item[{Static\+Table\+Header\+Names\+Are\+Common}]{}
\end{DoxyParamCaption}
)}\label{HPACKContextTests_8cpp_a0acdcd417751a0e00ebc9139a4673e77}


Definition at line 80 of file H\+P\+A\+C\+K\+Context\+Tests.\+cpp.


\begin{DoxyCode}
80                                                            \{
81   \textcolor{keyword}{auto}& table = StaticHeaderTable::get();
82   \textcolor{keywordflow}{for} (std::pair<HPACKHeaderName, std::list<uint32\_t>> entry : table.names()) \{
83     EXPECT\_TRUE(entry.first.isCommonHeader());
84   \}
85 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Context\+Tests, static\+\_\+table\+\_\+is\+\_\+header\+\_\+code\+\_\+in\+\_\+table\+\_\+with\+\_\+non\+\_\+empty\+\_\+value)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Context\+Tests}}]{, }
\item[{static\+\_\+table\+\_\+is\+\_\+header\+\_\+code\+\_\+in\+\_\+table\+\_\+with\+\_\+non\+\_\+empty\+\_\+value}]{}
\end{DoxyParamCaption}
)}\label{HPACKContextTests_8cpp_a865dad833ee557339e23da90a3b10da5}


Definition at line 87 of file H\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Header\+Name\+::get\+Header\+Code(), proxygen\+::\+H\+P\+A\+C\+K\+Header\+::name, and proxygen\+::\+H\+P\+A\+C\+K\+Header\+::value.


\begin{DoxyCode}
88                                                                   \{
89   \textcolor{keyword}{auto}& table = StaticHeaderTable::get();
90   \textcolor{keywordflow}{for} (uint32\_t i = 1; i <= table.size(); ++i) \{
91     \textcolor{keyword}{const} HPACKHeader& staticTableHeader = table.getHeader(i);
92     EXPECT\_TRUE(
93       staticTableHeader.value.empty() !=
94       StaticHeaderTable::isHeaderCodeInTableWithNonEmptyValue(
95         staticTableHeader.name.getHeaderCode()));
96   \}
97 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Context\+Tests, Static\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Context\+Tests}}]{, }
\item[{Static\+Index}]{}
\end{DoxyParamCaption}
)}\label{HPACKContextTests_8cpp_a6a71ca42796a7babf20b72110f627533}


Definition at line 99 of file H\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Context\+::get\+Header(), and proxygen\+::\+H\+P\+A\+C\+K\+::k\+Table\+Size.


\begin{DoxyCode}
99                                        \{
100   TestContext context(HPACK::kTableSize);
101   HPACKHeader authority(\textcolor{stringliteral}{":authority"}, \textcolor{stringliteral}{""});
102   EXPECT\_EQ(context.getHeader(1), authority);
103 
104   HPACKHeader post(\textcolor{stringliteral}{":method"}, \textcolor{stringliteral}{"POST"});
105   EXPECT\_EQ(context.getHeader(3), post);
106 
107   HPACKHeader contentLength(\textcolor{stringliteral}{"content-length"}, \textcolor{stringliteral}{""});
108   EXPECT\_EQ(context.getHeader(28), contentLength);
109 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Context\+Tests, Encoder\+Multiple\+Values)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Context\+Tests}}]{, }
\item[{Encoder\+Multiple\+Values}]{}
\end{DoxyParamCaption}
)}\label{HPACKContextTests_8cpp_a5cc8d275c00fdb9cf118bc29df261af3}


Definition at line 111 of file H\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Encoder\+::encode(), proxygen\+::\+H\+P\+A\+C\+K\+Context\+::get\+Table(), and proxygen\+::\+Header\+Table\+::size().


\begin{DoxyCode}
111                                                  \{
112   HPACKEncoder encoder(\textcolor{keyword}{true});
113   vector<HPACKHeader> req;
114   req.push\_back(HPACKHeader(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"gzip"}));
115   req.push\_back(HPACKHeader(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"sdch,gzip"}));
116   unique\_ptr<IOBuf> encoded = encoder.encode(req);
117   EXPECT\_TRUE(encoded->length() > 0);
118   EXPECT\_EQ(encoder.getTable().size(), 2);
119   \textcolor{comment}{// sending the same request again should lead to a smaller but non}
120   \textcolor{comment}{// empty buffer}
121   unique\_ptr<IOBuf> encoded2 = encoder.encode(req);
122   EXPECT\_LT(encoded2->computeChainDataLength(),
123             encoded->computeChainDataLength());
124   EXPECT\_GT(encoded2->computeChainDataLength(), 0);
125 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Context\+Tests, Decoder\+Large\+Header)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Context\+Tests}}]{, }
\item[{Decoder\+Large\+Header}]{}
\end{DoxyParamCaption}
)}\label{HPACKContextTests_8cpp_abd95cece86eb1e5de89115c81ea13057}


Definition at line 127 of file H\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::hpack\+::decode(), proxygen\+::\+H\+P\+A\+C\+K\+Encoder\+::encode(), proxygen\+::\+H\+P\+A\+C\+K\+Context\+::get\+Table(), and proxygen\+::\+Header\+Table\+::size().


\begin{DoxyCode}
127                                               \{
128   \textcolor{comment}{// with this size basically the table will not be able to store any entry}
129   uint32\_t size = 32;
130   HPACKHeader header;
131   HPACKEncoder encoder(\textcolor{keyword}{true}, size);
132   HPACKDecoder decoder(size);
133   vector<HPACKHeader> headers;
134   headers.push\_back(HPACKHeader(\textcolor{stringliteral}{":path"}, \textcolor{stringliteral}{"verylargeheader"}));
135   \textcolor{comment}{// add a static entry}
136   headers.push\_back(HPACKHeader(\textcolor{stringliteral}{":method"}, \textcolor{stringliteral}{"GET"}));
137   \textcolor{keyword}{auto} buf = encoder.encode(headers);
138   \textcolor{keyword}{auto} decoded = proxygen::hpack::decode(decoder, buf.get());
139   EXPECT\_EQ(encoder.getTable().size(), 0);
140   EXPECT\_EQ(decoder.getTable().size(), 0);
141 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Context\+Tests, Decoder\+Invalid\+Peek)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Context\+Tests}}]{, }
\item[{Decoder\+Invalid\+Peek}]{}
\end{DoxyParamCaption}
)}\label{HPACKContextTests_8cpp_a4cef56d3d0ddf77145e76b843b629ff4}
testing invalid memory access in the decoder; it has to always call peek() 

Definition at line 146 of file H\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+::\+Instruction\+::code, proxygen\+::hpack\+::decode(), proxygen\+::\+H\+P\+A\+C\+K\+Encoder\+::encode(), proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+Base\+::has\+Error(), and proxygen\+::\+H\+P\+A\+C\+K\+::\+I\+N\+D\+E\+X\+\_\+\+R\+EF.


\begin{DoxyCode}
146                                               \{
147   HPACKEncoder encoder(\textcolor{keyword}{true});
148   HPACKDecoder decoder;
149   vector<HPACKHeader> headers;
150   headers.push\_back(HPACKHeader(\textcolor{stringliteral}{"x-fb-debug"}, \textcolor{stringliteral}{"test"}));
151 
152   unique\_ptr<IOBuf> encoded = encoder.encode(headers);
153   unique\_ptr<IOBuf> first = IOBuf::create(128);
154   \textcolor{comment}{// set a trap for indexed header and don't call append}
155   first->writableData()[0] = HPACK::INDEX_REF.code;
156 
157   first->appendChain(std::move(encoded));
158   \textcolor{keyword}{auto} decoded = proxygen::hpack::decode(decoder, first.get());
159 
160   EXPECT\_FALSE(decoder.hasError());
161   EXPECT\_EQ(*decoded, headers);
162 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Context\+Tests, Decoder\+Invalid\+Literal\+Peek)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Context\+Tests}}]{, }
\item[{Decoder\+Invalid\+Literal\+Peek}]{}
\end{DoxyParamCaption}
)}\label{HPACKContextTests_8cpp_abe64454152b368f9524304cd98c1636a}
similar with the one above, but slightly different code paths 

Definition at line 167 of file H\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::hpack\+::decode(), proxygen\+::\+H\+P\+A\+C\+K\+Encoder\+::encode(), and proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+Base\+::has\+Error().


\begin{DoxyCode}
167                                                      \{
168   HPACKEncoder encoder(\textcolor{keyword}{true});
169   HPACKDecoder decoder;
170   vector<HPACKHeader> headers;
171   headers.push\_back(HPACKHeader(\textcolor{stringliteral}{"x-fb-random"}, \textcolor{stringliteral}{"bla"}));
172   unique\_ptr<IOBuf> encoded = encoder.encode(headers);
173 
174   unique\_ptr<IOBuf> first = IOBuf::create(128);
175   first->writableData()[0] = 0x3F;
176 
177   first->appendChain(std::move(encoded));
178   \textcolor{keyword}{auto} decoded = proxygen::hpack::decode(decoder, first.get());
179 
180   EXPECT\_FALSE(decoder.hasError());
181   EXPECT\_EQ(*decoded, headers);
182 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Context\+Tests, Decode\+Errors)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Context\+Tests}}]{, }
\item[{Decode\+Errors}]{}
\end{DoxyParamCaption}
)}\label{HPACKContextTests_8cpp_af42beaab6150ceff5c82eb7509727a78}


Definition at line 194 of file H\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References check\+Error().


\begin{DoxyCode}
194                                         \{
195   unique\_ptr<IOBuf> buf = IOBuf::create(128);
196 
197   \textcolor{comment}{// 1. simulate an error decoding the index for an indexed header name}
198   \textcolor{comment}{// we try to encode index 65}
199   buf->writableData()[0] = 0x3F;
200   buf->append(1);  \textcolor{comment}{// intentionally omit the second byte}
201   checkError(buf.get(), HPACK::DecodeError::BUFFER\_UNDERFLOW);
202 
203   \textcolor{comment}{// 2. invalid index for indexed header name}
204   buf->writableData()[0] = 0x7F;
205   buf->writableData()[1] = 0xFF;
206   buf->writableData()[2] = 0x7F;
207   buf->append(2);
208   checkError(buf.get(), HPACK::DecodeError::INVALID\_INDEX);
209 
210   \textcolor{comment}{// 2a. invalid integer for indexed header name}
211   buf->writableData()[0] = 0x7F;
212   buf->writableData()[1] = 0xFF;
213   buf->writableData()[2] = 0xFF;
214   checkError(buf.get(), HPACK::DecodeError::BUFFER\_UNDERFLOW);
215 
216   \textcolor{comment}{// 3. buffer overflow when decoding literal header name}
217   buf->writableData()[0] = 0x00;  \textcolor{comment}{// this will activate the non-indexed branch}
218   checkError(buf.get(), HPACK::DecodeError::BUFFER\_UNDERFLOW);
219 
220   \textcolor{comment}{// 4. buffer overflow when decoding a header value}
221   \textcolor{comment}{// size for header name size and the actual header name}
222   buf->writableData()[1] = 0x01;
223   buf->writableData()[2] = \textcolor{charliteral}{'h'};
224   checkError(buf.get(), HPACK::DecodeError::BUFFER\_UNDERFLOW);
225 
226   \textcolor{comment}{// 5. buffer overflow decoding the index of an indexed header}
227   buf->writableData()[0] = 0xFF; \textcolor{comment}{// first bit is 1 to mark indexed header}
228   buf->writableData()[1] = 0x80; \textcolor{comment}{// first bit is 1 to continue the}
229                                  \textcolor{comment}{// variable-length encoding}
230   buf->writableData()[2] = 0x80;
231   checkError(buf.get(), HPACK::DecodeError::BUFFER\_UNDERFLOW);
232 
233   \textcolor{comment}{// 6. Increase the table size}
234   buf->writableData()[0] = 0x3F;
235   buf->writableData()[1] = 0xFF;
236   buf->writableData()[2] = 0x7F;
237   checkError(buf.get(), HPACK::DecodeError::INVALID\_TABLE\_SIZE);
238 
239   \textcolor{comment}{// 7. integer overflow decoding the index of an indexed header}
240   buf->writableData()[0] = 0xFF; \textcolor{comment}{// first bit is 1 to mark indexed header}
241   buf->writableData()[1] = 0xFF;
242   buf->writableData()[2] = 0xFF;
243   buf->writableData()[3] = 0xFF;
244   buf->writableData()[4] = 0xFF;
245   buf->writableData()[5] = 0xFF;
246   buf->writableData()[6] = 0xFF;
247   buf->writableData()[7] = 0xFF;
248   buf->writableData()[8] = 0xFF;
249   buf->writableData()[9] = 0xFF;
250   buf->writableData()[10] = 0x7F;
251   buf->append(8);
252   checkError(buf.get(), HPACK::DecodeError::INTEGER\_OVERFLOW);
253 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Context\+Tests, Exclude\+Headers\+Larger\+Than\+Table)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Context\+Tests}}]{, }
\item[{Exclude\+Headers\+Larger\+Than\+Table}]{}
\end{DoxyParamCaption}
)}\label{HPACKContextTests_8cpp_a05dcf9f81b0ea745c607fbc3e0246077}


Definition at line 255 of file H\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Header\+::bytes().


\begin{DoxyCode}
255                                                          \{
256   HPACKEncoder encoder\{\textcolor{keyword}{true}, 128\};
257   std::string longer = std::string(150, \textcolor{charliteral}{'.'});
258   HPACKHeader header1(longer, \textcolor{stringliteral}{"header"});
259   HPACKHeader header2(\textcolor{stringliteral}{"Short"}, \textcolor{stringliteral}{"header"});
260 
261   CHECK\_GT(header1.bytes(), 128);
262   CHECK\_LT(header2.bytes(), 128);
263 
264   vector<HPACKHeader> headers;
265   headers.push\_back(std::move(header2));
266   headers.push\_back(std::move(header1));
267 
268   encoder.encode(headers);
269 
270   CHECK\_EQ(encoder.getIndex(headers[1]), 0);
271   CHECK\_EQ(encoder.getIndex(headers[0]), 62);
272 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}!T\+E\+S\+T\+\_\+P@{T\+E\+S\+T\+\_\+P}}
\index{T\+E\+S\+T\+\_\+P@{T\+E\+S\+T\+\_\+P}!H\+P\+A\+C\+K\+Context\+Tests.\+cpp@{H\+P\+A\+C\+K\+Context\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+P(\+H\+P\+A\+C\+K\+Context\+Tests, Context\+Update)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+P (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Context\+Tests}}]{, }
\item[{Context\+Update}]{}
\end{DoxyParamCaption}
)}\label{HPACKContextTests_8cpp_a1ce604fadec6b9c1a3cc1180837b3dad}


Definition at line 274 of file H\+P\+A\+C\+K\+Context\+Tests.\+cpp.



References proxygen\+::hpack\+::decode(), proxygen\+::\+H\+P\+A\+C\+K\+Encoder\+::encode(), proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+Base\+::get\+Error(), proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+Base\+::has\+Error(), I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+P(), proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+::set\+Header\+Table\+Max\+Size(), and proxygen\+::\+H\+P\+A\+C\+K\+Encoder\+::set\+Header\+Table\+Size().


\begin{DoxyCode}
274                                          \{
275   HPACKEncoder encoder(\textcolor{keyword}{true});
276   HPACKDecoder decoder;
277   vector<HPACKHeader> headers;
278   \textcolor{keywordtype}{bool} setDecoderSize = GetParam();
279   encoder.setHeaderTableSize(8192);
280   \textcolor{keywordflow}{if} (setDecoderSize) \{
281     decoder.setHeaderTableMaxSize(8192);
282   \}
283   headers.push\_back(HPACKHeader(\textcolor{stringliteral}{"x-fb-random"}, \textcolor{stringliteral}{"bla"}));
284   unique\_ptr<IOBuf> encoded = encoder.encode(headers);
285 
286   unique\_ptr<IOBuf> first = IOBuf::create(128);
287 
288   first->appendChain(std::move(encoded));
289   \textcolor{keyword}{auto} decoded = proxygen::hpack::decode(decoder, first.get());
290 
291 
292   EXPECT\_EQ(decoder.hasError(), !setDecoderSize);
293   \textcolor{keywordflow}{if} (setDecoderSize) \{
294     EXPECT\_EQ(*decoded, headers);
295   \} \textcolor{keywordflow}{else} \{
296     EXPECT\_EQ(decoder.getError(), HPACK::DecodeError::INVALID\_TABLE\_SIZE);
297   \}
298 \}
\end{DoxyCode}
