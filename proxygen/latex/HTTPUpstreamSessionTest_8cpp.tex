\section{proxygen/lib/http/session/test/\+H\+T\+T\+P\+Upstream\+Session\+Test.cpp File Reference}
\label{HTTPUpstreamSessionTest_8cpp}\index{proxygen/lib/http/session/test/\+H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{proxygen/lib/http/session/test/\+H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
{\ttfamily \#include $<$folly/io/\+Cursor.\+h$>$}\\*
{\ttfamily \#include $<$folly/io/async/\+Event\+Base.\+h$>$}\\*
{\ttfamily \#include $<$folly/io/async/\+Timeout\+Manager.\+h$>$}\\*
{\ttfamily \#include $<$wangle/acceptor/\+Connection\+Manager.\+h$>$}\\*
{\ttfamily \#include $<$folly/portability/\+G\+Test.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/test/\+Mock\+H\+T\+T\+P\+Codec.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/\+H\+T\+T\+P\+Codec\+Factory.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/test/\+Test\+Utils.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/session/\+H\+T\+T\+P\+Upstream\+Session.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/session/test/\+Mock\+Byte\+Event\+Tracker.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/session/test/\+H\+T\+T\+P\+Session\+Mocks.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/session/test/\+H\+T\+T\+P\+Session\+Test.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/session/test/\+Test\+Utils.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/test/\+Test\+Async\+Transport.\+h$>$}\\*
{\ttfamily \#include $<$string$>$}\\*
{\ttfamily \#include $<$folly/io/async/test/\+Mock\+Async\+Transport.\+h$>$}\\*
{\ttfamily \#include $<$vector$>$}\\*
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class {\bf Test\+Priority\+Map\+Builder}
\item 
class {\bf Test\+Priority\+Adapter}
\item 
class {\bf H\+T\+T\+P\+Upstream\+Test$<$ C $>$}
\item 
class {\bf Timeoutable\+H\+T\+T\+P\+Upstream\+Test$<$ C $>$}
\item 
class {\bf H\+T\+T\+P2\+Upstream\+Session\+With\+Virtual\+Nodes\+Test}
\item 
class {\bf H\+T\+T\+P2\+Upstream\+Session\+With\+Priority\+Tree}
\item 
class {\bf H\+T\+T\+P\+Upstream\+Recv\+Stream\+Test}
\item 
class {\bf No\+Flush\+Upstream\+Session\+Test}
\item 
class {\bf Mock\+H\+T\+T\+P\+Upstream\+Test}
\item 
class {\bf Mock\+H\+T\+T\+P2\+Upstream\+Test}
\item 
class {\bf Test\+Abort\+Post$<$ stage $>$}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using {\bf H\+T\+T\+P\+Upstream\+Session\+Test} = {\bf H\+T\+T\+P\+Upstream\+Test}$<$ {\bf H\+T\+T\+P1x\+Codec\+Pair} $>$
\item 
using {\bf S\+P\+D\+Y3\+Upstream\+Session\+Test} = {\bf H\+T\+T\+P\+Upstream\+Test}$<$ {\bf S\+P\+D\+Y3\+Codec\+Pair} $>$
\item 
using {\bf H\+T\+T\+P2\+Upstream\+Session\+Test} = {\bf H\+T\+T\+P\+Upstream\+Test}$<$ {\bf H\+T\+T\+P2\+Codec\+Pair} $>$
\item 
using {\bf H\+T\+T\+P\+Upstream\+Timeout\+Test} = {\bf Timeoutable\+H\+T\+T\+P\+Upstream\+Test}$<$ {\bf H\+T\+T\+P1x\+Codec\+Pair} $>$
\item 
typedef {\bf Test\+Abort\+Post}$<$ 0 $>$ {\bf Test\+Abort\+Post0}
\item 
typedef {\bf Test\+Abort\+Post}$<$ 1 $>$ {\bf Test\+Abort\+Post1}
\item 
typedef {\bf Test\+Abort\+Post}$<$ 2 $>$ {\bf Test\+Abort\+Post2}
\item 
typedef {\bf Test\+Abort\+Post}$<$ 3 $>$ {\bf Test\+Abort\+Post3}
\item 
typedef {\bf Test\+Abort\+Post}$<$ 4 $>$ {\bf Test\+Abort\+Post4}
\item 
typedef {\bf Test\+Abort\+Post}$<$ 5 $>$ {\bf Test\+Abort\+Post5}
\item 
using {\bf All\+Types} = \+::testing\+::\+Types$<$ {\bf H\+T\+T\+P1x\+Codec\+Pair}, {\bf S\+P\+D\+Y3\+Codec\+Pair} $>$
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\bf T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P} ({\bf H\+T\+T\+P\+Upstream\+Test})
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf S\+P\+D\+Y3\+Upstream\+Session\+Test}, Server\+Push)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf S\+P\+D\+Y3\+Upstream\+Session\+Test}, Ingress\+Goaway\+Abort\+Uncreated\+Streams)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf S\+P\+D\+Y3\+Upstream\+Session\+Test}, Ingress\+Goaway\+Session\+Error)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf S\+P\+D\+Y3\+Upstream\+Session\+Test}, Test\+Under\+Limit\+On\+Write\+Error)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf S\+P\+D\+Y3\+Upstream\+Session\+Test}, Test\+Overlimit\+Resume)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P2\+Upstream\+Session\+Test}, Test\+Priority)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P2\+Upstream\+Session\+Test}, Test\+Settings\+Ack)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P2\+Upstream\+Session\+Test}, Test\+Settings\+Info\+Callbacks)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P2\+Upstream\+Session\+Test}, Test\+Set\+Controller\+Init\+Header\+Indexing\+Strat)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P2\+Upstream\+Session\+Test}, Exheader\+From\+Server)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P2\+Upstream\+Session\+Test}, Invalid\+Control\+Stream)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P2\+Upstream\+Session\+With\+Virtual\+Nodes\+Test}, Virtual\+Nodes)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P2\+Upstream\+Session\+With\+Priority\+Tree}, Priority\+Tree)
\item 
{\bf T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+P} ({\bf H\+T\+T\+P\+Upstream\+Test}, Immediate\+Eof)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Upstream\+Session\+Test}, Basic\+Request)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Upstream\+Session\+Test}, Two\+Requests)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Upstream\+Session\+Test}, 10\+Requests)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Upstream\+Session\+Test}, Test\+First\+Header\+Byte\+Event\+Tracker)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Upstream\+Session\+Test}, Http10\+Keepalive)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Upstream\+Session\+Test}, Basic\+Trailers)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P2\+Upstream\+Session\+Test}, Basic\+Trailers)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P2\+Upstream\+Session\+Test}, Headers\+Then\+Body\+Then\+Headers)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Upstream\+Session\+Test}, Two\+Requests\+With\+Pause)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Upstream\+Timeout\+Test}, Write\+Timeout\+After\+Response)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Upstream\+Session\+Test}, Set\+Transaction\+Timeout)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Upstream\+Session\+Test}, Read\+Timeout)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Upstream\+Session\+Test}, 100\+Continue\+Keepalive)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Upstream\+Session\+Test}, 417\+Keepalive)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Upstream\+Session\+Test}, 101\+Upgrade)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Upstream\+Session\+Test}, Http\+Upgrade\+Native\+H2)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Upstream\+Session\+Test}, Http\+Upgrade\+Native\+Unknown)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Upstream\+Session\+Test}, Http\+Upgrade\+Native\+Whitespace)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Upstream\+Session\+Test}, Http\+Upgrade\+Native\+Junk)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Upstream\+Session\+Test}, Http\+Upgrade101\+Unexpected)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Upstream\+Session\+Test}, Http\+Upgrade101\+Missing\+Upgrade)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Upstream\+Session\+Test}, Http\+Upgrade101\+Bogus\+Header)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Upstream\+Session\+Test}, Http\+Upgrade\+Post100)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Upstream\+Session\+Test}, Http\+Upgrade\+Post100\+Http2)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Upstream\+Session\+Test}, Http\+Upgrade\+On\+Txn2)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Upstream\+Recv\+Stream\+Test}, Upgrade\+Flow\+Control)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf No\+Flush\+Upstream\+Session\+Test}, Session\+Paused\+Start\+Paused)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf No\+Flush\+Upstream\+Session\+Test}, Delete\+Txn\+On\+Unpause)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P2\+Upstream\+Session\+Test}, Server\+Push)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+H\+T\+T\+P2\+Upstream\+Test}, Parse\+Error\+No\+Txn)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+H\+T\+T\+P\+Upstream\+Test}, 0\+Max\+Outgoing\+Txns)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+H\+T\+T\+P\+Upstream\+Test}, Outgoing\+Txn\+Settings)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+H\+T\+T\+P\+Upstream\+Test}, Ingress\+Goaway\+Drain)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+H\+T\+T\+P\+Upstream\+Test}, Goaway)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+H\+T\+T\+P\+Upstream\+Test}, Goaway\+Pre\+Headers)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+H\+T\+T\+P\+Upstream\+Test}, No\+Window\+Update\+On\+Drain)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+H\+T\+T\+P\+Upstream\+Test}, Get\+With\+Body)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+H\+T\+T\+P\+Upstream\+Test}, Header\+With\+Eom)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Test\+Abort\+Post1}, Test)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Test\+Abort\+Post2}, Test)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Test\+Abort\+Post3}, Test)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Test\+Abort\+Post4}, Test)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Test\+Abort\+Post5}, Test)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+H\+T\+T\+P\+Upstream\+Test}, Abort\+Upgrade)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+H\+T\+T\+P\+Upstream\+Test}, Drain\+Before\+Send\+Headers)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+H\+T\+T\+P2\+Upstream\+Test}, Receive\+Double\+Goaway)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+H\+T\+T\+P2\+Upstream\+Test}, Server\+Push\+Invalid\+Assoc)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+H\+T\+T\+P2\+Upstream\+Test}, Server\+Push\+After\+Fin)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+H\+T\+T\+P2\+Upstream\+Test}, Server\+Push\+Handler\+Install\+Fail)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+H\+T\+T\+P2\+Upstream\+Test}, Server\+Push\+Unhandled\+Assoc)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+H\+T\+T\+P\+Upstream\+Test}, Headers\+Then\+Body\+Then\+Headers)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+H\+T\+T\+P2\+Upstream\+Test}, Delay\+Upstream\+Window\+Update)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Mock\+H\+T\+T\+P\+Upstream\+Test}, Force\+Shutdown\+In\+Set\+Transaction)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P2\+Upstream\+Session\+Test}, Test\+Replay\+Safety\+Callback)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P2\+Upstream\+Session\+Test}, Test\+Already\+Replay\+Safe)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P2\+Upstream\+Session\+Test}, Test\+Chained\+Buf\+Ingress)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P2\+Upstream\+Session\+Test}, Attach\+Detach)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P2\+Upstream\+Session\+Test}, Detach\+Flow\+Control\+Timeout)
\item 
{\bf R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P} ({\bf H\+T\+T\+P\+Upstream\+Test}, Immediate\+Eof)
\item 
{\bf I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P} (All\+Types\+Prefix, {\bf H\+T\+T\+P\+Upstream\+Test}, {\bf All\+Types})
\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!All\+Types@{All\+Types}}
\index{All\+Types@{All\+Types}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{All\+Types}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf All\+Types} =  \+::testing\+::\+Types$<${\bf H\+T\+T\+P1x\+Codec\+Pair}, {\bf S\+P\+D\+Y3\+Codec\+Pair}$>$}\label{HTTPUpstreamSessionTest_8cpp_a26e7de6d9e9c7e0fc10660e6677e5c3c}


Definition at line 2761 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.

\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!H\+T\+T\+P2\+Upstream\+Session\+Test@{H\+T\+T\+P2\+Upstream\+Session\+Test}}
\index{H\+T\+T\+P2\+Upstream\+Session\+Test@{H\+T\+T\+P2\+Upstream\+Session\+Test}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{H\+T\+T\+P2\+Upstream\+Session\+Test}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf H\+T\+T\+P2\+Upstream\+Session\+Test} =  {\bf H\+T\+T\+P\+Upstream\+Test}$<${\bf H\+T\+T\+P2\+Codec\+Pair}$>$}\label{HTTPUpstreamSessionTest_8cpp_a4a4e71c87e650b89aa53c8a3200e85f6}


Definition at line 405 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.

\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!H\+T\+T\+P\+Upstream\+Session\+Test@{H\+T\+T\+P\+Upstream\+Session\+Test}}
\index{H\+T\+T\+P\+Upstream\+Session\+Test@{H\+T\+T\+P\+Upstream\+Session\+Test}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{H\+T\+T\+P\+Upstream\+Session\+Test}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf H\+T\+T\+P\+Upstream\+Session\+Test} =  {\bf H\+T\+T\+P\+Upstream\+Test}$<${\bf H\+T\+T\+P1x\+Codec\+Pair}$>$}\label{HTTPUpstreamSessionTest_8cpp_abc78f056c79bbc4e5709cfed34bec74d}


Definition at line 403 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.

\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!H\+T\+T\+P\+Upstream\+Timeout\+Test@{H\+T\+T\+P\+Upstream\+Timeout\+Test}}
\index{H\+T\+T\+P\+Upstream\+Timeout\+Test@{H\+T\+T\+P\+Upstream\+Timeout\+Test}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{H\+T\+T\+P\+Upstream\+Timeout\+Test}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf H\+T\+T\+P\+Upstream\+Timeout\+Test} =  {\bf Timeoutable\+H\+T\+T\+P\+Upstream\+Test}$<${\bf H\+T\+T\+P1x\+Codec\+Pair}$>$}\label{HTTPUpstreamSessionTest_8cpp_ab618c44e7feda945e3b104ec5ce35be7}


Definition at line 1269 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.

\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!S\+P\+D\+Y3\+Upstream\+Session\+Test@{S\+P\+D\+Y3\+Upstream\+Session\+Test}}
\index{S\+P\+D\+Y3\+Upstream\+Session\+Test@{S\+P\+D\+Y3\+Upstream\+Session\+Test}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{S\+P\+D\+Y3\+Upstream\+Session\+Test}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf S\+P\+D\+Y3\+Upstream\+Session\+Test} =  {\bf H\+T\+T\+P\+Upstream\+Test}$<${\bf S\+P\+D\+Y3\+Codec\+Pair}$>$}\label{HTTPUpstreamSessionTest_8cpp_a7d6e5f8ec6e2a20b4a82bcff361a640e}


Definition at line 404 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.

\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!Test\+Abort\+Post0@{Test\+Abort\+Post0}}
\index{Test\+Abort\+Post0@{Test\+Abort\+Post0}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{Test\+Abort\+Post0}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Test\+Abort\+Post}$<$0$>$ {\bf Test\+Abort\+Post0}}\label{HTTPUpstreamSessionTest_8cpp_a52bbcb0767aa50585ea5558b49ffabb8}


Definition at line 2258 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.

\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!Test\+Abort\+Post1@{Test\+Abort\+Post1}}
\index{Test\+Abort\+Post1@{Test\+Abort\+Post1}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{Test\+Abort\+Post1}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Test\+Abort\+Post}$<$1$>$ {\bf Test\+Abort\+Post1}}\label{HTTPUpstreamSessionTest_8cpp_a5c19ca781c0b91bc41cc2c002de13756}


Definition at line 2259 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.

\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!Test\+Abort\+Post2@{Test\+Abort\+Post2}}
\index{Test\+Abort\+Post2@{Test\+Abort\+Post2}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{Test\+Abort\+Post2}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Test\+Abort\+Post}$<$2$>$ {\bf Test\+Abort\+Post2}}\label{HTTPUpstreamSessionTest_8cpp_a03910fd67304a55bbb9f540263008957}


Definition at line 2260 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.

\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!Test\+Abort\+Post3@{Test\+Abort\+Post3}}
\index{Test\+Abort\+Post3@{Test\+Abort\+Post3}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{Test\+Abort\+Post3}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Test\+Abort\+Post}$<$3$>$ {\bf Test\+Abort\+Post3}}\label{HTTPUpstreamSessionTest_8cpp_abd659acade146ef7e1f8b133e62d82b7}


Definition at line 2261 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.

\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!Test\+Abort\+Post4@{Test\+Abort\+Post4}}
\index{Test\+Abort\+Post4@{Test\+Abort\+Post4}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{Test\+Abort\+Post4}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Test\+Abort\+Post}$<$4$>$ {\bf Test\+Abort\+Post4}}\label{HTTPUpstreamSessionTest_8cpp_aa6a6405f0c0b0c7d70260dd5b6f88bd3}


Definition at line 2262 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.

\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!Test\+Abort\+Post5@{Test\+Abort\+Post5}}
\index{Test\+Abort\+Post5@{Test\+Abort\+Post5}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{Test\+Abort\+Post5}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Test\+Abort\+Post}$<$5$>$ {\bf Test\+Abort\+Post5}}\label{HTTPUpstreamSessionTest_8cpp_af0dfc18925a12ed422af2f198a1a1f18}


Definition at line 2263 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



\subsection{Function Documentation}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P@{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P}}
\index{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P@{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+P(\+All\+Types\+Prefix, H\+T\+T\+P\+Upstream\+Test, All\+Types)}]{\setlength{\rightskip}{0pt plus 5cm}I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P (
\begin{DoxyParamCaption}
\item[{All\+Types\+Prefix}]{, }
\item[{{\bf H\+T\+T\+P\+Upstream\+Test}}]{, }
\item[{{\bf All\+Types}}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_acbcb9c60b2c0c20efc9a66343199808d}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P@{R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P}}
\index{R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P@{R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+P(\+H\+T\+T\+P\+Upstream\+Test, Immediate\+Eof)}]{\setlength{\rightskip}{0pt plus 5cm}R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Test}}]{, }
\item[{Immediate\+Eof}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a084219c2e9e2499e7b561ec074341c91}


Referenced by T\+E\+S\+T\+\_\+\+F().

\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+S\+P\+D\+Y3\+Upstream\+Session\+Test, Server\+Push)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf S\+P\+D\+Y3\+Upstream\+Session\+Test}}]{, }
\item[{Server\+Push}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a830d5c44123c53483d7275c10817b30e}


Definition at line 407 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::\+S\+P\+D\+Y\+Codec\+::generate\+Body(), proxygen\+::\+S\+P\+D\+Y\+Codec\+::generate\+Header(), proxygen\+::\+S\+P\+D\+Y\+Codec\+::generate\+Push\+Promise(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), make\+Buf(), proxygen\+::\+H\+T\+T\+P\+Headers\+::set(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::set\+Handler(), proxygen\+::\+H\+T\+T\+P\+Message\+::set\+Status\+Code(), proxygen\+::\+H\+T\+T\+P\+Message\+::set\+Status\+Message(), and proxygen\+::\+H\+T\+T\+P\+Message\+::set\+U\+R\+L().


\begin{DoxyCode}
407                                              \{
408   SPDYCodec egressCodec(TransportDirection::DOWNSTREAM,
409                         SPDYVersion::SPDY3);
410   folly::IOBufQueue output(folly::IOBufQueue::cacheChainLength());
411 
412   HTTPMessage push;
413   push.getHeaders().set(\textcolor{stringliteral}{"HOST"}, \textcolor{stringliteral}{"www.foo.com"});
414   push.setURL(\textcolor{stringliteral}{"https://www.foo.com/"});
415   egressCodec.generatePushPromise(output, 2, push, 1, \textcolor{keyword}{false}, \textcolor{keyword}{nullptr});
416   \textcolor{keyword}{auto} buf = makeBuf(100);
417   egressCodec.generateBody(output, 2, std::move(buf), HTTPCodec::NoPadding,
418                            \textcolor{keyword}{true} \textcolor{comment}{/* eom */});
419 
420   HTTPMessage resp;
421   resp.setStatusCode(200);
422   resp.setStatusMessage(\textcolor{stringliteral}{"Ohai"});
423   egressCodec.generateHeader(output, 1, resp, \textcolor{keyword}{false}, \textcolor{keyword}{nullptr});
424   buf = makeBuf(100);
425   egressCodec.generateBody(output, 1, std::move(buf), HTTPCodec::NoPadding,
426                            \textcolor{keyword}{true} \textcolor{comment}{/* eom */});
427 
428   std::unique\_ptr<folly::IOBuf> input = output.move();
429   input->coalesce();
430 
431   MockHTTPHandler pushHandler;
432 
433   InSequence enforceOrder;
434 
435   \textcolor{keyword}{auto} handler = openTransaction();
436   EXPECT\_CALL(*handler, onPushedTransaction(\_))
437     .WillOnce(Invoke([&pushHandler] (HTTPTransaction* pushTxn) \{
438           pushTxn->setHandler(&pushHandler);
439         \}));
440   EXPECT\_CALL(pushHandler, setTransaction(\_));
441   EXPECT\_CALL(pushHandler, onHeadersComplete(\_))
442     .WillOnce(Invoke([&] (std::shared\_ptr<HTTPMessage> msg) \{
443           EXPECT\_EQ(httpSession\_->getNumIncomingStreams(), 1);
444           EXPECT\_TRUE(msg->getIsChunked());
445           EXPECT\_FALSE(msg->getIsUpgraded());
446           EXPECT\_EQ(msg->getPath(), \textcolor{stringliteral}{"/"});
447           EXPECT\_EQ(msg->getHeaders().getSingleOrEmpty(HTTP\_HEADER\_HOST),
448                     \textcolor{stringliteral}{"www.foo.com"});
449         \}));
450   EXPECT\_CALL(pushHandler, onBody(\_));
451   EXPECT\_CALL(pushHandler, onEOM());
452   EXPECT\_CALL(pushHandler, detachTransaction());
453 
454   handler->expectHeaders([&] (std::shared\_ptr<HTTPMessage> msg) \{
455       EXPECT\_FALSE(msg->getIsUpgraded());
456       EXPECT\_EQ(200, msg->getStatusCode());
457     \});
458   EXPECT\_CALL(*handler, onBody(\_));
459   handler->expectEOM();
460   handler->expectDetachTransaction();
461 
462   handler->sendRequest();
463   readAndLoop(input->data(), input->length());
464 
465   EXPECT\_EQ(httpSession\_->getNumIncomingStreams(), 0);
466   httpSession\_->destroy();
467 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+S\+P\+D\+Y3\+Upstream\+Session\+Test, Ingress\+Goaway\+Abort\+Uncreated\+Streams)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf S\+P\+D\+Y3\+Upstream\+Session\+Test}}]{, }
\item[{Ingress\+Goaway\+Abort\+Uncreated\+Streams}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a061e992bbdab23918e128f576ee90d12}


Definition at line 469 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::\+S\+P\+D\+Y\+Codec\+::generate\+Goaway(), proxygen\+::\+Exception\+::get\+Proxygen\+Error(), proxygen\+::\+Exception\+::has\+Proxygen\+Error(), proxygen\+::k\+Error\+Stream\+Unacknowledged, and proxygen\+::\+Exception\+::what().


\begin{DoxyCode}
469                                                                      \{
470   \textcolor{comment}{// Tests whether the session aborts the streams which are not created}
471   \textcolor{comment}{// at the remote end.}
472 
473   \textcolor{comment}{// Create SPDY buf for GOAWAY with last good stream as 0 (no streams created)}
474   SPDYCodec egressCodec(TransportDirection::DOWNSTREAM,
475                         SPDYVersion::SPDY3);
476   folly::IOBufQueue respBuf\{IOBufQueue::cacheChainLength()\};
477   egressCodec.generateGoaway(respBuf, 0, ErrorCode::NO\_ERROR);
478   std::unique\_ptr<folly::IOBuf> goawayFrame = respBuf.move();
479   goawayFrame->coalesce();
480 
481   InSequence enforceOrder;
482 
483   \textcolor{keyword}{auto} handler = openTransaction();
484   handler->expectGoaway();
485   handler->expectError([&] (\textcolor{keyword}{const} HTTPException& err) \{
486       EXPECT\_TRUE(err.hasProxygenError());
487       EXPECT\_EQ(err.getProxygenError(), kErrorStreamUnacknowledged);
488       ASSERT\_EQ(
489         folly::to<std::string>(\textcolor{stringliteral}{"StreamUnacknowledged on transaction id: "},
490                                handler->txn\_->getID()),
491         std::string(err.what()));
492     \});
493   handler->expectDetachTransaction([\textcolor{keyword}{this}] \{
494       \textcolor{comment}{// Make sure the session can't create any more transactions.}
495       MockHTTPHandler handler2;
496       EXPECT\_EQ(httpSession\_->newTransaction(&handler2), \textcolor{keyword}{nullptr});
497     \});
498 
499   \textcolor{comment}{// Send the GET request}
500   handler->sendRequest();
501 
502   \textcolor{comment}{// Receive GOAWAY frame while waiting for SYN\_REPLY}
503   readAndLoop(goawayFrame->data(), goawayFrame->length());
504 
505   \textcolor{comment}{// Session will delete itself after the abort}
506 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+S\+P\+D\+Y3\+Upstream\+Session\+Test, Ingress\+Goaway\+Session\+Error)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf S\+P\+D\+Y3\+Upstream\+Session\+Test}}]{, }
\item[{Ingress\+Goaway\+Session\+Error}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a28afa1dec3f063b948fc23bc3a10d6ff}


Definition at line 508 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::\+S\+P\+D\+Y\+Codec\+::generate\+Goaway(), proxygen\+::\+Exception\+::get\+Proxygen\+Error(), proxygen\+::\+Exception\+::has\+Proxygen\+Error(), proxygen\+::k\+Error\+Stream\+Unacknowledged, and proxygen\+::\+Exception\+::what().


\begin{DoxyCode}
508                                                             \{
509   \textcolor{comment}{// Tests whether the session aborts the streams which are not created}
510   \textcolor{comment}{// at the remote end which have error codes.}
511 
512   \textcolor{comment}{// Create SPDY buf for GOAWAY with last good stream as 0 (no streams created)}
513   SPDYCodec egressCodec(TransportDirection::DOWNSTREAM,
514                         SPDYVersion::SPDY3);
515   folly::IOBufQueue respBuf\{IOBufQueue::cacheChainLength()\};
516   egressCodec.generateGoaway(respBuf, 0, ErrorCode::PROTOCOL\_ERROR);
517   std::unique\_ptr<folly::IOBuf> goawayFrame = respBuf.move();
518   goawayFrame->coalesce();
519 
520   InSequence enforceOrder;
521 
522   \textcolor{keyword}{auto} handler = openTransaction();
523   handler->expectGoaway();
524   handler->expectError([&] (\textcolor{keyword}{const} HTTPException& err) \{
525       EXPECT\_TRUE(err.hasProxygenError());
526       EXPECT\_EQ(err.getProxygenError(), kErrorStreamUnacknowledged);
527       ASSERT\_EQ(
528         folly::to<std::string>(\textcolor{stringliteral}{"StreamUnacknowledged on transaction id: "},
529                                handler->txn\_->getID(),
530                                \textcolor{stringliteral}{" with codec error: PROTOCOL\_ERROR"}),
531         std::string(err.what()));
532     \});
533   handler->expectDetachTransaction([\textcolor{keyword}{this}] \{
534       \textcolor{comment}{// Make sure the session can't create any more transactions.}
535       MockHTTPHandler handler2;
536       EXPECT\_EQ(httpSession\_->newTransaction(&handler2), \textcolor{keyword}{nullptr});
537     \});
538 
539   \textcolor{comment}{// Send the GET request}
540   handler->sendRequest();
541 
542   \textcolor{comment}{// Receive GOAWAY frame while waiting for SYN\_REPLY}
543   readAndLoop(goawayFrame->data(), goawayFrame->length());
544 
545   \textcolor{comment}{// Session will delete itself after the abort}
546 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+S\+P\+D\+Y3\+Upstream\+Session\+Test, Test\+Under\+Limit\+On\+Write\+Error)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf S\+P\+D\+Y3\+Upstream\+Session\+Test}}]{, }
\item[{Test\+Under\+Limit\+On\+Write\+Error}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a4754d8589b78e6ee624a157e96c13c90}


Definition at line 548 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Post\+Request(), and make\+Buf().


\begin{DoxyCode}
548                                                              \{
549   InSequence enforceOrder;
550   \textcolor{keyword}{auto} handler = openTransaction();
551 
552   \textcolor{keyword}{auto} req = getPostRequest();
553   handler->txn\_->sendHeaders(req);
554   \textcolor{comment}{// pause writes}
555   pauseWrites\_ = \textcolor{keyword}{true};
556   handler->expectEgressPaused();
557 
558   \textcolor{comment}{// send body}
559   handler->txn\_->sendBody(makeBuf(70000));
560   eventBase\_.loopOnce();
561 
562   \textcolor{comment}{// but no expectEgressResumed}
563   handler->expectError();
564   handler->expectDetachTransaction();
565   failWrites\_ = \textcolor{keyword}{true};
566   resumeWrites();
567 
568   this->eventBase\_.loop();
569   EXPECT\_EQ(this->sessionDestroyed\_, \textcolor{keyword}{true});
570 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+S\+P\+D\+Y3\+Upstream\+Session\+Test, Test\+Overlimit\+Resume)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf S\+P\+D\+Y3\+Upstream\+Session\+Test}}]{, }
\item[{Test\+Overlimit\+Resume}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a7f9948052f12c4c1507af72a2a714c48}


Definition at line 572 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Post\+Request(), and make\+Buf().


\begin{DoxyCode}
572                                                       \{
573   InSequence enforceOrder;
574   \textcolor{keyword}{auto} handler1 = openTransaction();
575   \textcolor{keyword}{auto} handler2 = openTransaction();
576 
577   \textcolor{comment}{// Disable stream flow control for this test}
578   handler1->txn\_->onIngressWindowUpdate(80000);
579   handler2->txn\_->onIngressWindowUpdate(80000);
580 
581   \textcolor{keyword}{auto} req = getPostRequest();
582   handler1->txn\_->sendHeaders(req);
583   handler2->txn\_->sendHeaders(req);
584   \textcolor{comment}{// pause writes}
585   pauseWrites\_ = \textcolor{keyword}{true};
586   handler1->expectEgressPaused();
587   handler2->expectEgressPaused();
588 
589   \textcolor{comment}{// send body}
590   handler1->txn\_->sendBody(makeBuf(70000));
591   handler2->txn\_->sendBody(makeBuf(70000));
592   eventBase\_.loopOnce();
593 
594   \textcolor{comment}{// when this handler is resumed, re-pause the pipe}
595   handler1->expectEgressResumed([&] \{
596       handler1->txn\_->sendBody(makeBuf(70000));
597     \});
598   \textcolor{comment}{// handler2 will get a shot}
599   handler2->expectEgressResumed();
600 
601   \textcolor{comment}{// both handlers will be paused}
602   handler1->expectEgressPaused();
603   handler2->expectEgressPaused();
604   resumeWrites();
605 
606   \textcolor{comment}{// They both get resumed}
607   handler1->expectEgressResumed([&] \{ handler1->txn\_->sendEOM(); \});
608   handler2->expectEgressResumed([&] \{ handler2->txn\_->sendEOM(); \});
609 
610   this->eventBase\_.loop();
611 
612   \textcolor{comment}{// less than graceful shutdown}
613   handler1->expectError();
614   handler1->expectDetachTransaction();
615   handler2->expectError();
616   handler2->expectDetachTransaction();
617 
618   httpSession\_->dropConnection();
619   EXPECT\_EQ(this->sessionDestroyed\_, \textcolor{keyword}{true});
620 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P2\+Upstream\+Session\+Test, Test\+Priority)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P2\+Upstream\+Session\+Test}}]{, }
\item[{Test\+Priority}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a355af32c6c4c18b627b85ea9060f0dd6}


Definition at line 622 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Get\+Request(), and make\+Server\+Codec().


\begin{DoxyCode}
622                                                \{
623   InSequence enforceOrder;
624   \textcolor{comment}{// virtual priority node with pri=8}
625   \textcolor{keyword}{auto} priGroupID = httpSession\_->sendPriority(\{0, \textcolor{keyword}{false}, 7\});
626   \textcolor{keyword}{auto} handler1 = openTransaction();
627   \textcolor{keyword}{auto} handler2 = openTransaction();
628 
629   \textcolor{keyword}{auto} req = getGetRequest();
630   \textcolor{comment}{// send request with maximal weight}
631   req.setHTTP2Priority(HTTPMessage::HTTPPriority(0, \textcolor{keyword}{false}, 255));
632   handler1->sendRequest(req);
633   handler2->sendRequest(req);
634 
635   \textcolor{keyword}{auto} \textcolor{keywordtype}{id} = handler1->txn\_->getID();
636   \textcolor{keyword}{auto} id2 = handler2->txn\_->getID();
637 
638   \textcolor{comment}{// Insert depth is 1, only root node has depth 0}
639   EXPECT\_EQ(std::get<0>(handler1->txn\_->getPrioritySummary()), 1);
640   EXPECT\_EQ(handler1->txn\_->getPriorityFallback(), \textcolor{keyword}{false});
641 
642   \textcolor{comment}{// update handler to be in the pri-group}
643   handler1->txn\_->updateAndSendPriority(
644     http2::PriorityUpdate\{priGroupID, \textcolor{keyword}{false}, 15\});
645   handler2->txn\_->updateAndSendPriority(
646     http2::PriorityUpdate\{priGroupID + 254, \textcolor{keyword}{false}, 15\});
647 
648   \textcolor{comment}{// Change pri-group weight to max}
649   httpSession\_->sendPriority(priGroupID, http2::PriorityUpdate\{0, \textcolor{keyword}{false}, 255\});
650   eventBase\_.loop();
651 
652   \textcolor{keyword}{auto} serverCodec = makeServerCodec();
653   NiceMock<MockHTTPCodecCallback> callbacks;
654   serverCodec->setCallback(&callbacks);
655   EXPECT\_CALL(callbacks, onPriority(priGroupID,
656                                     HTTPMessage::HTTPPriority(0, \textcolor{keyword}{false}, 7)));
657   EXPECT\_CALL(callbacks, onHeadersComplete(\textcolor{keywordtype}{id}, \_))
658     .WillOnce(Invoke([&] (HTTPCodec::StreamID,
659                           std::shared\_ptr<HTTPMessage> msg) \{
660           EXPECT\_EQ(*(msg->getHTTP2Priority()),
661                     HTTPMessage::HTTPPriority(0, \textcolor{keyword}{false}, 255));
662         \}));
663   EXPECT\_CALL(callbacks, onHeadersComplete(id2, \_))
664     .WillOnce(Invoke([&] (HTTPCodec::StreamID,
665                           std::shared\_ptr<HTTPMessage> msg) \{
666           EXPECT\_EQ(*(msg->getHTTP2Priority()),
667                     HTTPMessage::HTTPPriority(0, \textcolor{keyword}{false}, 255));
668           \}));
669   EXPECT\_CALL(callbacks,
670               onPriority(
671                 \textcolor{keywordtype}{id}, HTTPMessage::HTTPPriority(priGroupID, \textcolor{keyword}{false}, 15)));
672   EXPECT\_CALL(callbacks,
673               onPriority(
674                 id2, HTTPMessage::HTTPPriority(priGroupID + 254, \textcolor{keyword}{false}, 15)));
675   EXPECT\_EQ(handler1->txn\_->getPriorityFallback(), \textcolor{keyword}{false});
676   EXPECT\_EQ(handler2->txn\_->getPriorityFallback(), \textcolor{keyword}{false});
677 
678   EXPECT\_EQ(std::get<1>(handler1->txn\_->getPrioritySummary()), 2);
679   \textcolor{comment}{// created virtual parent node}
680   EXPECT\_EQ(std::get<1>(handler2->txn\_->getPrioritySummary()), 2);
681   EXPECT\_CALL(callbacks,
682               onPriority(priGroupID, HTTPMessage::HTTPPriority(0, \textcolor{keyword}{false}, 255)));
683   parseOutput(*serverCodec);
684   eventBase\_.loop();
685 
686   handler1->expectError();
687   handler1->expectDetachTransaction();
688   handler2->expectError();
689   handler2->expectDetachTransaction();
690   httpSession\_->dropConnection();
691   eventBase\_.loop();
692   EXPECT\_EQ(sessionDestroyed\_, \textcolor{keyword}{true});
693 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P2\+Upstream\+Session\+Test, Test\+Settings\+Ack)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P2\+Upstream\+Session\+Test}}]{, }
\item[{Test\+Settings\+Ack}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a663d6a8e27b7e7d1c860e55f8ee4a9bc}


Definition at line 695 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References make\+Server\+Codec().


\begin{DoxyCode}
695                                                   \{
696   \textcolor{keyword}{auto} serverCodec = makeServerCodec();
697   folly::IOBufQueue buf\{IOBufQueue::cacheChainLength()\};
698   serverCodec->generateSettings(buf);
699   \textcolor{keyword}{auto} settingsFrame = buf.move();
700   settingsFrame->coalesce();
701 
702   InSequence enforceOrder;
703 
704   NiceMock<MockHTTPCodecCallback> callbacks;
705   serverCodec->setCallback(&callbacks);
706   EXPECT\_CALL(callbacks, onSettings(\_));
707   EXPECT\_CALL(callbacks, onSettingsAck());
708 
709   readAndLoop(settingsFrame.get());
710   parseOutput(*serverCodec);
711   httpSession\_->dropConnection();
712   EXPECT\_EQ(sessionDestroyed\_, \textcolor{keyword}{true});
713 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P2\+Upstream\+Session\+Test, Test\+Settings\+Info\+Callbacks)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P2\+Upstream\+Session\+Test}}]{, }
\item[{Test\+Settings\+Info\+Callbacks}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_ac2f512c15695d47cad225e78131c5d3d}


Definition at line 715 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References make\+Server\+Codec().


\begin{DoxyCode}
715                                                             \{
716   \textcolor{keyword}{auto} serverCodec = makeServerCodec();
717 
718   folly::IOBufQueue settingsBuf\{IOBufQueue::cacheChainLength()\};
719   serverCodec->generateSettings(settingsBuf);
720   \textcolor{keyword}{auto} settingsFrame = settingsBuf.move();
721 
722   folly::IOBufQueue settingsAckBuf\{IOBufQueue::cacheChainLength()\};
723   serverCodec->generateSettingsAck(settingsAckBuf);
724   \textcolor{keyword}{auto} settingsAckFrame = settingsAckBuf.move();
725 
726   MockHTTPSessionInfoCallback infoCb;
727   httpSession\_->setInfoCallback(&infoCb);
728 
729   EXPECT\_CALL(infoCb, onRead(\_, \_)).Times(2);
730   EXPECT\_CALL(infoCb, onWrite(\_, \_)).Times(1);
731   EXPECT\_CALL(infoCb, onDestroy(\_)).Times(1);
732 
733   EXPECT\_CALL(infoCb, onSettings(\_, \_)).Times(1);
734   EXPECT\_CALL(infoCb, onSettingsAck(\_)).Times(1);
735 
736   InSequence enforceOrder;
737 
738   readAndLoop(settingsFrame.get());
739   readAndLoop(settingsAckFrame.get());
740 
741   httpSession\_->destroy();
742 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P2\+Upstream\+Session\+Test, Test\+Set\+Controller\+Init\+Header\+Indexing\+Strat)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P2\+Upstream\+Session\+Test}}]{, }
\item[{Test\+Set\+Controller\+Init\+Header\+Indexing\+Strat}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a1c29a1b8dc87f6621e246c23fddaae85}


Definition at line 744 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::\+H\+T\+T\+P2\+Codec\+::get\+Header\+Indexing\+Strategy().


\begin{DoxyCode}
744                                                                            \{
745   StrictMock<MockUpstreamController> mockController;
746   HeaderIndexingStrategy testH2IndexingStrat;
747   EXPECT\_CALL(mockController, getHeaderIndexingStrategy())
748     .WillOnce(
749       Return(&testH2IndexingStrat)
750   );
751 
752   httpSession\_->setController(&mockController);
753 
754   \textcolor{keyword}{auto} handler = openTransaction();
755   handler->expectDetachTransaction();
756 
757   \textcolor{keyword}{const} HTTP2Codec* h2Codec = \textcolor{keyword}{static\_cast<}\textcolor{keyword}{const }HTTP2Codec*\textcolor{keyword}{>}(
758     &handler->txn\_->getTransport().getCodec());
759   EXPECT\_EQ(h2Codec->getHeaderIndexingStrategy(), &testH2IndexingStrat);
760 
761   handler->txn\_->sendAbort();
762   eventBase\_.loop();
763 
764   EXPECT\_CALL(mockController, detachSession(\_));
765   httpSession\_->destroy();
766 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P2\+Upstream\+Session\+Test, Exheader\+From\+Server)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P2\+Upstream\+Session\+Test}}]{, }
\item[{Exheader\+From\+Server}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a86eaf863720124cac60c6790dfa0f0b1}


Definition at line 777 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Get\+Request(), proxygen\+::get\+Response(), make\+Server\+Codec(), and proxygen\+::\+H\+T\+T\+P\+Transaction\+::set\+Handler().


\begin{DoxyCode}
777                                                      \{
778   folly::IOBufQueue queue\{IOBufQueue::cacheChainLength()\};
779 
780   \textcolor{comment}{// generate enable\_ex\_headers setting}
781   \textcolor{keyword}{auto} serverCodec = makeServerCodec();
782   enableExHeader(serverCodec.get());
783   serverCodec->generateSettings(queue);
784   \textcolor{comment}{// generate the response for control stream, but EOM}
785   \textcolor{keyword}{auto} cStreamId = HTTPCodec::StreamID(1);
786   serverCodec->generateHeader(queue, cStreamId, getResponse(200, 0),
787                               \textcolor{keyword}{false}, \textcolor{keyword}{nullptr});
788   \textcolor{comment}{// generate a request from server, encapsulated in EX\_HEADERS frame}
789   serverCodec->generateExHeader(queue, 2, getGetRequest(\textcolor{stringliteral}{"/messaging"}),
790                                 HTTPCodec::ExAttributes(cStreamId, \textcolor{keyword}{false}),
791                                 \textcolor{keyword}{true}, \textcolor{keyword}{nullptr});
792   serverCodec->generateEOM(queue, 1);
793 
794   \textcolor{keyword}{auto} cHandler = openTransaction();
795   cHandler->sendRequest(getGetRequest(\textcolor{stringliteral}{"/cc"}));
796 
797   NiceMock<MockHTTPHandler> pubHandler;
798   InSequence handlerSequence;
799   cHandler->expectHeaders([&] (std::shared\_ptr<HTTPMessage> msg) \{
800       EXPECT\_EQ(200, msg->getStatusCode());
801     \});
802 
803   EXPECT\_CALL(*cHandler, onExTransaction(\_))
804     .WillOnce(Invoke([&pubHandler] (HTTPTransaction* pubTxn) \{
805           pubTxn->setHandler(&pubHandler);
806           pubHandler.txn\_ = pubTxn;
807         \}));
808   pubHandler.expectHeaders([&] (std::shared\_ptr<HTTPMessage> msg) \{
809       EXPECT\_EQ(msg->getPath(), \textcolor{stringliteral}{"/messaging"});
810     \});
811   pubHandler.expectEOM([&] () \{
812       pubHandler.txn\_->sendAbort();
813     \});
814   pubHandler.expectDetachTransaction();
815 
816   cHandler->expectEOM();
817   cHandler->expectDetachTransaction();
818 
819   \textcolor{keyword}{auto} buf = queue.move();
820   buf->coalesce();
821   readAndLoop(buf.get());
822 
823   httpSession\_->destroy();
824 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P2\+Upstream\+Session\+Test, Invalid\+Control\+Stream)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P2\+Upstream\+Session\+Test}}]{, }
\item[{Invalid\+Control\+Stream}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a4b3a8f1881e475a6e79919bbd51b5d0e}


Definition at line 826 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Get\+Request(), proxygen\+::get\+Response(), and make\+Server\+Codec().


\begin{DoxyCode}
826                                                        \{
827   folly::IOBufQueue queue\{IOBufQueue::cacheChainLength()\};
828 
829   \textcolor{comment}{// generate enable\_ex\_headers setting}
830   \textcolor{keyword}{auto} serverCodec = makeServerCodec();
831   enableExHeader(serverCodec.get());
832   serverCodec->generateSettings(queue);
833   \textcolor{comment}{// generate the response for control stream, but EOM}
834   \textcolor{keyword}{auto} cStreamId = HTTPCodec::StreamID(1);
835   serverCodec->generateHeader(queue, cStreamId, getResponse(200, 0),
836                               \textcolor{keyword}{false}, \textcolor{keyword}{nullptr});
837   \textcolor{comment}{// generate a EX\_HEADERS frame with non-existing control stream}
838   serverCodec->generateExHeader(queue, 2, getGetRequest(\textcolor{stringliteral}{"/messaging"}),
839                                 HTTPCodec::ExAttributes(cStreamId + 2, \textcolor{keyword}{false}),
840                                 \textcolor{keyword}{true}, \textcolor{keyword}{nullptr});
841   serverCodec->generateEOM(queue, 1);
842 
843   \textcolor{keyword}{auto} cHandler = openTransaction();
844   cHandler->sendRequest(getGetRequest(\textcolor{stringliteral}{"/cc"}));
845 
846   InSequence handlerSequence;
847   cHandler->expectHeaders([&] (std::shared\_ptr<HTTPMessage> msg) \{
848       EXPECT\_EQ(200, msg->getStatusCode());
849     \});
850   EXPECT\_CALL(*cHandler, onExTransaction(\_)).Times(0);
851   cHandler->expectEOM();
852   cHandler->expectDetachTransaction();
853 
854   \textcolor{keyword}{auto} buf = queue.move();
855   buf->coalesce();
856   readAndLoop(buf.get());
857 
858   httpSession\_->destroy();
859 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P2\+Upstream\+Session\+With\+Virtual\+Nodes\+Test, Virtual\+Nodes)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P2\+Upstream\+Session\+With\+Virtual\+Nodes\+Test}}]{, }
\item[{Virtual\+Nodes}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_aee3ae093fa57552d5fb64c6bbae34596}


Definition at line 928 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
928                                                                \{
929   InSequence enforceOrder;
930 
931   HTTPCodec::StreamID deps[] = \{11, 13, 15\};
932   EXPECT\_CALL(*codecPtr\_, addPriorityNodes(\_, \_, \_))
933     .Times(1)
934     .WillOnce(Invoke([&] (
935             HTTPCodec::PriorityQueue&,
936             folly::IOBufQueue&,
937             uint8\_t maxLevel) \{
938           \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < maxLevel; i++) \{
939             dependencies.push\_back(deps[i]);
940           \}
941           \textcolor{keywordflow}{return} 123;
942         \}));
943   httpSession\_->startNow();
944 
945   EXPECT\_EQ(level\_, dependencies.size());
946   StrictMock<MockHTTPHandler> handler;
947   handler.expectTransaction();
948   \textcolor{keyword}{auto} txn = httpSession\_->newTransaction(&handler);
949 
950   EXPECT\_CALL(*codecPtr\_, mapPriorityToDependency(\_))
951     .Times(1)
952     .WillOnce(Invoke([&] (uint8\_t priority) \{
953             \textcolor{keywordflow}{return} dependencies[priority];
954           \}));
955   txn->updateAndSendPriority(0);
956 
957   handler.expectError();
958   handler.expectDetachTransaction();
959   httpSession\_->dropConnection();
960 
961   eventBase\_.loop();
962 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P2\+Upstream\+Session\+With\+Priority\+Tree, Priority\+Tree)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P2\+Upstream\+Session\+With\+Priority\+Tree}}]{, }
\item[{Priority\+Tree}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_ac69d270995c9573cae62e1e1856629ed}


Definition at line 972 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
972                                                            \{
973   InSequence enforceOrder;
974 
975   std::array<HTTPCodec::StreamID, 3> deps = \{ \{11, 13, 15\} \};
976   EXPECT\_CALL(*codecPtr\_, addPriorityNodes(\_, \_, \_))
977     .Times(0)
978     .WillOnce(Invoke([&] (
979             HTTPCodec::PriorityQueue&,
980             folly::IOBufQueue&,
981             uint8\_t maxLevel) \{
982           \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < maxLevel; i++) \{
983             dependencies.push\_back(deps[i]);
984           \}
985           \textcolor{keywordflow}{return} 123;
986         \}));
987   httpSession\_->startNow();
988 
989   \textcolor{comment}{// It should have built the virtual streams from the tree but not the old}
990   \textcolor{comment}{// priority levels.}
991   EXPECT\_EQ(dependencies.size(), 0);
992   HTTPMessage::HTTPPriority hiPri =
993       *httpSession\_->getHTTPPriority(builder\_->hiPriLevel\_);
994   EXPECT\_EQ(std::get<2>(hiPri), builder\_->hiPriWeight\_);
995   HTTPMessage::HTTPPriority loPri =
996       *httpSession\_->getHTTPPriority(builder\_->loPriLevel\_);
997   EXPECT\_EQ(std::get<2>(loPri), builder\_->loPriWeight\_);
998 
999   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} level = 0; level < 256; ++level) \{
1000     \textcolor{keywordflow}{if} (level == builder\_->hiPriLevel\_) \{
1001       \textcolor{keywordflow}{continue};
1002     \}
1003     HTTPMessage::HTTPPriority pri = *httpSession\_->getHTTPPriority(level);
1004     EXPECT\_EQ(pri, loPri);
1005   \}
1006 
1007   StrictMock<MockHTTPHandler> handler;
1008   handler.expectTransaction();
1009   \textcolor{keyword}{auto} txn = httpSession\_->newTransaction(&handler);
1010 
1011   txn->updateAndSendPriority(0);
1012 
1013   handler.expectError();
1014   handler.expectDetachTransaction();
1015   httpSession\_->dropConnection();
1016 
1017   eventBase\_.loop();
1018 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Upstream\+Session\+Test, Basic\+Request)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Session\+Test}}]{, }
\item[{Basic\+Request}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a9ff3c767961ceb5460ea9b36d7f07b02}


Definition at line 1049 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
1049                                               \{
1050   testBasicRequest();
1051   httpSession\_->destroy();
1052 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Upstream\+Session\+Test, Two\+Requests)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Session\+Test}}]{, }
\item[{Two\+Requests}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_afc1d1fc1d6e1dca31bca0c635549f8e7}


Definition at line 1054 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
1054                                              \{
1055   testBasicRequest();
1056   testBasicRequest();
1057   httpSession\_->destroy();
1058 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Upstream\+Session\+Test, 10\+Requests)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Session\+Test}}]{, }
\item[{10\+Requests}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a7fd74576232d79545a10ef09a92c128c}


Definition at line 1060 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
1060                                             \{
1061   \textcolor{keywordflow}{for} (uint16\_t i = 0; i < 10; i++) \{
1062     testBasicRequest();
1063   \}
1064   httpSession\_->destroy();
1065 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Upstream\+Session\+Test, Test\+First\+Header\+Byte\+Event\+Tracker)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Session\+Test}}]{, }
\item[{Test\+First\+Header\+Byte\+Event\+Tracker}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a7521acf25b6d8e6476488919e93349f6}


Definition at line 1067 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Transaction\+::increment\+Pending\+Byte\+Events().


\begin{DoxyCode}
1067                                                                  \{
1068   \textcolor{keyword}{auto} byteEventTracker = setMockByteEventTracker();
1069 
1070   EXPECT\_CALL(*byteEventTracker, addFirstHeaderByteEvent(\_, \_))
1071       .WillOnce(Invoke([] (uint64\_t \textcolor{comment}{/*byteNo*/},
1072                            HTTPTransaction* txn) \{
1073                          txn->incrementPendingByteEvents();
1074                        \}));
1075 
1076   InSequence enforceOrder;
1077 
1078   \textcolor{keyword}{auto} handler = openTransaction();
1079   handler->expectHeaders([&] (std::shared\_ptr<HTTPMessage> msg) \{
1080       EXPECT\_TRUE(msg->getIsChunked());
1081       EXPECT\_FALSE(msg->getIsUpgraded());
1082       EXPECT\_EQ(200, msg->getStatusCode());
1083     \});
1084   handler->expectEOM();
1085   handler->expectDetachTransaction();
1086 
1087   handler->sendRequest();
1088   readAndLoop(\textcolor{stringliteral}{"HTTP/1.1 200 OK\(\backslash\)r\(\backslash\)n"}
1089               \textcolor{stringliteral}{"Transfer-Encoding: chunked\(\backslash\)r\(\backslash\)n\(\backslash\)r\(\backslash\)n"}
1090               \textcolor{stringliteral}{"0\(\backslash\)r\(\backslash\)n\(\backslash\)r\(\backslash\)n"});
1091 
1092   CHECK(httpSession\_->supportsMoreTransactions());
1093   CHECK\_EQ(httpSession\_->getNumOutgoingStreams(), 0);
1094   handler->txn\_->decrementPendingByteEvents();
1095   httpSession\_->destroy();
1096 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Upstream\+Session\+Test, Http10\+Keepalive)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Session\+Test}}]{, }
\item[{Http10\+Keepalive}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a3afd8d3765dbfe82a9ba5f74dc79d2ca}


Definition at line 1132 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
1132                                                  \{
1133   testBasicRequestHttp10(\textcolor{keyword}{true});
1134   testBasicRequestHttp10(\textcolor{keyword}{false});
1135 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Upstream\+Session\+Test, Basic\+Trailers)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Session\+Test}}]{, }
\item[{Basic\+Trailers}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a6b849cf48b65cdfc469613a35335e501}


Definition at line 1137 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
1137                                                \{
1138   InSequence enforceOrder;
1139 
1140   \textcolor{keyword}{auto} handler = openTransaction();
1141   handler->expectHeaders([&] (std::shared\_ptr<HTTPMessage> msg) \{
1142       EXPECT\_TRUE(msg->getIsChunked());
1143       EXPECT\_FALSE(msg->getIsUpgraded());
1144       EXPECT\_EQ(200, msg->getStatusCode());
1145     \});
1146   EXPECT\_CALL(*handler, onTrailers(\_));
1147   handler->expectEOM();
1148   handler->expectDetachTransaction();
1149 
1150   handler->sendRequest();
1151   readAndLoop(\textcolor{stringliteral}{"HTTP/1.1 200 OK\(\backslash\)r\(\backslash\)n"}
1152               \textcolor{stringliteral}{"Transfer-Encoding: chunked\(\backslash\)r\(\backslash\)n\(\backslash\)r\(\backslash\)n"}
1153               \textcolor{stringliteral}{"0\(\backslash\)r\(\backslash\)n"}
1154               \textcolor{stringliteral}{"X-Trailer1: foo\(\backslash\)r\(\backslash\)n"}
1155               \textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"});
1156 
1157   CHECK(httpSession\_->supportsMoreTransactions());
1158   CHECK\_EQ(httpSession\_->getNumOutgoingStreams(), 0);
1159   httpSession\_->destroy();
1160 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P2\+Upstream\+Session\+Test, Basic\+Trailers)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P2\+Upstream\+Session\+Test}}]{, }
\item[{Basic\+Trailers}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a1c0b108aee254ef1f148916f4dbf9b31}


Definition at line 1162 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), make\+Buf(), make\+Server\+Codec(), proxygen\+::\+H\+T\+T\+P\+Headers\+::set(), and proxygen\+::\+H\+T\+T\+P\+Message\+::set\+Status\+Code().


\begin{DoxyCode}
1162                                                 \{
1163   \textcolor{keyword}{auto} egressCodec = makeServerCodec();
1164   folly::IOBufQueue output(folly::IOBufQueue::cacheChainLength());
1165 
1166   egressCodec->generateSettings(output);
1167 
1168   HTTPMessage resp;
1169   resp.setStatusCode(200);
1170   resp.getHeaders().set(\textcolor{stringliteral}{"header1"}, \textcolor{stringliteral}{"value1"});
1171   egressCodec->generateHeader(output, 1, resp);
1172   \textcolor{keyword}{auto} buf = makeBuf(100);
1173   egressCodec->generateBody(
1174       output, 1, std::move(buf), HTTPCodec::NoPadding, \textcolor{keyword}{false} \textcolor{comment}{/* eom */});
1175   HTTPHeaders trailers;
1176   trailers.set(\textcolor{stringliteral}{"trailer2"}, \textcolor{stringliteral}{"value2"});
1177   egressCodec->generateTrailers(output, 1, trailers);
1178 
1179   std::unique\_ptr<folly::IOBuf> input = output.move();
1180   input->coalesce();
1181 
1182   \textcolor{keyword}{auto} handler = openTransaction();
1183 
1184   handler->expectHeaders([&](std::shared\_ptr<HTTPMessage> msg) \{
1185     EXPECT\_EQ(200, msg->getStatusCode());
1186     EXPECT\_EQ(msg->getHeaders().getSingleOrEmpty(\textcolor{stringliteral}{"header1"}), \textcolor{stringliteral}{"value1"});
1187   \});
1188   handler->expectBody();
1189   handler->expectTrailers([&](std::shared\_ptr<HTTPHeaders> trailers) \{
1190     EXPECT\_EQ(trailers->getSingleOrEmpty(\textcolor{stringliteral}{"trailer2"}), \textcolor{stringliteral}{"value2"});
1191   \});
1192   handler->expectEOM();
1193   handler->expectDetachTransaction();
1194 
1195   handler->sendRequest();
1196   readAndLoop(input->data(), input->length());
1197 
1198   httpSession\_->destroy();
1199 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P2\+Upstream\+Session\+Test, Headers\+Then\+Body\+Then\+Headers)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P2\+Upstream\+Session\+Test}}]{, }
\item[{Headers\+Then\+Body\+Then\+Headers}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a4916550ff8f679d948134b2efe7fb474}


Definition at line 1201 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), proxygen\+::\+Exception\+::get\+Proxygen\+Error(), proxygen\+::\+Exception\+::has\+Proxygen\+Error(), proxygen\+::k\+Error\+Ingress\+State\+Transition, make\+Buf(), make\+Server\+Codec(), proxygen\+::\+H\+T\+T\+P\+Headers\+::set(), proxygen\+::\+H\+T\+T\+P\+Message\+::set\+Status\+Code(), and proxygen\+::\+Exception\+::what().


\begin{DoxyCode}
1201                                                              \{
1202   \textcolor{keyword}{auto} egressCodec = makeServerCodec();
1203   folly::IOBufQueue output(folly::IOBufQueue::cacheChainLength());
1204 
1205   egressCodec->generateSettings(output);
1206 
1207   HTTPMessage resp;
1208   resp.setStatusCode(200);
1209   resp.getHeaders().set(\textcolor{stringliteral}{"header1"}, \textcolor{stringliteral}{"value1"});
1210   egressCodec->generateHeader(output, 1, resp);
1211   \textcolor{keyword}{auto} buf = makeBuf(100);
1212   egressCodec->generateBody(
1213       output, 1, std::move(buf), HTTPCodec::NoPadding, \textcolor{keyword}{false} \textcolor{comment}{/* eom */});
1214   \textcolor{comment}{// generate same headers again on the same stream}
1215   egressCodec->generateHeader(output, 1, resp);
1216 
1217   std::unique\_ptr<folly::IOBuf> input = output.move();
1218   input->coalesce();
1219 
1220   \textcolor{keyword}{auto} handler = openTransaction();
1221 
1222   handler->expectHeaders([&](std::shared\_ptr<HTTPMessage> msg) \{
1223     EXPECT\_EQ(200, msg->getStatusCode());
1224     EXPECT\_EQ(msg->getHeaders().getSingleOrEmpty(\textcolor{stringliteral}{"header1"}), \textcolor{stringliteral}{"value1"});
1225   \});
1226   handler->expectBody();
1227   handler->expectError([&](\textcolor{keyword}{const} HTTPException& err) \{
1228     EXPECT\_TRUE(err.hasProxygenError());
1229     EXPECT\_EQ(err.getProxygenError(), kErrorIngressStateTransition);
1230     ASSERT\_EQ(
1231         \textcolor{stringliteral}{"Invalid ingress state transition, state=RegularBodyReceived, "}
1232         \textcolor{stringliteral}{"event=onHeaders, streamID=1"},
1233         std::string(err.what()));
1234   \});
1235   handler->expectDetachTransaction();
1236 
1237   handler->sendRequest();
1238   readAndLoop(input->data(), input->length());
1239 
1240   httpSession\_->destroy();
1241 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Upstream\+Session\+Test, Two\+Requests\+With\+Pause)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Session\+Test}}]{, }
\item[{Two\+Requests\+With\+Pause}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a1d2bc02b21c2a145dc14921969557361}


Definition at line 1243 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
1243                                                       \{
1244   InSequence enforceOrder;
1245 
1246   \textcolor{keyword}{auto} handler = openTransaction();
1247   handler->expectHeaders([&] (std::shared\_ptr<HTTPMessage> msg) \{
1248       EXPECT\_TRUE(msg->getIsChunked());
1249       EXPECT\_FALSE(msg->getIsUpgraded());
1250       EXPECT\_EQ(200, msg->getStatusCode());
1251     \});
1252 
1253   handler->expectEOM([&] () \{ handler->txn\_->pauseIngress(); \});
1254   handler->expectDetachTransaction();
1255 
1256   handler->sendRequest();
1257   readAndLoop(\textcolor{stringliteral}{"HTTP/1.1 200 OK\(\backslash\)r\(\backslash\)n"}
1258               \textcolor{stringliteral}{"Transfer-Encoding: chunked\(\backslash\)r\(\backslash\)n\(\backslash\)r\(\backslash\)n"}
1259               \textcolor{stringliteral}{"0\(\backslash\)r\(\backslash\)n\(\backslash\)r\(\backslash\)n"});
1260 
1261   \textcolor{comment}{// Even though the previous transaction paused ingress just before it}
1262   \textcolor{comment}{// finished up, reads resume automatically when the number of}
1263   \textcolor{comment}{// transactions goes to zero. This way, the second request can read}
1264   \textcolor{comment}{// without having to call resumeIngress()}
1265   testBasicRequest();
1266   httpSession\_->destroy();
1267 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Upstream\+Timeout\+Test, Write\+Timeout\+After\+Response)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Timeout\+Test}}]{, }
\item[{Write\+Timeout\+After\+Response}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a9a1f6af532e2f1b1ea5405813703985c}


Definition at line 1270 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Exception\+::get\+Direction(), proxygen\+::get\+Post\+Request(), proxygen\+::\+Exception\+::get\+Proxygen\+Error(), proxygen\+::\+Exception\+::has\+Proxygen\+Error(), proxygen\+::k\+Error\+Write\+Timeout, and proxygen\+::\+Exception\+::what().


\begin{DoxyCode}
1270                                                            \{
1271   \textcolor{comment}{// Test where the upstream session times out while writing the request}
1272   \textcolor{comment}{// to the server, but after the server has already sent back a full}
1273   \textcolor{comment}{// response.}
1274   pauseWrites\_ = \textcolor{keyword}{true};
1275   HTTPMessage req = getPostRequest();
1276 
1277   InSequence enforceOrder;
1278   \textcolor{keyword}{auto} handler = openTransaction();
1279   handler->expectHeaders([&] (std::shared\_ptr<HTTPMessage> msg) \{
1280       EXPECT\_TRUE(msg->getIsChunked());
1281       EXPECT\_FALSE(msg->getIsUpgraded());
1282       EXPECT\_EQ(200, msg->getStatusCode());
1283     \});
1284   handler->expectEOM();
1285   handler->expectError([&] (\textcolor{keyword}{const} HTTPException& err) \{
1286       EXPECT\_TRUE(err.hasProxygenError());
1287       ASSERT\_EQ(err.getDirection(),
1288                 HTTPException::Direction::INGRESS\_AND\_EGRESS);
1289       EXPECT\_EQ(err.getProxygenError(), kErrorWriteTimeout);
1290       ASSERT\_EQ(
1291         folly::to<std::string>(\textcolor{stringliteral}{"WriteTimeout on transaction id: "},
1292                                handler->txn\_->getID()),
1293         std::string(err.what()));
1294     \});
1295   handler->expectDetachTransaction();
1296 
1297   handler->txn\_->sendHeaders(req);
1298   \textcolor{comment}{// Don't send the body, but get a response immediately}
1299   readAndLoop(\textcolor{stringliteral}{"HTTP/1.1 200 OK\(\backslash\)r\(\backslash\)n"}
1300               \textcolor{stringliteral}{"Transfer-Encoding: chunked\(\backslash\)r\(\backslash\)n\(\backslash\)r\(\backslash\)n"}
1301               \textcolor{stringliteral}{"0\(\backslash\)r\(\backslash\)n\(\backslash\)r\(\backslash\)n"});
1302 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Upstream\+Session\+Test, Set\+Transaction\+Timeout)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Session\+Test}}]{, }
\item[{Set\+Transaction\+Timeout}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a036eda556c8d4457d98b8671b8a29eb1}


Definition at line 1304 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
1304                                                        \{
1305   \textcolor{comment}{// Test that setting a new timeout on the transaction will cancel}
1306   \textcolor{comment}{// the old one.}
1307   \textcolor{keyword}{auto} handler = openTransaction();
1308   handler->expectDetachTransaction();
1309 
1310   EXPECT\_TRUE(handler->txn\_->hasIdleTimeout());
1311   handler->txn\_->setIdleTimeout(std::chrono::milliseconds(747));
1312   EXPECT\_TRUE(handler->txn\_->hasIdleTimeout());
1313   EXPECT\_TRUE(handler->txn\_->isScheduled());
1314   EXPECT\_EQ(transactionTimeouts\_->count(), 1);
1315   handler->txn\_->sendAbort();
1316   eventBase\_.loop();
1317 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Upstream\+Session\+Test, Read\+Timeout)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Session\+Test}}]{, }
\item[{Read\+Timeout}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a600d2ec70073c98b953aa69fcdda1858}


Definition at line 1319 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
1319                                              \{
1320   NiceMock<MockUpstreamController> controller;
1321   httpSession\_->setController(&controller);
1322   \textcolor{keyword}{auto} cm = wangle::ConnectionManager::makeUnique(
1323     &eventBase\_, std::chrono::milliseconds(50));
1324   cm->addConnection(httpSession\_, \textcolor{keyword}{true});
1325   eventBase\_.loop();
1326 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Upstream\+Session\+Test, 100\+Continue\+Keepalive)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Session\+Test}}]{, }
\item[{100\+Continue\+Keepalive}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a7ffcd3b659fa00a6000439b55f1b7d1f}


Definition at line 1328 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Get\+Request(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), and proxygen\+::\+H\+T\+T\+P\+Headers\+::set().


\begin{DoxyCode}
1328                                                       \{
1329   \textcolor{comment}{// Test a request with 100 continue on a keepalive connection. Then make}
1330   \textcolor{comment}{// another request.}
1331   HTTPMessage req = getGetRequest();
1332   req.getHeaders().set(HTTP\_HEADER\_EXPECT, \textcolor{stringliteral}{"100-continue"});
1333 
1334   InSequence enforceOrder;
1335 
1336   \textcolor{keyword}{auto} handler = openTransaction();
1337   handler->expectHeaders([&] (std::shared\_ptr<HTTPMessage> msg) \{
1338       EXPECT\_FALSE(msg->getIsChunked());
1339       EXPECT\_FALSE(msg->getIsUpgraded());
1340       EXPECT\_EQ(100, msg->getStatusCode());
1341     \});
1342   handler->expectHeaders([&] (std::shared\_ptr<HTTPMessage> msg) \{
1343       EXPECT\_TRUE(msg->getIsChunked());
1344       EXPECT\_FALSE(msg->getIsUpgraded());
1345       EXPECT\_EQ(200, msg->getStatusCode());
1346     \});
1347   handler->expectEOM();
1348   handler->expectDetachTransaction();
1349 
1350   handler->sendRequest(req);
1351   readAndLoop(\textcolor{stringliteral}{"HTTP/1.1 100 Continue\(\backslash\)r\(\backslash\)n\(\backslash\)r\(\backslash\)n"}
1352               \textcolor{stringliteral}{"HTTP/1.1 200 OK\(\backslash\)r\(\backslash\)n"}
1353               \textcolor{stringliteral}{"Transfer-Encoding: chunked\(\backslash\)r\(\backslash\)n\(\backslash\)r\(\backslash\)n"}
1354               \textcolor{stringliteral}{"0\(\backslash\)r\(\backslash\)n\(\backslash\)r\(\backslash\)n"});
1355 
1356   \textcolor{comment}{// Now make sure everything still works}
1357   testBasicRequest();
1358   httpSession\_->destroy();
1359 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Upstream\+Session\+Test, 417\+Keepalive)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Session\+Test}}]{, }
\item[{417\+Keepalive}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a05c30349e2a35c1c9cc89a74d0881791}


Definition at line 1361 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Get\+Request(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), and proxygen\+::\+H\+T\+T\+P\+Headers\+::set().


\begin{DoxyCode}
1361                                               \{
1362   \textcolor{comment}{// Test a request with 100 continue on a keepalive connection. Then make}
1363   \textcolor{comment}{// another request after the expectation fails.}
1364   HTTPMessage req = getGetRequest();
1365   req.getHeaders().set(HTTP\_HEADER\_EXPECT, \textcolor{stringliteral}{"100-continue"});
1366 
1367   InSequence enforceOrder;
1368 
1369   \textcolor{keyword}{auto} handler = openTransaction();
1370   handler->expectHeaders([&] (std::shared\_ptr<HTTPMessage> msg) \{
1371       EXPECT\_FALSE(msg->getIsChunked());
1372       EXPECT\_FALSE(msg->getIsUpgraded());
1373       EXPECT\_EQ(417, msg->getStatusCode());
1374     \});
1375   handler->expectEOM();
1376   handler->expectDetachTransaction();
1377 
1378   handler->sendRequest(req);
1379   readAndLoop(\textcolor{stringliteral}{"HTTP/1.1 417 Expectation Failed\(\backslash\)r\(\backslash\)n"}
1380               \textcolor{stringliteral}{"Content-Length: 0\(\backslash\)r\(\backslash\)n\(\backslash\)r\(\backslash\)n"});
1381 
1382   \textcolor{comment}{// Now make sure everything still works}
1383   testBasicRequest();
1384   EXPECT\_FALSE(sessionDestroyed\_);
1385   httpSession\_->destroy();
1386 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Upstream\+Session\+Test, 101\+Upgrade)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Session\+Test}}]{, }
\item[{101\+Upgrade}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_ae190f157f50455c2628b7b96b795f38b}


Definition at line 1388 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Get\+Request(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), and proxygen\+::\+H\+T\+T\+P\+Headers\+::set().


\begin{DoxyCode}
1388                                             \{
1389   \textcolor{comment}{// Test an upgrade request with sending 101 response. Then send}
1390   \textcolor{comment}{// some data and check the onBody callback contents}
1391   HTTPMessage req = getGetRequest();
1392   req.getHeaders().set(HTTP\_HEADER\_UPGRADE, \textcolor{stringliteral}{"http/2.0"});
1393 
1394   InSequence enforceOrder;
1395 
1396   \textcolor{keyword}{auto} handler = openTransaction();
1397   handler->expectHeaders([&] (std::shared\_ptr<HTTPMessage> msg) \{
1398       EXPECT\_FALSE(msg->getIsChunked());
1399       EXPECT\_EQ(101, msg->getStatusCode());
1400     \});
1401   EXPECT\_CALL(*handler, onUpgrade(\_));
1402   EXPECT\_CALL(*handler, onBody(\_))
1403     .WillOnce(ExpectString(\textcolor{stringliteral}{"Test Body\(\backslash\)r\(\backslash\)n"}));
1404   handler->expectEOM();
1405   handler->expectDetachTransaction();
1406 
1407   handler->sendRequest(req);
1408   eventBase\_.loop();
1409   readAndLoop(\textcolor{stringliteral}{"HTTP/1.1 101 Switching Protocols\(\backslash\)r\(\backslash\)n"}
1410               \textcolor{stringliteral}{"Upgrade: http/2.0\(\backslash\)r\(\backslash\)n\(\backslash\)r\(\backslash\)n"}
1411               \textcolor{stringliteral}{"Test Body\(\backslash\)r\(\backslash\)n"});
1412   readCallback\_->readEOF();
1413   eventBase\_.loop();
1414 
1415   CHECK\_EQ(httpSession\_->getNumOutgoingStreams(), 0);
1416   httpSession\_->destroy();
1417 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Upstream\+Session\+Test, Http\+Upgrade\+Native\+H2)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Session\+Test}}]{, }
\item[{Http\+Upgrade\+Native\+H2}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_aa32736cd0bae3bd5503381935431e48e}


Definition at line 1473 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
1473                                                      \{
1474   testSimpleUpgrade(\textcolor{stringliteral}{"h2c"}, \textcolor{stringliteral}{"h2c"}, CodecProtocol::HTTP\_2);
1475 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Upstream\+Session\+Test, Http\+Upgrade\+Native\+Unknown)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Session\+Test}}]{, }
\item[{Http\+Upgrade\+Native\+Unknown}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_aa45cdb231b91aba3e4ef32917aac8811}


Definition at line 1478 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
1478                                                           \{
1479   testSimpleUpgrade(\textcolor{stringliteral}{"blarf, h2c"}, \textcolor{stringliteral}{"h2c"}, CodecProtocol::HTTP\_2);
1480 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Upstream\+Session\+Test, Http\+Upgrade\+Native\+Whitespace)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Session\+Test}}]{, }
\item[{Http\+Upgrade\+Native\+Whitespace}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_ab4793e10d07bf49d3e36f8e74d38dcd7}


Definition at line 1483 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
1483                                                              \{
1484   testSimpleUpgrade(\textcolor{stringliteral}{"blarf, \(\backslash\)th2c\(\backslash\)t, xyz"}, \textcolor{stringliteral}{"h2c"},
1485                     CodecProtocol::HTTP\_2);
1486 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Upstream\+Session\+Test, Http\+Upgrade\+Native\+Junk)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Session\+Test}}]{, }
\item[{Http\+Upgrade\+Native\+Junk}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_aa38f62acdedf7201db32989b48a89b5d}


Definition at line 1489 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
1489                                                        \{
1490   testSimpleUpgrade(\textcolor{stringliteral}{",,,,   ,,\(\backslash\)t~^%$(*&@(@$^^*(,h2c"}, \textcolor{stringliteral}{"h2c"},
1491                     CodecProtocol::HTTP\_2);
1492 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Upstream\+Session\+Test, Http\+Upgrade101\+Unexpected)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Session\+Test}}]{, }
\item[{Http\+Upgrade101\+Unexpected}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a0fa166d71e2da858ed0de363310ea749}


Definition at line 1494 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
1494                                                           \{
1495   InSequence dummy;
1496   \textcolor{keyword}{auto} handler = openTransaction();
1497 
1498   EXPECT\_CALL(*handler, onError(\_));
1499   handler->expectDetachTransaction();
1500 
1501   handler->sendRequest();
1502   eventBase\_.loop();
1503   readAndLoop(folly::to<string>(\textcolor{stringliteral}{"HTTP/1.1 101 Switching Protocols\(\backslash\)r\(\backslash\)n"}
1504                                 \textcolor{stringliteral}{"Upgrade: spdy/3\(\backslash\)r\(\backslash\)n"}
1505                                 \textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"}));
1506   EXPECT\_EQ(readCallback\_, \textcolor{keyword}{nullptr});
1507   EXPECT\_TRUE(sessionDestroyed\_);
1508 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Upstream\+Session\+Test, Http\+Upgrade101\+Missing\+Upgrade)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Session\+Test}}]{, }
\item[{Http\+Upgrade101\+Missing\+Upgrade}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a7edafd87f13d8114e775af9aa96a1b06}


Definition at line 1510 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Upgrade\+Request().


\begin{DoxyCode}
1510                                                               \{
1511   InSequence dummy;
1512   \textcolor{keyword}{auto} handler = openTransaction();
1513 
1514   EXPECT\_CALL(*handler, onError(\_));
1515   handler->expectDetachTransaction();
1516 
1517   handler->sendRequest(getUpgradeRequest(\textcolor{stringliteral}{"spdy/3"}));
1518   readAndLoop(folly::to<string>(\textcolor{stringliteral}{"HTTP/1.1 101 Switching Protocols\(\backslash\)r\(\backslash\)n"}
1519                                 \textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"}));
1520   EXPECT\_EQ(readCallback\_, \textcolor{keyword}{nullptr});
1521   EXPECT\_TRUE(sessionDestroyed\_);
1522 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Upstream\+Session\+Test, Http\+Upgrade101\+Bogus\+Header)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Session\+Test}}]{, }
\item[{Http\+Upgrade101\+Bogus\+Header}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a05a79387118d3fc4add1c7ea487785ec}


Definition at line 1524 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Upgrade\+Request().


\begin{DoxyCode}
1524                                                            \{
1525   InSequence dummy;
1526   \textcolor{keyword}{auto} handler = openTransaction();
1527 
1528   EXPECT\_CALL(*handler, onError(\_));
1529   handler->expectDetachTransaction();
1530 
1531   handler->sendRequest(getUpgradeRequest(\textcolor{stringliteral}{"spdy/3"}));
1532   eventBase\_.loop();
1533   readAndLoop(folly::to<string>(\textcolor{stringliteral}{"HTTP/1.1 101 Switching Protocols\(\backslash\)r\(\backslash\)n"}
1534                                 \textcolor{stringliteral}{"Upgrade: blarf\(\backslash\)r\(\backslash\)n"}
1535                                 \textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"}));
1536   EXPECT\_EQ(readCallback\_, \textcolor{keyword}{nullptr});
1537   EXPECT\_TRUE(sessionDestroyed\_);
1538 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Upstream\+Session\+Test, Http\+Upgrade\+Post100)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Session\+Test}}]{, }
\item[{Http\+Upgrade\+Post100}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_afe42b992802adb4708faf713a13d64f4}


Definition at line 1540 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References make\+Buf().


\begin{DoxyCode}
1540                                                     \{
1541   InSequence dummy;
1542   \textcolor{keyword}{auto} handler = openTransaction();
1543 
1544   handler->expectHeaders([] (std::shared\_ptr<HTTPMessage> msg) \{
1545       EXPECT\_EQ(100, msg->getStatusCode());
1546     \});
1547   handler->expectHeaders([] (std::shared\_ptr<HTTPMessage> msg) \{
1548       EXPECT\_EQ(200, msg->getStatusCode());
1549     \});
1550   handler->expectBody();
1551   handler->expectEOM();
1552   handler->expectDetachTransaction();
1553 
1554   \textcolor{keyword}{auto} txn = handler->txn\_;
1555   HTTPMessage req = getUpgradePostRequest(100, \textcolor{stringliteral}{"h2c"}, \textcolor{keyword}{true} \textcolor{comment}{/* 100 */});
1556   txn->sendHeaders(req);
1557   \textcolor{keyword}{auto} buf = makeBuf(100);
1558   txn->sendBody(std::move(buf));
1559   txn->sendEOM();
1560   eventBase\_.loop();
1561   readAndLoop(folly::to<string>(\textcolor{stringliteral}{"HTTP/1.1 100 Continue\(\backslash\)r\(\backslash\)n"}
1562                                 \textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"}
1563                                 \textcolor{stringliteral}{"HTTP/1.1 101 Switching Protocols\(\backslash\)r\(\backslash\)n"}
1564                                 \textcolor{stringliteral}{"Upgrade: h2c\(\backslash\)r\(\backslash\)n"}
1565                                 \textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"}));
1566   readAndLoop(
1567     getResponseBuf(CodecProtocol::HTTP\_2, txn->getID(), 200, 100).\textcolor{keyword}{get}());
1568   httpSession\_->destroy();
1569 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Upstream\+Session\+Test, Http\+Upgrade\+Post100\+Http2)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Session\+Test}}]{, }
\item[{Http\+Upgrade\+Post100\+Http2}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a05a74ab916693937837c0c5d729724aa}


Definition at line 1571 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References make\+Buf().


\begin{DoxyCode}
1571                                                          \{
1572   InSequence dummy;
1573   \textcolor{keyword}{auto} handler = openTransaction();
1574 
1575   handler->expectHeaders([] (std::shared\_ptr<HTTPMessage> msg) \{
1576       EXPECT\_EQ(100, msg->getStatusCode());
1577     \});
1578   handler->expectHeaders([] (std::shared\_ptr<HTTPMessage> msg) \{
1579       EXPECT\_EQ(200, msg->getStatusCode());
1580     \});
1581   handler->expectBody();
1582   handler->expectEOM();
1583   handler->expectDetachTransaction();
1584 
1585   \textcolor{keyword}{auto} txn = handler->txn\_;
1586   HTTPMessage req = getUpgradePostRequest(100, \textcolor{stringliteral}{"h2c"});
1587   txn->sendHeaders(req);
1588   \textcolor{keyword}{auto} buf = makeBuf(100);
1589   txn->sendBody(std::move(buf));
1590   txn->sendEOM();
1591   eventBase\_.loop();
1592   readAndLoop(folly::to<string>(\textcolor{stringliteral}{"HTTP/1.1 101 Switching Protocols\(\backslash\)r\(\backslash\)n"}
1593                                 \textcolor{stringliteral}{"Upgrade: h2c\(\backslash\)r\(\backslash\)n"}
1594                                 \textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"}));
1595   readAndLoop(getResponseBuf(CodecProtocol::HTTP\_2,
1596                              txn->getID(), 200, 100, \textcolor{keyword}{true}).\textcolor{keyword}{get}());
1597   httpSession\_->destroy();
1598 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Upstream\+Session\+Test, Http\+Upgrade\+On\+Txn2)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Session\+Test}}]{, }
\item[{Http\+Upgrade\+On\+Txn2}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_af58177f5fcdfcd8c11eb60bf93a5c6c4}


Definition at line 1600 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Upgrade\+Request().


\begin{DoxyCode}
1600                                                    \{
1601   InSequence dummy;
1602   \textcolor{keyword}{auto} handler1 = openTransaction();
1603 
1604   handler1->expectHeaders([] (std::shared\_ptr<HTTPMessage> msg) \{
1605       EXPECT\_EQ(200, msg->getStatusCode());
1606     \});
1607   handler1->expectBody();
1608   handler1->expectEOM();
1609   handler1->expectDetachTransaction();
1610 
1611   \textcolor{keyword}{auto} txn = handler1->txn\_;
1612   HTTPMessage req = getUpgradeRequest(\textcolor{stringliteral}{"spdy/3"});
1613   txn->sendHeaders(req);
1614   txn->sendEOM();
1615   readAndLoop(\textcolor{stringliteral}{"HTTP/1.1 200 Ok\(\backslash\)r\(\backslash\)n"}
1616               \textcolor{stringliteral}{"Content-Length: 10\(\backslash\)r\(\backslash\)n"}
1617               \textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"}
1618               \textcolor{stringliteral}{"abcdefghij"});
1619   eventBase\_.loop();
1620 
1621   \textcolor{keyword}{auto} handler2 = openTransaction();
1622 
1623   txn = handler2->txn\_;
1624   txn->sendHeaders(req);
1625   txn->sendEOM();
1626 
1627   handler2->expectHeaders();
1628   handler2->expectEOM();
1629   handler2->expectDetachTransaction();
1630   readAndLoop(\textcolor{stringliteral}{"HTTP/1.1 200 OK\(\backslash\)r\(\backslash\)nContent-Length: 0\(\backslash\)r\(\backslash\)n\(\backslash\)r\(\backslash\)n"});
1631   httpSession\_->destroy();
1632 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Upstream\+Recv\+Stream\+Test, Upgrade\+Flow\+Control)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Recv\+Stream\+Test}}]{, }
\item[{Upgrade\+Flow\+Control}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_ab8f537c907bb08deaa579b28baabcdb1}


Definition at line 1641 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::\+H\+T\+T\+P2\+Codec\+::get\+Default\+Window\+Size(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::set\+Callback(), and settings.


\begin{DoxyCode}
1641                                                        \{
1642   InSequence dummy;
1643   testSimpleUpgrade(\textcolor{stringliteral}{"h2c"}, \textcolor{stringliteral}{"h2c"}, CodecProtocol::HTTP\_2);
1644 
1645   HTTP2Codec serverCodec(TransportDirection::DOWNSTREAM);
1646   NiceMock<MockHTTPCodecCallback> callbacks;
1647   serverCodec.setCallback(&callbacks);
1648   EXPECT\_CALL(callbacks, onSettings(\_))
1649     .WillOnce(Invoke([\textcolor{keyword}{this}] (\textcolor{keyword}{const} SettingsList& settings) \{
1650           \textcolor{keywordflow}{if} (flowControl\_[0] > 0) \{
1651             \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& setting: settings) \{
1652               \textcolor{keywordflow}{if} (setting.id == SettingsId::INITIAL\_WINDOW\_SIZE) \{
1653                 EXPECT\_EQ(flowControl\_[0], setting.value);
1654               \}
1655             \}
1656           \}
1657         \}));
1658   EXPECT\_CALL(callbacks, onWindowUpdate(0, flowControl\_[2] -
1659                                         serverCodec.getDefaultWindowSize()));
1660   \textcolor{keywordtype}{size\_t} initWindow = flowControl\_[0] > 0 ?
1661     flowControl\_[0] : serverCodec.getDefaultWindowSize();
1662   EXPECT\_CALL(callbacks, onWindowUpdate(1, flowControl\_[1] - initWindow));
1663   parseOutput(serverCodec);
1664 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+No\+Flush\+Upstream\+Session\+Test, Session\+Paused\+Start\+Paused)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf No\+Flush\+Upstream\+Session\+Test}}]{, }
\item[{Session\+Paused\+Start\+Paused}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_ad72d1d9766b0c9cf24b16f4f400eb9fc}


Definition at line 1690 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Get\+Request(), and make\+Buf().


\begin{DoxyCode}
1690                                                              \{
1691   \textcolor{comment}{// If the session is paused, new upstream transactions should start}
1692   \textcolor{comment}{// paused too.}
1693   HTTPMessage req = getGetRequest();
1694 
1695   InSequence enforceOrder;
1696 
1697   \textcolor{keyword}{auto} handler1 = openNiceTransaction();
1698   handler1->txn\_->sendHeaders(req);
1699   Mock::VerifyAndClearExpectations(handler1.get());
1700   \textcolor{comment}{// The session pauses all txns since no writeSuccess for too many bytes}
1701   handler1->expectEgressPaused();
1702   \textcolor{comment}{// Send a body big enough to pause egress}
1703   handler1->txn\_->sendBody(makeBuf(httpSession\_->getWriteBufferLimit()));
1704   eventBase\_.loop();
1705   Mock::VerifyAndClearExpectations(handler1.get());
1706 
1707   \textcolor{keyword}{auto} handler2 = openNiceTransaction(\textcolor{keyword}{true} \textcolor{comment}{/* expect start paused */});
1708   eventBase\_.loop();
1709   Mock::VerifyAndClearExpectations(handler2.get());
1710 
1711   httpSession\_->dropConnection();
1712 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+No\+Flush\+Upstream\+Session\+Test, Delete\+Txn\+On\+Unpause)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf No\+Flush\+Upstream\+Session\+Test}}]{, }
\item[{Delete\+Txn\+On\+Unpause}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a3d37b6a40fe9d26478da504d591cfb90}


Definition at line 1714 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Get\+Request(), and make\+Buf().


\begin{DoxyCode}
1714                                                        \{
1715   \textcolor{comment}{// Test where the handler gets onEgressPaused() and triggers another}
1716   \textcolor{comment}{// HTTPSession call to iterate over all transactions (to ensure nested}
1717   \textcolor{comment}{// iteration works).}
1718 
1719   HTTPMessage req = getGetRequest();
1720 
1721   InSequence enforceOrder;
1722 
1723   \textcolor{keyword}{auto} handler1 = openNiceTransaction();
1724   \textcolor{keyword}{auto} handler2 = openNiceTransaction();
1725   \textcolor{keyword}{auto} handler3 = openNiceTransaction();
1726   handler2->expectEgressPaused([\textcolor{keyword}{this}] \{
1727       \textcolor{comment}{// This time it is invoked by the session on all transactions}
1728       httpSession\_->dropConnection();
1729     \});
1730   handler2->txn\_->sendHeaders(req);
1731   \textcolor{comment}{// This happens when the body write fills the txn egress queue}
1732   \textcolor{comment}{// Send a body big enough to pause egress}
1733   handler2->txn\_->onIngressWindowUpdate(100);
1734   handler2->txn\_->sendBody(makeBuf(httpSession\_->getWriteBufferLimit() + 1));
1735   eventBase\_.loop();
1736 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P2\+Upstream\+Session\+Test, Server\+Push)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P2\+Upstream\+Session\+Test}}]{, }
\item[{Server\+Push}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a760b2d5ba8bb92f8223fba8b63ab77c8}


Definition at line 1798 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::\+Mock\+H\+T\+T\+P\+Handler\+::expect\+Body(), proxygen\+::\+Mock\+H\+T\+T\+P\+Handler\+::expect\+Detach\+Transaction(), proxygen\+::\+Mock\+H\+T\+T\+P\+Handler\+::expect\+E\+O\+M(), proxygen\+::\+Mock\+H\+T\+T\+P\+Handler\+::expect\+Headers(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), make\+Buf(), make\+Server\+Codec(), proxygen\+::\+H\+T\+T\+P\+Headers\+::set(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::set\+Handler(), proxygen\+::\+H\+T\+T\+P\+Message\+::set\+Status\+Code(), and proxygen\+::\+H\+T\+T\+P\+Message\+::set\+U\+R\+L().


\begin{DoxyCode}
1798                                              \{
1799   httpSession\_->setEgressSettings(\{\{SettingsId::ENABLE\_PUSH, 1\}\});
1800 
1801   \textcolor{keyword}{auto} egressCodec = makeServerCodec();
1802   folly::IOBufQueue output(folly::IOBufQueue::cacheChainLength());
1803 
1804   HTTPMessage push;
1805   push.getHeaders().set(\textcolor{stringliteral}{"HOST"}, \textcolor{stringliteral}{"www.foo.com"});
1806   push.setURL(\textcolor{stringliteral}{"https://www.foo.com/"});
1807   egressCodec->generateSettings(output);
1808   \textcolor{comment}{// PUSH\_PROMISE}
1809   egressCodec->generatePushPromise(output, 2, push, 1);
1810 
1811   \textcolor{comment}{// Pushed resource}
1812   HTTPMessage resp;
1813   resp.setStatusCode(200);
1814   resp.getHeaders().set(\textcolor{stringliteral}{"ohai"}, \textcolor{stringliteral}{"push"});
1815   egressCodec->generateHeader(output, 2, resp);
1816   \textcolor{keyword}{auto} buf = makeBuf(100);
1817   egressCodec->generateBody(output, 2, std::move(buf), HTTPCodec::NoPadding,
1818                             \textcolor{keyword}{true} \textcolor{comment}{/* eom */});
1819 
1820   \textcolor{comment}{// Original resource}
1821   resp.getHeaders().set(\textcolor{stringliteral}{"ohai"}, \textcolor{stringliteral}{"orig"});
1822   egressCodec->generateHeader(output, 1, resp);
1823   buf = makeBuf(100);
1824   egressCodec->generateBody(output, 1, std::move(buf), HTTPCodec::NoPadding,
1825                            \textcolor{keyword}{true} \textcolor{comment}{/* eom */});
1826 
1827   std::unique\_ptr<folly::IOBuf> input = output.move();
1828   input->coalesce();
1829 
1830   MockHTTPHandler pushHandler;
1831 
1832   InSequence enforceOrder;
1833 
1834   \textcolor{keyword}{auto} handler = openTransaction();
1835   EXPECT\_CALL(*handler, onPushedTransaction(\_))
1836     .WillOnce(Invoke([&pushHandler] (HTTPTransaction* pushTxn) \{
1837           pushTxn->setHandler(&pushHandler);
1838         \}));
1839   EXPECT\_CALL(pushHandler, setTransaction(\_));
1840   pushHandler.expectHeaders([&] (std::shared\_ptr<HTTPMessage> msg) \{
1841       EXPECT\_EQ(httpSession\_->getNumIncomingStreams(), 1);
1842       EXPECT\_TRUE(msg->getIsChunked());
1843       EXPECT\_FALSE(msg->getIsUpgraded());
1844       EXPECT\_EQ(msg->getPath(), \textcolor{stringliteral}{"/"});
1845       EXPECT\_EQ(msg->getHeaders().getSingleOrEmpty(HTTP\_HEADER\_HOST),
1846                 \textcolor{stringliteral}{"www.foo.com"});
1847     \});
1848   pushHandler.expectHeaders([&] (std::shared\_ptr<HTTPMessage> msg) \{
1849       EXPECT\_EQ(msg->getStatusCode(), 200);
1850       EXPECT\_EQ(msg->getHeaders().getSingleOrEmpty(\textcolor{stringliteral}{"ohai"}), \textcolor{stringliteral}{"push"});
1851     \});
1852   pushHandler.expectBody();
1853   pushHandler.expectEOM();
1854   pushHandler.expectDetachTransaction();
1855 
1856   handler->expectHeaders([&] (std::shared\_ptr<HTTPMessage> msg) \{
1857       EXPECT\_FALSE(msg->getIsUpgraded());
1858       EXPECT\_EQ(200, msg->getStatusCode());
1859       EXPECT\_EQ(msg->getHeaders().getSingleOrEmpty(\textcolor{stringliteral}{"ohai"}), \textcolor{stringliteral}{"orig"});
1860     \});
1861   handler->expectBody();
1862   handler->expectEOM();
1863   handler->expectDetachTransaction();
1864 
1865   handler->sendRequest();
1866   readAndLoop(input->data(), input->length());
1867 
1868   EXPECT\_EQ(httpSession\_->getNumIncomingStreams(), 0);
1869   httpSession\_->destroy();
1870 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+H\+T\+T\+P2\+Upstream\+Test, Parse\+Error\+No\+Txn)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+H\+T\+T\+P2\+Upstream\+Test}}]{, }
\item[{Parse\+Error\+No\+Txn}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a3dc1847248b3368075b5c97a0c8fbcf2}


Definition at line 1887 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Post\+Request(), proxygen\+::k\+Error\+Parse\+Header, proxygen\+::\+H\+T\+T\+P\+Exception\+::set\+Codec\+Status\+Code(), and proxygen\+::\+Exception\+::set\+Proxygen\+Error().


\begin{DoxyCode}
1887                                                \{
1888   \textcolor{comment}{// 1) Create streamID == 1}
1889   \textcolor{comment}{// 2) Send request}
1890   \textcolor{comment}{// 3) Detach handler}
1891   \textcolor{comment}{// 4) Get an ingress parse error on reply}
1892   \textcolor{comment}{// Expect that the codec should be asked to generate an abort on streamID==1}
1893 
1894   \textcolor{comment}{// Setup the codec expectations.}
1895   EXPECT\_CALL(*codecPtr\_, generateHeader(\_, \_, \_, \_, \_))
1896     .WillOnce(Invoke([] (folly::IOBufQueue& writeBuf, HTTPCodec::StreamID,
1897                          \textcolor{keyword}{const} HTTPMessage&, \textcolor{keywordtype}{bool}, HTTPHeaderSize*) \{
1898                        writeBuf.append(\textcolor{stringliteral}{"1"}, 1);
1899                      \}));
1900   EXPECT\_CALL(*codecPtr\_, generateEOM(\_, \_))
1901     .WillOnce(Return(20));
1902   EXPECT\_CALL(*codecPtr\_, generateRstStream(\_, 1, \_));
1903 
1904   \textcolor{comment}{// 1)}
1905   \textcolor{keyword}{auto} handler = openTransaction();
1906 
1907   \textcolor{comment}{// 2)}
1908   handler->sendRequest(getPostRequest());
1909 
1910   \textcolor{comment}{// 3) Note this sendAbort() doesn't destroy the txn since byte events are}
1911   \textcolor{comment}{// enqueued}
1912   handler->txn\_->sendAbort();
1913 
1914   \textcolor{comment}{// 4)}
1915   HTTPException ex(HTTPException::Direction::INGRESS\_AND\_EGRESS, \textcolor{stringliteral}{"foo"});
1916   ex.setProxygenError(kErrorParseHeader);
1917   ex.setCodecStatusCode(ErrorCode::REFUSED\_STREAM);
1918   codecCb\_->onError(1, ex, \textcolor{keyword}{true});
1919 
1920   \textcolor{comment}{// cleanup}
1921   handler->expectDetachTransaction();
1922   httpSession\_->dropConnection();
1923   eventBase\_.loop();
1924 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+H\+T\+T\+P\+Upstream\+Test, 0\+Max\+Outgoing\+Txns)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+H\+T\+T\+P\+Upstream\+Test}}]{, }
\item[{0\+Max\+Outgoing\+Txns}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a359a1aa8934e103b97de02ad57594780}


Definition at line 1926 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
1926                                                \{
1927   \textcolor{comment}{// Test where an upstream session gets a SETTINGS frame with 0 max}
1928   \textcolor{comment}{// outgoing transactions. In our implementation, we jsut send a GOAWAY}
1929   \textcolor{comment}{// and close the connection.}
1930 
1931   codecCb\_->onSettings(\{\{SettingsId::MAX\_CONCURRENT\_STREAMS, 0\}\});
1932   EXPECT\_TRUE(transactionsFull\_);
1933   httpSession\_->dropConnection();
1934 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+H\+T\+T\+P\+Upstream\+Test, Outgoing\+Txn\+Settings)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+H\+T\+T\+P\+Upstream\+Test}}]{, }
\item[{Outgoing\+Txn\+Settings}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a8270641b079bedf671809259bdc9f7cb}


Definition at line 1936 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
1936                                                   \{
1937   \textcolor{comment}{// Create 2 transactions, then receive a settings frame from}
1938   \textcolor{comment}{// the server indicating 1 parallel transaction at a time is allowed.}
1939   \textcolor{comment}{// Then get another SETTINGS frame indicating 100 max parallel}
1940   \textcolor{comment}{// transactions. Expect that HTTPSession invokes both info callbacks.}
1941 
1942   NiceMock<MockHTTPHandler> handler1;
1943   NiceMock<MockHTTPHandler> handler2;
1944   httpSession\_->newTransaction(&handler1);
1945   httpSession\_->newTransaction(&handler2);
1946 
1947   codecCb\_->onSettings(\{\{SettingsId::MAX\_CONCURRENT\_STREAMS, 1\}\});
1948   EXPECT\_TRUE(transactionsFull\_);
1949   codecCb\_->onSettings(\{\{SettingsId::MAX\_CONCURRENT\_STREAMS, 100\}\});
1950   EXPECT\_FALSE(transactionsFull\_);
1951   httpSession\_->dropConnection();
1952 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+H\+T\+T\+P\+Upstream\+Test, Ingress\+Goaway\+Drain)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+H\+T\+T\+P\+Upstream\+Test}}]{, }
\item[{Ingress\+Goaway\+Drain}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a46ad57ab662d29617f77d61751296ec4}


Definition at line 1954 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::make\+Response().


\begin{DoxyCode}
1954                                                  \{
1955   \textcolor{comment}{// Tests whether the session drains existing transactions and}
1956   \textcolor{comment}{// deletes itself after receiving a GOAWAY.}
1957 
1958   InSequence enforceOrder;
1959 
1960   \textcolor{keyword}{auto} handler = openTransaction();
1961   EXPECT\_CALL(*handler, onGoaway(ErrorCode::NO\_ERROR));
1962   handler->expectHeaders([&] (std::shared\_ptr<HTTPMessage> msg) \{
1963       EXPECT\_FALSE(msg->getIsUpgraded());
1964       EXPECT\_EQ(200, msg->getStatusCode());
1965     \});
1966   handler->expectEOM();
1967   handler->expectDetachTransaction();
1968 
1969   \textcolor{comment}{// Send the GET request}
1970   handler->sendRequest();
1971 
1972   \textcolor{comment}{// Receive GOAWAY frame with last good stream as 1}
1973   codecCb\_->onGoaway(1, ErrorCode::NO\_ERROR);
1974 
1975   \textcolor{comment}{// New transactions cannot be created afrer goaway}
1976   EXPECT\_FALSE(httpSession\_->isReusable());
1977   EXPECT\_EQ(httpSession\_->newTransaction(handler.get()), \textcolor{keyword}{nullptr});
1978 
1979   \textcolor{comment}{// Receive 200 OK}
1980   \textcolor{keyword}{auto} resp = makeResponse(200);
1981   codecCb\_->onMessageBegin(1, resp.get());
1982   codecCb\_->onHeadersComplete(1, std::move(resp));
1983   codecCb\_->onMessageComplete(1, \textcolor{keyword}{false});
1984   eventBase\_.loop();
1985 
1986   \textcolor{comment}{// Session will delete itself after getting the response}
1987 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+H\+T\+T\+P\+Upstream\+Test, Goaway)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+H\+T\+T\+P\+Upstream\+Test}}]{, }
\item[{Goaway}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a613b2dece65b29abac0128e0c753f970}


Definition at line 1989 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::\+Mock\+H\+T\+T\+P\+Handler\+::expect\+Detach\+Transaction(), proxygen\+::\+Mock\+H\+T\+T\+P\+Handler\+::expect\+E\+O\+M(), proxygen\+::\+Mock\+H\+T\+T\+P\+Handler\+::expect\+Headers(), proxygen\+::\+Mock\+H\+T\+T\+P\+Handler\+::expect\+Transaction(), proxygen\+::make\+Response(), and proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::send\+Request().


\begin{DoxyCode}
1989                                      \{
1990   \textcolor{comment}{// Make sure existing txns complete successfully even if we drain the}
1991   \textcolor{comment}{// upstream session}
1992   \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} numTxns = 10;
1993   MockHTTPHandler handler[numTxns];
1994 
1995   InSequence enforceOrder;
1996 
1997   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i = 0; i < numTxns; ++i) \{
1998     handler[i].expectTransaction();
1999     handler[i].expectHeaders([&] (std::shared\_ptr<HTTPMessage> msg) \{
2000         EXPECT\_FALSE(msg->getIsUpgraded());
2001         EXPECT\_EQ(200, msg->getStatusCode());
2002       \});
2003     httpSession\_->newTransaction(&handler[i]);
2004 
2005     \textcolor{comment}{// Send the GET request}
2006     handler[i].sendRequest();
2007 
2008     \textcolor{comment}{// Receive 200 OK}
2009     \textcolor{keyword}{auto} resp = makeResponse(200);
2010     codecCb\_->onMessageBegin(handler[i].txn\_->getID(), resp.get());
2011     codecCb\_->onHeadersComplete(handler[i].txn\_->getID(), std::move(resp));
2012   \}
2013 
2014   codecCb\_->onGoaway(numTxns * 2 + 1, ErrorCode::NO\_ERROR);
2015   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i = 0; i < numTxns; ++i) \{
2016     handler[i].expectEOM();
2017     handler[i].expectDetachTransaction();
2018     codecCb\_->onMessageComplete(i*2 + 1, \textcolor{keyword}{false});
2019   \}
2020   eventBase\_.loop();
2021 
2022   \textcolor{comment}{// Session will delete itself after drain completes}
2023 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+H\+T\+T\+P\+Upstream\+Test, Goaway\+Pre\+Headers)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+H\+T\+T\+P\+Upstream\+Test}}]{, }
\item[{Goaway\+Pre\+Headers}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_afd029c8335aaede79b16b325f599b10f}


Definition at line 2025 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::\+Mock\+H\+T\+T\+P\+Handler\+::expect\+Detach\+Transaction(), proxygen\+::\+Mock\+H\+T\+T\+P\+Handler\+::expect\+E\+O\+M(), proxygen\+::\+Mock\+H\+T\+T\+P\+Handler\+::expect\+Headers(), proxygen\+::\+Mock\+H\+T\+T\+P\+Handler\+::expect\+Transaction(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+I\+D(), proxygen\+::make\+Response(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::send\+Request(), and proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::txn\+\_\+.


\begin{DoxyCode}
2025                                                \{
2026   \textcolor{comment}{// Make sure existing txns complete successfully even if we drain the}
2027   \textcolor{comment}{// upstream session}
2028   MockHTTPHandler handler;
2029 
2030   InSequence enforceOrder;
2031 
2032   handler.expectTransaction();
2033   EXPECT\_CALL(*codecPtr\_, generateHeader(\_, \_, \_, \_, \_))
2034       .WillOnce(Invoke(
2035           [&](IOBufQueue& writeBuf,
2036               HTTPCodec::StreamID \textcolor{comment}{/*stream*/},
2037               \textcolor{keyword}{const} HTTPMessage& \textcolor{comment}{/*msg*/},
2038               \textcolor{keywordtype}{bool} \textcolor{comment}{/*eom*/},
2039               HTTPHeaderSize* \textcolor{comment}{/*size*/}) \{ writeBuf.append(\textcolor{stringliteral}{"HEADERS"}, 7); \}));
2040   handler.expectHeaders([&] (std::shared\_ptr<HTTPMessage> msg) \{
2041       EXPECT\_FALSE(msg->getIsUpgraded());
2042       EXPECT\_EQ(200, msg->getStatusCode());
2043     \});
2044   httpSession\_->newTransaction(&handler);
2045   httpSession\_->drain();
2046 
2047   \textcolor{comment}{// Send the GET request}
2048   handler.sendRequest();
2049 
2050   \textcolor{comment}{// Receive 200 OK}
2051   \textcolor{keyword}{auto} resp = makeResponse(200);
2052   codecCb\_->onMessageBegin(handler.txn_->getID(), resp.get());
2053   codecCb\_->onHeadersComplete(handler.txn_->getID(), std::move(resp));
2054 
2055   codecCb\_->onGoaway(1, ErrorCode::NO\_ERROR);
2056   handler.expectEOM();
2057   handler.expectDetachTransaction();
2058   codecCb\_->onMessageComplete(1, \textcolor{keyword}{false});
2059   eventBase\_.loop();
2060 
2061   \textcolor{keyword}{auto} buf = writes\_.move();
2062   ASSERT\_TRUE(buf != \textcolor{keyword}{nullptr});
2063   EXPECT\_EQ(buf->moveToFbString().data(), string(\textcolor{stringliteral}{"HEADERSGOAWAY"}));
2064   \textcolor{comment}{// Session will delete itself after drain completes}
2065 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+H\+T\+T\+P\+Upstream\+Test, No\+Window\+Update\+On\+Drain)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+H\+T\+T\+P\+Upstream\+Test}}]{, }
\item[{No\+Window\+Update\+On\+Drain}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_ab3469062cc5f35bfe7378f639be0672e}


Definition at line 2067 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References make\+Buf(), proxygen\+::make\+Response(), and stream\+ID.


\begin{DoxyCode}
2067                                                     \{
2068   EXPECT\_CALL(*codecPtr\_, supportsStreamFlowControl())
2069     .WillRepeatedly(Return(\textcolor{keyword}{true}));
2070 
2071   \textcolor{keyword}{auto} handler = openTransaction();
2072 
2073   handler->sendRequest();
2074   httpSession\_->drain();
2075   \textcolor{keyword}{auto} streamID = handler->txn\_->getID();
2076 
2077   EXPECT\_CALL(*handler, onGoaway(ErrorCode::NO\_ERROR));
2078   handler->expectHeaders([&] (std::shared\_ptr<HTTPMessage> msg) \{
2079       EXPECT\_FALSE(msg->getIsUpgraded());
2080       EXPECT\_EQ(200, msg->getStatusCode());
2081     \});
2082   EXPECT\_CALL(*handler, onBody(\_))
2083     .Times(3);
2084   handler->expectEOM();
2085 
2086   handler->expectDetachTransaction();
2087 
2088   uint32\_t outstanding = 0;
2089   uint32\_t sendWindow = 65536;
2090   uint32\_t toSend = sendWindow * 1.55;
2091 
2092   \textcolor{comment}{// We'll get exactly one window update because we are draining}
2093   EXPECT\_CALL(*codecPtr\_, generateWindowUpdate(\_, \_, \_))
2094       .WillOnce(Invoke([&](folly::IOBufQueue& writeBuf,
2095                            HTTPCodec::StreamID \textcolor{comment}{/*stream*/},
2096                            uint32\_t delta) \{
2097         EXPECT\_EQ(delta, sendWindow);
2098         outstanding -= delta;
2099         uint32\_t len = std::min(toSend, sendWindow - outstanding);
2100         EXPECT\_LT(len, sendWindow);
2101         toSend -= len;
2102         EXPECT\_EQ(toSend, 0);
2103         eventBase\_.tryRunAfterDelay(
2104             [\textcolor{keyword}{this}, streamID, len] \{
2105               failWrites\_ = \textcolor{keyword}{true};
2106               \textcolor{keyword}{auto} respBody = makeBuf(len);
2107               codecCb\_->onBody(streamID, std::move(respBody), 0);
2108               codecCb\_->onMessageComplete(streamID, \textcolor{keyword}{false});
2109             \},
2110             50);
2111 
2112         \textcolor{keyword}{const} std::string dummy(\textcolor{stringliteral}{"window"});
2113         writeBuf.append(dummy);
2114         \textcolor{keywordflow}{return} 6;
2115       \}));
2116 
2117   codecCb\_->onGoaway(streamID, ErrorCode::NO\_ERROR);
2118   \textcolor{keyword}{auto} resp = makeResponse(200);
2119   codecCb\_->onMessageBegin(streamID, resp.get());
2120   codecCb\_->onHeadersComplete(streamID, std::move(resp));
2121 
2122   \textcolor{comment}{// While there is room and the window and body to send}
2123   \textcolor{keywordflow}{while} (sendWindow - outstanding > 0 && toSend > 0) \{
2124     \textcolor{comment}{// Send up to a 36k chunk}
2125     uint32\_t len = std::min(toSend, uint32\_t(36000));
2126     \textcolor{comment}{// limited by the available window}
2127     len = std::min(len, sendWindow - outstanding);
2128     \textcolor{keyword}{auto} respBody = makeBuf(len);
2129     toSend -= len;
2130     outstanding += len;
2131     codecCb\_->onBody(streamID, std::move(respBody), 0);
2132   \}
2133 
2134   eventBase\_.loop();
2135 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+H\+T\+T\+P\+Upstream\+Test, Get\+With\+Body)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+H\+T\+T\+P\+Upstream\+Test}}]{, }
\item[{Get\+With\+Body}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a9f8af98ff4497b5eb464f1ae03189a0c}


Definition at line 2137 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Get\+Request(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), make\+Buf(), and proxygen\+::\+H\+T\+T\+P\+Headers\+::set().


\begin{DoxyCode}
2137                                           \{
2138   \textcolor{comment}{// Should be allowed to send a GET request with body.}
2139   NiceMock<MockHTTPHandler> handler;
2140   HTTPMessage req = getGetRequest();
2141   req.getHeaders().set(HTTP\_HEADER\_CONTENT\_LENGTH, \textcolor{stringliteral}{"10"});
2142 
2143   InSequence enforceOrder;
2144 
2145   EXPECT\_CALL(*codecPtr\_, generateHeader(\_, \_, \_, \_, \_));
2146   EXPECT\_CALL(*codecPtr\_, generateBody(\_, \_, \_, \_, \textcolor{keyword}{true}));
2147 
2148   \textcolor{keyword}{auto} txn = httpSession\_->newTransaction(&handler);
2149   txn->sendHeaders(req);
2150   txn->sendBody(makeBuf(10));
2151   txn->sendEOM();
2152 
2153   eventBase\_.loop();
2154   httpSession\_->dropConnection();
2155 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+H\+T\+T\+P\+Upstream\+Test, Header\+With\+Eom)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+H\+T\+T\+P\+Upstream\+Test}}]{, }
\item[{Header\+With\+Eom}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a63cb8316891100d256165094098713d0}


Definition at line 2157 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Get\+Request().


\begin{DoxyCode}
2157                                             \{
2158   NiceMock<MockHTTPHandler> handler;
2159   HTTPMessage req = getGetRequest();
2160   EXPECT\_CALL(*codecPtr\_, generateHeader(\_, \_, \_, \textcolor{keyword}{true}, \_));
2161 
2162   \textcolor{keyword}{auto} txn = httpSession\_->newTransaction(&handler);
2163   txn->sendHeadersWithEOM(req);
2164   eventBase\_.loop();
2165   EXPECT\_TRUE(txn->isEgressComplete());
2166   httpSession\_->dropConnection();
2167 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Test\+Abort\+Post1, Test)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Abort\+Post1}}]{, }
\item[{Test}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a0737a4da1a703e786ab883d26b3315c7}


Definition at line 2265 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
2265 \{ doAbortTest(); \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Test\+Abort\+Post2, Test)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Abort\+Post2}}]{, }
\item[{Test}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a2dd61385b0ddf2cc17f9e9e5e6e4430e}


Definition at line 2266 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
2266 \{ doAbortTest(); \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Test\+Abort\+Post3, Test)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Abort\+Post3}}]{, }
\item[{Test}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a34d062f00657483eac1fefaacc1253de}


Definition at line 2267 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
2267 \{ doAbortTest(); \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Test\+Abort\+Post4, Test)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Abort\+Post4}}]{, }
\item[{Test}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_aeccafd0e1decb2793ea3905380293d86}


Definition at line 2268 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
2268 \{ doAbortTest(); \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Test\+Abort\+Post5, Test)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Test\+Abort\+Post5}}]{, }
\item[{Test}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a2743efa685d63c184cd5995445d8013e}


Definition at line 2269 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
2269 \{ doAbortTest(); \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+H\+T\+T\+P\+Upstream\+Test, Abort\+Upgrade)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+H\+T\+T\+P\+Upstream\+Test}}]{, }
\item[{Abort\+Upgrade}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_abeb86a12c3aca80b0e53b68be918a6f5}


Definition at line 2271 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Post\+Request(), make\+Buf(), proxygen\+::make\+Response(), and stream\+ID.


\begin{DoxyCode}
2271                                            \{
2272   \textcolor{comment}{// This is basically the same test as above, just for the upgrade path}
2273   InSequence enforceOrder;
2274   StrictMock<MockHTTPHandler> handler;
2275   HTTPMessage req = getPostRequest(10);
2276 
2277   std::unique\_ptr<HTTPMessage> resp = makeResponse(200);
2278 
2279   handler.expectTransaction();
2280   EXPECT\_CALL(*codecPtr\_, generateHeader(\_, \_, \_, \_, \_));
2281 
2282   \textcolor{keyword}{auto} txn = httpSession\_->newTransaction(&handler);
2283   \textcolor{keyword}{const} \textcolor{keyword}{auto} streamID = txn->getID();
2284   txn->sendHeaders(req);
2285   txn->sendBody(makeBuf(5)); \textcolor{comment}{// only send half the body}
2286 
2287   handler.expectHeaders();
2288   codecCb\_->onHeadersComplete(streamID, std::move(resp));
2289 
2290   EXPECT\_CALL(*codecPtr\_, generateRstStream(\_, streamID, \_));
2291   handler.expectDetachTransaction();
2292   EXPECT\_CALL(*codecPtr\_, generateRstStream(\_, streamID,
2293                                             ErrorCode::\_SPDY\_INVALID\_STREAM));
2294   txn->sendAbort();
2295   codecCb\_->onMessageComplete(streamID, \textcolor{keyword}{true}); \textcolor{comment}{// upgrade}
2296   EXPECT\_CALL(*codecPtr\_, generateRstStream(\_, streamID,
2297                                             ErrorCode::\_SPDY\_INVALID\_STREAM));
2298   codecCb\_->onMessageComplete(streamID, \textcolor{keyword}{false}); \textcolor{comment}{// eom}
2299 
2300   eventBase\_.loop();
2301 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+H\+T\+T\+P\+Upstream\+Test, Drain\+Before\+Send\+Headers)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+H\+T\+T\+P\+Upstream\+Test}}]{, }
\item[{Drain\+Before\+Send\+Headers}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a6668cbd4e07aa3442e4cc48fbc3d3444}


Definition at line 2303 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::make\+Response().


\begin{DoxyCode}
2303                                                      \{
2304   \textcolor{comment}{// Test that drain on session before sendHeaders() is called on open txn}
2305 
2306   InSequence enforceOrder;
2307   MockHTTPHandler pushHandler;
2308 
2309   \textcolor{keyword}{auto} handler = openTransaction();
2310   EXPECT\_CALL(*codecPtr\_, generateHeader(\_, \_, \_, \_, \_));
2311 
2312   handler->expectHeaders();
2313   handler->expectEOM();
2314   handler->expectDetachTransaction();
2315 
2316   httpSession\_->drain();
2317   handler->sendRequest();
2318   codecCb\_->onHeadersComplete(handler->txn\_->getID(), makeResponse(200));
2319   codecCb\_->onMessageComplete(handler->txn\_->getID(), \textcolor{keyword}{false}); \textcolor{comment}{// eom}
2320 
2321   eventBase\_.loop();
2322 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+H\+T\+T\+P2\+Upstream\+Test, Receive\+Double\+Goaway)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+H\+T\+T\+P2\+Upstream\+Test}}]{, }
\item[{Receive\+Double\+Goaway}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a464ea1a7de7ff1ab18253c205b9a73f8}


Definition at line 2324 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Get\+Request(), proxygen\+::\+Exception\+::get\+Proxygen\+Error(), proxygen\+::\+Exception\+::has\+Proxygen\+Error(), proxygen\+::k\+Error\+Stream\+Unacknowledged, and proxygen\+::\+Exception\+::what().


\begin{DoxyCode}
2324                                                    \{
2325   \textcolor{comment}{// Test that we handle receiving two goaways correctly}
2326 
2327   InSequence enforceOrder;
2328   \textcolor{keyword}{auto} req = getGetRequest();
2329 
2330   \textcolor{comment}{// Open 2 txns but doesn't send headers yet}
2331   \textcolor{keyword}{auto} handler1 = openTransaction();
2332   \textcolor{keyword}{auto} handler2 = openTransaction();
2333 
2334   \textcolor{comment}{// Get first goaway acking many un-started txns}
2335   handler1->expectGoaway();
2336   handler2->expectGoaway();
2337   codecCb\_->onGoaway(101, ErrorCode::NO\_ERROR);
2338 
2339   \textcolor{comment}{// This txn should be alive since it was ack'd by the above goaway}
2340   handler1->txn\_->sendHeaders(req);
2341 
2342   \textcolor{comment}{// Second goaway acks the only the current outstanding transaction}
2343   handler1->expectGoaway();
2344   handler2->expectGoaway();
2345   handler2->expectError([&] (\textcolor{keyword}{const} HTTPException& err) \{
2346       EXPECT\_TRUE(err.hasProxygenError());
2347       EXPECT\_EQ(err.getProxygenError(), kErrorStreamUnacknowledged);
2348       ASSERT\_EQ(
2349         folly::to<std::string>(\textcolor{stringliteral}{"StreamUnacknowledged on transaction id: "},
2350                                handler2->txn\_->getID()),
2351         std::string(err.what()));
2352     \});
2353   handler2->expectDetachTransaction();
2354   codecCb\_->onGoaway(handler1->txn\_->getID(), ErrorCode::NO\_ERROR);
2355 
2356   \textcolor{comment}{// Clean up}
2357   httpSession\_->drain();
2358   EXPECT\_CALL(*codecPtr\_, generateRstStream(\_, handler1->txn\_->getID(), \_));
2359   handler1->expectDetachTransaction();
2360   handler1->txn\_->sendAbort();
2361   eventBase\_.loop();
2362 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+H\+T\+T\+P2\+Upstream\+Test, Server\+Push\+Invalid\+Assoc)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+H\+T\+T\+P2\+Upstream\+Test}}]{, }
\item[{Server\+Push\+Invalid\+Assoc}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a16e5aa4e725932ec8ff5c8bfc8e1a1bb}


Definition at line 2364 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Get\+Request(), proxygen\+::make\+Response(), and stream\+ID.


\begin{DoxyCode}
2364                                                       \{
2365   \textcolor{comment}{// Test that protocol error is generated on server push}
2366   \textcolor{comment}{// with invalid assoc stream id}
2367   InSequence enforceOrder;
2368   \textcolor{keyword}{auto} req = getGetRequest();
2369   \textcolor{keyword}{auto} handler = openTransaction();
2370 
2371   \textcolor{keywordtype}{int} streamID = handler->txn\_->getID();
2372   \textcolor{keywordtype}{int} pushID = streamID + 1;
2373   \textcolor{keywordtype}{int} badAssocID = streamID + 2;
2374 
2375   EXPECT\_CALL(*codecPtr\_,
2376               generateRstStream(\_, pushID, ErrorCode::PROTOCOL\_ERROR));
2377   EXPECT\_CALL(*codecPtr\_,
2378               generateRstStream(\_, pushID, ErrorCode::\_SPDY\_INVALID\_STREAM))
2379     .Times(2);
2380 
2381   \textcolor{keyword}{auto} resp = makeResponse(200);
2382   codecCb\_->onPushMessageBegin(pushID, badAssocID, resp.get());
2383   codecCb\_->onHeadersComplete(pushID, std::move(resp));
2384   codecCb\_->onMessageComplete(pushID, \textcolor{keyword}{false});
2385 
2386   handler->expectHeaders([&] (std::shared\_ptr<HTTPMessage> msg) \{
2387       EXPECT\_FALSE(msg->getIsUpgraded());
2388       EXPECT\_EQ(200, msg->getStatusCode());
2389     \});
2390   handler->expectEOM();
2391 
2392   resp = makeResponse(200);
2393   codecCb\_->onMessageBegin(streamID, resp.get());
2394   codecCb\_->onHeadersComplete(streamID, std::move(resp));
2395   codecCb\_->onMessageComplete(streamID, \textcolor{keyword}{false});
2396 
2397   \textcolor{comment}{// Cleanup}
2398   EXPECT\_CALL(*codecPtr\_, generateRstStream(\_, streamID, \_));
2399   EXPECT\_CALL(*handler, detachTransaction());
2400   handler->terminate();
2401 
2402   EXPECT\_TRUE(!httpSession\_->hasActiveTransactions());
2403   httpSession\_->destroy();
2404 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+H\+T\+T\+P2\+Upstream\+Test, Server\+Push\+After\+Fin)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+H\+T\+T\+P2\+Upstream\+Test}}]{, }
\item[{Server\+Push\+After\+Fin}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a2fb0068c7e858d383b865122b91047ce}


Definition at line 2406 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Get\+Request(), proxygen\+::make\+Response(), and stream\+ID.


\begin{DoxyCode}
2406                                                   \{
2407   \textcolor{comment}{// Test that protocol error is generated on server push}
2408   \textcolor{comment}{// after FIN is received on regular response on the stream}
2409   InSequence enforceOrder;
2410   \textcolor{keyword}{auto} req = getGetRequest();
2411   \textcolor{keyword}{auto} handler = openTransaction();
2412 
2413   \textcolor{keywordtype}{int} streamID = handler->txn\_->getID();
2414   \textcolor{keywordtype}{int} pushID = streamID + 1;
2415 
2416   handler->expectHeaders([&] (std::shared\_ptr<HTTPMessage> msg) \{
2417       EXPECT\_FALSE(msg->getIsUpgraded());
2418       EXPECT\_EQ(200, msg->getStatusCode());
2419     \});
2420   handler->expectEOM();
2421 
2422   \textcolor{keyword}{auto} resp = makeResponse(200);
2423   codecCb\_->onMessageBegin(streamID, resp.get());
2424   codecCb\_->onHeadersComplete(streamID, std::move(resp));
2425   codecCb\_->onMessageComplete(streamID, \textcolor{keyword}{false});
2426 
2427   EXPECT\_CALL(*codecPtr\_,
2428               generateRstStream(\_, pushID, ErrorCode::PROTOCOL\_ERROR))
2429     .WillOnce(InvokeWithoutArgs([\textcolor{keyword}{this}] \{
2430             \textcolor{comment}{// Verify that the assoc txn is still present}
2431             EXPECT\_TRUE(httpSession\_->hasActiveTransactions());
2432             \textcolor{keywordflow}{return} 1;
2433           \}));
2434   EXPECT\_CALL(*codecPtr\_,
2435               generateRstStream(\_, pushID, ErrorCode::\_SPDY\_INVALID\_STREAM))
2436     .Times(2);
2437 
2438   resp = makeResponse(200);
2439   codecCb\_->onPushMessageBegin(pushID, streamID, resp.get());
2440   codecCb\_->onHeadersComplete(pushID, std::move(resp));
2441   codecCb\_->onMessageComplete(pushID, \textcolor{keyword}{false});
2442 
2443   \textcolor{comment}{// Cleanup}
2444   EXPECT\_CALL(*codecPtr\_, generateRstStream(\_, streamID, \_));
2445   EXPECT\_CALL(*handler, detachTransaction());
2446   handler->terminate();
2447 
2448   EXPECT\_TRUE(!httpSession\_->hasActiveTransactions());
2449   httpSession\_->destroy();
2450 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+H\+T\+T\+P2\+Upstream\+Test, Server\+Push\+Handler\+Install\+Fail)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+H\+T\+T\+P2\+Upstream\+Test}}]{, }
\item[{Server\+Push\+Handler\+Install\+Fail}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a0f4d8f12921c04f0e76e0fb05d3e7708}


Definition at line 2452 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Get\+Request(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::set\+Handler(), and stream\+ID.


\begin{DoxyCode}
2452                                                             \{
2453   \textcolor{comment}{// Test that REFUSED\_STREAM error is generated when the session}
2454   \textcolor{comment}{// fails to install the server push handler}
2455   InSequence enforceOrder;
2456   \textcolor{keyword}{auto} req = getGetRequest();
2457   \textcolor{keyword}{auto} handler = openTransaction();
2458 
2459   \textcolor{keywordtype}{int} streamID = handler->txn\_->getID();
2460   \textcolor{keywordtype}{int} pushID = streamID + 1;
2461 
2462   EXPECT\_CALL(*handler, onPushedTransaction(\_))
2463     .WillOnce(Invoke([] (HTTPTransaction* txn) \{
2464             \textcolor{comment}{// Intentionally unset the handler on the upstream push txn}
2465             txn->setHandler(\textcolor{keyword}{nullptr});
2466           \}));
2467   EXPECT\_CALL(*codecPtr\_,
2468               generateRstStream(\_, pushID, ErrorCode::REFUSED\_STREAM));
2469   EXPECT\_CALL(*codecPtr\_,
2470               generateRstStream(\_, pushID, ErrorCode::\_SPDY\_INVALID\_STREAM))
2471     .Times(2);
2472 
2473   \textcolor{keyword}{auto} resp = std::make\_unique<HTTPMessage>();
2474   resp->setStatusCode(200);
2475   resp->setStatusMessage(\textcolor{stringliteral}{"OK"});
2476   codecCb\_->onPushMessageBegin(pushID, streamID, resp.get());
2477   codecCb\_->onHeadersComplete(pushID, std::move(resp));
2478   codecCb\_->onMessageComplete(pushID, \textcolor{keyword}{false});
2479 
2480   handler->expectHeaders([&] (std::shared\_ptr<HTTPMessage> msg) \{
2481       EXPECT\_FALSE(msg->getIsUpgraded());
2482       EXPECT\_EQ(200, msg->getStatusCode());
2483     \});
2484   handler->expectEOM();
2485 
2486   resp = std::make\_unique<HTTPMessage>();
2487   resp->setStatusCode(200);
2488   resp->setStatusMessage(\textcolor{stringliteral}{"OK"});
2489   codecCb\_->onMessageBegin(streamID, resp.get());
2490   codecCb\_->onHeadersComplete(streamID, std::move(resp));
2491   codecCb\_->onMessageComplete(streamID, \textcolor{keyword}{false});
2492 
2493   \textcolor{comment}{// Cleanup}
2494   EXPECT\_CALL(*codecPtr\_, generateRstStream(\_, streamID, \_));
2495   EXPECT\_CALL(*handler, detachTransaction());
2496   handler->terminate();
2497 
2498   EXPECT\_TRUE(!httpSession\_->hasActiveTransactions());
2499   httpSession\_->destroy();
2500 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+H\+T\+T\+P2\+Upstream\+Test, Server\+Push\+Unhandled\+Assoc)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+H\+T\+T\+P2\+Upstream\+Test}}]{, }
\item[{Server\+Push\+Unhandled\+Assoc}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_ad52c5435ffcfc9fca54c9dec1b3f9948}


Definition at line 2502 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Get\+Request(), and stream\+ID.


\begin{DoxyCode}
2502                                                         \{
2503   \textcolor{comment}{// Test that REFUSED\_STREAM error is generated when the assoc txn}
2504   \textcolor{comment}{// is unhandled}
2505   InSequence enforceOrder;
2506   \textcolor{keyword}{auto} req = getGetRequest();
2507   \textcolor{keyword}{auto} handler = openTransaction();
2508 
2509   \textcolor{keywordtype}{int} streamID = handler->txn\_->getID();
2510   \textcolor{keywordtype}{int} pushID = streamID + 1;
2511 
2512   \textcolor{comment}{// Forcefully unset the handler on the assoc txn}
2513   handler->txn\_->setHandler(\textcolor{keyword}{nullptr});
2514 
2515   EXPECT\_CALL(*codecPtr\_,
2516               generateRstStream(\_, pushID, ErrorCode::REFUSED\_STREAM));
2517   EXPECT\_CALL(*codecPtr\_,
2518               generateRstStream(\_, pushID, ErrorCode::\_SPDY\_INVALID\_STREAM))
2519     .Times(2);
2520 
2521   \textcolor{keyword}{auto} resp = std::make\_unique<HTTPMessage>();
2522   resp->setStatusCode(200);
2523   resp->setStatusMessage(\textcolor{stringliteral}{"OK"});
2524   codecCb\_->onPushMessageBegin(pushID, streamID, resp.get());
2525   codecCb\_->onHeadersComplete(pushID, std::move(resp));
2526   codecCb\_->onMessageComplete(pushID, \textcolor{keyword}{false});
2527 
2528   \textcolor{comment}{// Cleanup}
2529   EXPECT\_CALL(*codecPtr\_, generateRstStream(\_, streamID, \_));
2530   handler->terminate();
2531 
2532   EXPECT\_TRUE(!httpSession\_->hasActiveTransactions());
2533   httpSession\_->destroy();
2534 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+H\+T\+T\+P\+Upstream\+Test, Headers\+Then\+Body\+Then\+Headers)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+H\+T\+T\+P\+Upstream\+Test}}]{, }
\item[{Headers\+Then\+Body\+Then\+Headers}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a3ca17b2ce0ef75161741a9aec734998b}


Definition at line 2536 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Get\+Request(), proxygen\+::\+Exception\+::get\+Proxygen\+Error(), proxygen\+::\+Exception\+::has\+Proxygen\+Error(), proxygen\+::k\+Error\+Ingress\+State\+Transition, make\+Buf(), proxygen\+::make\+Response(), and proxygen\+::\+Exception\+::what().


\begin{DoxyCode}
2536                                                          \{
2537   HTTPMessage req = getGetRequest();
2538   \textcolor{keyword}{auto} handler = openTransaction();
2539   handler->txn\_->sendHeaders(req);
2540 
2541   handler->expectHeaders();
2542   EXPECT\_CALL(*handler, onBody(\_));
2543   \textcolor{comment}{// After getting the second headers, transaction will detach the handler}
2544   handler->expectError([&] (\textcolor{keyword}{const} HTTPException& err) \{
2545       EXPECT\_TRUE(err.hasProxygenError());
2546       EXPECT\_EQ(err.getProxygenError(), kErrorIngressStateTransition);
2547       ASSERT\_EQ(\textcolor{stringliteral}{"Invalid ingress state transition, state=RegularBodyReceived, "}
2548                 \textcolor{stringliteral}{"event=onHeaders, streamID=1"},
2549                 std::string(err.what()));
2550     \});
2551   handler->expectDetachTransaction();
2552   \textcolor{keyword}{auto} resp = makeResponse(200);
2553   codecCb\_->onMessageBegin(1, resp.get());
2554   codecCb\_->onHeadersComplete(1, std::move(resp));
2555   codecCb\_->onBody(1, makeBuf(20), 0);
2556   \textcolor{comment}{// Now receive headers again, on the same stream (illegal!)}
2557   codecCb\_->onHeadersComplete(1, makeResponse(200));
2558   eventBase\_.loop();
2559 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+H\+T\+T\+P2\+Upstream\+Test, Delay\+Upstream\+Window\+Update)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+H\+T\+T\+P2\+Upstream\+Test}}]{, }
\item[{Delay\+Upstream\+Window\+Update}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a691baf3bd71e316cfb170d8bd7f6fd9c}


Definition at line 2561 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Get\+Request().


\begin{DoxyCode}
2561                                                          \{
2562   EXPECT\_CALL(*codecPtr\_, supportsStreamFlowControl())
2563     .WillRepeatedly(Return(\textcolor{keyword}{true}));
2564 
2565   \textcolor{keyword}{auto} handler = openTransaction();
2566   handler->txn\_->setReceiveWindow(1000000); \textcolor{comment}{// One miiiillion}
2567 
2568   InSequence enforceOrder;
2569   EXPECT\_CALL(*codecPtr\_, generateHeader(\_, \_, \_, \_, \_));
2570   EXPECT\_CALL(*codecPtr\_, generateWindowUpdate(\_, \_, \_));
2571 
2572   HTTPMessage req = getGetRequest();
2573   handler->txn\_->sendHeaders(req);
2574   handler->expectDetachTransaction();
2575   handler->txn\_->sendAbort();
2576   httpSession\_->destroy();
2577 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Mock\+H\+T\+T\+P\+Upstream\+Test, Force\+Shutdown\+In\+Set\+Transaction)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+H\+T\+T\+P\+Upstream\+Test}}]{, }
\item[{Force\+Shutdown\+In\+Set\+Transaction}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a9e653c4224277f216d6cb04d0132af32}


Definition at line 2579 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::\+Exception\+::get\+Proxygen\+Error(), proxygen\+::\+Exception\+::has\+Proxygen\+Error(), proxygen\+::k\+Error\+Dropped, and proxygen\+::\+Exception\+::what().


\begin{DoxyCode}
2579                                                             \{
2580   StrictMock<MockHTTPHandler> handler;
2581   handler.expectTransaction([&] (HTTPTransaction* txn) \{
2582       handler.txn\_ = txn;
2583       httpSession\_->dropConnection();
2584     \});
2585   handler.expectError([&] (\textcolor{keyword}{const} HTTPException& err) \{
2586       EXPECT\_TRUE(err.hasProxygenError());
2587       EXPECT\_EQ(err.getProxygenError(), kErrorDropped);
2588       ASSERT\_EQ(folly::to<std::string>(\textcolor{stringliteral}{"Dropped on transaction id: "},
2589                                        handler.txn\_->getID()),
2590         std::string(err.what()));
2591     \});
2592   handler.expectDetachTransaction();
2593   (void)httpSession\_->newTransaction(&handler);
2594 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P2\+Upstream\+Session\+Test, Test\+Replay\+Safety\+Callback)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P2\+Upstream\+Session\+Test}}]{, }
\item[{Test\+Replay\+Safety\+Callback}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a681429553c0c769da1c929939484dd5b}


Definition at line 2596 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport\+::add\+Waiting\+For\+Replay\+Safety().


\begin{DoxyCode}
2596                                                            \{
2597   \textcolor{keyword}{auto} sock = \textcolor{keyword}{dynamic\_cast<}HTTPTransaction::Transport*\textcolor{keyword}{>}(httpSession\_);
2598 
2599   StrictMock<folly::test::MockReplaySafetyCallback> cb1;
2600   StrictMock<folly::test::MockReplaySafetyCallback> cb2;
2601   StrictMock<folly::test::MockReplaySafetyCallback> cb3;
2602 
2603   EXPECT\_CALL(*transport\_, isReplaySafe())
2604     .WillRepeatedly(Return(\textcolor{keyword}{false}));
2605   sock->addWaitingForReplaySafety(&cb1);
2606   sock->addWaitingForReplaySafety(&cb2);
2607   sock->addWaitingForReplaySafety(&cb3);
2608   sock->removeWaitingForReplaySafety(&cb2);
2609 
2610   ON\_CALL(*transport\_, isReplaySafe())
2611     .WillByDefault(Return(\textcolor{keyword}{true}));
2612   EXPECT\_CALL(cb1, onReplaySafe\_());
2613   EXPECT\_CALL(cb3, onReplaySafe\_());
2614   replaySafetyCallback\_->onReplaySafe();
2615 
2616   httpSession\_->destroy();
2617 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P2\+Upstream\+Session\+Test, Test\+Already\+Replay\+Safe)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P2\+Upstream\+Session\+Test}}]{, }
\item[{Test\+Already\+Replay\+Safe}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a3a071b303c47e64742a48ccce83c179d}


Definition at line 2619 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
2619                                                         \{
2620   \textcolor{keyword}{auto} sock = \textcolor{keyword}{dynamic\_cast<}HTTPTransaction::Transport*\textcolor{keyword}{>}(httpSession\_);
2621 
2622   StrictMock<folly::test::MockReplaySafetyCallback> cb;
2623 
2624   EXPECT\_CALL(*transport\_, isReplaySafe())
2625     .WillRepeatedly(Return(\textcolor{keyword}{true}));
2626   EXPECT\_CALL(cb, onReplaySafe\_());
2627   sock->addWaitingForReplaySafety(&cb);
2628 
2629   httpSession\_->destroy();
2630 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P2\+Upstream\+Session\+Test, Test\+Chained\+Buf\+Ingress)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P2\+Upstream\+Session\+Test}}]{, }
\item[{Test\+Chained\+Buf\+Ingress}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_afd6d890b3e022665d28856b9e14708ce}


Definition at line 2632 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
2632                                                         \{
2633   \textcolor{keyword}{auto} buf = folly::IOBuf::copyBuffer(\textcolor{stringliteral}{"hi"});
2634   buf->prependChain(folly::IOBuf::copyBuffer(\textcolor{stringliteral}{"hello"}));
2635 
2636   MockHTTPSessionInfoCallback infoCb;
2637   this->httpSession\_->setInfoCallback(&infoCb);
2638 
2639   EXPECT\_CALL(infoCb, onRead(\_, 7));
2640   readCallback\_->readBufferAvailable(std::move(buf));
2641 
2642   httpSession\_->destroy();
2643 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P2\+Upstream\+Session\+Test, Attach\+Detach)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P2\+Upstream\+Session\+Test}}]{, }
\item[{Attach\+Detach}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a89805bc738b38a125a885fa9bd5a7bd3}


Definition at line 2645 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References make\+Buf(), make\+Server\+Codec(), and proxygen\+::\+H\+T\+T\+P\+Message\+::set\+Status\+Code().


\begin{DoxyCode}
2645                                                \{
2646   folly::EventBase base;
2647   \textcolor{keyword}{auto} timer =
2648     folly::HHWheelTimer::newTimer(
2649       &base,
2650       std::chrono::milliseconds(folly::HHWheelTimer::DEFAULT\_TICK\_INTERVAL),
2651       TimeoutManager::InternalEnum::INTERNAL, std::chrono::milliseconds(500));
2652   WheelTimerInstance timerInstance(timer.get());
2653   uint64\_t filterCount = 0;
2654   \textcolor{keyword}{auto} fn = [&filterCount](HTTPCodecFilter* \textcolor{comment}{/*filter*/}) \{ filterCount++; \};
2655 
2656   InSequence enforceOrder;
2657   \textcolor{keyword}{auto} egressCodec = makeServerCodec();
2658   folly::IOBufQueue output(folly::IOBufQueue::cacheChainLength());
2659   egressCodec->generateConnectionPreface(output);
2660   egressCodec->generateSettings(output);
2661 
2662   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = 0; i < 2; i++) \{
2663     \textcolor{keyword}{auto} handler = openTransaction();
2664     handler->expectHeaders([&] (std::shared\_ptr<HTTPMessage> msg) \{
2665         EXPECT\_EQ(200, msg->getStatusCode());
2666       \});
2667     handler->expectBody();
2668     handler->expectEOM();
2669     handler->expectDetachTransaction();
2670 
2671     HTTPMessage resp;
2672     resp.setStatusCode(200);
2673     egressCodec->generateHeader(output, handler->txn\_->getID(), resp);
2674     egressCodec->generateBody(output, handler->txn\_->getID(), makeBuf(20),
2675                               HTTPCodec::NoPadding, \textcolor{keyword}{true} \textcolor{comment}{/* eom */});
2676 
2677     handler->sendRequest();
2678     \textcolor{keyword}{auto} buf = output.move();
2679     buf->coalesce();
2680     readAndLoop(buf.get());
2681 
2682     httpSession\_->detachThreadLocals();
2683     httpSession\_->attachThreadLocals(&base, \textcolor{keyword}{nullptr}, timerInstance, \textcolor{keyword}{nullptr}, fn,
2684                                      \textcolor{keyword}{nullptr}, \textcolor{keyword}{nullptr});
2685     EXPECT\_EQ(filterCount, 2);
2686     filterCount = 0;
2687     base.loopOnce();
2688   \}
2689   httpSession\_->destroy();
2690 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P2\+Upstream\+Session\+Test, Detach\+Flow\+Control\+Timeout)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P2\+Upstream\+Session\+Test}}]{, }
\item[{Detach\+Flow\+Control\+Timeout}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a662e8adacd6afa72a789adc651be6d92}


Definition at line 2692 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.



References proxygen\+::get\+Post\+Request(), make\+Buf(), make\+Server\+Codec(), R\+E\+G\+I\+S\+T\+E\+R\+\_\+\+T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+P(), and proxygen\+::\+H\+T\+T\+P\+Message\+::set\+Status\+Code().


\begin{DoxyCode}
2692                                                            \{
2693   folly::EventBase base;
2694   \textcolor{keyword}{auto} timer =
2695     folly::HHWheelTimer::newTimer(
2696       &base,
2697       std::chrono::milliseconds(folly::HHWheelTimer::DEFAULT\_TICK\_INTERVAL),
2698       TimeoutManager::InternalEnum::INTERNAL, std::chrono::milliseconds(500));
2699   WheelTimerInstance timerInstance(timer.get());
2700   uint64\_t filterCount = 0;
2701   \textcolor{keyword}{auto} fn = [&filterCount](HTTPCodecFilter* \textcolor{comment}{/*filter*/}) \{ filterCount++; \};
2702 
2703   InSequence enforceOrder;
2704   \textcolor{keyword}{auto} egressCodec = makeServerCodec();
2705   folly::IOBufQueue output(folly::IOBufQueue::cacheChainLength());
2706   egressCodec->generateConnectionPreface(output);
2707   egressCodec->generateSettings(output);
2708 
2709   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = 0; i < 2; i++) \{
2710     \textcolor{keyword}{auto} handler = openTransaction();
2711     \textcolor{keywordflow}{if} (i == 1) \{
2712       handler->expectHeaders([&] (std::shared\_ptr<HTTPMessage> msg) \{
2713           EXPECT\_EQ(200, msg->getStatusCode());
2714         \});
2715       handler->expectBody();
2716       handler->expectEOM();
2717 
2718       HTTPMessage resp;
2719       resp.setStatusCode(200);
2720       egressCodec->generateHeader(output, handler->txn\_->getID(), resp);
2721       egressCodec->generateBody(output, handler->txn\_->getID(), makeBuf(20),
2722                                 HTTPCodec::NoPadding, \textcolor{keyword}{true} \textcolor{comment}{/* eom */});
2723     \} \textcolor{keywordflow}{else} \{
2724       handler->expectEgressPaused();
2725       egressCodec->generateWindowUpdate(output, 0, 65536 * 2);
2726     \}
2727     handler->expectDetachTransaction();
2728 
2729     handler->txn\_->sendHeaders(getPostRequest(65536 - 2 * i));
2730     handler->txn\_->sendBody(makeBuf(65536 - 2 * i));
2731     handler->txn\_->sendEOM();
2732     \textcolor{keywordflow}{if} (i == 0) \{
2733       eventBase\_.loopOnce();
2734       handler->txn\_->sendAbort();
2735       \textcolor{comment}{// Even though there are no transactions, the fc timeout is still}
2736       \textcolor{comment}{// registered.}
2737       EXPECT\_FALSE(httpSession\_->isDetachable(\textcolor{keyword}{false}));
2738     \}
2739 
2740     \textcolor{keyword}{auto} buf = output.move();
2741     buf->coalesce();
2742     readAndLoop(buf.get());
2743 
2744     EXPECT\_TRUE(httpSession\_->isDetachable(\textcolor{keyword}{false}));
2745     httpSession\_->detachThreadLocals();
2746     httpSession\_->attachThreadLocals(&base, \textcolor{keyword}{nullptr}, timerInstance, \textcolor{keyword}{nullptr}, fn,
2747                                      \textcolor{keyword}{nullptr}, \textcolor{keyword}{nullptr});
2748     EXPECT\_EQ(filterCount, 2);
2749     filterCount = 0;
2750     base.loopOnce();
2751   \}
2752   httpSession\_->destroy();
2753 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P@{T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P}}
\index{T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P@{T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+P(\+H\+T\+T\+P\+Upstream\+Test)}]{\setlength{\rightskip}{0pt plus 5cm}T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Test}}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_afd2be3d90dafd200b1a61e6e2c6fcd86}
\index{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}!T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+P@{T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+P}}
\index{T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+P@{T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+P}!H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp@{H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp}}
\subsubsection[{T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+\+P(\+H\+T\+T\+P\+Upstream\+Test, Immediate\+Eof)}]{\setlength{\rightskip}{0pt plus 5cm}T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+P (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Upstream\+Test}}]{, }
\item[{Immediate\+Eof}]{}
\end{DoxyParamCaption}
)}\label{HTTPUpstreamSessionTest_8cpp_a6b9f0e05bd6c02452554b5d8fad74f4c}


Definition at line 1020 of file H\+T\+T\+P\+Upstream\+Session\+Test.\+cpp.


\begin{DoxyCode}
1020                                              \{
1021   \textcolor{comment}{// Receive an EOF without any request data}
1022   this->readCallback\_->readEOF();
1023   this->eventBase\_.loop();
1024   EXPECT\_EQ(this->sessionDestroyed\_, \textcolor{keyword}{true});
1025 \}
\end{DoxyCode}
