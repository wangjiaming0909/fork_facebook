\section{proxygen/lib/http/session/test/\+H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test.cpp File Reference}
\label{HTTPDefaultSessionCodecFactoryTest_8cpp}\index{proxygen/lib/http/session/test/\+H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test.\+cpp@{proxygen/lib/http/session/test/\+H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test.\+cpp}}
{\ttfamily \#include $<$proxygen/lib/http/session/\+H\+T\+T\+P\+Default\+Session\+Codec\+Factory.\+h$>$}\\*
{\ttfamily \#include $<$folly/portability/\+G\+Test.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/\+H\+T\+T\+P1x\+Codec.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/\+H\+T\+T\+P2\+Codec.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/\+H\+T\+T\+P2\+Constants.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/\+S\+P\+D\+Y\+Codec.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/services/\+Acceptor\+Configuration.\+h$>$}\\*
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\bf T\+E\+ST} (H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test, Get\+Codec\+S\+P\+DY)
\item 
{\bf T\+E\+ST} (H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test, Get\+Codec\+H2)
\item 
{\bf T\+E\+ST} (H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test, Get\+Codec\+Upgrade\+Protocols)
\item 
{\bf T\+E\+ST} (H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test, Get\+Codec)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test.\+cpp@{H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test.\+cpp@{H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test, Get\+Codec\+S\+P\+D\+Y)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test}]{, }
\item[{Get\+Codec\+S\+P\+DY}]{}
\end{DoxyParamCaption}
)}\label{HTTPDefaultSessionCodecFactoryTest_8cpp_a5517fc66e6bf155944ee19609687b20b}


Definition at line 21 of file H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test.\+cpp.



References proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, proxygen\+::\+H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+::get\+Codec(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::get\+Protocol(), proxygen\+::\+S\+P\+D\+Y\+Codec\+::get\+Protocol(), proxygen\+::\+H\+T\+T\+P\+\_\+2, proxygen\+::\+Acceptor\+Configuration\+::plaintext\+Protocol, proxygen\+::\+S\+P\+D\+Y\+\_\+3, proxygen\+::\+S\+P\+D\+Y\+\_\+3\+\_\+1, and proxygen\+::\+U\+P\+S\+T\+R\+E\+AM.


\begin{DoxyCode}
21                                                        \{
22   AcceptorConfiguration conf;
23   \textcolor{comment}{// If set directly on the acceptor, we should always return the SPDY version.}
24   conf.plaintextProtocol = \textcolor{stringliteral}{"spdy/3.1"};
25 
26   HTTPDefaultSessionCodecFactory factory(conf);
27   \textcolor{keyword}{auto} codec = factory.getCodec(
28       \textcolor{stringliteral}{"http/1.1"}, TransportDirection::UPSTREAM, \textcolor{keyword}{false} \textcolor{comment}{/* isTLS */});
29   SPDYCodec* spdyCodec = \textcolor{keyword}{dynamic\_cast<}SPDYCodec*\textcolor{keyword}{>}(codec.get());
30   EXPECT\_NE(spdyCodec, \textcolor{keyword}{nullptr});
31   EXPECT\_EQ(spdyCodec->getProtocol(), CodecProtocol::SPDY\_3\_1);
32 
33   codec = factory.getCodec(
34       \textcolor{stringliteral}{"spdy/3"}, TransportDirection::UPSTREAM, \textcolor{keyword}{false} \textcolor{comment}{/* isTLS */});
35   spdyCodec = \textcolor{keyword}{dynamic\_cast<}SPDYCodec*\textcolor{keyword}{>}(codec.get());
36   EXPECT\_NE(spdyCodec, \textcolor{keyword}{nullptr});
37   EXPECT\_EQ(spdyCodec->getProtocol(), CodecProtocol::SPDY\_3\_1);
38 
39   conf.plaintextProtocol = \textcolor{stringliteral}{"spdy/3"};
40 
41   HTTPDefaultSessionCodecFactory secondFactory(conf);
42   codec = secondFactory.getCodec(
43       \textcolor{stringliteral}{"http/1.1"}, TransportDirection::UPSTREAM, \textcolor{keyword}{false} \textcolor{comment}{/* isTLS */});
44   spdyCodec = \textcolor{keyword}{dynamic\_cast<}SPDYCodec*\textcolor{keyword}{>}(codec.get());
45   EXPECT\_NE(spdyCodec, \textcolor{keyword}{nullptr});
46   EXPECT\_EQ(spdyCodec->getProtocol(), CodecProtocol::SPDY\_3);
47 
48   codec = secondFactory.getCodec(
49       \textcolor{stringliteral}{"spdy/3.1"}, TransportDirection::UPSTREAM, \textcolor{keyword}{false} \textcolor{comment}{/* isTLS */});
50   spdyCodec = \textcolor{keyword}{dynamic\_cast<}SPDYCodec*\textcolor{keyword}{>}(codec.get());
51   EXPECT\_NE(spdyCodec, \textcolor{keyword}{nullptr});
52   EXPECT\_EQ(spdyCodec->getProtocol(), CodecProtocol::SPDY\_3);
53 
54   \textcolor{comment}{// On a somewhat contrived example, if TLS we should return the version}
55   \textcolor{comment}{// negotiated through ALPN.}
56   codec = secondFactory.getCodec(
57       \textcolor{stringliteral}{"h2"}, TransportDirection::DOWNSTREAM, \textcolor{keyword}{true} \textcolor{comment}{/* isTLS */});
58   HTTP2Codec* httpCodec = \textcolor{keyword}{dynamic\_cast<}HTTP2Codec*\textcolor{keyword}{>}(codec.get());
59   EXPECT\_NE(httpCodec, \textcolor{keyword}{nullptr});
60   EXPECT\_EQ(httpCodec->getProtocol(), CodecProtocol::HTTP\_2);
61 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test.\+cpp@{H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test.\+cpp@{H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test, Get\+Codec\+H2)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test}]{, }
\item[{Get\+Codec\+H2}]{}
\end{DoxyParamCaption}
)}\label{HTTPDefaultSessionCodecFactoryTest_8cpp_a993d2c2d90da48eb7b9b75ad831844cf}


Definition at line 63 of file H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test.\+cpp.



References proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, proxygen\+::\+H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+::get\+Codec(), proxygen\+::\+H\+T\+T\+P1x\+Codec\+::get\+Protocol(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::get\+Protocol(), proxygen\+::\+H\+T\+T\+P\+\_\+1\+\_\+1, proxygen\+::\+H\+T\+T\+P\+\_\+2, proxygen\+::\+Acceptor\+Configuration\+::plaintext\+Protocol, and proxygen\+::\+U\+P\+S\+T\+R\+E\+AM.


\begin{DoxyCode}
63                                                      \{
64   AcceptorConfiguration conf;
65   \textcolor{comment}{// If set directly on the acceptor, we should always return the H2C version.}
66   conf.plaintextProtocol = \textcolor{stringliteral}{"h2c"};
67   HTTPDefaultSessionCodecFactory factory(conf);
68   \textcolor{keyword}{auto} codec = factory.getCodec(
69       \textcolor{stringliteral}{"http/1.1"}, TransportDirection::DOWNSTREAM, \textcolor{keyword}{false} \textcolor{comment}{/* isTLS */});
70   HTTP2Codec* httpCodec = \textcolor{keyword}{dynamic\_cast<}HTTP2Codec*\textcolor{keyword}{>}(codec.get());
71   EXPECT\_NE(httpCodec, \textcolor{keyword}{nullptr});
72   EXPECT\_EQ(httpCodec->getProtocol(), CodecProtocol::HTTP\_2);
73 
74   \textcolor{comment}{// On a somewhat contrived example, if TLS we should return the version}
75   \textcolor{comment}{// negotiated through ALPN.}
76   codec = factory.getCodec(
77       \textcolor{stringliteral}{"http/1.1"}, TransportDirection::UPSTREAM, \textcolor{keyword}{true} \textcolor{comment}{/* isTLS */});
78   HTTP1xCodec* http1Codec = \textcolor{keyword}{dynamic\_cast<}HTTP1xCodec*\textcolor{keyword}{>}(codec.get());
79   EXPECT\_NE(http1Codec, \textcolor{keyword}{nullptr});
80   EXPECT\_EQ(http1Codec->getProtocol(), CodecProtocol::HTTP\_1\_1);
81 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test.\+cpp@{H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test.\+cpp@{H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test, Get\+Codec\+Upgrade\+Protocols)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test}]{, }
\item[{Get\+Codec\+Upgrade\+Protocols}]{}
\end{DoxyParamCaption}
)}\label{HTTPDefaultSessionCodecFactoryTest_8cpp_aa522693be62437969c310d0207cc3d27}


Definition at line 83 of file H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test.\+cpp.



References proxygen\+::\+Acceptor\+Configuration\+::allowed\+Plaintext\+Upgrade\+Protocols, proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, proxygen\+::\+H\+T\+T\+P1x\+Codec\+::get\+Allowed\+Upgrade\+Protocols(), proxygen\+::\+H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+::get\+Codec(), and proxygen\+::http2\+::k\+Protocol\+Cleartext\+String.


\begin{DoxyCode}
83                                                                    \{
84   std::list<std::string> plainTextUpgrades = \{http2::kProtocolCleartextString\};
85   AcceptorConfiguration conf;
86   conf.allowedPlaintextUpgradeProtocols = plainTextUpgrades;
87   HTTPDefaultSessionCodecFactory factory(conf);
88 
89   \textcolor{keyword}{auto} codec =
90       factory.getCodec(\textcolor{stringliteral}{"http/1.1"}, TransportDirection::DOWNSTREAM, \textcolor{keyword}{false});
91   HTTP1xCodec* downstreamCodec = \textcolor{keyword}{dynamic\_cast<}HTTP1xCodec*\textcolor{keyword}{>}(codec.get());
92   EXPECT\_NE(downstreamCodec, \textcolor{keyword}{nullptr});
93   EXPECT\_FALSE(downstreamCodec->getAllowedUpgradeProtocols().empty());
94   EXPECT\_EQ(downstreamCodec->getAllowedUpgradeProtocols(),
95             http2::kProtocolCleartextString);
96 
97   \textcolor{comment}{// If TLS, we should not attempt to upgrade.}
98   codec = factory.getCodec(\textcolor{stringliteral}{"http/1.1"}, TransportDirection::DOWNSTREAM, \textcolor{keyword}{true});
99   downstreamCodec = \textcolor{keyword}{dynamic\_cast<}HTTP1xCodec*\textcolor{keyword}{>}(codec.get());
100   EXPECT\_NE(downstreamCodec, \textcolor{keyword}{nullptr});
101   EXPECT\_TRUE(downstreamCodec->getAllowedUpgradeProtocols().empty());
102 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test.\+cpp@{H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test.\+cpp}!T\+E\+ST@{T\+E\+ST}}
\index{T\+E\+ST@{T\+E\+ST}!H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test.\+cpp@{H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T(\+H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test, Get\+Codec)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+ST (
\begin{DoxyParamCaption}
\item[{H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test}]{, }
\item[{Get\+Codec}]{}
\end{DoxyParamCaption}
)}\label{HTTPDefaultSessionCodecFactoryTest_8cpp_af80d3ffe0a56c53566c59d54ce418a3a}


Definition at line 104 of file H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+Test.\+cpp.



References proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, proxygen\+::\+H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+::get\+Codec(), proxygen\+::\+H\+T\+T\+P1x\+Codec\+::get\+Protocol(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::get\+Protocol(), proxygen\+::\+S\+P\+D\+Y\+Codec\+::get\+Protocol(), proxygen\+::\+H\+T\+T\+P\+\_\+1\+\_\+1, proxygen\+::\+H\+T\+T\+P\+\_\+2, proxygen\+::\+S\+P\+D\+Y\+\_\+3\+\_\+1, and proxygen\+::\+U\+P\+S\+T\+R\+E\+AM.


\begin{DoxyCode}
104                                                    \{
105   AcceptorConfiguration conf;
106   HTTPDefaultSessionCodecFactory factory(conf);
107 
108   \textcolor{comment}{// Empty protocol should default to http/1.1}
109   \textcolor{keyword}{auto} codec =
110       factory.getCodec(\textcolor{stringliteral}{""}, TransportDirection::DOWNSTREAM, \textcolor{keyword}{false} \textcolor{comment}{/* isTLS */});
111   HTTP1xCodec* http1Codec = \textcolor{keyword}{dynamic\_cast<}HTTP1xCodec*\textcolor{keyword}{>}(codec.get());
112   EXPECT\_NE(http1Codec, \textcolor{keyword}{nullptr});
113   EXPECT\_EQ(http1Codec->getProtocol(), CodecProtocol::HTTP\_1\_1);
114 
115   codec = factory.getCodec(
116       \textcolor{stringliteral}{"spdy/3.1"}, TransportDirection::UPSTREAM, \textcolor{keyword}{false} \textcolor{comment}{/* isTLS */});
117   SPDYCodec* spdyCodec = \textcolor{keyword}{dynamic\_cast<}SPDYCodec*\textcolor{keyword}{>}(codec.get());
118   EXPECT\_NE(spdyCodec, \textcolor{keyword}{nullptr});
119   EXPECT\_EQ(spdyCodec->getProtocol(), CodecProtocol::SPDY\_3\_1);
120 
121   codec =
122       factory.getCodec(\textcolor{stringliteral}{"h2"}, TransportDirection::DOWNSTREAM, \textcolor{keyword}{false} \textcolor{comment}{/* isTLS */});
123   HTTP2Codec* httpCodec = \textcolor{keyword}{dynamic\_cast<}HTTP2Codec*\textcolor{keyword}{>}(codec.get());
124   EXPECT\_NE(httpCodec, \textcolor{keyword}{nullptr});
125   EXPECT\_EQ(httpCodec->getProtocol(), CodecProtocol::HTTP\_2);
126 
127   \textcolor{comment}{// Not supported protocols should return nullptr.}
128   codec = factory.getCodec(
129       \textcolor{stringliteral}{"not/supported"}, TransportDirection::DOWNSTREAM, \textcolor{keyword}{false} \textcolor{comment}{/* isTLS */});
130   EXPECT\_EQ(codec, \textcolor{keyword}{nullptr});
131 \}
\end{DoxyCode}
