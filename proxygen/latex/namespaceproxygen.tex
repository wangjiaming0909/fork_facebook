\section{proxygen Namespace Reference}
\label{namespaceproxygen}\index{proxygen@{proxygen}}
\subsection*{Namespaces}
\begin{DoxyCompactItemize}
\item 
 {\bf compress}
\item 
 {\bf headers}
\item 
 {\bf hpack}
\item 
 {\bf H\+P\+A\+CK}
\item 
 {\bf http2}
\item 
 {\bf huffman}
\item 
 {\bf logging\+\_\+details}
\item 
 {\bf R\+F\+C2616}
\item 
 {\bf spdy}
\item 
 {\bf Structured\+Headers}
\end{DoxyCompactItemize}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct {\bf Acceptor\+Address}
\item 
struct {\bf Acceptor\+Configuration}
\item 
class {\bf Acceptor\+Factory}
\item 
class {\bf Ack\+Byte\+Event}
\item 
struct {\bf Ack\+Latency\+Event}
\item 
class {\bf Ack\+Timeout}
\item 
struct {\bf Ascii\+Case\+Underscore\+Insensitive}
\item 
class {\bf Async\+Timeout\+Set}
\item 
class {\bf Base64}
\item 
class {\bf Bin\+Printer}
\item 
class {\bf Byte\+Event}
\item 
class {\bf Byte\+Event\+Tracker}
\item 
class {\bf Chain\+Info\+Printer}
\item 
class {\bf Cob\+Helper}
\item 
class {\bf Codec\+Error\+Response\+Handler}
\item 
class {\bf Codec\+Util}
\item 
struct {\bf Compression\+Info}
\item 
class {\bf Consistent\+Hash}
\item 
class {\bf Dangling\+Queue\+Test}
\item 
class {\bf Dangling\+Queue\+Test\+Base}
\item 
class {\bf Default\+H\+T\+T\+P\+Codec\+Factory}
\item 
class {\bf Direct\+Response\+Handler}
\item 
class {\bf Dummy\+H\+T\+T\+P\+Session\+Stats}
\item 
class {\bf Dummy\+Timeout}
\item 
class {\bf Exception}
\item 
class {\bf Ex\+Message\+Handler}
\item 
class {\bf Fake\+H\+T\+T\+P\+Codec\+Callback}
\item 
class {\bf Filter}
\item 
class {\bf Filter\+Chain}
\item 
class {\bf Flow\+Control\+Filter}
\item 
class {\bf Generic\+Filter}
\item 
class {\bf Gzip\+Header\+Codec}
\item 
class {\bf Handler\+Callbacks}
\item 
class {\bf Has\+H\+T\+T\+P\+Header\+Matcher\+Impl}
\item 
class {\bf Header\+Codec}
\item 
class {\bf Header\+Decode\+Info}
\item 
struct {\bf Header\+Decode\+Result}
\item 
class {\bf Header\+Indexing\+Strategy}
\item 
class {\bf Header\+Table}
\item 
class {\bf Header\+Table\+Tests}
\item 
class {\bf Hex16\+Printer}
\item 
class {\bf Hex\+Folly\+Printer}
\item 
class {\bf H\+P\+A\+C\+K\+Codec}
\item 
class {\bf H\+P\+A\+C\+K\+Context}
\item 
class {\bf H\+P\+A\+C\+K\+Decode\+Buffer}
\item 
class {\bf H\+P\+A\+C\+K\+Decoder}
\item 
class {\bf H\+P\+A\+C\+K\+Decoder\+Base}
\item 
class {\bf H\+P\+A\+C\+K\+Encode\+Buffer}
\item 
class {\bf H\+P\+A\+C\+K\+Encoder}
\item 
class {\bf H\+P\+A\+C\+K\+Encoder\+Base}
\item 
class {\bf H\+P\+A\+C\+K\+Header}
\item 
class {\bf H\+P\+A\+C\+K\+Header\+Name}
\item 
class {\bf H\+P\+A\+C\+K\+Queue}
\item 
class {\bf H\+T\+T\+P1x\+Codec}
\item 
struct {\bf H\+T\+T\+P1x\+Codec\+Pair}
\item 
class {\bf H\+T\+T\+P2\+Codec}
\item 
struct {\bf H\+T\+T\+P2\+Codec\+Pair}
\item 
class {\bf H\+T\+T\+P2\+Priority\+Queue}
\item 
class {\bf H\+T\+T\+P2\+Priority\+Queue\+Base}
\item 
class {\bf H\+T\+T\+P\+Acceptor}
\item 
class {\bf H\+T\+T\+P\+Archive}
\item 
class {\bf H\+T\+T\+P\+Checks}
\item 
class {\bf H\+T\+T\+P\+Codec}
\item 
class {\bf H\+T\+T\+P\+Codec\+Factory}
\item 
class {\bf H\+T\+T\+P\+Codec\+Printer}
\item 
class {\bf H\+T\+T\+P\+Common\+Headers}
\item 
class {\bf H\+T\+T\+P\+Connector}
\item 
class {\bf H\+T\+T\+P\+Default\+Session\+Codec\+Factory}
\item 
class {\bf H\+T\+T\+P\+Direct\+Response\+Handler}
\item 
class {\bf H\+T\+T\+P\+Downstream\+Session}
\item 
class {\bf H\+T\+T\+P\+Error\+Page}
\item 
class {\bf H\+T\+T\+P\+Event}
\item 
class {\bf H\+T\+T\+P\+Exception}
\item 
class {\bf H\+T\+T\+P\+Handler\+Base}
\item 
class {\bf H\+T\+T\+P\+Headers}
\item 
class {\bf H\+T\+T\+P\+Message}
\item 
class {\bf H\+T\+T\+P\+Message\+Filter}
\item 
class {\bf H\+T\+T\+P\+Parallel\+Codec}
\item 
class {\bf H\+T\+T\+P\+Priority\+Map\+Factory\+Provider}
\item 
class {\bf H\+T\+T\+P\+Push\+Transaction\+Handler}
\item 
class {\bf H\+T\+T\+P\+Request\+Verifier}
\item 
class {\bf H\+T\+T\+P\+Server}
\item 
class {\bf H\+T\+T\+P\+Server\+Acceptor}
\item 
class {\bf H\+T\+T\+P\+Server\+Options}
\item 
class {\bf H\+T\+T\+P\+Session}
\item 
class {\bf H\+T\+T\+P\+Session\+Acceptor}
\item 
class {\bf H\+T\+T\+P\+Session\+Base}
\item 
class {\bf H\+T\+T\+P\+Session\+Controller}
\item 
class {\bf H\+T\+T\+P\+Session\+Stats}
\item 
struct {\bf H\+T\+T\+P\+Setting}
\item 
class {\bf H\+T\+T\+P\+Settings}
\item 
class {\bf H\+T\+T\+P\+Static\+Error\+Page}
\item 
class {\bf H\+T\+T\+P\+Transaction}
\item 
class {\bf H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data}
\item 
class {\bf H\+T\+T\+P\+Transaction\+Handler}
\item 
class {\bf H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data}
\item 
class {\bf H\+T\+T\+P\+Transaction\+Transport\+Callback}
\item 
class {\bf H\+T\+T\+P\+Upstream\+Session}
\item 
class {\bf H\+T\+T\+P\+Upstream\+Session\+Controller}
\item 
class {\bf Illegal\+Item\+Test}
\item 
class {\bf Illegal\+List\+Test}
\item 
class {\bf I\+O\+Buf\+Printer}
\item 
class {\bf Legal\+Binary\+Content\+Tests}
\item 
class {\bf Legal\+Float\+Tests}
\item 
class {\bf Legal\+Integer\+Tests}
\item 
class {\bf Legal\+String\+Tests}
\item 
class {\bf Mock1867\+Callback}
\item 
class {\bf Mock\+Byte\+Event\+Tracker}
\item 
class {\bf Mock\+Controller}
\item 
class {\bf Mock\+H\+T\+T\+P\+Codec}
\item 
class {\bf Mock\+H\+T\+T\+P\+Codec\+Callback}
\item 
struct {\bf Mock\+H\+T\+T\+P\+Codec\+Pair}
\item 
class {\bf Mock\+H\+T\+T\+P\+Handler}
\item 
class {\bf Mock\+H\+T\+T\+P\+Message\+Filter}
\item 
class {\bf Mock\+H\+T\+T\+P\+Push\+Handler}
\item 
class {\bf Mock\+H\+T\+T\+P\+Session\+Info\+Callback}
\item 
class {\bf Mock\+H\+T\+T\+P\+Session\+Stats}
\item 
class {\bf Mock\+H\+T\+T\+P\+Transaction}
\item 
class {\bf Mock\+H\+T\+T\+P\+Transaction\+Transport}
\item 
class {\bf Mock\+H\+T\+T\+P\+Transaction\+Transport\+Callback}
\item 
class {\bf Mock\+Request\+Handler}
\item 
class {\bf Mock\+Response\+Handler}
\item 
class {\bf Mock\+Secondary\+Auth\+Manager}
\item 
class {\bf Mock\+Time\+Util\+Generic}
\item 
class {\bf Mock\+Upstream\+Controller}
\item 
class {\bf No\+Path\+Indexing\+Strategy}
\item 
class {\bf Null\+Stream}
\item 
struct {\bf Null\+Trace\+Event\+Observer}
\item 
class {\bf Parse\+U\+RL}
\item 
class {\bf Pass\+Through\+H\+T\+T\+P\+Codec\+Filter}
\item 
class {\bf Pass\+Through\+Transport\+Filter}
\item 
class {\bf Perfect\+Index\+Map}
\item 
class {\bf Ping\+Byte\+Event}
\item 
class {\bf Push\+Handler}
\item 
class {\bf Q\+P\+A\+C\+K\+Codec}
\item 
class {\bf Q\+P\+A\+C\+K\+Context}
\item 
class {\bf Q\+P\+A\+C\+K\+Decoder}
\item 
class {\bf Q\+P\+A\+C\+K\+Encoder}
\item 
class {\bf Q\+P\+A\+C\+K\+Header\+Table}
\item 
class {\bf Q\+P\+A\+C\+K\+Header\+Table\+Tests}
\item 
class {\bf Q\+P\+A\+C\+K\+Static\+Header\+Table}
\item 
class {\bf Queue\+Test}
\item 
class {\bf Reject\+Connect\+Filter}
\item 
class {\bf Reject\+Connect\+Filter\+Factory}
\item 
class {\bf Rendezvous\+Hash}
\item 
class {\bf Request\+Handler}
\item 
class {\bf Request\+Handler\+Adaptor}
\item 
class {\bf Request\+Handler\+Chain}
\item 
class {\bf Request\+Handler\+Factory}
\item 
class {\bf Request\+Worker}
\item 
class {\bf Response\+Builder}
\item 
class {\bf Response\+Handler}
\item 
class {\bf R\+F\+C1867\+Base}
\item 
class {\bf R\+F\+C1867\+Codec}
\item 
class {\bf R\+F\+C1867\+CR}
\item 
class {\bf R\+F\+C1867\+Test}
\item 
class {\bf Scoped\+Handler}
\item 
class {\bf Scoped\+Handler\+Factory}
\item 
class {\bf Scoped\+H\+T\+T\+P\+Server}
\item 
class {\bf Secondary\+Auth\+Manager}
\item 
class {\bf Secondary\+Auth\+Manager\+Base}
\item 
class {\bf Service}
\item 
class {\bf Service\+Configuration}
\item 
class {\bf Service\+Worker}
\item 
class {\bf Signal\+Handler}
\item 
class {\bf Simple\+Controller}
\item 
class {\bf Simple\+Timeout\+Clock}
\item 
struct {\bf S\+P\+D\+Y3\+\_\+1\+Codec\+Pair}
\item 
struct {\bf S\+P\+D\+Y3\+Codec\+Pair}
\item 
class {\bf S\+P\+D\+Y\+Codec}
\item 
struct {\bf S\+P\+D\+Y\+Version\+Settings}
\item 
class {\bf Stack\+Trace\+Printer\+With\+Exception}
\item 
class {\bf State\+Machine}
\item 
class {\bf Static\+Header\+Table}
\item 
class {\bf Structured\+Headers\+Buffer}
\item 
class {\bf Structured\+Headers\+Buffer\+Test}
\item 
class {\bf Structured\+Headers\+Decoder}
\item 
class {\bf Structured\+Headers\+Decoder\+Test}
\item 
class {\bf Structured\+Headers\+Encoder}
\item 
class {\bf Structured\+Headers\+Encoder\+Test}
\item 
class {\bf Structured\+Headers\+Standard\+Test}
\item 
class {\bf Test\+Streaming\+Callback}
\item 
class {\bf Time\+Util\+Generic}
\item 
class {\bf Trace\+Event}
\item 
class {\bf Trace\+Event\+Context}
\item 
struct {\bf Trace\+Event\+Observer}
\item 
class {\bf Transaction\+Byte\+Event}
\item 
class {\bf Transaction\+Info}
\item 
class {\bf T\+T\+L\+B\+A\+Stats}
\item 
class {\bf U\+RL}
\item 
class {\bf Wheel\+Timer\+Instance}
\item 
class {\bf Window}
\item 
class {\bf Worker\+Thread}
\item 
class {\bf Zlib\+Server\+Filter}
\item 
class {\bf Zlib\+Server\+Filter\+Factory}
\item 
class {\bf Zlib\+Stream\+Compressor}
\item 
class {\bf Zlib\+Stream\+Decompressor}
\item 
class {\bf Zstd\+Stream\+Decompressor}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
typedef {\bf Generic\+Filter}$<$ {\bf H\+T\+T\+P\+Codec}, {\bf H\+T\+T\+P\+Codec\+::\+Callback},\&{\bf H\+T\+T\+P\+Codec\+::set\+Callback}, true $>$ {\bf H\+T\+T\+P\+Codec\+Filter}
\item 
typedef {\bf Filter\+Chain}$<$ {\bf H\+T\+T\+P\+Codec}, {\bf H\+T\+T\+P\+Codec\+::\+Callback}, {\bf Pass\+Through\+H\+T\+T\+P\+Codec\+Filter},\&{\bf H\+T\+T\+P\+Codec\+::set\+Callback}, true $>$ {\bf H\+T\+T\+P\+Codec\+Filter\+Chain}
\item 
using {\bf Settings\+Value} = uint64\+\_\+t
\item 
using {\bf Settings\+List} = std\+::vector$<$ {\bf H\+T\+T\+P\+Setting} $>$
\item 
using {\bf Setting\+Pair} = std\+::pair$<$ {\bf Settings\+Id}, uint32\+\_\+t $>$
\item 
using {\bf H\+T\+T\+P\+Header\+Size} = wangle\+::\+H\+T\+T\+P\+Header\+Size
\item 
using {\bf H\+T\+T\+P\+Transaction\+Egress\+SM} = {\bf State\+Machine}$<$ {\bf H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data} $>$
\item 
using {\bf H\+T\+T\+P\+Transaction\+Ingress\+SM} = {\bf State\+Machine}$<$ {\bf H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data} $>$
\item 
using {\bf I\+D\+List} = std\+::list$<$ std\+::pair$<$ {\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}, uint8\+\_\+t $>$$>$
\item 
typedef {\bf Generic\+Filter}$<$ folly\+::\+Async\+Transport\+Wrapper, folly\+::\+Async\+Transport\+Wrapper\+::\+Read\+Callback,\&folly\+::\+Async\+Transport\+Wrapper\+::set\+Read\+CB, true, folly\+::\+Async\+Transport\+Wrapper\+::\+Destructor $>$ {\bf Transport\+Filter}
\item 
typedef {\bf Filter\+Chain}$<$ folly\+::\+Async\+Transport\+Wrapper, folly\+::\+Async\+Transport\+Wrapper\+::\+Read\+Callback, {\bf Pass\+Through\+Transport\+Filter},\&folly\+::\+Async\+Transport\+Wrapper\+::set\+Read\+CB, false $>$ {\bf Transport\+Filter\+Chain}
\item 
using {\bf string\+\_\+buf} = boost\+::iostreams\+::stream\+\_\+buffer$<$ boost\+::iostreams\+::back\+\_\+insert\+\_\+device$<$ std\+::string $>$ $>$
\item 
using {\bf Acceptor\+Type} = {\bf Acceptor\+Address\+::\+Acceptor\+Type}
\item 
using {\bf Mock\+Time\+Util} = {\bf Mock\+Time\+Util\+Generic}$<$$>$
\item 
using {\bf Steady\+Clock} = std\+::chrono\+::steady\+\_\+clock
\item 
using {\bf System\+Clock} = std\+::chrono\+::system\+\_\+clock
\item 
using {\bf Time\+Point} = Steady\+Clock\+::time\+\_\+point
\item 
using {\bf System\+Time\+Point} = System\+Clock\+::time\+\_\+point
\item 
using {\bf Time\+Util} = {\bf Time\+Util\+Generic}$<$$>$
\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum {\bf Codec\+Protocol} \+: uint8\+\_\+t \{ \\*
{\bf Codec\+Protocol\+::\+H\+T\+T\+P\+\_\+1\+\_\+1}, 
{\bf Codec\+Protocol\+::\+S\+P\+D\+Y\+\_\+3}, 
{\bf Codec\+Protocol\+::\+S\+P\+D\+Y\+\_\+3\+\_\+1}, 
{\bf Codec\+Protocol\+::\+H\+T\+T\+P\+\_\+2}, 
\\*
{\bf Codec\+Protocol\+::\+HQ}
 \}
\item 
enum {\bf Gzip\+Decode\+Error} \+: uint8\+\_\+t \{ \\*
{\bf Gzip\+Decode\+Error\+::\+N\+O\+NE} = 0, 
{\bf Gzip\+Decode\+Error\+::\+B\+A\+D\+\_\+\+E\+N\+C\+O\+D\+I\+NG} = 1, 
{\bf Gzip\+Decode\+Error\+::\+H\+E\+A\+D\+E\+R\+S\+\_\+\+T\+O\+O\+\_\+\+L\+A\+R\+GE} = 2, 
{\bf Gzip\+Decode\+Error\+::\+I\+N\+F\+L\+A\+T\+E\+\_\+\+D\+I\+C\+T\+I\+O\+N\+A\+RY} = 3, 
\\*
{\bf Gzip\+Decode\+Error\+::\+E\+M\+P\+T\+Y\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+N\+A\+ME} = 4, 
{\bf Gzip\+Decode\+Error\+::\+E\+M\+P\+T\+Y\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+V\+A\+L\+UE} = 5, 
{\bf Gzip\+Decode\+Error\+::\+I\+N\+V\+A\+L\+I\+D\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+V\+A\+L\+UE} = 6
 \}
\item 
enum {\bf Error\+Code} \+: uint8\+\_\+t \{ \\*
{\bf Error\+Code\+::\+N\+O\+\_\+\+E\+R\+R\+OR} = 0, 
{\bf Error\+Code\+::\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR} = 1, 
{\bf Error\+Code\+::\+I\+N\+T\+E\+R\+N\+A\+L\+\_\+\+E\+R\+R\+OR} = 2, 
{\bf Error\+Code\+::\+F\+L\+O\+W\+\_\+\+C\+O\+N\+T\+R\+O\+L\+\_\+\+E\+R\+R\+OR} = 3, 
\\*
{\bf Error\+Code\+::\+S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+T\+I\+M\+E\+O\+UT} = 4, 
{\bf Error\+Code\+::\+S\+T\+R\+E\+A\+M\+\_\+\+C\+L\+O\+S\+ED} = 5, 
{\bf Error\+Code\+::\+F\+R\+A\+M\+E\+\_\+\+S\+I\+Z\+E\+\_\+\+E\+R\+R\+OR} = 6, 
{\bf Error\+Code\+::\+R\+E\+F\+U\+S\+E\+D\+\_\+\+S\+T\+R\+E\+AM} = 7, 
\\*
{\bf Error\+Code\+::\+C\+A\+N\+C\+EL} = 8, 
{\bf Error\+Code\+::\+C\+O\+M\+P\+R\+E\+S\+S\+I\+O\+N\+\_\+\+E\+R\+R\+OR} = 9, 
{\bf Error\+Code\+::\+C\+O\+N\+N\+E\+C\+T\+\_\+\+E\+R\+R\+OR} = 10, 
{\bf Error\+Code\+::\+E\+N\+H\+A\+N\+C\+E\+\_\+\+Y\+O\+U\+R\+\_\+\+C\+A\+LM} = 11, 
\\*
{\bf Error\+Code\+::\+I\+N\+A\+D\+E\+Q\+U\+A\+T\+E\+\_\+\+S\+E\+C\+U\+R\+I\+TY} = 12, 
{\bf Error\+Code\+::\+H\+T\+T\+P\+\_\+1\+\_\+1\+\_\+\+R\+E\+Q\+U\+I\+R\+ED} = 13, 
{\bf Error\+Code\+::\+\_\+\+S\+P\+D\+Y\+\_\+\+I\+N\+V\+A\+L\+I\+D\+\_\+\+S\+T\+R\+E\+AM} = 100
 \}
\item 
enum {\bf Settings\+Id} \+: uint64\+\_\+t \{ \\*
{\bf Settings\+Id\+::\+H\+E\+A\+D\+E\+R\+\_\+\+T\+A\+B\+L\+E\+\_\+\+S\+I\+ZE} = 1, 
{\bf Settings\+Id\+::\+E\+N\+A\+B\+L\+E\+\_\+\+P\+U\+SH} = 2, 
{\bf Settings\+Id\+::\+M\+A\+X\+\_\+\+C\+O\+N\+C\+U\+R\+R\+E\+N\+T\+\_\+\+S\+T\+R\+E\+A\+MS} = 3, 
{\bf Settings\+Id\+::\+I\+N\+I\+T\+I\+A\+L\+\_\+\+W\+I\+N\+D\+O\+W\+\_\+\+S\+I\+ZE} = 4, 
\\*
{\bf Settings\+Id\+::\+M\+A\+X\+\_\+\+F\+R\+A\+M\+E\+\_\+\+S\+I\+ZE} = 5, 
{\bf Settings\+Id\+::\+M\+A\+X\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+L\+I\+S\+T\+\_\+\+S\+I\+ZE} = 6, 
{\bf Settings\+Id\+::\+E\+N\+A\+B\+L\+E\+\_\+\+C\+O\+N\+N\+E\+C\+T\+\_\+\+P\+R\+O\+T\+O\+C\+OL} = 8, 
{\bf Settings\+Id\+::\+T\+H\+R\+I\+F\+T\+\_\+\+C\+H\+A\+N\+N\+E\+L\+\_\+\+I\+D\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+ED} = 100, 
\\*
{\bf Settings\+Id\+::\+E\+N\+A\+B\+L\+E\+\_\+\+E\+X\+\_\+\+H\+E\+A\+D\+E\+RS} = 0xfbfb, 
{\bf Settings\+Id\+::\+T\+H\+R\+I\+F\+T\+\_\+\+C\+H\+A\+N\+N\+E\+L\+\_\+\+ID} = 0xf100, 
{\bf Settings\+Id\+::\+S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+H\+T\+T\+P\+\_\+\+C\+E\+R\+T\+\_\+\+A\+U\+TH} = 0xff00, 
{\bf Settings\+Id\+::\+\_\+\+S\+P\+D\+Y\+\_\+\+U\+P\+L\+O\+A\+D\+\_\+\+B\+A\+N\+D\+W\+I\+D\+TH} = (1 $<$$<$ 16) $\vert$ 1, 
\\*
{\bf Settings\+Id\+::\+\_\+\+S\+P\+D\+Y\+\_\+\+D\+O\+W\+N\+L\+O\+A\+D\+\_\+\+B\+A\+N\+D\+W\+I\+D\+TH} = (1 $<$$<$ 16) $\vert$ 2, 
{\bf Settings\+Id\+::\+\_\+\+S\+P\+D\+Y\+\_\+\+R\+O\+U\+N\+D\+\_\+\+T\+R\+I\+P\+\_\+\+T\+I\+ME} = (1 $<$$<$ 16) $\vert$ 3, 
{\bf Settings\+Id\+::\+\_\+\+S\+P\+D\+Y\+\_\+\+C\+U\+R\+R\+E\+N\+T\+\_\+\+C\+W\+ND} = (1 $<$$<$ 16) $\vert$ 5, 
{\bf Settings\+Id\+::\+\_\+\+S\+P\+D\+Y\+\_\+\+D\+O\+W\+N\+L\+O\+A\+D\+\_\+\+R\+E\+T\+R\+A\+N\+S\+\_\+\+R\+A\+TE} = (1 $<$$<$ 16) $\vert$ 6, 
\\*
{\bf Settings\+Id\+::\+\_\+\+S\+P\+D\+Y\+\_\+\+C\+L\+I\+E\+N\+T\+\_\+\+C\+E\+R\+T\+I\+F\+I\+C\+A\+T\+E\+\_\+\+V\+E\+C\+T\+O\+R\+\_\+\+S\+I\+ZE} = (1 $<$$<$ 16) $\vert$ 8, 
{\bf Settings\+Id\+::\+\_\+\+H\+Q\+\_\+\+N\+U\+M\+\_\+\+P\+L\+A\+C\+E\+H\+O\+L\+D\+E\+RS} = (((uint64\+\_\+t)1) $<$$<$ 32) $\vert$ 3, 
{\bf Settings\+Id\+::\+\_\+\+H\+Q\+\_\+\+Q\+P\+A\+C\+K\+\_\+\+B\+L\+O\+C\+K\+E\+D\+\_\+\+S\+T\+R\+E\+A\+MS} = (((uint64\+\_\+t)1) $<$$<$ 32) $\vert$ 7
 \}
\item 
enum {\bf S\+P\+D\+Y\+Version} \{ {\bf S\+P\+D\+Y\+Version\+::\+S\+P\+D\+Y3} = 0, 
{\bf S\+P\+D\+Y\+Version\+::\+S\+P\+D\+Y3\+\_\+1}
 \}
\item 
enum {\bf Transport\+Direction} \+: uint8\+\_\+t \{ {\bf Transport\+Direction\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM}, 
{\bf Transport\+Direction\+::\+U\+P\+S\+T\+R\+E\+AM}
 \}
\item 
enum {\bf H\+T\+T\+P\+Header\+Code} \+: uint8\+\_\+t \{ {\bf H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+N\+O\+NE} = 0, 
{\bf H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER} = 1
 \}
\item 
enum {\bf H\+T\+T\+P\+Common\+Header\+Table\+Type} \+: uint8\+\_\+t \{ {\bf T\+A\+B\+L\+E\+\_\+\+C\+A\+M\+E\+L\+C\+A\+SE} = 0, 
{\bf T\+A\+B\+L\+E\+\_\+\+L\+O\+W\+E\+R\+C\+A\+SE} = 1
 \}
\item 
enum {\bf Connection\+Close\+Reason} \{ \\*
{\bf Connection\+Close\+Reason\+::\+S\+H\+U\+T\+D\+O\+WN}, 
{\bf Connection\+Close\+Reason\+::\+R\+E\+A\+D\+\_\+\+E\+OF}, 
{\bf Connection\+Close\+Reason\+::\+G\+O\+A\+W\+AY}, 
{\bf Connection\+Close\+Reason\+::\+S\+E\+S\+S\+I\+O\+N\+\_\+\+P\+A\+R\+S\+E\+\_\+\+E\+R\+R\+OR}, 
\\*
{\bf Connection\+Close\+Reason\+::\+R\+E\+M\+O\+T\+E\+\_\+\+E\+R\+R\+OR}, 
{\bf Connection\+Close\+Reason\+::\+T\+R\+A\+N\+S\+A\+C\+T\+I\+O\+N\+\_\+\+A\+B\+O\+RT}, 
{\bf Connection\+Close\+Reason\+::\+T\+I\+M\+E\+O\+UT}, 
{\bf Connection\+Close\+Reason\+::\+I\+O\+\_\+\+R\+E\+A\+D\+\_\+\+E\+R\+R\+OR}, 
\\*
{\bf Connection\+Close\+Reason\+::\+I\+O\+\_\+\+W\+R\+I\+T\+E\+\_\+\+E\+R\+R\+OR}, 
{\bf Connection\+Close\+Reason\+::\+R\+E\+Q\+\_\+\+N\+O\+T\+R\+E\+U\+S\+A\+B\+LE}, 
{\bf Connection\+Close\+Reason\+::\+E\+R\+R\+\_\+\+R\+E\+SP}, 
{\bf Connection\+Close\+Reason\+::\+U\+N\+K\+N\+O\+WN}, 
\\*
{\bf Connection\+Close\+Reason\+::\+F\+L\+O\+W\+\_\+\+C\+O\+N\+T\+R\+OL}, 
{\bf Connection\+Close\+Reason\+::k\+M\+A\+X\+\_\+\+R\+E\+A\+S\+ON}
 \}
\item 
enum {\bf Upgrade\+Protocol} \+: int \{ {\bf Upgrade\+Protocol\+::\+T\+CP}
 \}
\item 
enum {\bf H\+T\+T\+P\+Method} \{ \\*
{\bf H\+T\+T\+P\+Method\+::\+G\+ET}, 
{\bf H\+T\+T\+P\+Method\+::\+P\+O\+ST}, 
{\bf H\+T\+T\+P\+Method\+::\+O\+P\+T\+I\+O\+NS}, 
{\bf H\+T\+T\+P\+Method\+::\+D\+E\+L\+E\+TE}, 
\\*
{\bf H\+T\+T\+P\+Method\+::\+H\+E\+AD}, 
{\bf H\+T\+T\+P\+Method\+::\+C\+O\+N\+N\+E\+CT}, 
{\bf H\+T\+T\+P\+Method\+::\+P\+UT}, 
{\bf H\+T\+T\+P\+Method\+::\+T\+R\+A\+CE}, 
\\*
{\bf H\+T\+T\+P\+Method\+::\+P\+A\+T\+CH}, 
{\bf H\+T\+T\+P\+Method\+::\+S\+UB}, 
{\bf H\+T\+T\+P\+Method\+::\+P\+UB}, 
{\bf H\+T\+T\+P\+Method\+::\+U\+N\+S\+UB}
 \}
\item 
enum {\bf Proxygen\+Error} \{ \\*
{\bf k\+Error\+None}, 
{\bf k\+Error\+Message}, 
{\bf k\+Error\+Connect}, 
{\bf k\+Error\+Connect\+Timeout}, 
\\*
{\bf k\+Error\+Read}, 
{\bf k\+Error\+Write}, 
{\bf k\+Error\+Timeout}, 
{\bf k\+Error\+Handshake}, 
\\*
{\bf k\+Error\+No\+Server}, 
{\bf k\+Error\+Max\+Redirects}, 
{\bf k\+Error\+Invalid\+Redirect}, 
{\bf k\+Error\+Response\+Action}, 
\\*
{\bf k\+Error\+Max\+Connects}, 
{\bf k\+Error\+Dropped}, 
{\bf k\+Error\+Connection}, 
{\bf k\+Error\+Connection\+Reset}, 
\\*
{\bf k\+Error\+Parse\+Header}, 
{\bf k\+Error\+Parse\+Body}, 
{\bf k\+Error\+E\+OF}, 
{\bf k\+Error\+Client\+Renegotiation}, 
\\*
{\bf k\+Error\+Unknown}, 
{\bf k\+Error\+Bad\+Decompress}, 
{\bf k\+Error\+S\+SL}, 
{\bf k\+Error\+Stream\+Abort}, 
\\*
{\bf k\+Error\+Stream\+Unacknowledged}, 
{\bf k\+Error\+Write\+Timeout}, 
{\bf k\+Error\+Address\+Private}, 
{\bf k\+Error\+Address\+Family\+Not\+Supported}, 
\\*
{\bf k\+Error\+D\+N\+S\+No\+Results}, 
{\bf k\+Error\+Malformed\+Input}, 
{\bf k\+Error\+Unsupported\+Expectation}, 
{\bf k\+Error\+Method\+Not\+Supported}, 
\\*
{\bf k\+Error\+Unsupported\+Scheme}, 
{\bf k\+Error\+Shutdown}, 
{\bf k\+Error\+Ingress\+State\+Transition}, 
{\bf k\+Error\+Client\+Silent}, 
\\*
{\bf k\+Error\+Canceled}, 
{\bf k\+Error\+Parse\+Response}, 
{\bf k\+Error\+Conn\+Refused}, 
{\bf k\+Error\+D\+N\+S\+Other\+Server}, 
\\*
{\bf k\+Error\+D\+N\+S\+Other\+Client}, 
{\bf k\+Error\+D\+N\+S\+Other\+Cancelled}, 
{\bf k\+Error\+D\+N\+Sshutdown}, 
{\bf k\+Error\+D\+N\+Sgetaddrinfo}, 
\\*
{\bf k\+Error\+D\+N\+Sthreadpool}, 
{\bf k\+Error\+D\+N\+Sunimplemented}, 
{\bf k\+Error\+Network}, 
{\bf k\+Error\+Configuration}, 
\\*
{\bf k\+Error\+Early\+Data\+Rejected}, 
{\bf k\+Error\+Early\+Data\+Failed}, 
{\bf k\+Error\+Auth\+Required}, 
{\bf k\+Error\+Unauthorized}, 
\\*
{\bf k\+Error\+Max}
 \}
\item 
enum {\bf Zlib\+Compression\+Type} \+: int \{ {\bf Zlib\+Compression\+Type\+::\+N\+O\+NE} = 0, 
{\bf Zlib\+Compression\+Type\+::\+D\+E\+F\+L\+A\+TE} = 15, 
{\bf Zlib\+Compression\+Type\+::\+G\+Z\+IP} = 31
 \}
\item 
enum {\bf Zstd\+Status\+Type} \+: int \{ \\*
{\bf Zstd\+Status\+Type\+::\+N\+O\+NE}, 
{\bf Zstd\+Status\+Type\+::\+S\+U\+C\+C\+E\+SS}, 
{\bf Zstd\+Status\+Type\+::\+N\+O\+D\+I\+CT}, 
{\bf Zstd\+Status\+Type\+::\+C\+O\+N\+T\+I\+N\+UE}, 
\\*
{\bf Zstd\+Status\+Type\+::\+E\+R\+R\+OR}
 \}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\footnotesize template$<$$>$ }\\std\+::unique\+\_\+ptr$<$ {\bf Scoped\+H\+T\+T\+P\+Server} $>$ {\bf Scoped\+H\+T\+T\+P\+Server\+::start$<$ std\+::unique\+\_\+ptr$<$ Request\+Handler\+Factory $>$ $>$} (std\+::unique\+\_\+ptr$<$ {\bf Request\+Handler\+Factory} $>$ f, int port, int num\+Threads, std\+::unique\+\_\+ptr$<$ wangle\+::\+S\+S\+L\+Context\+Config $>$ ssl\+Cfg)
\item 
const std\+::string \& {\bf get\+Codec\+Protocol\+String} ({\bf Codec\+Protocol} proto)
\item 
bool {\bf is\+Valid\+Codec\+Protocol\+Str} (const std\+::string \&protocol\+Str)
\item 
{\bf Codec\+Protocol} {\bf get\+Codec\+Protocol\+From\+Str} (const std\+::string \&protocol\+Str)
\item 
bool {\bf is\+Spdy\+Codec\+Protocol} ({\bf Codec\+Protocol} protocol)
\item 
bool {\bf is\+H\+T\+T\+P2\+Codec\+Protocol} ({\bf Codec\+Protocol} protocol)
\item 
bool {\bf is\+H\+Q\+Codec\+Protocol} ({\bf Codec\+Protocol} protocol)
\item 
bool {\bf is\+Parallel\+Codec\+Protocol} ({\bf Codec\+Protocol} protocol)
\item 
folly\+::\+Optional$<$ std\+::pair$<$ {\bf Codec\+Protocol}, std\+::string $>$ $>$ {\bf check\+For\+Protocol\+Upgrade} (const std\+::string \&client\+Upgrade, const std\+::string \&server\+Upgrade, bool server\+Mode)
\item 
bool {\bf operator==} (const {\bf H\+T\+T\+P\+Message} \&msg1, const {\bf H\+T\+T\+P\+Message} \&msg2)
\item 
std\+::ostream \& {\bf operator$<$$<$} (std\+::ostream \&os, const {\bf Header\+Table} \&table)
\item 
std\+::ostream \& {\bf operator$<$$<$} (std\+::ostream \&os, const {\bf H\+P\+A\+C\+K\+Codec} \&codec)
\item 
std\+::ostream \& {\bf operator$<$$<$} (std\+::ostream \&os, const {\bf H\+P\+A\+C\+K\+Context} \&context)
\item 
std\+::ostream \& {\bf operator$<$$<$} (std\+::ostream \&os, const {\bf H\+P\+A\+C\+K\+Header} \&h)
\item 
std\+::ostream \& {\bf operator$<$$<$} (std\+::ostream \&os, const {\bf H\+P\+A\+C\+K\+Header\+Name} \&{\bf name})
\item 
ostream \& {\bf operator$<$$<$} (ostream \&os, const std\+::list$<$ uint32\+\_\+t $>$ $\ast$refset)
\item 
std\+::ostream \& {\bf operator$<$$<$} (std\+::ostream \&os, const std\+::vector$<$ {\bf H\+P\+A\+C\+K\+Header} $>$ \&v)
\item 
string {\bf print\+Delta} (const vector$<$ {\bf H\+P\+A\+C\+K\+Header} $>$ \&v1, const vector$<$ {\bf H\+P\+A\+C\+K\+Header} $>$ \&v2)
\item 
std\+::ostream \& {\bf operator$<$$<$} (std\+::ostream \&os, const {\bf Q\+P\+A\+C\+K\+Codec} \&codec)
\item 
std\+::ostream \& {\bf operator$<$$<$} (std\+::ostream \&os, const {\bf Q\+P\+A\+C\+K\+Context} \&context)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Header\+Table\+Tests}, Index\+Translation)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Header\+Table\+Tests}, Add)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Header\+Table\+Tests}, Evict)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Header\+Table\+Tests}, Reduce\+Capacity)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Header\+Table\+Tests}, Comparison)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Header\+Table\+Tests}, Print)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Header\+Table\+Tests}, Increase\+Capacity)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Header\+Table\+Tests}, Vary\+Capacity)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Header\+Table\+Tests}, Vary\+Capacity\+Malign\+Head\+Index)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Header\+Table\+Tests}, Add\+Larger\+Than\+Table)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Header\+Table\+Tests}, Increase\+Length\+Of\+Full\+Table)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Header\+Table\+Tests}, Small\+Table)
\item 
std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ {\bf read\+File\+To\+I\+O\+Buf} (const std\+::string \&filename)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Q\+P\+A\+C\+K\+Header\+Table\+Tests}, Indexing)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Q\+P\+A\+C\+K\+Header\+Table\+Tests}, Eviction)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Q\+P\+A\+C\+K\+Header\+Table\+Tests}, Bad\+Eviction)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Q\+P\+A\+C\+K\+Header\+Table\+Tests}, Wrapcount)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Q\+P\+A\+C\+K\+Header\+Table\+Tests}, Name\+Index)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Q\+P\+A\+C\+K\+Header\+Table\+Tests}, Get\+Index)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Q\+P\+A\+C\+K\+Header\+Table\+Tests}, Duplication)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Q\+P\+A\+C\+K\+Header\+Table\+Tests}, Can\+Evict\+With\+Room)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Q\+P\+A\+C\+K\+Header\+Table\+Tests}, Evict\+Non\+Drained)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Q\+P\+A\+C\+K\+Header\+Table\+Tests}, Bad\+Sync)
\item 
const char $\ast$ {\bf get\+Error\+Code\+String} ({\bf Error\+Code} error)
\item 
std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Message} $>$ {\bf get\+Priority\+Message} (uint8\+\_\+t priority)
\item 
std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ {\bf make\+Buf} (uint32\+\_\+t size)
\item 
std\+::unique\+\_\+ptr$<$ testing\+::\+Nice\+Mock$<$ {\bf Mock\+H\+T\+T\+P\+Codec} $>$ $>$ {\bf make\+Mock\+Parallel\+Codec} ({\bf Transport\+Direction} dir)
\item 
std\+::unique\+\_\+ptr$<$ testing\+::\+Nice\+Mock$<$ {\bf Mock\+H\+T\+T\+P\+Codec} $>$ $>$ {\bf make\+Downstream\+Parallel\+Codec} ()
\item 
std\+::unique\+\_\+ptr$<$ testing\+::\+Nice\+Mock$<$ {\bf Mock\+H\+T\+T\+P\+Codec} $>$ $>$ {\bf make\+Upstream\+Parallel\+Codec} ()
\item 
{\bf H\+T\+T\+P\+Message} {\bf get\+Get\+Request} (const std\+::string \&url)
\item 
{\bf H\+T\+T\+P\+Message} {\bf get\+Big\+Get\+Request} (const std\+::string \&url)
\item 
std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Message} $>$ {\bf make\+Get\+Request} ()
\item 
{\bf H\+T\+T\+P\+Message} {\bf get\+Post\+Request} (uint32\+\_\+t content\+Length)
\item 
{\bf H\+T\+T\+P\+Message} {\bf get\+Chunked\+Post\+Request} ()
\item 
std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Message} $>$ {\bf make\+Post\+Request} (uint32\+\_\+t content\+Length)
\item 
{\bf H\+T\+T\+P\+Message} {\bf get\+Pub\+Request} (const std\+::string \&url)
\item 
{\bf H\+T\+T\+P\+Message} {\bf get\+Response} (uint32\+\_\+t code, uint32\+\_\+t body\+Len)
\item 
std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Message} $>$ {\bf make\+Response} (uint16\+\_\+t {\bf status\+Code})
\item 
std\+::tuple$<$ std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Message} $>$, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ $>$ {\bf make\+Response} (uint16\+\_\+t {\bf status\+Code}, size\+\_\+t len)
\item 
{\bf H\+T\+T\+P\+Message} {\bf get\+Upgrade\+Request} (const std\+::string \&upgrade\+Header, {\bf H\+T\+T\+P\+Method} method, uint32\+\_\+t body\+Len)
\item 
void {\bf fake\+Mock\+Codec} ({\bf Mock\+H\+T\+T\+P\+Codec} \&codec)
\item 
{\footnotesize template$<$class T $>$ }\\size\+\_\+t {\bf parse} ({\bf T} $\ast$codec, const uint8\+\_\+t $\ast$input\+Data, uint32\+\_\+t length, int32\+\_\+t at\+Once=0, std\+::function$<$ bool()$>$ stop\+Fn=[$\,$]\{return false;\})
\item 
{\footnotesize template$<$class T $>$ }\\size\+\_\+t {\bf parse\+Unidirectional} ({\bf T} $\ast$codec, const uint8\+\_\+t $\ast$input\+Data, uint32\+\_\+t length, int32\+\_\+t at\+Once=0, std\+::function$<$ bool()$>$ stop\+Fn=[$\,$]\{return false;\})
\item 
{\bf M\+A\+T\+C\+H\+E\+R\+\_\+P} (Ptr\+Buf\+Has\+Len, n,\char`\"{}\char`\"{})
\item 
const char $\ast$ {\bf get\+Transport\+Direction\+String} ({\bf Transport\+Direction} dir)
\item 
{\bf Transport\+Direction} {\bf operator!} ({\bf Transport\+Direction} dir)
\item 
std\+::ostream \& {\bf operator$<$$<$} (std\+::ostream \&os, const {\bf Transport\+Direction} dir)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf R\+F\+C1867\+Test}, Test\+Simple\+Post)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf R\+F\+C1867\+Test}, Test\+Splits)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf R\+F\+C1867\+Test}, Test\+Splits\+With\+Filename)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf R\+F\+C1867\+Test}, Test\+Headers\+Chunk\+Extra\+Cr)
\item 
{\bf T\+E\+S\+T\+\_\+P} ({\bf R\+F\+C1867\+CR}, Test)
\item 
{\bf I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P} (Value\+Test, {\bf R\+F\+C1867\+CR},\+::testing\+::\+Values(string(\char`\"{}zyx\textbackslash{}r\textbackslash{}nwvu\char`\"{}, 8), string(\char`\"{}\textbackslash{}rzyxwvut\char`\"{}, 8), string(\char`\"{}zyxwvut\textbackslash{}r\char`\"{}, 8), string(\char`\"{}\textbackslash{}nzyxwvut\char`\"{}, 8), string(\char`\"{}zyxwvut\textbackslash{}n\char`\"{}, 8), string(\char`\"{}\textbackslash{}r\textbackslash{}n\textbackslash{}r\textbackslash{}n\textbackslash{}r\textbackslash{}n\textbackslash{}r\textbackslash{}n\char`\"{}, 8), string(\char`\"{}\textbackslash{}r\textbackslash{}r\textbackslash{}r\textbackslash{}r\textbackslash{}r\textbackslash{}r\textbackslash{}r\textbackslash{}r\char`\"{}, 8)))
\item 
const char $\ast$ {\bf get\+Connection\+Close\+Reason\+String\+By\+Index} (unsigned int index)
\item 
const char $\ast$ {\bf get\+Connection\+Close\+Reason\+String} ({\bf Connection\+Close\+Reason} r)
\item 
std\+::ostream \& {\bf operator$<$$<$} (std\+::ostream \&os, const {\bf H\+T\+T\+P\+Exception} \&ex)
\item 
bool {\bf is\+L\+WS} (char c)
\item 
std\+::ostream \& {\bf operator$<$$<$} (std\+::ostream \&os, const {\bf H\+T\+T\+P\+Message} \&msg)
\item 
{\footnotesize template$<$typename Str $>$ }\\std\+::string {\bf strip\+Cntrl\+Chars} (const Str \&str)
\item 
folly\+::\+Optional$<$ {\bf H\+T\+T\+P\+Method} $>$ {\bf string\+To\+Method} (folly\+::\+String\+Piece method)
\item 
const std\+::string \& {\bf method\+To\+String} ({\bf H\+T\+T\+P\+Method} method)
\item 
std\+::ostream \& {\bf operator$<$$<$} (std\+::ostream \&out, {\bf H\+T\+T\+P\+Method} method)
\item 
const char $\ast$ {\bf get\+Error\+String} ({\bf Proxygen\+Error} error)
\item 
const char $\ast$ {\bf get\+Error\+String\+By\+Index} (int i)
\item 
std\+::ostream \& {\bf operator$<$$<$} (std\+::ostream \&os, const {\bf Byte\+Event} \&be)
\item 
std\+::ostream \& {\bf operator$<$$<$} (std\+::ostream \&os, {\bf H\+T\+T\+P\+Event\+::\+Type} e)
\item 
std\+::ostream \& {\bf operator$<$$<$} (std\+::ostream \&os, const {\bf H\+T\+T\+P\+Transaction} \&txn)
\item 
std\+::ostream \& {\bf operator$<$$<$} (std\+::ostream \&os, {\bf H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data\+::\+State} s)
\item 
std\+::ostream \& {\bf operator$<$$<$} (std\+::ostream \&os, {\bf H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data\+::\+Event} e)
\item 
std\+::ostream \& {\bf operator$<$$<$} (std\+::ostream \&os, {\bf H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::\+State} s)
\item 
std\+::ostream \& {\bf operator$<$$<$} (std\+::ostream \&os, {\bf H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::\+Event} e)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Basic)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Remove\+Leaf)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Remove\+Parent)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Remove\+Parent\+Weights)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Node\+Depth)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Update\+Weight)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Duplicate\+ID)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Update\+Weight\+Not\+Enqueued)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Update\+Weight\+Excl)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Update\+Weight\+Excl\+Dequeued)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Update\+Weight\+Unknown\+Parent)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Update\+Parent\+Sibling)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Update\+Parent\+Sibling\+Excl)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Update\+Parent\+Ancestor)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Update\+Parent\+Ancestor\+Excl)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Update\+Parent\+Descendant)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Update\+Parent\+Descendant\+Excl)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Exclusive\+Add)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Add\+Unknown)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Add\+Max)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Misc)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Iterate\+B\+FS)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Next\+Egress)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Next\+Egress\+Exclusive\+Add)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Next\+Egress\+Exclusive\+Add\+With\+Egress)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Update\+Priority\+Reparent\+Subtree)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Next\+Egress\+Remove\+Parent)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Add\+Exclusive\+Descendant\+Enqueued)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Next\+Egress\+Remove\+Parent\+Enqueued)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Next\+Egress\+Remove\+Parent\+Enqueued\+Indirect)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Chrome\+Test)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Next\+Egress\+Spdy)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Add\+Or\+Update)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Dangling\+Queue\+Test}, Basic)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Dangling\+Queue\+Test}, Chain)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Dangling\+Queue\+Test}, Drop)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Dangling\+Queue\+Test}, Expire\+Parent\+Of\+Mismatched\+Twins)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Dangling\+Queue\+Test}, Refresh)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Dangling\+Queue\+Test}, Max)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Queue\+Test}, Rebuild)
\item 
{\bf A\+C\+T\+I\+O\+N\+\_\+P} (Expect\+String, expected)
\item 
{\bf A\+C\+T\+I\+O\+N\+\_\+P} (Expect\+Body\+Len, expected\+Len)
\item 
folly\+::\+H\+H\+Wheel\+Timer\+::\+Unique\+Ptr {\bf make\+Internal\+Timeout\+Set} (Event\+Base $\ast$evb)
\item 
folly\+::\+H\+H\+Wheel\+Timer\+::\+Unique\+Ptr {\bf make\+Timeout\+Set} (Event\+Base $\ast$evb)
\item 
testing\+::\+Nice\+Mock$<$ Mock\+Async\+Transport $>$ $\ast$ {\bf new\+Mock\+Transport} (Event\+Base $\ast$evb)
\item 
folly\+::\+H\+H\+Wheel\+Timer\+::\+Unique\+Ptr {\bf make\+Internal\+Timeout\+Set} (folly\+::\+Event\+Base $\ast$evb)
\item 
folly\+::\+H\+H\+Wheel\+Timer\+::\+Unique\+Ptr {\bf make\+Timeout\+Set} (folly\+::\+Event\+Base $\ast$evb)
\item 
testing\+::\+Nice\+Mock$<$ folly\+::test\+::\+Mock\+Async\+Transport $>$ $\ast$ {\bf new\+Mock\+Transport} (folly\+::\+Event\+Base $\ast$evb)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Binary\+Content)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Binary\+Content\+Illegal\+Characters)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Binary\+Content\+No\+Ending\+Asterisk)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Binary\+Content\+Empty)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Identifier)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Identifier\+All\+Legal\+Characters)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Identifier\+Beginning\+Underscore)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+String)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+String\+Escaped\+Quote)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+String\+Escaped\+Backslash)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+String\+Stray\+Backslash)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+String\+Invalid\+Character)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+String\+Parsing\+Repeated)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Integer)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Integer\+Two\+Negatives)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Integer\+Empty\+After\+Negative)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Integer\+Negative)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Integer\+Overflow)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Integer\+High\+Borderline)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Integer\+Low\+Borderline)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Integer\+Underflow)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Float)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Float\+Preceding\+Whitespace)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Float\+No\+Digit\+Preceding\+Decimal)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Integer\+Too\+Many\+Chars)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Float\+Too\+Many\+Chars)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Float\+Borderline\+Num\+Chars)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Float\+Ends\+With\+Decimal)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Consume\+Comma)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Consume\+Equals)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Consume\+Messy)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Buffer\+Test}, Test\+Inequality\+Operator)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Decoder\+Test}, Test\+Item)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Decoder\+Test}, Test\+List)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Decoder\+Test}, Test\+List\+Beginning\+Whitespace)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Decoder\+Test}, Test\+List\+Ending\+Whitespace)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Decoder\+Test}, Test\+List\+No\+Whitespace)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Decoder\+Test}, Test\+List\+One\+Item)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Decoder\+Test}, Test\+Dictionary\+Many\+Elts)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Decoder\+Test}, Test\+Dictionary\+One\+Elt)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Decoder\+Test}, Test\+Param\+List\+One\+Elt)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Decoder\+Test}, Test\+Param\+List\+Many\+Elts)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Decoder\+Test}, Test\+Param\+List\+No\+Params)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Decoder\+Test}, Test\+Param\+List\+Whitespace)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Decoder\+Test}, Test\+Param\+List\+Null\+Values)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+Integer)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+Integer\+Negative)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+Float)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+Float\+Too\+Much\+Precision)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+Float\+Negative)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+String)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+String\+Bad\+Content)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+String\+Backslash)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+String\+Quote)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+Binary\+Content)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+Identifier)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+Identifier\+Bad\+Content)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+Wrong\+Type)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+List\+Many\+Elts)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+List\+One\+Elt)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+List\+Empty)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+List\+Bad\+Item)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+Dictionary\+One\+Elt)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+Dictionary\+Many\+Elts)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+Dictionary\+Empty)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+Dictionary\+Bad\+Item)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+Dictionary\+Bad\+Identifier)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+Param\+List\+One\+Elt)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+Param\+List\+Successive\+Nulls)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+Param\+List\+Many\+Elts)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+Param\+List\+Empty)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+Param\+List\+Bad\+Secondary\+Identifier)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+Param\+List\+Bad\+Primary\+Identifier)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Encoder\+Test}, Test\+Param\+List\+Bad\+Items)
\item 
{\bf T\+E\+S\+T\+\_\+P} ({\bf Legal\+String\+Tests}, Legal\+Strings)
\item 
{\bf T\+E\+S\+T\+\_\+P} ({\bf Legal\+Binary\+Content\+Tests}, Legal\+Binary\+Content)
\item 
{\bf T\+E\+S\+T\+\_\+P} ({\bf Legal\+Integer\+Tests}, Legal\+Integers)
\item 
{\bf T\+E\+S\+T\+\_\+P} ({\bf Legal\+Float\+Tests}, Legal\+Floats)
\item 
{\bf T\+E\+S\+T\+\_\+P} ({\bf Illegal\+Item\+Test}, Illegal\+Item)
\item 
{\bf T\+E\+S\+T\+\_\+P} ({\bf Illegal\+List\+Test}, Illegal\+List)
\item 
{\bf I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P} (Test\+Legal\+Strings, {\bf Legal\+String\+Tests},\+::testing\+::\+Values\+In({\bf k\+Legal\+String\+Tests}))
\item 
{\bf I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P} (Test\+Legal\+Binary\+Content, {\bf Legal\+Binary\+Content\+Tests},\+::testing\+::\+Values\+In({\bf k\+Legal\+Bin\+Content\+Tests}))
\item 
{\bf I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P} (Test\+Legal\+Ints, {\bf Legal\+Integer\+Tests},\+::testing\+::\+Values\+In({\bf k\+Legal\+Int\+Tests}))
\item 
{\bf I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P} (Test\+Legal\+Floats, {\bf Legal\+Float\+Tests},\+::testing\+::\+Values\+In({\bf k\+Legal\+Float\+Tests}))
\item 
{\bf I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P} (Test\+Illegal\+Items, {\bf Illegal\+Item\+Test},\+::testing\+::\+Values\+In({\bf k\+Illegal\+Item\+Tests}))
\item 
{\bf I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P} (Test\+Illegal\+Lists, {\bf Illegal\+List\+Test},\+::testing\+::\+Values\+In({\bf k\+Illegal\+List\+Tests}))
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Standard\+Test}, Test\+Basic\+List)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Standard\+Test}, Test\+Single\+Item\+List)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Standard\+Test}, Test\+No\+Whitespace\+List)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Structured\+Headers\+Standard\+Test}, Test\+Extra\+Whitespace\+List)
\item 
inline\+::testing\+::\+Matcher$<$ {\bf H\+T\+T\+P\+Headers} \& $>$ {\bf Has\+H\+T\+T\+P\+Header} (std\+::string {\bf name})
\item 
inline\+::testing\+::\+Matcher$<$ {\bf H\+T\+T\+P\+Headers} \& $>$ {\bf Has\+H\+T\+T\+P\+Header} (std\+::string {\bf name}, std\+::string value)
\item 
bool {\bf operator$<$} (const {\bf Acceptor\+Address} \&lv, const {\bf Acceptor\+Address} \&rv)
\item 
std\+::ostream \& {\bf operator$<$$<$} (std\+::ostream \&os, const {\bf Acceptor\+Address\+::\+Acceptor\+Type} \&acc\+Type)
\item 
std\+::ostream \& {\bf operator$<$$<$} (std\+::ostream \&os, const {\bf Acceptor\+Address} \&acc\+Addr)
\item 
{\bf Async\+Timeout\+Set\+::\+Timeout\+Clock} \& {\bf get\+Timeout\+Clock} ()
\item 
std\+::string {\bf base64\+Encode} (folly\+::\+Byte\+Range text)
\item 
std\+::string {\bf md5\+Encode} (folly\+::\+Byte\+Range text)
\item 
folly\+::\+Optional$<$ int64\+\_\+t $>$ {\bf parse\+H\+T\+T\+P\+Date\+Time} (const std\+::string \&s)
\item 
string {\bf hex\+Str} (String\+Piece sp)
\item 
void {\bf dump\+Bin\+To\+File} (const string \&filename, const I\+O\+Buf $\ast$buf)
\item 
{\footnotesize template$<$class T $>$ }\\{\bf Null\+Stream} \& {\bf operator$<$$<$} ({\bf Null\+Stream} \&ns, const {\bf T} \&)
\item 
void {\bf dump\+Bin\+To\+File} (const std\+::string \&filename, const folly\+::\+I\+O\+Buf $\ast$buf)
\item 
std\+::string {\bf hex\+Str} (folly\+::\+String\+Piece sp)
\item 
static bool {\bf validate\+Scheme} (folly\+::\+String\+Piece url)
\item 
std\+::string {\bf get\+Date\+Time\+Str} (const A\+S\+N1\+\_\+\+T\+I\+ME $\ast$const time)
\item 
{\footnotesize template$<$typename T $>$ }\\bool {\bf duration\+Initialized} (const {\bf T} \&duration)
\item 
{\footnotesize template$<$typename T $>$ }\\bool {\bf time\+Point\+Initialized} (const {\bf T} \&time)
\item 
{\footnotesize template$<$typename Clock\+Type  = Steady\+Clock$>$ }\\std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$ {\bf get\+Current\+Time} ()
\item 
std\+::chrono\+::system\+\_\+clock\+::time\+\_\+point {\bf to\+System\+Time\+Point} ({\bf Time\+Point} t)
\item 
time\+\_\+t {\bf to\+TimeT} ({\bf Time\+Point} t)
\item 
std\+::chrono\+::milliseconds {\bf milliseconds\+Since\+Epoch} ()
\item 
std\+::chrono\+::seconds {\bf seconds\+Since\+Epoch} ()
\item 
std\+::chrono\+::milliseconds {\bf milliseconds\+Since\+Epoch} ({\bf Time\+Point} t)
\item 
std\+::chrono\+::seconds {\bf seconds\+Since\+Epoch} ({\bf Time\+Point} t)
\item 
{\footnotesize template$<$typename Clock\+Type  = Steady\+Clock$>$ }\\std\+::chrono\+::microseconds {\bf microseconds\+Between} (std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$ finish, std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$ start)
\item 
{\footnotesize template$<$typename Clock\+Type  = Steady\+Clock$>$ }\\std\+::chrono\+::milliseconds {\bf milliseconds\+Between} (std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$ finish, std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$ start)
\item 
{\footnotesize template$<$typename Clock\+Type  = Steady\+Clock$>$ }\\std\+::chrono\+::seconds {\bf seconds\+Between} (std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$ finish, std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$ start)
\item 
{\footnotesize template$<$typename Clock\+Type  = Steady\+Clock$>$ }\\std\+::chrono\+::milliseconds {\bf milliseconds\+Since} (std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$ t)
\item 
{\footnotesize template$<$typename Clock\+Type  = Steady\+Clock$>$ }\\std\+::chrono\+::seconds {\bf seconds\+Since} (std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$ t)
\item 
void {\bf get\+Date\+Time\+Str} (char datebuf[32], char timebuf[32])
\item 
void {\bf get\+Date\+Offset\+Str} (char datebuf[32], int day\+Offset)
\item 
std\+::string {\bf get\+Date\+Time\+Str} ({\bf Time\+Point} tp)
\item 
std\+::ostream \& {\bf operator$<$$<$} (std\+::ostream \&os, Trace\+Event\+Type event\+Type)
\item 
std\+::ostream \& {\bf operator$<$$<$} (std\+::ostream \&os, Trace\+Field\+Type field\+Type)
\item 
std\+::ostream \& {\bf operator$<$$<$} (std\+::ostream \&out, const {\bf Trace\+Event} \&event)
\item 
bool {\bf case\+Insensitive\+Equal} (folly\+::\+String\+Piece s, folly\+::\+String\+Piece t)
\item 
bool {\bf case\+Underscore\+Insensitive\+Equal} (folly\+::\+String\+Piece s, folly\+::\+String\+Piece t)
\item 
bool {\bf validate\+U\+RL} (folly\+::\+Byte\+Range url)
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const char {\bf k\+S\+P\+D\+Yv2\+Dictionary} [$\,$]
\item 
const unsigned char {\bf k\+S\+P\+D\+Yv3\+Dictionary} [$\,$]
\item 
const uint8\+\_\+t {\bf k\+Max\+Error\+Code} = 12
\item 
constexpr folly\+::\+String\+Piece {\bf k\+Upgrade\+Token} = \char`\"{}websocket\char`\"{}
\item 
constexpr folly\+::\+String\+Piece {\bf k\+Upgrade\+Connection\+Token} = \char`\"{}Upgrade\char`\"{}
\item 
constexpr folly\+::\+String\+Piece {\bf k\+W\+S\+Magic\+String} = \char`\"{}258\+E\+A\+F\+A5-\/\+E914-\/47\+D\+A-\/95\+C\+A-\/\+C5\+A\+B0\+D\+C85\+B11\char`\"{}
\item 
const {\bf H\+T\+T\+P\+Settings} {\bf k\+Default\+Ingress\+Settings}
\item 
const uint8\+\_\+t {\bf H\+T\+T\+P\+Header\+Code\+Common\+Offset} = 2
\item 
const std\+::string {\bf empty\+\_\+string}
\item 
const char $\ast$ {\bf connection\+Close\+Strings} [$\,$]
\item 
static const std\+::string {\bf k\+Message\+Filter\+Default\+Name\+\_\+} = \char`\"{}Unknown\char`\"{}
\item 
const char $\ast$const {\bf k\+Type\+Strings} [$\,$]
\item 
constexpr uint32\+\_\+t {\bf k\+Default\+Max\+Concurrent\+Outgoing\+Streams} = 100
\item 
const wangle\+::\+Transport\+Info {\bf mock\+Transport\+Info} = wangle\+::\+Transport\+Info()
\item 
const Socket\+Address {\bf local\+Addr} \{\char`\"{}127.\+0.\+0.\+1\char`\"{}, 80\}
\item 
const Socket\+Address {\bf peer\+Addr} \{\char`\"{}127.\+0.\+0.\+1\char`\"{}, 12345\}
\item 
static const std\+::vector$<$ std\+::pair$<$ std\+::string, std\+::string $>$ $>$ {\bf k\+Legal\+String\+Tests}
\item 
static const std\+::vector$<$ std\+::pair$<$ std\+::string, std\+::string $>$ $>$ {\bf k\+Legal\+Bin\+Content\+Tests}
\item 
static const std\+::vector$<$ std\+::pair$<$ std\+::string, int64\+\_\+t $>$ $>$ {\bf k\+Legal\+Int\+Tests}
\item 
static const std\+::vector$<$ std\+::pair$<$ std\+::string, double $>$ $>$ {\bf k\+Legal\+Float\+Tests}
\item 
static const std\+::vector$<$ std\+::string $>$ {\bf k\+Illegal\+Item\+Tests}
\item 
static const std\+::vector$<$ std\+::string $>$ {\bf k\+Illegal\+List\+Tests}
\item 
static const std\+::string {\bf k\+Mock\+Filter\+Name} = \char`\"{}Mock\+Filter\char`\"{}
\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\index{proxygen@{proxygen}!Acceptor\+Type@{Acceptor\+Type}}
\index{Acceptor\+Type@{Acceptor\+Type}!proxygen@{proxygen}}
\subsubsection[{Acceptor\+Type}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::\+Acceptor\+Type} = typedef {\bf Acceptor\+Address\+::\+Acceptor\+Type}}\label{namespaceproxygen_a95530964d6c2b62b38fe57ec81ac35d5}


Definition at line 59 of file Acceptor\+Address.\+h.

\index{proxygen@{proxygen}!H\+T\+T\+P\+Codec\+Filter@{H\+T\+T\+P\+Codec\+Filter}}
\index{H\+T\+T\+P\+Codec\+Filter@{H\+T\+T\+P\+Codec\+Filter}!proxygen@{proxygen}}
\subsubsection[{H\+T\+T\+P\+Codec\+Filter}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Generic\+Filter}$<$ {\bf H\+T\+T\+P\+Codec}, {\bf H\+T\+T\+P\+Codec\+::\+Callback}, \&{\bf H\+T\+T\+P\+Codec\+::set\+Callback}, true$>$ {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+Filter}}\label{namespaceproxygen_ac0eaae14747186a4429ac2cf1b2569cf}


Definition at line 21 of file H\+T\+T\+P\+Codec\+Filter.\+h.

\index{proxygen@{proxygen}!H\+T\+T\+P\+Codec\+Filter\+Chain@{H\+T\+T\+P\+Codec\+Filter\+Chain}}
\index{H\+T\+T\+P\+Codec\+Filter\+Chain@{H\+T\+T\+P\+Codec\+Filter\+Chain}!proxygen@{proxygen}}
\subsubsection[{H\+T\+T\+P\+Codec\+Filter\+Chain}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Filter\+Chain}$<$ {\bf H\+T\+T\+P\+Codec}, {\bf H\+T\+T\+P\+Codec\+::\+Callback}, {\bf Pass\+Through\+H\+T\+T\+P\+Codec\+Filter}, \&{\bf H\+T\+T\+P\+Codec\+::set\+Callback}, true$>$ {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+Filter\+Chain}}\label{namespaceproxygen_a3ace5f258ceebf6e188f3575b180dd4b}


Definition at line 255 of file H\+T\+T\+P\+Codec\+Filter.\+h.

\index{proxygen@{proxygen}!H\+T\+T\+P\+Header\+Size@{H\+T\+T\+P\+Header\+Size}}
\index{H\+T\+T\+P\+Header\+Size@{H\+T\+T\+P\+Header\+Size}!proxygen@{proxygen}}
\subsubsection[{H\+T\+T\+P\+Header\+Size}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::\+H\+T\+T\+P\+Header\+Size} = typedef wangle\+::\+H\+T\+T\+P\+Header\+Size}\label{namespaceproxygen_a3229605c4d71bcf5379d0dd133870421}


Definition at line 18 of file H\+T\+T\+P\+Header\+Size.\+h.

\index{proxygen@{proxygen}!H\+T\+T\+P\+Transaction\+Egress\+SM@{H\+T\+T\+P\+Transaction\+Egress\+SM}}
\index{H\+T\+T\+P\+Transaction\+Egress\+SM@{H\+T\+T\+P\+Transaction\+Egress\+SM}!proxygen@{proxygen}}
\subsubsection[{H\+T\+T\+P\+Transaction\+Egress\+SM}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+Egress\+SM} = typedef {\bf State\+Machine}$<${\bf H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data}$>$}\label{namespaceproxygen_a047c59ff6c449b0d553461f225faa032}


Definition at line 61 of file H\+T\+T\+P\+Transaction\+Egress\+S\+M.\+h.

\index{proxygen@{proxygen}!H\+T\+T\+P\+Transaction\+Ingress\+SM@{H\+T\+T\+P\+Transaction\+Ingress\+SM}}
\index{H\+T\+T\+P\+Transaction\+Ingress\+SM@{H\+T\+T\+P\+Transaction\+Ingress\+SM}!proxygen@{proxygen}}
\subsubsection[{H\+T\+T\+P\+Transaction\+Ingress\+SM}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+Ingress\+SM} = typedef {\bf State\+Machine}$<${\bf H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data}$>$}\label{namespaceproxygen_af048357226422af446094c47308dbcf0}


Definition at line 64 of file H\+T\+T\+P\+Transaction\+Ingress\+S\+M.\+h.

\index{proxygen@{proxygen}!I\+D\+List@{I\+D\+List}}
\index{I\+D\+List@{I\+D\+List}!proxygen@{proxygen}}
\subsubsection[{I\+D\+List}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::\+I\+D\+List} = typedef std\+::list$<$std\+::pair$<${\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}, uint8\+\_\+t$>$$>$}\label{namespaceproxygen_af85ee76f99f4f707295885bb7879ab3b}


Definition at line 53 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.

\index{proxygen@{proxygen}!Mock\+Time\+Util@{Mock\+Time\+Util}}
\index{Mock\+Time\+Util@{Mock\+Time\+Util}!proxygen@{proxygen}}
\subsubsection[{Mock\+Time\+Util}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::\+Mock\+Time\+Util} = typedef {\bf Mock\+Time\+Util\+Generic}$<$$>$}\label{namespaceproxygen_a1892a1ded09bea580aa3a51af9ef6ec6}


Definition at line 42 of file Mock\+Time.\+h.

\index{proxygen@{proxygen}!Setting\+Pair@{Setting\+Pair}}
\index{Setting\+Pair@{Setting\+Pair}!proxygen@{proxygen}}
\subsubsection[{Setting\+Pair}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::\+Setting\+Pair} = typedef std\+::pair$<${\bf Settings\+Id}, uint32\+\_\+t$>$}\label{namespaceproxygen_a46b9e5fe9b6ededd4f72da3025aa9bce}


Definition at line 58 of file Settings\+Id.\+h.

\index{proxygen@{proxygen}!Settings\+List@{Settings\+List}}
\index{Settings\+List@{Settings\+List}!proxygen@{proxygen}}
\subsubsection[{Settings\+List}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::\+Settings\+List} = typedef std\+::vector$<${\bf H\+T\+T\+P\+Setting}$>$}\label{namespaceproxygen_a178ae546fbff60576dc3e3ce2de52410}


Definition at line 81 of file H\+T\+T\+P\+Settings.\+h.

\index{proxygen@{proxygen}!Settings\+Value@{Settings\+Value}}
\index{Settings\+Value@{Settings\+Value}!proxygen@{proxygen}}
\subsubsection[{Settings\+Value}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::\+Settings\+Value} = typedef uint64\+\_\+t}\label{namespaceproxygen_a80e64b3bc6f0486db160ceea90c518a4}


Definition at line 25 of file H\+T\+T\+P\+Settings.\+h.

\index{proxygen@{proxygen}!Steady\+Clock@{Steady\+Clock}}
\index{Steady\+Clock@{Steady\+Clock}!proxygen@{proxygen}}
\subsubsection[{Steady\+Clock}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::\+Steady\+Clock} = typedef std\+::chrono\+::steady\+\_\+clock}\label{namespaceproxygen_acb11a56b2209c2cc4abb10a22d9c637b}


Definition at line 23 of file Time.\+h.

\index{proxygen@{proxygen}!string\+\_\+buf@{string\+\_\+buf}}
\index{string\+\_\+buf@{string\+\_\+buf}!proxygen@{proxygen}}
\subsubsection[{string\+\_\+buf}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::string\+\_\+buf} = typedef boost\+::iostreams\+::stream\+\_\+buffer$<$ boost\+::iostreams\+::back\+\_\+insert\+\_\+device$<$std\+::string$>$ $>$}\label{namespaceproxygen_a09c44472567cfbc8e368ec07bfd51ff7}


Definition at line 26 of file Structured\+Headers\+Encoder.\+h.

\index{proxygen@{proxygen}!System\+Clock@{System\+Clock}}
\index{System\+Clock@{System\+Clock}!proxygen@{proxygen}}
\subsubsection[{System\+Clock}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::\+System\+Clock} = typedef std\+::chrono\+::system\+\_\+clock}\label{namespaceproxygen_ae075dee7ac33d30dfc497ea26ce28c0d}


Definition at line 24 of file Time.\+h.

\index{proxygen@{proxygen}!System\+Time\+Point@{System\+Time\+Point}}
\index{System\+Time\+Point@{System\+Time\+Point}!proxygen@{proxygen}}
\subsubsection[{System\+Time\+Point}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::\+System\+Time\+Point} = typedef System\+Clock\+::time\+\_\+point}\label{namespaceproxygen_af696701ef88c8e36bad93f2b2b76b9c5}


Definition at line 26 of file Time.\+h.

\index{proxygen@{proxygen}!Time\+Point@{Time\+Point}}
\index{Time\+Point@{Time\+Point}!proxygen@{proxygen}}
\subsubsection[{Time\+Point}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::\+Time\+Point} = typedef Steady\+Clock\+::time\+\_\+point}\label{namespaceproxygen_ab1ccd825f69c99dd89b92765687b8d27}


Definition at line 25 of file Time.\+h.

\index{proxygen@{proxygen}!Time\+Util@{Time\+Util}}
\index{Time\+Util@{Time\+Util}!proxygen@{proxygen}}
\subsubsection[{Time\+Util}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::\+Time\+Util} = typedef {\bf Time\+Util\+Generic}$<$$>$}\label{namespaceproxygen_aa8e5b382f279dff53aa5afbb21eeb5f7}


Definition at line 194 of file Time.\+h.

\index{proxygen@{proxygen}!Transport\+Filter@{Transport\+Filter}}
\index{Transport\+Filter@{Transport\+Filter}!proxygen@{proxygen}}
\subsubsection[{Transport\+Filter}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Generic\+Filter}$<$ folly\+::\+Async\+Transport\+Wrapper, folly\+::\+Async\+Transport\+Wrapper\+::\+Read\+Callback, \&folly\+::\+Async\+Transport\+Wrapper\+::set\+Read\+CB, true, folly\+::\+Async\+Transport\+Wrapper\+::\+Destructor$>$ {\bf proxygen\+::\+Transport\+Filter}}\label{namespaceproxygen_ac99770d0f98ef10f8115eb62312ddbe4}


Definition at line 23 of file Transport\+Filter.\+h.

\index{proxygen@{proxygen}!Transport\+Filter\+Chain@{Transport\+Filter\+Chain}}
\index{Transport\+Filter\+Chain@{Transport\+Filter\+Chain}!proxygen@{proxygen}}
\subsubsection[{Transport\+Filter\+Chain}]{\setlength{\rightskip}{0pt plus 5cm}typedef {\bf Filter\+Chain}$<$ folly\+::\+Async\+Transport\+Wrapper, folly\+::\+Async\+Transport\+Wrapper\+::\+Read\+Callback, {\bf Pass\+Through\+Transport\+Filter}, \&folly\+::\+Async\+Transport\+Wrapper\+::set\+Read\+CB, false$>$ {\bf proxygen\+::\+Transport\+Filter\+Chain}}\label{namespaceproxygen_add5a92de318d2730594ecb19bbc4cd7e}


Definition at line 121 of file Transport\+Filter.\+h.



\subsection{Enumeration Type Documentation}
\index{proxygen@{proxygen}!Codec\+Protocol@{Codec\+Protocol}}
\index{Codec\+Protocol@{Codec\+Protocol}!proxygen@{proxygen}}
\subsubsection[{Codec\+Protocol}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+Codec\+Protocol} \+: uint8\+\_\+t\hspace{0.3cm}{\ttfamily [strong]}}\label{namespaceproxygen_a470a61083ee151f964f0382f345a2b42}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{H\+T\+T\+P\+\_\+1\+\_\+1@{H\+T\+T\+P\+\_\+1\+\_\+1}!proxygen@{proxygen}}\index{proxygen@{proxygen}!H\+T\+T\+P\+\_\+1\+\_\+1@{H\+T\+T\+P\+\_\+1\+\_\+1}}\item[{\em 
H\+T\+T\+P\+\_\+1\+\_\+1\label{namespaceproxygen_a470a61083ee151f964f0382f345a2b42a5f1f9932b84e67c4a4b7e91c03335077}
}]\index{S\+P\+D\+Y\+\_\+3@{S\+P\+D\+Y\+\_\+3}!proxygen@{proxygen}}\index{proxygen@{proxygen}!S\+P\+D\+Y\+\_\+3@{S\+P\+D\+Y\+\_\+3}}\item[{\em 
S\+P\+D\+Y\+\_\+3\label{namespaceproxygen_a470a61083ee151f964f0382f345a2b42a61b2283dd44b9ac51c5b0cd35d91cbe3}
}]\index{S\+P\+D\+Y\+\_\+3\+\_\+1@{S\+P\+D\+Y\+\_\+3\+\_\+1}!proxygen@{proxygen}}\index{proxygen@{proxygen}!S\+P\+D\+Y\+\_\+3\+\_\+1@{S\+P\+D\+Y\+\_\+3\+\_\+1}}\item[{\em 
S\+P\+D\+Y\+\_\+3\+\_\+1\label{namespaceproxygen_a470a61083ee151f964f0382f345a2b42a68a2e6fc7a7542406bb6db8d120f9e86}
}]\index{H\+T\+T\+P\+\_\+2@{H\+T\+T\+P\+\_\+2}!proxygen@{proxygen}}\index{proxygen@{proxygen}!H\+T\+T\+P\+\_\+2@{H\+T\+T\+P\+\_\+2}}\item[{\em 
H\+T\+T\+P\+\_\+2\label{namespaceproxygen_a470a61083ee151f964f0382f345a2b42ad1ea3abbe73fec0b8ae7b3454a9430c6}
}]\index{HQ@{HQ}!proxygen@{proxygen}}\index{proxygen@{proxygen}!HQ@{HQ}}\item[{\em 
HQ\label{namespaceproxygen_a470a61083ee151f964f0382f345a2b42a8fe49abfd9ab1d6620b6e84dde100789}
}]\end{description}
\end{Desc}


Definition at line 19 of file Codec\+Protocol.\+h.


\begin{DoxyCode}
19                          : uint8\_t \{
20   HTTP_1_1,
21   SPDY_3,
22   SPDY_3_1,
23   HTTP_2,
24   HQ,
25 \};
\end{DoxyCode}
\index{proxygen@{proxygen}!Connection\+Close\+Reason@{Connection\+Close\+Reason}}
\index{Connection\+Close\+Reason@{Connection\+Close\+Reason}!proxygen@{proxygen}}
\subsubsection[{Connection\+Close\+Reason}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+Connection\+Close\+Reason}\hspace{0.3cm}{\ttfamily [strong]}}\label{namespaceproxygen_aa4a7ba4818c6145c6ec3879c3dd9f667}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{S\+H\+U\+T\+D\+O\+WN@{S\+H\+U\+T\+D\+O\+WN}!proxygen@{proxygen}}\index{proxygen@{proxygen}!S\+H\+U\+T\+D\+O\+WN@{S\+H\+U\+T\+D\+O\+WN}}\item[{\em 
S\+H\+U\+T\+D\+O\+WN\label{namespaceproxygen_aa4a7ba4818c6145c6ec3879c3dd9f667ab9984206799a7f9fe4bd1b6c18db8112}
}]\index{R\+E\+A\+D\+\_\+\+E\+OF@{R\+E\+A\+D\+\_\+\+E\+OF}!proxygen@{proxygen}}\index{proxygen@{proxygen}!R\+E\+A\+D\+\_\+\+E\+OF@{R\+E\+A\+D\+\_\+\+E\+OF}}\item[{\em 
R\+E\+A\+D\+\_\+\+E\+OF\label{namespaceproxygen_aa4a7ba4818c6145c6ec3879c3dd9f667ada99ff010941809df479eeee1686f05b}
}]\index{G\+O\+A\+W\+AY@{G\+O\+A\+W\+AY}!proxygen@{proxygen}}\index{proxygen@{proxygen}!G\+O\+A\+W\+AY@{G\+O\+A\+W\+AY}}\item[{\em 
G\+O\+A\+W\+AY\label{namespaceproxygen_aa4a7ba4818c6145c6ec3879c3dd9f667a21c426cbdb92c2439053c570eb511c30}
}]\index{S\+E\+S\+S\+I\+O\+N\+\_\+\+P\+A\+R\+S\+E\+\_\+\+E\+R\+R\+OR@{S\+E\+S\+S\+I\+O\+N\+\_\+\+P\+A\+R\+S\+E\+\_\+\+E\+R\+R\+OR}!proxygen@{proxygen}}\index{proxygen@{proxygen}!S\+E\+S\+S\+I\+O\+N\+\_\+\+P\+A\+R\+S\+E\+\_\+\+E\+R\+R\+OR@{S\+E\+S\+S\+I\+O\+N\+\_\+\+P\+A\+R\+S\+E\+\_\+\+E\+R\+R\+OR}}\item[{\em 
S\+E\+S\+S\+I\+O\+N\+\_\+\+P\+A\+R\+S\+E\+\_\+\+E\+R\+R\+OR\label{namespaceproxygen_aa4a7ba4818c6145c6ec3879c3dd9f667abc8291e3bfd7bc90d6b646914e71e20a}
}]\index{R\+E\+M\+O\+T\+E\+\_\+\+E\+R\+R\+OR@{R\+E\+M\+O\+T\+E\+\_\+\+E\+R\+R\+OR}!proxygen@{proxygen}}\index{proxygen@{proxygen}!R\+E\+M\+O\+T\+E\+\_\+\+E\+R\+R\+OR@{R\+E\+M\+O\+T\+E\+\_\+\+E\+R\+R\+OR}}\item[{\em 
R\+E\+M\+O\+T\+E\+\_\+\+E\+R\+R\+OR\label{namespaceproxygen_aa4a7ba4818c6145c6ec3879c3dd9f667a84805da9a7b187e3c776e9b9397eedc9}
}]\index{T\+R\+A\+N\+S\+A\+C\+T\+I\+O\+N\+\_\+\+A\+B\+O\+RT@{T\+R\+A\+N\+S\+A\+C\+T\+I\+O\+N\+\_\+\+A\+B\+O\+RT}!proxygen@{proxygen}}\index{proxygen@{proxygen}!T\+R\+A\+N\+S\+A\+C\+T\+I\+O\+N\+\_\+\+A\+B\+O\+RT@{T\+R\+A\+N\+S\+A\+C\+T\+I\+O\+N\+\_\+\+A\+B\+O\+RT}}\item[{\em 
T\+R\+A\+N\+S\+A\+C\+T\+I\+O\+N\+\_\+\+A\+B\+O\+RT\label{namespaceproxygen_aa4a7ba4818c6145c6ec3879c3dd9f667aaf5a2dd0c659c4547760d2d9acc3bc02}
}]\index{T\+I\+M\+E\+O\+UT@{T\+I\+M\+E\+O\+UT}!proxygen@{proxygen}}\index{proxygen@{proxygen}!T\+I\+M\+E\+O\+UT@{T\+I\+M\+E\+O\+UT}}\item[{\em 
T\+I\+M\+E\+O\+UT\label{namespaceproxygen_aa4a7ba4818c6145c6ec3879c3dd9f667a070a0fb40f6c308ab544b227660aadff}
}]\index{I\+O\+\_\+\+R\+E\+A\+D\+\_\+\+E\+R\+R\+OR@{I\+O\+\_\+\+R\+E\+A\+D\+\_\+\+E\+R\+R\+OR}!proxygen@{proxygen}}\index{proxygen@{proxygen}!I\+O\+\_\+\+R\+E\+A\+D\+\_\+\+E\+R\+R\+OR@{I\+O\+\_\+\+R\+E\+A\+D\+\_\+\+E\+R\+R\+OR}}\item[{\em 
I\+O\+\_\+\+R\+E\+A\+D\+\_\+\+E\+R\+R\+OR\label{namespaceproxygen_aa4a7ba4818c6145c6ec3879c3dd9f667a162a7cc9ea71b6da4c955edbec3648c3}
}]\index{I\+O\+\_\+\+W\+R\+I\+T\+E\+\_\+\+E\+R\+R\+OR@{I\+O\+\_\+\+W\+R\+I\+T\+E\+\_\+\+E\+R\+R\+OR}!proxygen@{proxygen}}\index{proxygen@{proxygen}!I\+O\+\_\+\+W\+R\+I\+T\+E\+\_\+\+E\+R\+R\+OR@{I\+O\+\_\+\+W\+R\+I\+T\+E\+\_\+\+E\+R\+R\+OR}}\item[{\em 
I\+O\+\_\+\+W\+R\+I\+T\+E\+\_\+\+E\+R\+R\+OR\label{namespaceproxygen_aa4a7ba4818c6145c6ec3879c3dd9f667ae7b30c1de0f6fd86fc42cd43e23bb8cb}
}]\index{R\+E\+Q\+\_\+\+N\+O\+T\+R\+E\+U\+S\+A\+B\+LE@{R\+E\+Q\+\_\+\+N\+O\+T\+R\+E\+U\+S\+A\+B\+LE}!proxygen@{proxygen}}\index{proxygen@{proxygen}!R\+E\+Q\+\_\+\+N\+O\+T\+R\+E\+U\+S\+A\+B\+LE@{R\+E\+Q\+\_\+\+N\+O\+T\+R\+E\+U\+S\+A\+B\+LE}}\item[{\em 
R\+E\+Q\+\_\+\+N\+O\+T\+R\+E\+U\+S\+A\+B\+LE\label{namespaceproxygen_aa4a7ba4818c6145c6ec3879c3dd9f667a8286701e6ad7f545d758e3fb34aabb84}
}]\index{E\+R\+R\+\_\+\+R\+E\+SP@{E\+R\+R\+\_\+\+R\+E\+SP}!proxygen@{proxygen}}\index{proxygen@{proxygen}!E\+R\+R\+\_\+\+R\+E\+SP@{E\+R\+R\+\_\+\+R\+E\+SP}}\item[{\em 
E\+R\+R\+\_\+\+R\+E\+SP\label{namespaceproxygen_aa4a7ba4818c6145c6ec3879c3dd9f667afa16e786e8fd5cdf5a3bb60d01fe84ac}
}]\index{U\+N\+K\+N\+O\+WN@{U\+N\+K\+N\+O\+WN}!proxygen@{proxygen}}\index{proxygen@{proxygen}!U\+N\+K\+N\+O\+WN@{U\+N\+K\+N\+O\+WN}}\item[{\em 
U\+N\+K\+N\+O\+WN\label{namespaceproxygen_aa4a7ba4818c6145c6ec3879c3dd9f667a696b031073e74bf2cb98e5ef201d4aa3}
}]\index{F\+L\+O\+W\+\_\+\+C\+O\+N\+T\+R\+OL@{F\+L\+O\+W\+\_\+\+C\+O\+N\+T\+R\+OL}!proxygen@{proxygen}}\index{proxygen@{proxygen}!F\+L\+O\+W\+\_\+\+C\+O\+N\+T\+R\+OL@{F\+L\+O\+W\+\_\+\+C\+O\+N\+T\+R\+OL}}\item[{\em 
F\+L\+O\+W\+\_\+\+C\+O\+N\+T\+R\+OL\label{namespaceproxygen_aa4a7ba4818c6145c6ec3879c3dd9f667ad4d13dc452c1991ebc2c8b57a0c7feba}
}]\index{k\+M\+A\+X\+\_\+\+R\+E\+A\+S\+ON@{k\+M\+A\+X\+\_\+\+R\+E\+A\+S\+ON}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+M\+A\+X\+\_\+\+R\+E\+A\+S\+ON@{k\+M\+A\+X\+\_\+\+R\+E\+A\+S\+ON}}\item[{\em 
k\+M\+A\+X\+\_\+\+R\+E\+A\+S\+ON\label{namespaceproxygen_aa4a7ba4818c6145c6ec3879c3dd9f667af3265889b7cb54a22716221cdaa0fdce}
}]\end{description}
\end{Desc}


Definition at line 51 of file H\+T\+T\+P\+Constants.\+h.


\begin{DoxyCode}
51                                  \{
52   CONNECTION_CLOSE_REASON_GEN(CONNECTION_CLOSE_REASON_ENUM)
\end{DoxyCode}
\index{proxygen@{proxygen}!Error\+Code@{Error\+Code}}
\index{Error\+Code@{Error\+Code}!proxygen@{proxygen}}
\subsubsection[{Error\+Code}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+Error\+Code} \+: uint8\+\_\+t\hspace{0.3cm}{\ttfamily [strong]}}\label{namespaceproxygen_a3d6f6c837ecc1ee254de4e790826ae9b}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{N\+O\+\_\+\+E\+R\+R\+OR@{N\+O\+\_\+\+E\+R\+R\+OR}!proxygen@{proxygen}}\index{proxygen@{proxygen}!N\+O\+\_\+\+E\+R\+R\+OR@{N\+O\+\_\+\+E\+R\+R\+OR}}\item[{\em 
N\+O\+\_\+\+E\+R\+R\+OR\label{namespaceproxygen_a3d6f6c837ecc1ee254de4e790826ae9bad306b6fdee05fe87455110ddf6501e6c}
}]\index{P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR@{P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR}!proxygen@{proxygen}}\index{proxygen@{proxygen}!P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR@{P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR}}\item[{\em 
P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR\label{namespaceproxygen_a3d6f6c837ecc1ee254de4e790826ae9ba23f149f0f9ae9ed9e0119e7209178a5d}
}]\index{I\+N\+T\+E\+R\+N\+A\+L\+\_\+\+E\+R\+R\+OR@{I\+N\+T\+E\+R\+N\+A\+L\+\_\+\+E\+R\+R\+OR}!proxygen@{proxygen}}\index{proxygen@{proxygen}!I\+N\+T\+E\+R\+N\+A\+L\+\_\+\+E\+R\+R\+OR@{I\+N\+T\+E\+R\+N\+A\+L\+\_\+\+E\+R\+R\+OR}}\item[{\em 
I\+N\+T\+E\+R\+N\+A\+L\+\_\+\+E\+R\+R\+OR\label{namespaceproxygen_a3d6f6c837ecc1ee254de4e790826ae9bae8c0c70879b5895c615677261d64a1ee}
}]\index{F\+L\+O\+W\+\_\+\+C\+O\+N\+T\+R\+O\+L\+\_\+\+E\+R\+R\+OR@{F\+L\+O\+W\+\_\+\+C\+O\+N\+T\+R\+O\+L\+\_\+\+E\+R\+R\+OR}!proxygen@{proxygen}}\index{proxygen@{proxygen}!F\+L\+O\+W\+\_\+\+C\+O\+N\+T\+R\+O\+L\+\_\+\+E\+R\+R\+OR@{F\+L\+O\+W\+\_\+\+C\+O\+N\+T\+R\+O\+L\+\_\+\+E\+R\+R\+OR}}\item[{\em 
F\+L\+O\+W\+\_\+\+C\+O\+N\+T\+R\+O\+L\+\_\+\+E\+R\+R\+OR\label{namespaceproxygen_a3d6f6c837ecc1ee254de4e790826ae9ba20973c7b1b8e3fe85f3926d10271a8d4}
}]\index{S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+T\+I\+M\+E\+O\+UT@{S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+T\+I\+M\+E\+O\+UT}!proxygen@{proxygen}}\index{proxygen@{proxygen}!S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+T\+I\+M\+E\+O\+UT@{S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+T\+I\+M\+E\+O\+UT}}\item[{\em 
S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+T\+I\+M\+E\+O\+UT\label{namespaceproxygen_a3d6f6c837ecc1ee254de4e790826ae9ba653e43604415577e4a01fef2e382c9d1}
}]\index{S\+T\+R\+E\+A\+M\+\_\+\+C\+L\+O\+S\+ED@{S\+T\+R\+E\+A\+M\+\_\+\+C\+L\+O\+S\+ED}!proxygen@{proxygen}}\index{proxygen@{proxygen}!S\+T\+R\+E\+A\+M\+\_\+\+C\+L\+O\+S\+ED@{S\+T\+R\+E\+A\+M\+\_\+\+C\+L\+O\+S\+ED}}\item[{\em 
S\+T\+R\+E\+A\+M\+\_\+\+C\+L\+O\+S\+ED\label{namespaceproxygen_a3d6f6c837ecc1ee254de4e790826ae9ba795fcd4a9695a63ff230ad23d4122917}
}]\index{F\+R\+A\+M\+E\+\_\+\+S\+I\+Z\+E\+\_\+\+E\+R\+R\+OR@{F\+R\+A\+M\+E\+\_\+\+S\+I\+Z\+E\+\_\+\+E\+R\+R\+OR}!proxygen@{proxygen}}\index{proxygen@{proxygen}!F\+R\+A\+M\+E\+\_\+\+S\+I\+Z\+E\+\_\+\+E\+R\+R\+OR@{F\+R\+A\+M\+E\+\_\+\+S\+I\+Z\+E\+\_\+\+E\+R\+R\+OR}}\item[{\em 
F\+R\+A\+M\+E\+\_\+\+S\+I\+Z\+E\+\_\+\+E\+R\+R\+OR\label{namespaceproxygen_a3d6f6c837ecc1ee254de4e790826ae9ba3d53bd153221a9a3bc76c346f457b3c3}
}]\index{R\+E\+F\+U\+S\+E\+D\+\_\+\+S\+T\+R\+E\+AM@{R\+E\+F\+U\+S\+E\+D\+\_\+\+S\+T\+R\+E\+AM}!proxygen@{proxygen}}\index{proxygen@{proxygen}!R\+E\+F\+U\+S\+E\+D\+\_\+\+S\+T\+R\+E\+AM@{R\+E\+F\+U\+S\+E\+D\+\_\+\+S\+T\+R\+E\+AM}}\item[{\em 
R\+E\+F\+U\+S\+E\+D\+\_\+\+S\+T\+R\+E\+AM\label{namespaceproxygen_a3d6f6c837ecc1ee254de4e790826ae9ba3e2449dc6a7f4aee6278f70865604374}
}]\index{C\+A\+N\+C\+EL@{C\+A\+N\+C\+EL}!proxygen@{proxygen}}\index{proxygen@{proxygen}!C\+A\+N\+C\+EL@{C\+A\+N\+C\+EL}}\item[{\em 
C\+A\+N\+C\+EL\label{namespaceproxygen_a3d6f6c837ecc1ee254de4e790826ae9ba2027c027133e22c8929e2874dc44dd36}
}]\index{C\+O\+M\+P\+R\+E\+S\+S\+I\+O\+N\+\_\+\+E\+R\+R\+OR@{C\+O\+M\+P\+R\+E\+S\+S\+I\+O\+N\+\_\+\+E\+R\+R\+OR}!proxygen@{proxygen}}\index{proxygen@{proxygen}!C\+O\+M\+P\+R\+E\+S\+S\+I\+O\+N\+\_\+\+E\+R\+R\+OR@{C\+O\+M\+P\+R\+E\+S\+S\+I\+O\+N\+\_\+\+E\+R\+R\+OR}}\item[{\em 
C\+O\+M\+P\+R\+E\+S\+S\+I\+O\+N\+\_\+\+E\+R\+R\+OR\label{namespaceproxygen_a3d6f6c837ecc1ee254de4e790826ae9ba4d8716f0326b9aaf347c6f217e62e8bc}
}]\index{C\+O\+N\+N\+E\+C\+T\+\_\+\+E\+R\+R\+OR@{C\+O\+N\+N\+E\+C\+T\+\_\+\+E\+R\+R\+OR}!proxygen@{proxygen}}\index{proxygen@{proxygen}!C\+O\+N\+N\+E\+C\+T\+\_\+\+E\+R\+R\+OR@{C\+O\+N\+N\+E\+C\+T\+\_\+\+E\+R\+R\+OR}}\item[{\em 
C\+O\+N\+N\+E\+C\+T\+\_\+\+E\+R\+R\+OR\label{namespaceproxygen_a3d6f6c837ecc1ee254de4e790826ae9ba9bccf65b7a01f8d62c945340236971ae}
}]\index{E\+N\+H\+A\+N\+C\+E\+\_\+\+Y\+O\+U\+R\+\_\+\+C\+A\+LM@{E\+N\+H\+A\+N\+C\+E\+\_\+\+Y\+O\+U\+R\+\_\+\+C\+A\+LM}!proxygen@{proxygen}}\index{proxygen@{proxygen}!E\+N\+H\+A\+N\+C\+E\+\_\+\+Y\+O\+U\+R\+\_\+\+C\+A\+LM@{E\+N\+H\+A\+N\+C\+E\+\_\+\+Y\+O\+U\+R\+\_\+\+C\+A\+LM}}\item[{\em 
E\+N\+H\+A\+N\+C\+E\+\_\+\+Y\+O\+U\+R\+\_\+\+C\+A\+LM\label{namespaceproxygen_a3d6f6c837ecc1ee254de4e790826ae9ba3b119c9fe92621433d72165a79e94409}
}]\index{I\+N\+A\+D\+E\+Q\+U\+A\+T\+E\+\_\+\+S\+E\+C\+U\+R\+I\+TY@{I\+N\+A\+D\+E\+Q\+U\+A\+T\+E\+\_\+\+S\+E\+C\+U\+R\+I\+TY}!proxygen@{proxygen}}\index{proxygen@{proxygen}!I\+N\+A\+D\+E\+Q\+U\+A\+T\+E\+\_\+\+S\+E\+C\+U\+R\+I\+TY@{I\+N\+A\+D\+E\+Q\+U\+A\+T\+E\+\_\+\+S\+E\+C\+U\+R\+I\+TY}}\item[{\em 
I\+N\+A\+D\+E\+Q\+U\+A\+T\+E\+\_\+\+S\+E\+C\+U\+R\+I\+TY\label{namespaceproxygen_a3d6f6c837ecc1ee254de4e790826ae9bae5102d0ed2cad3aac7cb2d47d14d3b2e}
}]\index{H\+T\+T\+P\+\_\+1\+\_\+1\+\_\+\+R\+E\+Q\+U\+I\+R\+ED@{H\+T\+T\+P\+\_\+1\+\_\+1\+\_\+\+R\+E\+Q\+U\+I\+R\+ED}!proxygen@{proxygen}}\index{proxygen@{proxygen}!H\+T\+T\+P\+\_\+1\+\_\+1\+\_\+\+R\+E\+Q\+U\+I\+R\+ED@{H\+T\+T\+P\+\_\+1\+\_\+1\+\_\+\+R\+E\+Q\+U\+I\+R\+ED}}\item[{\em 
H\+T\+T\+P\+\_\+1\+\_\+1\+\_\+\+R\+E\+Q\+U\+I\+R\+ED\label{namespaceproxygen_a3d6f6c837ecc1ee254de4e790826ae9bac54d292457fb2007bab47625c8aa42fa}
}]\index{\+\_\+\+S\+P\+D\+Y\+\_\+\+I\+N\+V\+A\+L\+I\+D\+\_\+\+S\+T\+R\+E\+AM@{\+\_\+\+S\+P\+D\+Y\+\_\+\+I\+N\+V\+A\+L\+I\+D\+\_\+\+S\+T\+R\+E\+AM}!proxygen@{proxygen}}\index{proxygen@{proxygen}!\+\_\+\+S\+P\+D\+Y\+\_\+\+I\+N\+V\+A\+L\+I\+D\+\_\+\+S\+T\+R\+E\+AM@{\+\_\+\+S\+P\+D\+Y\+\_\+\+I\+N\+V\+A\+L\+I\+D\+\_\+\+S\+T\+R\+E\+AM}}\item[{\em 
\+\_\+\+S\+P\+D\+Y\+\_\+\+I\+N\+V\+A\+L\+I\+D\+\_\+\+S\+T\+R\+E\+AM\label{namespaceproxygen_a3d6f6c837ecc1ee254de4e790826ae9ba9376c5fa7420be29ddc25c951aea1b7e}
}]\end{description}
\end{Desc}


Definition at line 26 of file Error\+Code.\+h.


\begin{DoxyCode}
26                     : uint8\_t \{
27   NO_ERROR = 0,
28   PROTOCOL_ERROR = 1,
29   INTERNAL_ERROR = 2,
30   FLOW_CONTROL_ERROR = 3,
31   SETTINGS_TIMEOUT = 4,
32   STREAM_CLOSED = 5,
33   FRAME_SIZE_ERROR = 6,
34   REFUSED_STREAM = 7,
35   CANCEL = 8,
36   COMPRESSION_ERROR = 9,
37   CONNECT_ERROR = 10,
38   ENHANCE_YOUR_CALM = 11,
39   INADEQUATE_SECURITY = 12,
40   HTTP_1_1_REQUIRED = 13,
41   \textcolor{comment}{// This code is *NOT* to be used outside of SPDYCodec. Delete this}
42   \textcolor{comment}{// when we deprecate SPDY.}
43   _SPDY_INVALID_STREAM = 100,
44 \};
\end{DoxyCode}
\index{proxygen@{proxygen}!Gzip\+Decode\+Error@{Gzip\+Decode\+Error}}
\index{Gzip\+Decode\+Error@{Gzip\+Decode\+Error}!proxygen@{proxygen}}
\subsubsection[{Gzip\+Decode\+Error}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+Gzip\+Decode\+Error} \+: uint8\+\_\+t\hspace{0.3cm}{\ttfamily [strong]}}\label{namespaceproxygen_ac806516d31d9566f0bc8f2dbce8e9fac}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{N\+O\+NE@{N\+O\+NE}!proxygen@{proxygen}}\index{proxygen@{proxygen}!N\+O\+NE@{N\+O\+NE}}\item[{\em 
N\+O\+NE\label{namespaceproxygen_ac806516d31d9566f0bc8f2dbce8e9facab50339a10e1de285ac99d4c3990b8693}
}]\index{B\+A\+D\+\_\+\+E\+N\+C\+O\+D\+I\+NG@{B\+A\+D\+\_\+\+E\+N\+C\+O\+D\+I\+NG}!proxygen@{proxygen}}\index{proxygen@{proxygen}!B\+A\+D\+\_\+\+E\+N\+C\+O\+D\+I\+NG@{B\+A\+D\+\_\+\+E\+N\+C\+O\+D\+I\+NG}}\item[{\em 
B\+A\+D\+\_\+\+E\+N\+C\+O\+D\+I\+NG\label{namespaceproxygen_ac806516d31d9566f0bc8f2dbce8e9facaebbb45f2543186c124dd0c7e34d5ae69}
}]\index{H\+E\+A\+D\+E\+R\+S\+\_\+\+T\+O\+O\+\_\+\+L\+A\+R\+GE@{H\+E\+A\+D\+E\+R\+S\+\_\+\+T\+O\+O\+\_\+\+L\+A\+R\+GE}!proxygen@{proxygen}}\index{proxygen@{proxygen}!H\+E\+A\+D\+E\+R\+S\+\_\+\+T\+O\+O\+\_\+\+L\+A\+R\+GE@{H\+E\+A\+D\+E\+R\+S\+\_\+\+T\+O\+O\+\_\+\+L\+A\+R\+GE}}\item[{\em 
H\+E\+A\+D\+E\+R\+S\+\_\+\+T\+O\+O\+\_\+\+L\+A\+R\+GE\label{namespaceproxygen_ac806516d31d9566f0bc8f2dbce8e9facad96fc900cec6f090538eaee3ef96d45f}
}]\index{I\+N\+F\+L\+A\+T\+E\+\_\+\+D\+I\+C\+T\+I\+O\+N\+A\+RY@{I\+N\+F\+L\+A\+T\+E\+\_\+\+D\+I\+C\+T\+I\+O\+N\+A\+RY}!proxygen@{proxygen}}\index{proxygen@{proxygen}!I\+N\+F\+L\+A\+T\+E\+\_\+\+D\+I\+C\+T\+I\+O\+N\+A\+RY@{I\+N\+F\+L\+A\+T\+E\+\_\+\+D\+I\+C\+T\+I\+O\+N\+A\+RY}}\item[{\em 
I\+N\+F\+L\+A\+T\+E\+\_\+\+D\+I\+C\+T\+I\+O\+N\+A\+RY\label{namespaceproxygen_ac806516d31d9566f0bc8f2dbce8e9facae8a034ad1792e34effcefe3048a3b260}
}]\index{E\+M\+P\+T\+Y\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+N\+A\+ME@{E\+M\+P\+T\+Y\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+N\+A\+ME}!proxygen@{proxygen}}\index{proxygen@{proxygen}!E\+M\+P\+T\+Y\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+N\+A\+ME@{E\+M\+P\+T\+Y\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+N\+A\+ME}}\item[{\em 
E\+M\+P\+T\+Y\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+N\+A\+ME\label{namespaceproxygen_ac806516d31d9566f0bc8f2dbce8e9facabbc88e12cc7dee1241ffecfde4e0d529}
}]\index{E\+M\+P\+T\+Y\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+V\+A\+L\+UE@{E\+M\+P\+T\+Y\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+V\+A\+L\+UE}!proxygen@{proxygen}}\index{proxygen@{proxygen}!E\+M\+P\+T\+Y\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+V\+A\+L\+UE@{E\+M\+P\+T\+Y\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+V\+A\+L\+UE}}\item[{\em 
E\+M\+P\+T\+Y\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+V\+A\+L\+UE\label{namespaceproxygen_ac806516d31d9566f0bc8f2dbce8e9facafda4955a14b8c71f575839fc995dab91}
}]\index{I\+N\+V\+A\+L\+I\+D\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+V\+A\+L\+UE@{I\+N\+V\+A\+L\+I\+D\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+V\+A\+L\+UE}!proxygen@{proxygen}}\index{proxygen@{proxygen}!I\+N\+V\+A\+L\+I\+D\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+V\+A\+L\+UE@{I\+N\+V\+A\+L\+I\+D\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+V\+A\+L\+UE}}\item[{\em 
I\+N\+V\+A\+L\+I\+D\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+V\+A\+L\+UE\label{namespaceproxygen_ac806516d31d9566f0bc8f2dbce8e9facafed6e8aafea0c8b3b8b35d1c75a1cda3}
}]\end{description}
\end{Desc}


Definition at line 24 of file Gzip\+Header\+Codec.\+h.


\begin{DoxyCode}
24                            : uint8\_t \{
25   NONE = 0,
26   BAD_ENCODING = 1,
27   HEADERS_TOO_LARGE = 2,
28   INFLATE_DICTIONARY = 3,
29   EMPTY_HEADER_NAME = 4,
30   EMPTY_HEADER_VALUE = 5,
31   INVALID_HEADER_VALUE = 6
32 \};
\end{DoxyCode}
\index{proxygen@{proxygen}!H\+T\+T\+P\+Common\+Header\+Table\+Type@{H\+T\+T\+P\+Common\+Header\+Table\+Type}}
\index{H\+T\+T\+P\+Common\+Header\+Table\+Type@{H\+T\+T\+P\+Common\+Header\+Table\+Type}!proxygen@{proxygen}}
\subsubsection[{H\+T\+T\+P\+Common\+Header\+Table\+Type}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+H\+T\+T\+P\+Common\+Header\+Table\+Type} \+: uint8\+\_\+t}\label{namespaceproxygen_a8e08737e3f15907fb1fa313fc6748a32}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{T\+A\+B\+L\+E\+\_\+\+C\+A\+M\+E\+L\+C\+A\+SE@{T\+A\+B\+L\+E\+\_\+\+C\+A\+M\+E\+L\+C\+A\+SE}!proxygen@{proxygen}}\index{proxygen@{proxygen}!T\+A\+B\+L\+E\+\_\+\+C\+A\+M\+E\+L\+C\+A\+SE@{T\+A\+B\+L\+E\+\_\+\+C\+A\+M\+E\+L\+C\+A\+SE}}\item[{\em 
T\+A\+B\+L\+E\+\_\+\+C\+A\+M\+E\+L\+C\+A\+SE\label{namespaceproxygen_a8e08737e3f15907fb1fa313fc6748a32ae5efe1fc883502e57d8f7d67b3c90953}
}]\index{T\+A\+B\+L\+E\+\_\+\+L\+O\+W\+E\+R\+C\+A\+SE@{T\+A\+B\+L\+E\+\_\+\+L\+O\+W\+E\+R\+C\+A\+SE}!proxygen@{proxygen}}\index{proxygen@{proxygen}!T\+A\+B\+L\+E\+\_\+\+L\+O\+W\+E\+R\+C\+A\+SE@{T\+A\+B\+L\+E\+\_\+\+L\+O\+W\+E\+R\+C\+A\+SE}}\item[{\em 
T\+A\+B\+L\+E\+\_\+\+L\+O\+W\+E\+R\+C\+A\+SE\label{namespaceproxygen_a8e08737e3f15907fb1fa313fc6748a32a2e6234a6d6f08c285f443a7617e64399}
}]\end{description}
\end{Desc}


Definition at line 46 of file H\+T\+T\+P\+Common\+Headers.\+template.\+h.


\begin{DoxyCode}
46                               : uint8\_t \{
47   TABLE_CAMELCASE = 0,
48   TABLE_LOWERCASE = 1,
49 \};
\end{DoxyCode}
\index{proxygen@{proxygen}!H\+T\+T\+P\+Header\+Code@{H\+T\+T\+P\+Header\+Code}}
\index{H\+T\+T\+P\+Header\+Code@{H\+T\+T\+P\+Header\+Code}!proxygen@{proxygen}}
\subsubsection[{H\+T\+T\+P\+Header\+Code}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+H\+T\+T\+P\+Header\+Code} \+: uint8\+\_\+t}\label{namespaceproxygen_ad1d4eced401086307c787f249976d7de}
Codes (hashes) of common H\+T\+TP header names \begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+N\+O\+NE@{H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+N\+O\+NE}!proxygen@{proxygen}}\index{proxygen@{proxygen}!H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+N\+O\+NE@{H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+N\+O\+NE}}\item[{\em 
H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+N\+O\+NE\label{namespaceproxygen_ad1d4eced401086307c787f249976d7deabc889723fa685826bb2138f32056ac2f}
}]\index{H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER@{H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER}!proxygen@{proxygen}}\index{proxygen@{proxygen}!H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER@{H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER}}\item[{\em 
H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER\label{namespaceproxygen_ad1d4eced401086307c787f249976d7dea104e16030aa96e09e76dbed4d1ac2a0a}
}]\end{description}
\end{Desc}


Definition at line 22 of file H\+T\+T\+P\+Common\+Headers.\+template.\+h.


\begin{DoxyCode}
22                     : uint8\_t \{
23   \textcolor{comment}{// code reserved to indicate the absence of an HTTP header}
24   HTTP_HEADER_NONE = 0,
25   \textcolor{comment}{// code for any HTTP header name not in the list of common headers}
26   HTTP_HEADER_OTHER = 1,
27 
28   \textcolor{comment}{/* the following is a placeholder for the build script to generate a list}
29 \textcolor{comment}{   * of enum values from the list in HTTPCommonHeaders.txt}
30 \textcolor{comment}{   *}
31 \textcolor{comment}{   * enum name of Some-Header is HTTP\_HEADER\_SOME\_HEADER,}
32 \textcolor{comment}{   * so an example fragment of the generated list could be:}
33 \textcolor{comment}{   * ...}
34 \textcolor{comment}{   * HTTP\_HEADER\_WARNING = 65,}
35 \textcolor{comment}{   * HTTP\_HEADER\_WWW\_AUTHENTICATE = 66,}
36 \textcolor{comment}{   * HTTP\_HEADER\_X\_BACKEND = 67,}
37 \textcolor{comment}{   * HTTP\_HEADER\_X\_BLOCKID = 68,}
38 \textcolor{comment}{   * ...}
39 \textcolor{comment}{   */}
40 %%%%%
41 
42 \};
\end{DoxyCode}
\index{proxygen@{proxygen}!H\+T\+T\+P\+Method@{H\+T\+T\+P\+Method}}
\index{H\+T\+T\+P\+Method@{H\+T\+T\+P\+Method}!proxygen@{proxygen}}
\subsubsection[{H\+T\+T\+P\+Method}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+H\+T\+T\+P\+Method}\hspace{0.3cm}{\ttfamily [strong]}}\label{namespaceproxygen_a708d14cbb2dacbfffbe455f5b7941fff}
See the definitions in \doxyref{R\+F\+C2616}{p.}{namespaceproxygen_1_1RFC2616} 5.\+1.\+1 for the source of this list. Today, proxygen only understands the methods defined in 5.\+1.\+1 and is not aware of any extension methods. If you wish to support extension methods, you must handle those separately from this enum. \begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{G\+ET@{G\+ET}!proxygen@{proxygen}}\index{proxygen@{proxygen}!G\+ET@{G\+ET}}\item[{\em 
G\+ET\label{namespaceproxygen_a708d14cbb2dacbfffbe455f5b7941fffa7528035a93ee69cedb1dbddb2f0bfcc8}
}]\index{P\+O\+ST@{P\+O\+ST}!proxygen@{proxygen}}\index{proxygen@{proxygen}!P\+O\+ST@{P\+O\+ST}}\item[{\em 
P\+O\+ST\label{namespaceproxygen_a708d14cbb2dacbfffbe455f5b7941fffaa02439ec229d8be0e74b0c1602392310}
}]\index{O\+P\+T\+I\+O\+NS@{O\+P\+T\+I\+O\+NS}!proxygen@{proxygen}}\index{proxygen@{proxygen}!O\+P\+T\+I\+O\+NS@{O\+P\+T\+I\+O\+NS}}\item[{\em 
O\+P\+T\+I\+O\+NS\label{namespaceproxygen_a708d14cbb2dacbfffbe455f5b7941fffa164dd62adb30ca051b5289672a572f9b}
}]\index{D\+E\+L\+E\+TE@{D\+E\+L\+E\+TE}!proxygen@{proxygen}}\index{proxygen@{proxygen}!D\+E\+L\+E\+TE@{D\+E\+L\+E\+TE}}\item[{\em 
D\+E\+L\+E\+TE\label{namespaceproxygen_a708d14cbb2dacbfffbe455f5b7941fffa32f68a60cef40faedbc6af20298c1a1e}
}]\index{H\+E\+AD@{H\+E\+AD}!proxygen@{proxygen}}\index{proxygen@{proxygen}!H\+E\+AD@{H\+E\+AD}}\item[{\em 
H\+E\+AD\label{namespaceproxygen_a708d14cbb2dacbfffbe455f5b7941fffae15e216fc1c639f787b1231ecdfa1bf8}
}]\index{C\+O\+N\+N\+E\+CT@{C\+O\+N\+N\+E\+CT}!proxygen@{proxygen}}\index{proxygen@{proxygen}!C\+O\+N\+N\+E\+CT@{C\+O\+N\+N\+E\+CT}}\item[{\em 
C\+O\+N\+N\+E\+CT\label{namespaceproxygen_a708d14cbb2dacbfffbe455f5b7941fffab57e2519e26151feacdbe52076bc39ec}
}]\index{P\+UT@{P\+UT}!proxygen@{proxygen}}\index{proxygen@{proxygen}!P\+UT@{P\+UT}}\item[{\em 
P\+UT\label{namespaceproxygen_a708d14cbb2dacbfffbe455f5b7941fffa3e75383a5992a6d15fb81e872e46e256}
}]\index{T\+R\+A\+CE@{T\+R\+A\+CE}!proxygen@{proxygen}}\index{proxygen@{proxygen}!T\+R\+A\+CE@{T\+R\+A\+CE}}\item[{\em 
T\+R\+A\+CE\label{namespaceproxygen_a708d14cbb2dacbfffbe455f5b7941fffa2d3e4144aa384b18849ab9a8abad74d6}
}]\index{P\+A\+T\+CH@{P\+A\+T\+CH}!proxygen@{proxygen}}\index{proxygen@{proxygen}!P\+A\+T\+CH@{P\+A\+T\+CH}}\item[{\em 
P\+A\+T\+CH\label{namespaceproxygen_a708d14cbb2dacbfffbe455f5b7941fffa63bc9a3997d66d835d9f3ec29451407d}
}]\index{S\+UB@{S\+UB}!proxygen@{proxygen}}\index{proxygen@{proxygen}!S\+UB@{S\+UB}}\item[{\em 
S\+UB\label{namespaceproxygen_a708d14cbb2dacbfffbe455f5b7941fffa241dd841abade20fcb27b8a9f494e1eb}
}]\index{P\+UB@{P\+UB}!proxygen@{proxygen}}\index{proxygen@{proxygen}!P\+UB@{P\+UB}}\item[{\em 
P\+UB\label{namespaceproxygen_a708d14cbb2dacbfffbe455f5b7941fffa9aba7127268ef2f384fdc95498c7bb1a}
}]\index{U\+N\+S\+UB@{U\+N\+S\+UB}!proxygen@{proxygen}}\index{proxygen@{proxygen}!U\+N\+S\+UB@{U\+N\+S\+UB}}\item[{\em 
U\+N\+S\+UB\label{namespaceproxygen_a708d14cbb2dacbfffbe455f5b7941fffa962609d3b0fc081bc000a3d6d99bf809}
}]\end{description}
\end{Desc}


Definition at line 42 of file H\+T\+T\+P\+Method.\+h.


\begin{DoxyCode}
42                       \{
43   HTTP_METHOD_GEN(HTTP_METHOD_ENUM)
\end{DoxyCode}
\index{proxygen@{proxygen}!Proxygen\+Error@{Proxygen\+Error}}
\index{Proxygen\+Error@{Proxygen\+Error}!proxygen@{proxygen}}
\subsubsection[{Proxygen\+Error}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+Proxygen\+Error}}\label{namespaceproxygen_ac167448283d2eb2403c01822410d956d}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{k\+Error\+None@{k\+Error\+None}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+None@{k\+Error\+None}}\item[{\em 
k\+Error\+None\label{namespaceproxygen_ac167448283d2eb2403c01822410d956dadd9306fdee30fe221a92392c78e06a2a}
}]\index{k\+Error\+Message@{k\+Error\+Message}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Message@{k\+Error\+Message}}\item[{\em 
k\+Error\+Message\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da89951aa9e35076b79ba9d7ec254a32ab}
}]\index{k\+Error\+Connect@{k\+Error\+Connect}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Connect@{k\+Error\+Connect}}\item[{\em 
k\+Error\+Connect\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da69a0843c2c26ac2bf98684464858ee97}
}]\index{k\+Error\+Connect\+Timeout@{k\+Error\+Connect\+Timeout}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Connect\+Timeout@{k\+Error\+Connect\+Timeout}}\item[{\em 
k\+Error\+Connect\+Timeout\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da37bc41707a12ab9378d9b9369c680f7c}
}]\index{k\+Error\+Read@{k\+Error\+Read}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Read@{k\+Error\+Read}}\item[{\em 
k\+Error\+Read\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da29ef130b28c0086b1bf03a0594bb915a}
}]\index{k\+Error\+Write@{k\+Error\+Write}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Write@{k\+Error\+Write}}\item[{\em 
k\+Error\+Write\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da77ba7bef1a60134b557f8988a8d7009a}
}]\index{k\+Error\+Timeout@{k\+Error\+Timeout}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Timeout@{k\+Error\+Timeout}}\item[{\em 
k\+Error\+Timeout\label{namespaceproxygen_ac167448283d2eb2403c01822410d956dac8d82d9d46b9904442f90190d8aeb099}
}]\index{k\+Error\+Handshake@{k\+Error\+Handshake}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Handshake@{k\+Error\+Handshake}}\item[{\em 
k\+Error\+Handshake\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da4404c50ef263a44e6ad5039fdd3cf583}
}]\index{k\+Error\+No\+Server@{k\+Error\+No\+Server}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+No\+Server@{k\+Error\+No\+Server}}\item[{\em 
k\+Error\+No\+Server\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da80bee69a0933f00adc90c05f7257e0d5}
}]\index{k\+Error\+Max\+Redirects@{k\+Error\+Max\+Redirects}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Max\+Redirects@{k\+Error\+Max\+Redirects}}\item[{\em 
k\+Error\+Max\+Redirects\label{namespaceproxygen_ac167448283d2eb2403c01822410d956dae78b4286d6737484e4995f8bcc80a556}
}]\index{k\+Error\+Invalid\+Redirect@{k\+Error\+Invalid\+Redirect}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Invalid\+Redirect@{k\+Error\+Invalid\+Redirect}}\item[{\em 
k\+Error\+Invalid\+Redirect\label{namespaceproxygen_ac167448283d2eb2403c01822410d956dab35915ad5d748f2e54fb59cc409cff9c}
}]\index{k\+Error\+Response\+Action@{k\+Error\+Response\+Action}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Response\+Action@{k\+Error\+Response\+Action}}\item[{\em 
k\+Error\+Response\+Action\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da8437d7b3ac0639c15067309a50733774}
}]\index{k\+Error\+Max\+Connects@{k\+Error\+Max\+Connects}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Max\+Connects@{k\+Error\+Max\+Connects}}\item[{\em 
k\+Error\+Max\+Connects\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da81cad2b4bf6970c395e57668a44d7af5}
}]\index{k\+Error\+Dropped@{k\+Error\+Dropped}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Dropped@{k\+Error\+Dropped}}\item[{\em 
k\+Error\+Dropped\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da60363f6e1d6e06a3573282bc189ddb65}
}]\index{k\+Error\+Connection@{k\+Error\+Connection}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Connection@{k\+Error\+Connection}}\item[{\em 
k\+Error\+Connection\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da7287da29c7349df49e0e4bbaf8d2542b}
}]\index{k\+Error\+Connection\+Reset@{k\+Error\+Connection\+Reset}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Connection\+Reset@{k\+Error\+Connection\+Reset}}\item[{\em 
k\+Error\+Connection\+Reset\label{namespaceproxygen_ac167448283d2eb2403c01822410d956daf75d49c617a4ea8c27d4bf1b432cd42a}
}]\index{k\+Error\+Parse\+Header@{k\+Error\+Parse\+Header}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Parse\+Header@{k\+Error\+Parse\+Header}}\item[{\em 
k\+Error\+Parse\+Header\label{namespaceproxygen_ac167448283d2eb2403c01822410d956dab9b18a73dce44cf114c18d4d2ce0cff0}
}]\index{k\+Error\+Parse\+Body@{k\+Error\+Parse\+Body}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Parse\+Body@{k\+Error\+Parse\+Body}}\item[{\em 
k\+Error\+Parse\+Body\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da71d1707a93df7151bf58b8a5f6030846}
}]\index{k\+Error\+E\+OF@{k\+Error\+E\+OF}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+E\+OF@{k\+Error\+E\+OF}}\item[{\em 
k\+Error\+E\+OF\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da60f7c9e48bcca567facd26654ed3b4d8}
}]\index{k\+Error\+Client\+Renegotiation@{k\+Error\+Client\+Renegotiation}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Client\+Renegotiation@{k\+Error\+Client\+Renegotiation}}\item[{\em 
k\+Error\+Client\+Renegotiation\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da3fe049adc866c130ce0a28ff24c9020f}
}]\index{k\+Error\+Unknown@{k\+Error\+Unknown}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Unknown@{k\+Error\+Unknown}}\item[{\em 
k\+Error\+Unknown\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da9de201c2e8ea3434ffeebc4defda5f89}
}]\index{k\+Error\+Bad\+Decompress@{k\+Error\+Bad\+Decompress}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Bad\+Decompress@{k\+Error\+Bad\+Decompress}}\item[{\em 
k\+Error\+Bad\+Decompress\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da57ad9c2e4dd720e8a564976a496adeb1}
}]\index{k\+Error\+S\+SL@{k\+Error\+S\+SL}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+S\+SL@{k\+Error\+S\+SL}}\item[{\em 
k\+Error\+S\+SL\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da24f83ab6d120b0032608d6159f7c2f1c}
}]\index{k\+Error\+Stream\+Abort@{k\+Error\+Stream\+Abort}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Stream\+Abort@{k\+Error\+Stream\+Abort}}\item[{\em 
k\+Error\+Stream\+Abort\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da6e26e85744e3af152c1be71750ec85b0}
}]\index{k\+Error\+Stream\+Unacknowledged@{k\+Error\+Stream\+Unacknowledged}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Stream\+Unacknowledged@{k\+Error\+Stream\+Unacknowledged}}\item[{\em 
k\+Error\+Stream\+Unacknowledged\label{namespaceproxygen_ac167448283d2eb2403c01822410d956dae17549298750704ddfd2c5bd68dd0684}
}]\index{k\+Error\+Write\+Timeout@{k\+Error\+Write\+Timeout}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Write\+Timeout@{k\+Error\+Write\+Timeout}}\item[{\em 
k\+Error\+Write\+Timeout\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da60580b04a0444f809e2270068d934fa5}
}]\index{k\+Error\+Address\+Private@{k\+Error\+Address\+Private}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Address\+Private@{k\+Error\+Address\+Private}}\item[{\em 
k\+Error\+Address\+Private\label{namespaceproxygen_ac167448283d2eb2403c01822410d956dafe60835d384a9314743aaccce21a9e25}
}]\index{k\+Error\+Address\+Family\+Not\+Supported@{k\+Error\+Address\+Family\+Not\+Supported}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Address\+Family\+Not\+Supported@{k\+Error\+Address\+Family\+Not\+Supported}}\item[{\em 
k\+Error\+Address\+Family\+Not\+Supported\label{namespaceproxygen_ac167448283d2eb2403c01822410d956daef89ca8967b1e0161124295676f73ed0}
}]\index{k\+Error\+D\+N\+S\+No\+Results@{k\+Error\+D\+N\+S\+No\+Results}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+D\+N\+S\+No\+Results@{k\+Error\+D\+N\+S\+No\+Results}}\item[{\em 
k\+Error\+D\+N\+S\+No\+Results\label{namespaceproxygen_ac167448283d2eb2403c01822410d956daee8d1e45964b1a774650caef39cfdea2}
}]\index{k\+Error\+Malformed\+Input@{k\+Error\+Malformed\+Input}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Malformed\+Input@{k\+Error\+Malformed\+Input}}\item[{\em 
k\+Error\+Malformed\+Input\label{namespaceproxygen_ac167448283d2eb2403c01822410d956dae9e61641eb33762d87915177225665b3}
}]\index{k\+Error\+Unsupported\+Expectation@{k\+Error\+Unsupported\+Expectation}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Unsupported\+Expectation@{k\+Error\+Unsupported\+Expectation}}\item[{\em 
k\+Error\+Unsupported\+Expectation\label{namespaceproxygen_ac167448283d2eb2403c01822410d956dada984f8e347107835f77fd46ca9a83c3}
}]\index{k\+Error\+Method\+Not\+Supported@{k\+Error\+Method\+Not\+Supported}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Method\+Not\+Supported@{k\+Error\+Method\+Not\+Supported}}\item[{\em 
k\+Error\+Method\+Not\+Supported\label{namespaceproxygen_ac167448283d2eb2403c01822410d956daa75b3300ad7c2ea6060ba80de971cb33}
}]\index{k\+Error\+Unsupported\+Scheme@{k\+Error\+Unsupported\+Scheme}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Unsupported\+Scheme@{k\+Error\+Unsupported\+Scheme}}\item[{\em 
k\+Error\+Unsupported\+Scheme\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da4796893e590a805606eadb48c66e2d00}
}]\index{k\+Error\+Shutdown@{k\+Error\+Shutdown}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Shutdown@{k\+Error\+Shutdown}}\item[{\em 
k\+Error\+Shutdown\label{namespaceproxygen_ac167448283d2eb2403c01822410d956dae412d51b453d232342abc3fe726d9e16}
}]\index{k\+Error\+Ingress\+State\+Transition@{k\+Error\+Ingress\+State\+Transition}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Ingress\+State\+Transition@{k\+Error\+Ingress\+State\+Transition}}\item[{\em 
k\+Error\+Ingress\+State\+Transition\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da973718c9a40010086e7ba12e4b1bc07d}
}]\index{k\+Error\+Client\+Silent@{k\+Error\+Client\+Silent}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Client\+Silent@{k\+Error\+Client\+Silent}}\item[{\em 
k\+Error\+Client\+Silent\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da40f9dc4f4360525ec452e864be70737e}
}]\index{k\+Error\+Canceled@{k\+Error\+Canceled}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Canceled@{k\+Error\+Canceled}}\item[{\em 
k\+Error\+Canceled\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da126d91af969b4d21537b1d5b8e9d3500}
}]\index{k\+Error\+Parse\+Response@{k\+Error\+Parse\+Response}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Parse\+Response@{k\+Error\+Parse\+Response}}\item[{\em 
k\+Error\+Parse\+Response\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da7e9b73962344978c3fe5fa61a486a26f}
}]\index{k\+Error\+Conn\+Refused@{k\+Error\+Conn\+Refused}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Conn\+Refused@{k\+Error\+Conn\+Refused}}\item[{\em 
k\+Error\+Conn\+Refused\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da749e41f117a56d1c4f61ce97ee7fded8}
}]\index{k\+Error\+D\+N\+S\+Other\+Server@{k\+Error\+D\+N\+S\+Other\+Server}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+D\+N\+S\+Other\+Server@{k\+Error\+D\+N\+S\+Other\+Server}}\item[{\em 
k\+Error\+D\+N\+S\+Other\+Server\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da1fb81dc47d8b4c6d316067a0bd56f71f}
}]\index{k\+Error\+D\+N\+S\+Other\+Client@{k\+Error\+D\+N\+S\+Other\+Client}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+D\+N\+S\+Other\+Client@{k\+Error\+D\+N\+S\+Other\+Client}}\item[{\em 
k\+Error\+D\+N\+S\+Other\+Client\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da495bc10345ade94f51fa1e045620e89d}
}]\index{k\+Error\+D\+N\+S\+Other\+Cancelled@{k\+Error\+D\+N\+S\+Other\+Cancelled}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+D\+N\+S\+Other\+Cancelled@{k\+Error\+D\+N\+S\+Other\+Cancelled}}\item[{\em 
k\+Error\+D\+N\+S\+Other\+Cancelled\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da2257953c6cf154b50549e9547e6f3427}
}]\index{k\+Error\+D\+N\+Sshutdown@{k\+Error\+D\+N\+Sshutdown}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+D\+N\+Sshutdown@{k\+Error\+D\+N\+Sshutdown}}\item[{\em 
k\+Error\+D\+N\+Sshutdown\label{namespaceproxygen_ac167448283d2eb2403c01822410d956dafa2bad60ee220d5a18e01c60e775567a}
}]\index{k\+Error\+D\+N\+Sgetaddrinfo@{k\+Error\+D\+N\+Sgetaddrinfo}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+D\+N\+Sgetaddrinfo@{k\+Error\+D\+N\+Sgetaddrinfo}}\item[{\em 
k\+Error\+D\+N\+Sgetaddrinfo\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da814d2a93cff7c405786b751608588473}
}]\index{k\+Error\+D\+N\+Sthreadpool@{k\+Error\+D\+N\+Sthreadpool}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+D\+N\+Sthreadpool@{k\+Error\+D\+N\+Sthreadpool}}\item[{\em 
k\+Error\+D\+N\+Sthreadpool\label{namespaceproxygen_ac167448283d2eb2403c01822410d956dad0ada162bfe9c7cfea4ce66bd4fa9e59}
}]\index{k\+Error\+D\+N\+Sunimplemented@{k\+Error\+D\+N\+Sunimplemented}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+D\+N\+Sunimplemented@{k\+Error\+D\+N\+Sunimplemented}}\item[{\em 
k\+Error\+D\+N\+Sunimplemented\label{namespaceproxygen_ac167448283d2eb2403c01822410d956daed945e2aca1abca0683124a2929fa3bc}
}]\index{k\+Error\+Network@{k\+Error\+Network}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Network@{k\+Error\+Network}}\item[{\em 
k\+Error\+Network\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da13575f516160dd5f86998bd352e345da}
}]\index{k\+Error\+Configuration@{k\+Error\+Configuration}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Configuration@{k\+Error\+Configuration}}\item[{\em 
k\+Error\+Configuration\label{namespaceproxygen_ac167448283d2eb2403c01822410d956dae9f302134782b26a13eb4b56c3267382}
}]\index{k\+Error\+Early\+Data\+Rejected@{k\+Error\+Early\+Data\+Rejected}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Early\+Data\+Rejected@{k\+Error\+Early\+Data\+Rejected}}\item[{\em 
k\+Error\+Early\+Data\+Rejected\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da4491cb481d76b3c961811b963e207fbc}
}]\index{k\+Error\+Early\+Data\+Failed@{k\+Error\+Early\+Data\+Failed}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Early\+Data\+Failed@{k\+Error\+Early\+Data\+Failed}}\item[{\em 
k\+Error\+Early\+Data\+Failed\label{namespaceproxygen_ac167448283d2eb2403c01822410d956dacd942bf93f76abd92387cd35971da743}
}]\index{k\+Error\+Auth\+Required@{k\+Error\+Auth\+Required}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Auth\+Required@{k\+Error\+Auth\+Required}}\item[{\em 
k\+Error\+Auth\+Required\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da87137e647deb8b8f909edd6a110a6e30}
}]\index{k\+Error\+Unauthorized@{k\+Error\+Unauthorized}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Unauthorized@{k\+Error\+Unauthorized}}\item[{\em 
k\+Error\+Unauthorized\label{namespaceproxygen_ac167448283d2eb2403c01822410d956daea34e3491aaaaf6a431fe65b7713f14f}
}]\index{k\+Error\+Max@{k\+Error\+Max}!proxygen@{proxygen}}\index{proxygen@{proxygen}!k\+Error\+Max@{k\+Error\+Max}}\item[{\em 
k\+Error\+Max\label{namespaceproxygen_ac167448283d2eb2403c01822410d956da58e922cef0706a83e95fb294c2ce21ba}
}]\end{description}
\end{Desc}


Definition at line 75 of file Proxygen\+Error\+Enum.\+h.


\begin{DoxyCode}
75                    \{
76   PROXYGEN_ERROR_GEN(PROXYGEN_ERROR_ENUM)
\end{DoxyCode}
\index{proxygen@{proxygen}!Settings\+Id@{Settings\+Id}}
\index{Settings\+Id@{Settings\+Id}!proxygen@{proxygen}}
\subsubsection[{Settings\+Id}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+Settings\+Id} \+: uint64\+\_\+t\hspace{0.3cm}{\ttfamily [strong]}}\label{namespaceproxygen_a89466eaf4f6bbc394ccf41acbef3e045}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{H\+E\+A\+D\+E\+R\+\_\+\+T\+A\+B\+L\+E\+\_\+\+S\+I\+ZE@{H\+E\+A\+D\+E\+R\+\_\+\+T\+A\+B\+L\+E\+\_\+\+S\+I\+ZE}!proxygen@{proxygen}}\index{proxygen@{proxygen}!H\+E\+A\+D\+E\+R\+\_\+\+T\+A\+B\+L\+E\+\_\+\+S\+I\+ZE@{H\+E\+A\+D\+E\+R\+\_\+\+T\+A\+B\+L\+E\+\_\+\+S\+I\+ZE}}\item[{\em 
H\+E\+A\+D\+E\+R\+\_\+\+T\+A\+B\+L\+E\+\_\+\+S\+I\+ZE\label{namespaceproxygen_a89466eaf4f6bbc394ccf41acbef3e045ab21db98ae5570cf2d2eea1ae84dadc0c}
}]\index{E\+N\+A\+B\+L\+E\+\_\+\+P\+U\+SH@{E\+N\+A\+B\+L\+E\+\_\+\+P\+U\+SH}!proxygen@{proxygen}}\index{proxygen@{proxygen}!E\+N\+A\+B\+L\+E\+\_\+\+P\+U\+SH@{E\+N\+A\+B\+L\+E\+\_\+\+P\+U\+SH}}\item[{\em 
E\+N\+A\+B\+L\+E\+\_\+\+P\+U\+SH\label{namespaceproxygen_a89466eaf4f6bbc394ccf41acbef3e045a230ce83dbccb31567e5e780d698c7d1d}
}]\index{M\+A\+X\+\_\+\+C\+O\+N\+C\+U\+R\+R\+E\+N\+T\+\_\+\+S\+T\+R\+E\+A\+MS@{M\+A\+X\+\_\+\+C\+O\+N\+C\+U\+R\+R\+E\+N\+T\+\_\+\+S\+T\+R\+E\+A\+MS}!proxygen@{proxygen}}\index{proxygen@{proxygen}!M\+A\+X\+\_\+\+C\+O\+N\+C\+U\+R\+R\+E\+N\+T\+\_\+\+S\+T\+R\+E\+A\+MS@{M\+A\+X\+\_\+\+C\+O\+N\+C\+U\+R\+R\+E\+N\+T\+\_\+\+S\+T\+R\+E\+A\+MS}}\item[{\em 
M\+A\+X\+\_\+\+C\+O\+N\+C\+U\+R\+R\+E\+N\+T\+\_\+\+S\+T\+R\+E\+A\+MS\label{namespaceproxygen_a89466eaf4f6bbc394ccf41acbef3e045af6fa2500b99d7b98c0bb4479135f7967}
}]\index{I\+N\+I\+T\+I\+A\+L\+\_\+\+W\+I\+N\+D\+O\+W\+\_\+\+S\+I\+ZE@{I\+N\+I\+T\+I\+A\+L\+\_\+\+W\+I\+N\+D\+O\+W\+\_\+\+S\+I\+ZE}!proxygen@{proxygen}}\index{proxygen@{proxygen}!I\+N\+I\+T\+I\+A\+L\+\_\+\+W\+I\+N\+D\+O\+W\+\_\+\+S\+I\+ZE@{I\+N\+I\+T\+I\+A\+L\+\_\+\+W\+I\+N\+D\+O\+W\+\_\+\+S\+I\+ZE}}\item[{\em 
I\+N\+I\+T\+I\+A\+L\+\_\+\+W\+I\+N\+D\+O\+W\+\_\+\+S\+I\+ZE\label{namespaceproxygen_a89466eaf4f6bbc394ccf41acbef3e045addacca0555b4339b6e9dd1818d95e338}
}]\index{M\+A\+X\+\_\+\+F\+R\+A\+M\+E\+\_\+\+S\+I\+ZE@{M\+A\+X\+\_\+\+F\+R\+A\+M\+E\+\_\+\+S\+I\+ZE}!proxygen@{proxygen}}\index{proxygen@{proxygen}!M\+A\+X\+\_\+\+F\+R\+A\+M\+E\+\_\+\+S\+I\+ZE@{M\+A\+X\+\_\+\+F\+R\+A\+M\+E\+\_\+\+S\+I\+ZE}}\item[{\em 
M\+A\+X\+\_\+\+F\+R\+A\+M\+E\+\_\+\+S\+I\+ZE\label{namespaceproxygen_a89466eaf4f6bbc394ccf41acbef3e045ae787c90dc72d889f3497d9f97ab0236e}
}]\index{M\+A\+X\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+L\+I\+S\+T\+\_\+\+S\+I\+ZE@{M\+A\+X\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+L\+I\+S\+T\+\_\+\+S\+I\+ZE}!proxygen@{proxygen}}\index{proxygen@{proxygen}!M\+A\+X\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+L\+I\+S\+T\+\_\+\+S\+I\+ZE@{M\+A\+X\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+L\+I\+S\+T\+\_\+\+S\+I\+ZE}}\item[{\em 
M\+A\+X\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+L\+I\+S\+T\+\_\+\+S\+I\+ZE\label{namespaceproxygen_a89466eaf4f6bbc394ccf41acbef3e045a3b178b97bc72243896a77eed1af09f19}
}]\index{E\+N\+A\+B\+L\+E\+\_\+\+C\+O\+N\+N\+E\+C\+T\+\_\+\+P\+R\+O\+T\+O\+C\+OL@{E\+N\+A\+B\+L\+E\+\_\+\+C\+O\+N\+N\+E\+C\+T\+\_\+\+P\+R\+O\+T\+O\+C\+OL}!proxygen@{proxygen}}\index{proxygen@{proxygen}!E\+N\+A\+B\+L\+E\+\_\+\+C\+O\+N\+N\+E\+C\+T\+\_\+\+P\+R\+O\+T\+O\+C\+OL@{E\+N\+A\+B\+L\+E\+\_\+\+C\+O\+N\+N\+E\+C\+T\+\_\+\+P\+R\+O\+T\+O\+C\+OL}}\item[{\em 
E\+N\+A\+B\+L\+E\+\_\+\+C\+O\+N\+N\+E\+C\+T\+\_\+\+P\+R\+O\+T\+O\+C\+OL\label{namespaceproxygen_a89466eaf4f6bbc394ccf41acbef3e045a7be3af223f71fcfb6764045178ebb6f6}
}]\index{T\+H\+R\+I\+F\+T\+\_\+\+C\+H\+A\+N\+N\+E\+L\+\_\+\+I\+D\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+ED@{T\+H\+R\+I\+F\+T\+\_\+\+C\+H\+A\+N\+N\+E\+L\+\_\+\+I\+D\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+ED}!proxygen@{proxygen}}\index{proxygen@{proxygen}!T\+H\+R\+I\+F\+T\+\_\+\+C\+H\+A\+N\+N\+E\+L\+\_\+\+I\+D\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+ED@{T\+H\+R\+I\+F\+T\+\_\+\+C\+H\+A\+N\+N\+E\+L\+\_\+\+I\+D\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+ED}}\item[{\em 
T\+H\+R\+I\+F\+T\+\_\+\+C\+H\+A\+N\+N\+E\+L\+\_\+\+I\+D\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+ED\label{namespaceproxygen_a89466eaf4f6bbc394ccf41acbef3e045a8ef18664c0174d35854a7f7d5edbda2d}
}]\index{E\+N\+A\+B\+L\+E\+\_\+\+E\+X\+\_\+\+H\+E\+A\+D\+E\+RS@{E\+N\+A\+B\+L\+E\+\_\+\+E\+X\+\_\+\+H\+E\+A\+D\+E\+RS}!proxygen@{proxygen}}\index{proxygen@{proxygen}!E\+N\+A\+B\+L\+E\+\_\+\+E\+X\+\_\+\+H\+E\+A\+D\+E\+RS@{E\+N\+A\+B\+L\+E\+\_\+\+E\+X\+\_\+\+H\+E\+A\+D\+E\+RS}}\item[{\em 
E\+N\+A\+B\+L\+E\+\_\+\+E\+X\+\_\+\+H\+E\+A\+D\+E\+RS\label{namespaceproxygen_a89466eaf4f6bbc394ccf41acbef3e045a173e180931118bfa5eb34394106e923b}
}]\index{T\+H\+R\+I\+F\+T\+\_\+\+C\+H\+A\+N\+N\+E\+L\+\_\+\+ID@{T\+H\+R\+I\+F\+T\+\_\+\+C\+H\+A\+N\+N\+E\+L\+\_\+\+ID}!proxygen@{proxygen}}\index{proxygen@{proxygen}!T\+H\+R\+I\+F\+T\+\_\+\+C\+H\+A\+N\+N\+E\+L\+\_\+\+ID@{T\+H\+R\+I\+F\+T\+\_\+\+C\+H\+A\+N\+N\+E\+L\+\_\+\+ID}}\item[{\em 
T\+H\+R\+I\+F\+T\+\_\+\+C\+H\+A\+N\+N\+E\+L\+\_\+\+ID\label{namespaceproxygen_a89466eaf4f6bbc394ccf41acbef3e045a0d866cc98371596f03e9959842fb7741}
}]\index{S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+H\+T\+T\+P\+\_\+\+C\+E\+R\+T\+\_\+\+A\+U\+TH@{S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+H\+T\+T\+P\+\_\+\+C\+E\+R\+T\+\_\+\+A\+U\+TH}!proxygen@{proxygen}}\index{proxygen@{proxygen}!S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+H\+T\+T\+P\+\_\+\+C\+E\+R\+T\+\_\+\+A\+U\+TH@{S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+H\+T\+T\+P\+\_\+\+C\+E\+R\+T\+\_\+\+A\+U\+TH}}\item[{\em 
S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+H\+T\+T\+P\+\_\+\+C\+E\+R\+T\+\_\+\+A\+U\+TH\label{namespaceproxygen_a89466eaf4f6bbc394ccf41acbef3e045a0a527b0ec93777ae403ac7831c5b2ae7}
}]\index{\+\_\+\+S\+P\+D\+Y\+\_\+\+U\+P\+L\+O\+A\+D\+\_\+\+B\+A\+N\+D\+W\+I\+D\+TH@{\+\_\+\+S\+P\+D\+Y\+\_\+\+U\+P\+L\+O\+A\+D\+\_\+\+B\+A\+N\+D\+W\+I\+D\+TH}!proxygen@{proxygen}}\index{proxygen@{proxygen}!\+\_\+\+S\+P\+D\+Y\+\_\+\+U\+P\+L\+O\+A\+D\+\_\+\+B\+A\+N\+D\+W\+I\+D\+TH@{\+\_\+\+S\+P\+D\+Y\+\_\+\+U\+P\+L\+O\+A\+D\+\_\+\+B\+A\+N\+D\+W\+I\+D\+TH}}\item[{\em 
\+\_\+\+S\+P\+D\+Y\+\_\+\+U\+P\+L\+O\+A\+D\+\_\+\+B\+A\+N\+D\+W\+I\+D\+TH\label{namespaceproxygen_a89466eaf4f6bbc394ccf41acbef3e045a33233905cc47ebd71988d228d19c43c2}
}]\index{\+\_\+\+S\+P\+D\+Y\+\_\+\+D\+O\+W\+N\+L\+O\+A\+D\+\_\+\+B\+A\+N\+D\+W\+I\+D\+TH@{\+\_\+\+S\+P\+D\+Y\+\_\+\+D\+O\+W\+N\+L\+O\+A\+D\+\_\+\+B\+A\+N\+D\+W\+I\+D\+TH}!proxygen@{proxygen}}\index{proxygen@{proxygen}!\+\_\+\+S\+P\+D\+Y\+\_\+\+D\+O\+W\+N\+L\+O\+A\+D\+\_\+\+B\+A\+N\+D\+W\+I\+D\+TH@{\+\_\+\+S\+P\+D\+Y\+\_\+\+D\+O\+W\+N\+L\+O\+A\+D\+\_\+\+B\+A\+N\+D\+W\+I\+D\+TH}}\item[{\em 
\+\_\+\+S\+P\+D\+Y\+\_\+\+D\+O\+W\+N\+L\+O\+A\+D\+\_\+\+B\+A\+N\+D\+W\+I\+D\+TH\label{namespaceproxygen_a89466eaf4f6bbc394ccf41acbef3e045ae8155222736c1dc3766be2ac40671fa6}
}]\index{\+\_\+\+S\+P\+D\+Y\+\_\+\+R\+O\+U\+N\+D\+\_\+\+T\+R\+I\+P\+\_\+\+T\+I\+ME@{\+\_\+\+S\+P\+D\+Y\+\_\+\+R\+O\+U\+N\+D\+\_\+\+T\+R\+I\+P\+\_\+\+T\+I\+ME}!proxygen@{proxygen}}\index{proxygen@{proxygen}!\+\_\+\+S\+P\+D\+Y\+\_\+\+R\+O\+U\+N\+D\+\_\+\+T\+R\+I\+P\+\_\+\+T\+I\+ME@{\+\_\+\+S\+P\+D\+Y\+\_\+\+R\+O\+U\+N\+D\+\_\+\+T\+R\+I\+P\+\_\+\+T\+I\+ME}}\item[{\em 
\+\_\+\+S\+P\+D\+Y\+\_\+\+R\+O\+U\+N\+D\+\_\+\+T\+R\+I\+P\+\_\+\+T\+I\+ME\label{namespaceproxygen_a89466eaf4f6bbc394ccf41acbef3e045af5339f4b99bc8e66dd79406ac4fa2a0e}
}]\index{\+\_\+\+S\+P\+D\+Y\+\_\+\+C\+U\+R\+R\+E\+N\+T\+\_\+\+C\+W\+ND@{\+\_\+\+S\+P\+D\+Y\+\_\+\+C\+U\+R\+R\+E\+N\+T\+\_\+\+C\+W\+ND}!proxygen@{proxygen}}\index{proxygen@{proxygen}!\+\_\+\+S\+P\+D\+Y\+\_\+\+C\+U\+R\+R\+E\+N\+T\+\_\+\+C\+W\+ND@{\+\_\+\+S\+P\+D\+Y\+\_\+\+C\+U\+R\+R\+E\+N\+T\+\_\+\+C\+W\+ND}}\item[{\em 
\+\_\+\+S\+P\+D\+Y\+\_\+\+C\+U\+R\+R\+E\+N\+T\+\_\+\+C\+W\+ND\label{namespaceproxygen_a89466eaf4f6bbc394ccf41acbef3e045a721ed6b890de42caea464f74e0c25d12}
}]\index{\+\_\+\+S\+P\+D\+Y\+\_\+\+D\+O\+W\+N\+L\+O\+A\+D\+\_\+\+R\+E\+T\+R\+A\+N\+S\+\_\+\+R\+A\+TE@{\+\_\+\+S\+P\+D\+Y\+\_\+\+D\+O\+W\+N\+L\+O\+A\+D\+\_\+\+R\+E\+T\+R\+A\+N\+S\+\_\+\+R\+A\+TE}!proxygen@{proxygen}}\index{proxygen@{proxygen}!\+\_\+\+S\+P\+D\+Y\+\_\+\+D\+O\+W\+N\+L\+O\+A\+D\+\_\+\+R\+E\+T\+R\+A\+N\+S\+\_\+\+R\+A\+TE@{\+\_\+\+S\+P\+D\+Y\+\_\+\+D\+O\+W\+N\+L\+O\+A\+D\+\_\+\+R\+E\+T\+R\+A\+N\+S\+\_\+\+R\+A\+TE}}\item[{\em 
\+\_\+\+S\+P\+D\+Y\+\_\+\+D\+O\+W\+N\+L\+O\+A\+D\+\_\+\+R\+E\+T\+R\+A\+N\+S\+\_\+\+R\+A\+TE\label{namespaceproxygen_a89466eaf4f6bbc394ccf41acbef3e045a19e733c8bd662aa70c4e5152b4ff30e3}
}]\index{\+\_\+\+S\+P\+D\+Y\+\_\+\+C\+L\+I\+E\+N\+T\+\_\+\+C\+E\+R\+T\+I\+F\+I\+C\+A\+T\+E\+\_\+\+V\+E\+C\+T\+O\+R\+\_\+\+S\+I\+ZE@{\+\_\+\+S\+P\+D\+Y\+\_\+\+C\+L\+I\+E\+N\+T\+\_\+\+C\+E\+R\+T\+I\+F\+I\+C\+A\+T\+E\+\_\+\+V\+E\+C\+T\+O\+R\+\_\+\+S\+I\+ZE}!proxygen@{proxygen}}\index{proxygen@{proxygen}!\+\_\+\+S\+P\+D\+Y\+\_\+\+C\+L\+I\+E\+N\+T\+\_\+\+C\+E\+R\+T\+I\+F\+I\+C\+A\+T\+E\+\_\+\+V\+E\+C\+T\+O\+R\+\_\+\+S\+I\+ZE@{\+\_\+\+S\+P\+D\+Y\+\_\+\+C\+L\+I\+E\+N\+T\+\_\+\+C\+E\+R\+T\+I\+F\+I\+C\+A\+T\+E\+\_\+\+V\+E\+C\+T\+O\+R\+\_\+\+S\+I\+ZE}}\item[{\em 
\+\_\+\+S\+P\+D\+Y\+\_\+\+C\+L\+I\+E\+N\+T\+\_\+\+C\+E\+R\+T\+I\+F\+I\+C\+A\+T\+E\+\_\+\+V\+E\+C\+T\+O\+R\+\_\+\+S\+I\+ZE\label{namespaceproxygen_a89466eaf4f6bbc394ccf41acbef3e045a8ab877dc6a2a6c2518225f1def0c588a}
}]\index{\+\_\+\+H\+Q\+\_\+\+N\+U\+M\+\_\+\+P\+L\+A\+C\+E\+H\+O\+L\+D\+E\+RS@{\+\_\+\+H\+Q\+\_\+\+N\+U\+M\+\_\+\+P\+L\+A\+C\+E\+H\+O\+L\+D\+E\+RS}!proxygen@{proxygen}}\index{proxygen@{proxygen}!\+\_\+\+H\+Q\+\_\+\+N\+U\+M\+\_\+\+P\+L\+A\+C\+E\+H\+O\+L\+D\+E\+RS@{\+\_\+\+H\+Q\+\_\+\+N\+U\+M\+\_\+\+P\+L\+A\+C\+E\+H\+O\+L\+D\+E\+RS}}\item[{\em 
\+\_\+\+H\+Q\+\_\+\+N\+U\+M\+\_\+\+P\+L\+A\+C\+E\+H\+O\+L\+D\+E\+RS\label{namespaceproxygen_a89466eaf4f6bbc394ccf41acbef3e045a2384a4f95aa64ab4576ec8844655f03b}
}]\index{\+\_\+\+H\+Q\+\_\+\+Q\+P\+A\+C\+K\+\_\+\+B\+L\+O\+C\+K\+E\+D\+\_\+\+S\+T\+R\+E\+A\+MS@{\+\_\+\+H\+Q\+\_\+\+Q\+P\+A\+C\+K\+\_\+\+B\+L\+O\+C\+K\+E\+D\+\_\+\+S\+T\+R\+E\+A\+MS}!proxygen@{proxygen}}\index{proxygen@{proxygen}!\+\_\+\+H\+Q\+\_\+\+Q\+P\+A\+C\+K\+\_\+\+B\+L\+O\+C\+K\+E\+D\+\_\+\+S\+T\+R\+E\+A\+MS@{\+\_\+\+H\+Q\+\_\+\+Q\+P\+A\+C\+K\+\_\+\+B\+L\+O\+C\+K\+E\+D\+\_\+\+S\+T\+R\+E\+A\+MS}}\item[{\em 
\+\_\+\+H\+Q\+\_\+\+Q\+P\+A\+C\+K\+\_\+\+B\+L\+O\+C\+K\+E\+D\+\_\+\+S\+T\+R\+E\+A\+MS\label{namespaceproxygen_a89466eaf4f6bbc394ccf41acbef3e045aa80478fb0d11bcf53edfcd332440a00b}
}]\end{description}
\end{Desc}


Definition at line 21 of file Settings\+Id.\+h.


\begin{DoxyCode}
21                       : uint64\_t \{
22   \textcolor{comment}{// From HTTP/2}
23   HEADER_TABLE_SIZE = 1,
24   ENABLE_PUSH = 2,
25   MAX_CONCURRENT_STREAMS = 3,
26   INITIAL_WINDOW_SIZE = 4,
27   MAX_FRAME_SIZE = 5,
28   MAX_HEADER_LIST_SIZE = 6,
29 
30   ENABLE_CONNECT_PROTOCOL = 8,
31 
32   THRIFT_CHANNEL_ID_DEPRECATED = 100,
33 
34   \textcolor{comment}{// 0xf000 and 0xffff being reserved for Experimental Use}
35   ENABLE_EX_HEADERS = 0xfbfb,
36   THRIFT_CHANNEL_ID = 0xf100,
37 
38   \textcolor{comment}{// For secondary authentication in HTTP/2}
39   SETTINGS_HTTP_CERT_AUTH = 0xff00,
40 
41   \textcolor{comment}{// From SPDY, mostly unused}
42   _SPDY_UPLOAD_BANDWIDTH = SPDY_SETTINGS_MASK | 1,
43   _SPDY_DOWNLOAD_BANDWIDTH = SPDY_SETTINGS_MASK | 2,
44   _SPDY_ROUND_TRIP_TIME = SPDY_SETTINGS_MASK | 3,
45   \textcolor{comment}{//  MAX\_CONCURRENT\_STREAMS = 4,}
46   _SPDY_CURRENT_CWND = SPDY_SETTINGS_MASK | 5,
47   _SPDY_DOWNLOAD_RETRANS_RATE = SPDY_SETTINGS_MASK | 6,
48   \textcolor{comment}{//  INITIAL\_WINDOW\_SIZE = 7,}
49   _SPDY_CLIENT_CERTIFICATE_VECTOR_SIZE = SPDY_SETTINGS_MASK | 8,
50 
51   \textcolor{comment}{// From HQ}
52   \textcolor{comment}{//\_HQ\_HEADER\_TABLE\_SIZE = HQ\_SETTINGS\_MASK | 1, -- use HEADER\_TABLE\_SIZE}
53   _HQ_NUM_PLACEHOLDERS = HQ_SETTINGS_MASK | 3,
54   \textcolor{comment}{//\_HQ\_MAX\_HEADER\_LIST\_SIZE = HQ\_SETTINGS\_MASK | 6, -- use MAX\_HEADER\_LIST\_SIZE}
55   _HQ_QPACK_BLOCKED_STREAMS = HQ_SETTINGS_MASK | 7,
56 \};
\end{DoxyCode}
\index{proxygen@{proxygen}!S\+P\+D\+Y\+Version@{S\+P\+D\+Y\+Version}}
\index{S\+P\+D\+Y\+Version@{S\+P\+D\+Y\+Version}!proxygen@{proxygen}}
\subsubsection[{S\+P\+D\+Y\+Version}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+S\+P\+D\+Y\+Version}\hspace{0.3cm}{\ttfamily [strong]}}\label{namespaceproxygen_a2dfaa98b7bf31890f2e357d80f7fce60}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{S\+P\+D\+Y3@{S\+P\+D\+Y3}!proxygen@{proxygen}}\index{proxygen@{proxygen}!S\+P\+D\+Y3@{S\+P\+D\+Y3}}\item[{\em 
S\+P\+D\+Y3\label{namespaceproxygen_a2dfaa98b7bf31890f2e357d80f7fce60a7c824ff753b676cfedf738cee998d396}
}]\index{S\+P\+D\+Y3\+\_\+1@{S\+P\+D\+Y3\+\_\+1}!proxygen@{proxygen}}\index{proxygen@{proxygen}!S\+P\+D\+Y3\+\_\+1@{S\+P\+D\+Y3\+\_\+1}}\item[{\em 
S\+P\+D\+Y3\+\_\+1\label{namespaceproxygen_a2dfaa98b7bf31890f2e357d80f7fce60a7cfd38394c32163d5b152d8c6263f3e4}
}]\end{description}
\end{Desc}


Definition at line 14 of file S\+P\+D\+Y\+Version.\+h.


\begin{DoxyCode}
14 \{ SPDY3 = 0, SPDY3_1 \};
\end{DoxyCode}
\index{proxygen@{proxygen}!Transport\+Direction@{Transport\+Direction}}
\index{Transport\+Direction@{Transport\+Direction}!proxygen@{proxygen}}
\subsubsection[{Transport\+Direction}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+Transport\+Direction} \+: uint8\+\_\+t\hspace{0.3cm}{\ttfamily [strong]}}\label{namespaceproxygen_a00b4cbb0c54e966bfd87e0e7cb1cb33d}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{D\+O\+W\+N\+S\+T\+R\+E\+AM@{D\+O\+W\+N\+S\+T\+R\+E\+AM}!proxygen@{proxygen}}\index{proxygen@{proxygen}!D\+O\+W\+N\+S\+T\+R\+E\+AM@{D\+O\+W\+N\+S\+T\+R\+E\+AM}}\item[{\em 
D\+O\+W\+N\+S\+T\+R\+E\+AM\label{namespaceproxygen_a00b4cbb0c54e966bfd87e0e7cb1cb33daf8e7627f40cd51bcb234401511c640fd}
}]\index{U\+P\+S\+T\+R\+E\+AM@{U\+P\+S\+T\+R\+E\+AM}!proxygen@{proxygen}}\index{proxygen@{proxygen}!U\+P\+S\+T\+R\+E\+AM@{U\+P\+S\+T\+R\+E\+AM}}\item[{\em 
U\+P\+S\+T\+R\+E\+AM\label{namespaceproxygen_a00b4cbb0c54e966bfd87e0e7cb1cb33daef9d7023c0ca8728326a6a7205686518}
}]\end{description}
\end{Desc}


Definition at line 17 of file Transport\+Direction.\+h.


\begin{DoxyCode}
17                               : uint8\_t \{
18   DOWNSTREAM,  \textcolor{comment}{// toward the client}
19   UPSTREAM     \textcolor{comment}{// toward the origin application or data}
20 \};
\end{DoxyCode}
\index{proxygen@{proxygen}!Upgrade\+Protocol@{Upgrade\+Protocol}}
\index{Upgrade\+Protocol@{Upgrade\+Protocol}!proxygen@{proxygen}}
\subsubsection[{Upgrade\+Protocol}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+Upgrade\+Protocol} \+: int\hspace{0.3cm}{\ttfamily [strong]}}\label{namespaceproxygen_a7feed732013b7cc0e2213b19c7b82745}
Protocol to which the \doxyref{H\+T\+T\+P\+Transaction}{p.}{classproxygen_1_1HTTPTransaction} was upgraded \begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{T\+CP@{T\+CP}!proxygen@{proxygen}}\index{proxygen@{proxygen}!T\+CP@{T\+CP}}\item[{\em 
T\+CP\label{namespaceproxygen_a7feed732013b7cc0e2213b19c7b82745ab136ef5f6a01d816991fe3cf7a6ac763}
}]\end{description}
\end{Desc}


Definition at line 61 of file H\+T\+T\+P\+Constants.\+h.


\begin{DoxyCode}
62                           : \textcolor{keywordtype}{int} \{
63   \textcolor{comment}{// We only support changing to TCP after CONNECT requests}
64   TCP
\end{DoxyCode}
\index{proxygen@{proxygen}!Zlib\+Compression\+Type@{Zlib\+Compression\+Type}}
\index{Zlib\+Compression\+Type@{Zlib\+Compression\+Type}!proxygen@{proxygen}}
\subsubsection[{Zlib\+Compression\+Type}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+Zlib\+Compression\+Type} \+: int\hspace{0.3cm}{\ttfamily [strong]}}\label{namespaceproxygen_a8048fc0fa87c5a36cb3efb647ed29e18}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{N\+O\+NE@{N\+O\+NE}!proxygen@{proxygen}}\index{proxygen@{proxygen}!N\+O\+NE@{N\+O\+NE}}\item[{\em 
N\+O\+NE\label{namespaceproxygen_a8048fc0fa87c5a36cb3efb647ed29e18ab50339a10e1de285ac99d4c3990b8693}
}]\index{D\+E\+F\+L\+A\+TE@{D\+E\+F\+L\+A\+TE}!proxygen@{proxygen}}\index{proxygen@{proxygen}!D\+E\+F\+L\+A\+TE@{D\+E\+F\+L\+A\+TE}}\item[{\em 
D\+E\+F\+L\+A\+TE\label{namespaceproxygen_a8048fc0fa87c5a36cb3efb647ed29e18af17e827fa227b759dc5c053b334d77cc}
}]\index{G\+Z\+IP@{G\+Z\+IP}!proxygen@{proxygen}}\index{proxygen@{proxygen}!G\+Z\+IP@{G\+Z\+IP}}\item[{\em 
G\+Z\+IP\label{namespaceproxygen_a8048fc0fa87c5a36cb3efb647ed29e18af1cd28417b03cfab3a8e16d66e34e18a}
}]\end{description}
\end{Desc}


Definition at line 25 of file Zlib\+Stream\+Decompressor.\+h.


\begin{DoxyCode}
25                               : \textcolor{keywordtype}{int} \{
26   NONE = 0,
27   DEFLATE = 15,
28   GZIP = 31
29 \};
\end{DoxyCode}
\index{proxygen@{proxygen}!Zstd\+Status\+Type@{Zstd\+Status\+Type}}
\index{Zstd\+Status\+Type@{Zstd\+Status\+Type}!proxygen@{proxygen}}
\subsubsection[{Zstd\+Status\+Type}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+Zstd\+Status\+Type} \+: int\hspace{0.3cm}{\ttfamily [strong]}}\label{namespaceproxygen_ab18179a16a0bebed81cf3f62dff11064}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{N\+O\+NE@{N\+O\+NE}!proxygen@{proxygen}}\index{proxygen@{proxygen}!N\+O\+NE@{N\+O\+NE}}\item[{\em 
N\+O\+NE\label{namespaceproxygen_ab18179a16a0bebed81cf3f62dff11064ab50339a10e1de285ac99d4c3990b8693}
}]\index{S\+U\+C\+C\+E\+SS@{S\+U\+C\+C\+E\+SS}!proxygen@{proxygen}}\index{proxygen@{proxygen}!S\+U\+C\+C\+E\+SS@{S\+U\+C\+C\+E\+SS}}\item[{\em 
S\+U\+C\+C\+E\+SS\label{namespaceproxygen_ab18179a16a0bebed81cf3f62dff11064ad0749aaba8b833466dfcbb0428e4f89c}
}]\index{N\+O\+D\+I\+CT@{N\+O\+D\+I\+CT}!proxygen@{proxygen}}\index{proxygen@{proxygen}!N\+O\+D\+I\+CT@{N\+O\+D\+I\+CT}}\item[{\em 
N\+O\+D\+I\+CT\label{namespaceproxygen_ab18179a16a0bebed81cf3f62dff11064a1088a9fcfa1ac2b10fbc9862547c4b9a}
}]\index{C\+O\+N\+T\+I\+N\+UE@{C\+O\+N\+T\+I\+N\+UE}!proxygen@{proxygen}}\index{proxygen@{proxygen}!C\+O\+N\+T\+I\+N\+UE@{C\+O\+N\+T\+I\+N\+UE}}\item[{\em 
C\+O\+N\+T\+I\+N\+UE\label{namespaceproxygen_ab18179a16a0bebed81cf3f62dff11064a2f453cfe638e57e27bb0c9512436111e}
}]\index{E\+R\+R\+OR@{E\+R\+R\+OR}!proxygen@{proxygen}}\index{proxygen@{proxygen}!E\+R\+R\+OR@{E\+R\+R\+OR}}\item[{\em 
E\+R\+R\+OR\label{namespaceproxygen_ab18179a16a0bebed81cf3f62dff11064abb1ca97ec761fc37101737ba0aa2e7c5}
}]\end{description}
\end{Desc}


Definition at line 28 of file Zstd\+Stream\+Decompressor.\+h.


\begin{DoxyCode}
28                          : \textcolor{keywordtype}{int} \{
29   NONE,
30   SUCCESS,
31   NODICT,
32   CONTINUE,
33   ERROR,
34  \};
\end{DoxyCode}


\subsection{Function Documentation}
\index{proxygen@{proxygen}!A\+C\+T\+I\+O\+N\+\_\+P@{A\+C\+T\+I\+O\+N\+\_\+P}}
\index{A\+C\+T\+I\+O\+N\+\_\+P@{A\+C\+T\+I\+O\+N\+\_\+P}!proxygen@{proxygen}}
\subsubsection[{A\+C\+T\+I\+O\+N\+\_\+\+P(\+Expect\+String, expected)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+A\+C\+T\+I\+O\+N\+\_\+P (
\begin{DoxyParamCaption}
\item[{Expect\+String}]{, }
\item[{expected}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a8309b286680653c4efa5ff80beeae28e}


Definition at line 404 of file H\+T\+T\+P\+Session\+Mocks.\+h.


\begin{DoxyCode}
404                                  \{
405   std::string bodystr((\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)arg0->data(), arg0->length());
406   EXPECT\_EQ(bodystr, expected);
407 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!A\+C\+T\+I\+O\+N\+\_\+P@{A\+C\+T\+I\+O\+N\+\_\+P}}
\index{A\+C\+T\+I\+O\+N\+\_\+P@{A\+C\+T\+I\+O\+N\+\_\+P}!proxygen@{proxygen}}
\subsubsection[{A\+C\+T\+I\+O\+N\+\_\+\+P(\+Expect\+Body\+Len, expected\+Len)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+A\+C\+T\+I\+O\+N\+\_\+P (
\begin{DoxyParamCaption}
\item[{Expect\+Body\+Len}]{, }
\item[{expected\+Len}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a5b69d57713a7a15128e52970f629bb74}


Definition at line 409 of file H\+T\+T\+P\+Session\+Mocks.\+h.


\begin{DoxyCode}
409                                      \{
410   EXPECT\_EQ(arg1->computeChainDataLength(), expectedLen);
411 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!base64\+Encode@{base64\+Encode}}
\index{base64\+Encode@{base64\+Encode}!proxygen@{proxygen}}
\subsubsection[{base64\+Encode(folly\+::\+Byte\+Range text)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string proxygen\+::base64\+Encode (
\begin{DoxyParamCaption}
\item[{folly\+::\+Byte\+Range}]{text}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a9102da222c7136cf79262a6663fbd55e}


Definition at line 21 of file Crypt\+Util.\+cpp.



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
21                                             \{
22   std::string result;
23   BIO *b64 = BIO\_new(BIO\_f\_base64());
24   \textcolor{keywordflow}{if} (b64 == \textcolor{keyword}{nullptr}) \{
25     \textcolor{keywordflow}{return} result;
26   \}
27   BIO *bmem = BIO\_new(BIO\_s\_mem());
28   \textcolor{keywordflow}{if} (bmem == \textcolor{keyword}{nullptr}) \{
29     BIO\_free\_all(b64);
30     \textcolor{keywordflow}{return} result;
31   \}
32   BUF\_MEM *bptr;
33 
34   \textcolor{comment}{// chain base64 filter with the memory buffer}
35   \textcolor{comment}{// so that text will be encoded by base64 and flushed to buffer}
36   BIO *chain = BIO\_push(b64, bmem);
37   \textcolor{keywordflow}{if} (chain == \textcolor{keyword}{nullptr}) \{
38     BIO\_free\_all(b64);
39     \textcolor{keywordflow}{return} result;
40   \}
41   BIO\_set\_flags(chain, BIO\_FLAGS\_BASE64\_NO\_NL);
42   BIO\_write(chain, text.begin(), text.size());
43   \textcolor{keywordflow}{if} (BIO\_flush(chain) != 1) \{
44     BIO\_free\_all(chain);
45     \textcolor{keywordflow}{return} result;
46   \}
47 
48   BIO\_get\_mem\_ptr(chain, &bptr);
49 
50   \textcolor{keywordflow}{if} (bptr && bptr->length > 0) \{
51     result = std::string((\textcolor{keywordtype}{char} *)bptr->data, bptr->length);
52   \}
53 
54   \textcolor{comment}{// free the whole BIO chain (b64 and mem)}
55   BIO\_free\_all(chain);
56   \textcolor{keywordflow}{return} result;
57 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!case\+Insensitive\+Equal@{case\+Insensitive\+Equal}}
\index{case\+Insensitive\+Equal@{case\+Insensitive\+Equal}!proxygen@{proxygen}}
\subsubsection[{case\+Insensitive\+Equal(folly\+::\+String\+Piece s, folly\+::\+String\+Piece t)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::case\+Insensitive\+Equal (
\begin{DoxyParamCaption}
\item[{folly\+::\+String\+Piece}]{s, }
\item[{folly\+::\+String\+Piece}]{t}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_a003b5a50f13bec64521a6c11f574dd70}


Definition at line 17 of file Util\+Inl.\+h.



Referenced by proxygen\+::\+H\+T\+T\+P1x\+Codec\+::generate\+Header(), proxygen\+::\+S\+P\+D\+Y\+Codec\+::is\+S\+P\+D\+Y\+Reserved(), proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Headers\+Complete(), proxygen\+::\+S\+P\+D\+Y\+Codec\+::parse\+Headers(), proxygen\+::\+Perfect\+Index\+Map$<$ typename T\+::\+T\+Key, T\+::\+T\+Other\+Key, T\+::\+T\+None\+Key, T\+::\+Hash, T\+::\+T\+Allow\+Duplicates, T\+::\+T\+Case\+Insensitive $>$\+::search\+For\+Other\+Key(), string\+To\+Method(), and T\+E\+S\+T().


\begin{DoxyCode}
17                                                                          \{
18   \textcolor{keywordflow}{if} (s.size() != t.size()) \{
19     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
20   \}
21   \textcolor{keywordflow}{return} std::equal(
22       s.begin(), s.end(), t.begin(), folly::AsciiCaseInsensitive());
23 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!case\+Underscore\+Insensitive\+Equal@{case\+Underscore\+Insensitive\+Equal}}
\index{case\+Underscore\+Insensitive\+Equal@{case\+Underscore\+Insensitive\+Equal}!proxygen@{proxygen}}
\subsubsection[{case\+Underscore\+Insensitive\+Equal(folly\+::\+String\+Piece s, folly\+::\+String\+Piece t)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::case\+Underscore\+Insensitive\+Equal (
\begin{DoxyParamCaption}
\item[{folly\+::\+String\+Piece}]{s, }
\item[{folly\+::\+String\+Piece}]{t}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_ad4b0a327faecc13c1040c8a8eae42fa8}


Definition at line 38 of file Util\+Inl.\+h.


\begin{DoxyCode}
40                         \{
41   \textcolor{keywordflow}{if} (s.size() != t.size()) \{
42     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
43   \}
44   \textcolor{keywordtype}{bool} result = std::equal(
45       s.begin(), s.end(), t.begin(), AsciiCaseUnderscoreInsensitive());
46   \textcolor{keywordflow}{return} result;
47 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!check\+For\+Protocol\+Upgrade@{check\+For\+Protocol\+Upgrade}}
\index{check\+For\+Protocol\+Upgrade@{check\+For\+Protocol\+Upgrade}!proxygen@{proxygen}}
\subsubsection[{check\+For\+Protocol\+Upgrade(const std\+::string \&client\+Upgrade, const std\+::string \&server\+Upgrade, bool server\+Mode)}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+Optional$<$ std\+::pair$<$ {\bf Codec\+Protocol}, std\+::string $>$ $>$ proxygen\+::check\+For\+Protocol\+Upgrade (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{client\+Upgrade, }
\item[{const std\+::string \&}]{server\+Upgrade, }
\item[{bool}]{server\+Mode}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a2c76f84d789c5c895d62f4711bd6c315}
Search the client and server protocol lists for a matching native Codec\+Protocol 

Definition at line 91 of file Codec\+Protocol.\+cpp.



References get\+Codec\+Protocol\+From\+Str(), proxygen\+::\+H\+T\+T\+P\+Codec\+::\+No\+Ex\+Attributes, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+No\+Padding, and proxygen\+::\+H\+T\+T\+P\+Codec\+::\+No\+Stream.



Referenced by proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Headers\+Complete().


\begin{DoxyCode}
93                                          \{
94   CodecProtocol protocol;
95   \textcolor{keywordflow}{if} (clientUpgrade.empty() || serverUpgrade.empty()) \{
96     \textcolor{keywordflow}{return} folly::none;
97   \}
98 
99   \textcolor{comment}{// Should be a comma separated list of protocols, like NPN}
100   std::vector<folly::StringPiece> clientProtocols;
101   folly::split(\textcolor{stringliteral}{","}, clientUpgrade, clientProtocols, \textcolor{keyword}{true} \textcolor{comment}{/* ignore empty */});
102   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}& clientProtocol: clientProtocols) \{
103     boost::algorithm::trim(clientProtocol);
104   \}
105 
106   \textcolor{comment}{// List of server chosen protocols in layer-ascending order.  We can}
107   \textcolor{comment}{// only support one layer right now.  We just skip anything that}
108   \textcolor{comment}{// isn't an HTTP transport protocol}
109   std::vector<folly::StringPiece> serverProtocols;
110   folly::split(\textcolor{stringliteral}{","}, serverUpgrade, serverProtocols, \textcolor{keyword}{true} \textcolor{comment}{/* ignore empty */});
111 
112   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}& testProtocol: serverProtocols) \{
113     \textcolor{comment}{// Get rid of leading/trailing LWS}
114     boost::algorithm::trim(testProtocol);
115     \textcolor{keywordflow}{if} (std::find(clientProtocols.begin(), clientProtocols.end(),
116                   testProtocol) == clientProtocols.end()) \{
117       \textcolor{keywordflow}{if} (serverMode) \{
118         \textcolor{comment}{// client didn't offer this, try the next}
119         \textcolor{keywordflow}{continue};
120       \} \textcolor{keywordflow}{else} \{
121         \textcolor{comment}{// The server returned a protocol the client didn't ask for}
122         \textcolor{keywordflow}{return} folly::none;
123       \}
124     \}
125     protocol = getCodecProtocolFromStr(testProtocol);
126     \textcolor{comment}{// Non-native upgrades get returned as HTTP\_1\_1/<actual protocol>}
127     \textcolor{keywordflow}{return} std::make\_pair(protocol, testProtocol.str());
128   \}
129   \textcolor{keywordflow}{return} folly::none;
130 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!dump\+Bin\+To\+File@{dump\+Bin\+To\+File}}
\index{dump\+Bin\+To\+File@{dump\+Bin\+To\+File}!proxygen@{proxygen}}
\subsubsection[{dump\+Bin\+To\+File(const string \&filename, const I\+O\+Buf $\ast$buf)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::dump\+Bin\+To\+File (
\begin{DoxyParamCaption}
\item[{const string \&}]{filename, }
\item[{const I\+O\+Buf $\ast$}]{buf}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a6d6f04b3cc4975bc9ca0d93117426880}


Definition at line 133 of file Logging.\+cpp.



References E\+R\+R\+OR, and proxygen\+::\+I\+O\+Buf\+Printer\+::print\+Chain\+Info().



Referenced by H\+T\+T\+P\+Parallel\+Codec\+Test\+::dump\+To\+File(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
133                                                              \{
134   \textcolor{keyword}{struct }stat fstat;
135   \textcolor{keywordtype}{bool} exists = (stat(filename.c\_str(), &fstat) == 0);
136   \textcolor{keywordflow}{if} (exists) \{
137     \textcolor{comment}{// don't write anything if the file exists}
138     \textcolor{keywordflow}{return};
139   \}
140   std::ofstream file(filename, std::ofstream::binary);
141   \textcolor{keywordflow}{if} (!file.is\_open()) \{
142     LOG(ERROR) << \textcolor{stringliteral}{"cannot open file "} << filename;
143     \textcolor{keywordflow}{return};
144   \}
145   \textcolor{keywordflow}{if} (!buf) \{
146     file.close();
147     \textcolor{keywordflow}{return};
148   \}
149   \textcolor{keyword}{const} IOBuf* first = buf;
150   \textcolor{keywordflow}{do} \{
151     file.write((\textcolor{keyword}{const} \textcolor{keywordtype}{char} *)buf->data(), buf->length());
152     buf = buf->next();
153   \} \textcolor{keywordflow}{while} (buf != first);
154   file.close();
155   LOG(INFO) << \textcolor{stringliteral}{"wrote chain "} << IOBufPrinter::printChainInfo(buf)
156             << \textcolor{stringliteral}{" to "} << filename;
157 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!dump\+Bin\+To\+File@{dump\+Bin\+To\+File}}
\index{dump\+Bin\+To\+File@{dump\+Bin\+To\+File}!proxygen@{proxygen}}
\subsubsection[{dump\+Bin\+To\+File(const std\+::string \&filename, const folly\+::\+I\+O\+Buf $\ast$buf)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::dump\+Bin\+To\+File (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{filename, }
\item[{const folly\+::\+I\+O\+Buf $\ast$}]{buf}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a58573a8c43ca1b9dbf1619f8c1e4454d}
write the entire binary content from all the buffers into a binary file \index{proxygen@{proxygen}!duration\+Initialized@{duration\+Initialized}}
\index{duration\+Initialized@{duration\+Initialized}!proxygen@{proxygen}}
\subsubsection[{duration\+Initialized(const T \&duration)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ bool proxygen\+::duration\+Initialized (
\begin{DoxyParamCaption}
\item[{const {\bf T} \&}]{duration}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a6b3292892896f26cdbf5e59b071c2d2f}


Definition at line 29 of file Time.\+h.



References T.


\begin{DoxyCode}
29                                             \{
30   \textcolor{keyword}{static} T zero(0);
31   \textcolor{keywordflow}{return} duration != T::max() && duration >= zero;
32 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!fake\+Mock\+Codec@{fake\+Mock\+Codec}}
\index{fake\+Mock\+Codec@{fake\+Mock\+Codec}!proxygen@{proxygen}}
\subsubsection[{fake\+Mock\+Codec(\+Mock\+H\+T\+T\+P\+Codec \&codec)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::fake\+Mock\+Codec (
\begin{DoxyParamCaption}
\item[{{\bf Mock\+H\+T\+T\+P\+Codec} \&}]{codec}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a8cb872e2077ddfd9d87fc3882cd6b040}


Definition at line 173 of file Test\+Utils.\+cpp.



References make\+Buf().



Referenced by M\+A\+T\+C\+H\+E\+R\+\_\+\+P(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
173                                          \{
174   \textcolor{comment}{// For each generate* function, write some data to the chain}
175   EXPECT\_CALL(codec, generateHeader(\_, \_, \_, \_, \_))
176       .WillRepeatedly(Invoke(
177           [](folly::IOBufQueue& writeBuf,
178              HTTPCodec::StreamID \textcolor{comment}{/*stream*/},
179              \textcolor{keyword}{const} HTTPMessage& \textcolor{comment}{/*msg*/},
180              \textcolor{keywordtype}{bool} \textcolor{comment}{/*eom*/},
181              HTTPHeaderSize* \textcolor{comment}{/*size*/}) \{ writeBuf.append(makeBuf(10)); \}));
182 
183   EXPECT\_CALL(codec, generatePushPromise(\_, \_, \_, \_, \_, \_))
184       .WillRepeatedly(Invoke(
185           [](folly::IOBufQueue& writeBuf,
186              HTTPCodec::StreamID \textcolor{comment}{/*stream*/},
187              \textcolor{keyword}{const} HTTPMessage& \textcolor{comment}{/*msg*/},
188              HTTPCodec::StreamID \textcolor{comment}{/*assocStream*/},
189              \textcolor{keywordtype}{bool} \textcolor{comment}{/*eom*/},
190              HTTPHeaderSize* \textcolor{comment}{/*size*/}) \{ writeBuf.append(makeBuf(10)); \}));
191 
192   EXPECT\_CALL(codec, generateBody(\_, \_, \_, \_, \_))
193       .WillRepeatedly(Invoke([](folly::IOBufQueue& writeBuf,
194                                 HTTPCodec::StreamID \textcolor{comment}{/*stream*/},
195                                 std::shared\_ptr<folly::IOBuf> chain,
196                                 folly::Optional<uint8\_t> \textcolor{comment}{/*padding*/},
197                                 \textcolor{keywordtype}{bool} \textcolor{comment}{/*eom*/}) \{
198         \textcolor{keyword}{auto} len = chain->computeChainDataLength();
199         writeBuf.append(chain->clone());
200         \textcolor{keywordflow}{return} len;
201       \}));
202 
203   EXPECT\_CALL(codec, generateChunkHeader(\_, \_, \_))
204       .WillRepeatedly(Invoke([](folly::IOBufQueue& writeBuf,
205                                 HTTPCodec::StreamID \textcolor{comment}{/*stream*/},
206                                 \textcolor{keywordtype}{size\_t} length) \{
207         writeBuf.append(makeBuf(length));
208         \textcolor{keywordflow}{return} length;
209       \}));
210 
211   EXPECT\_CALL(codec, generateChunkTerminator(\_, \_))
212       .WillRepeatedly(Invoke(
213           [](folly::IOBufQueue& writeBuf, HTTPCodec::StreamID \textcolor{comment}{/*stream*/}) \{
214             writeBuf.append(makeBuf(4));
215             \textcolor{keywordflow}{return} 4;
216           \}));
217 
218   EXPECT\_CALL(codec, generateTrailers(\_, \_, \_))
219       .WillRepeatedly(Invoke([](folly::IOBufQueue& writeBuf,
220                                 HTTPCodec::StreamID \textcolor{comment}{/*stream*/},
221                                 \textcolor{keyword}{const} HTTPHeaders& \textcolor{comment}{/*trailers*/}) \{
222         writeBuf.append(makeBuf(30));
223         \textcolor{keywordflow}{return} 30;
224       \}));
225 
226   EXPECT\_CALL(codec, generateEOM(\_, \_))
227       .WillRepeatedly(Invoke(
228           [](folly::IOBufQueue& writeBuf, HTTPCodec::StreamID \textcolor{comment}{/*stream*/}) \{
229             writeBuf.append(makeBuf(6));
230             \textcolor{keywordflow}{return} 6;
231           \}));
232 
233   EXPECT\_CALL(codec, generateRstStream(\_, \_, \_))
234       .WillRepeatedly(Invoke([](folly::IOBufQueue& writeBuf,
235                                 HTTPCodec::StreamID \textcolor{comment}{/*stream*/},
236                                 ErrorCode \textcolor{comment}{/*code*/}) \{
237         writeBuf.append(makeBuf(6));
238         \textcolor{keywordflow}{return} 6;
239       \}));
240 
241   EXPECT\_CALL(codec, generateGoaway(\_, \_, \_, \_))
242       .WillRepeatedly(Invoke([](folly::IOBufQueue& writeBuf,
243                                 uint32\_t \textcolor{comment}{/*lastStream*/},
244                                 ErrorCode,
245                                 std::shared\_ptr<folly::IOBuf>) \{
246         writeBuf.append(makeBuf(6));
247         \textcolor{keywordflow}{return} 6;
248       \}));
249 
250   EXPECT\_CALL(codec, generatePingRequest(\_))
251     .WillRepeatedly(Invoke([] (folly::IOBufQueue& writeBuf) \{
252                              writeBuf.append(makeBuf(6));
253                              \textcolor{keywordflow}{return} 6;
254                            \}));
255 
256   EXPECT\_CALL(codec, generatePingReply(\_, \_))
257       .WillRepeatedly(Invoke([](folly::IOBufQueue& writeBuf, uint64\_t \textcolor{comment}{/*id*/}) \{
258         writeBuf.append(makeBuf(6));
259         \textcolor{keywordflow}{return} 6;
260       \}));
261 
262   EXPECT\_CALL(codec, generateSettings(\_))
263     .WillRepeatedly(Invoke([] (folly::IOBufQueue& writeBuf) \{
264                              writeBuf.append(makeBuf(6));
265                              \textcolor{keywordflow}{return} 6;
266                            \}));
267 
268   EXPECT\_CALL(codec, generateWindowUpdate(\_, \_, \_))
269       .WillRepeatedly(Invoke([](folly::IOBufQueue& writeBuf,
270                                 HTTPCodec::StreamID \textcolor{comment}{/*stream*/},
271                                 uint32\_t \textcolor{comment}{/*delta*/}) \{
272         writeBuf.append(makeBuf(6));
273         \textcolor{keywordflow}{return} 6;
274       \}));
275 
276   EXPECT\_CALL(codec, generateCertificateRequest(\_, \_, \_))
277       .WillRepeatedly(Invoke([](folly::IOBufQueue& writeBuf,
278                                 uint16\_t \textcolor{comment}{/*requestId*/},
279                                 std::shared\_ptr<folly::IOBuf>) \{
280         writeBuf.append(makeBuf(6));
281         \textcolor{keywordflow}{return} 6;
282       \}));
283 
284   EXPECT\_CALL(codec, generateCertificate(\_, \_, \_))
285       .WillRepeatedly(Invoke([](folly::IOBufQueue& writeBuf,
286                                 uint16\_t \textcolor{comment}{/*certId*/},
287                                 std::shared\_ptr<folly::IOBuf>) \{
288         writeBuf.append(makeBuf(6));
289         \textcolor{keywordflow}{return} 6;
290       \}));
291 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!get\+Big\+Get\+Request@{get\+Big\+Get\+Request}}
\index{get\+Big\+Get\+Request@{get\+Big\+Get\+Request}!proxygen@{proxygen}}
\subsubsection[{get\+Big\+Get\+Request(const std\+::string \&url)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Message} proxygen\+::get\+Big\+Get\+Request (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{url}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a8ab45f1543676be4af4c50886925e429}


Definition at line 85 of file Test\+Utils.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Headers\+::add(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), proxygen\+::http2\+::k\+Max\+Frame\+Payload\+Length\+Min, proxygen\+::\+H\+T\+T\+P\+Headers\+::set(), proxygen\+::\+H\+T\+T\+P\+Message\+::set\+H\+T\+T\+P\+Version(), proxygen\+::\+H\+T\+T\+P\+Message\+::set\+Method(), and proxygen\+::\+H\+T\+T\+P\+Message\+::set\+U\+R\+L().



Referenced by M\+A\+T\+C\+H\+E\+R\+\_\+\+P(), T\+E\+S\+T\+\_\+\+F(), and H\+T\+T\+P2\+Codec\+Test\+::test\+Frame\+Size\+Limit().


\begin{DoxyCode}
85                                                    \{
86   HTTPMessage req;
87   req.setMethod(\textcolor{stringliteral}{"GET"});
88   req.setURL(url);
89   req.setHTTPVersion(1, 1);
90   req.getHeaders().set(HTTP\_HEADER\_HOST, \textcolor{stringliteral}{"www.foo.com"});
91   req.getHeaders().add(HTTP\_HEADER\_USER\_AGENT, \textcolor{stringliteral}{"coolio"});
92   req.getHeaders().add(
93       \textcolor{stringliteral}{"x-huge-header"},
94       std::string(http2::kMaxFramePayloadLengthMin, \textcolor{charliteral}{'!'}));
95   \textcolor{keywordflow}{return} req;
96 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!get\+Chunked\+Post\+Request@{get\+Chunked\+Post\+Request}}
\index{get\+Chunked\+Post\+Request@{get\+Chunked\+Post\+Request}!proxygen@{proxygen}}
\subsubsection[{get\+Chunked\+Post\+Request()}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Message} proxygen\+::get\+Chunked\+Post\+Request (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a1d79a5c3b8eacfc28a45e429b4ad3cc5}


Definition at line 113 of file Test\+Utils.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), proxygen\+::\+H\+T\+T\+P\+Headers\+::set(), proxygen\+::\+H\+T\+T\+P\+Message\+::set\+H\+T\+T\+P\+Version(), proxygen\+::\+H\+T\+T\+P\+Message\+::set\+Is\+Chunked(), proxygen\+::\+H\+T\+T\+P\+Message\+::set\+Method(), and proxygen\+::\+H\+T\+T\+P\+Message\+::set\+U\+R\+L().



Referenced by M\+A\+T\+C\+H\+E\+R\+\_\+\+P().


\begin{DoxyCode}
113                                     \{
114   HTTPMessage req;
115   req.setMethod(\textcolor{stringliteral}{"POST"});
116   req.setURL<\textcolor{keywordtype}{string}>(\textcolor{stringliteral}{"/"});
117   req.setHTTPVersion(1, 1);
118   req.setIsChunked(\textcolor{keyword}{true});
119   req.getHeaders().set(HTTP\_HEADER\_HOST, \textcolor{stringliteral}{"www.foo.com"});
120   req.getHeaders().set(HTTP\_HEADER\_TRANSFER\_ENCODING, \textcolor{stringliteral}{"chunked"});
121   \textcolor{keywordflow}{return} req;
122 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!get\+Codec\+Protocol\+From\+Str@{get\+Codec\+Protocol\+From\+Str}}
\index{get\+Codec\+Protocol\+From\+Str@{get\+Codec\+Protocol\+From\+Str}!proxygen@{proxygen}}
\subsubsection[{get\+Codec\+Protocol\+From\+Str(const std\+::string \&protocol\+Str)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Codec\+Protocol} proxygen\+::get\+Codec\+Protocol\+From\+Str (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{protocol\+Str}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a3c6a87b62a7df2735caa790de9b5114b}
Get the protocol from the given debugging name. If it\textquotesingle{}s an invalid string, return the default protocol. 

Definition at line 69 of file Codec\+Protocol.\+cpp.



Referenced by check\+For\+Protocol\+Upgrade().


\begin{DoxyCode}
69                                                                            \{
70   \textcolor{keywordflow}{return} getCodecProtocolFromStr(folly::StringPiece(protocolStr));
71 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!get\+Codec\+Protocol\+String@{get\+Codec\+Protocol\+String}}
\index{get\+Codec\+Protocol\+String@{get\+Codec\+Protocol\+String}!proxygen@{proxygen}}
\subsubsection[{get\+Codec\+Protocol\+String(\+Codec\+Protocol proto)}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string \& proxygen\+::get\+Codec\+Protocol\+String (
\begin{DoxyParamCaption}
\item[{{\bf Codec\+Protocol}}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a8ec3757883de31c779b3eb31497e9e4e}
Returns a debugging name to refer to the given protocol. 

Definition at line 47 of file Codec\+Protocol.\+cpp.



References HQ, H\+T\+T\+P\+\_\+1\+\_\+1, H\+T\+T\+P\+\_\+2, S\+P\+D\+Y\+\_\+3, and S\+P\+D\+Y\+\_\+3\+\_\+1.



Referenced by proxygen\+::\+H\+T\+T\+P\+Session\+::describe(), proxygen\+::\+H\+T\+T\+P\+Session\+::new\+Ex\+Transaction(), H\+T\+T\+P\+Target\+Session\+Acceptor\+::on\+Create(), and proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Headers\+Complete().


\begin{DoxyCode}
47                                                                     \{
48   \textcolor{keywordflow}{switch} (proto) \{
49     \textcolor{keywordflow}{case} CodecProtocol::HTTP\_1\_1: \textcolor{keywordflow}{return} http\_1\_1;
50     \textcolor{keywordflow}{case} CodecProtocol::SPDY\_3: \textcolor{keywordflow}{return} spdy\_3;
51     \textcolor{keywordflow}{case} CodecProtocol::SPDY\_3\_1: \textcolor{keywordflow}{return} spdy\_3\_1;
52     \textcolor{keywordflow}{case} CodecProtocol::HTTP\_2: \textcolor{keywordflow}{return} http\_2;
53     \textcolor{keywordflow}{case} CodecProtocol::HQ: \textcolor{keywordflow}{return} hq;
54   \}
55   LOG(FATAL) << \textcolor{stringliteral}{"Unreachable"};
56   \textcolor{keywordflow}{return} empty;
57 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!get\+Connection\+Close\+Reason\+String@{get\+Connection\+Close\+Reason\+String}}
\index{get\+Connection\+Close\+Reason\+String@{get\+Connection\+Close\+Reason\+String}!proxygen@{proxygen}}
\subsubsection[{get\+Connection\+Close\+Reason\+String(\+Connection\+Close\+Reason r)}]{\setlength{\rightskip}{0pt plus 5cm}const char $\ast$ proxygen\+::get\+Connection\+Close\+Reason\+String (
\begin{DoxyParamCaption}
\item[{{\bf Connection\+Close\+Reason}}]{r}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a690b2895abeded5122d536edce04d4b1}


Definition at line 28 of file H\+T\+T\+P\+Constants.\+cpp.


\begin{DoxyCode}
28                                                                     \{
29   \textcolor{keywordflow}{return} connectionCloseStrings[(\textcolor{keywordtype}{unsigned} int)r];
30 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!get\+Connection\+Close\+Reason\+String\+By\+Index@{get\+Connection\+Close\+Reason\+String\+By\+Index}}
\index{get\+Connection\+Close\+Reason\+String\+By\+Index@{get\+Connection\+Close\+Reason\+String\+By\+Index}!proxygen@{proxygen}}
\subsubsection[{get\+Connection\+Close\+Reason\+String\+By\+Index(unsigned int index)}]{\setlength{\rightskip}{0pt plus 5cm}const char $\ast$ proxygen\+::get\+Connection\+Close\+Reason\+String\+By\+Index (
\begin{DoxyParamCaption}
\item[{unsigned int}]{index}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a2ca8b0e7c6a0a395f65375594873e04f}


Definition at line 20 of file H\+T\+T\+P\+Constants.\+cpp.



References k\+M\+A\+X\+\_\+\+R\+E\+A\+S\+ON.


\begin{DoxyCode}
20                                                                       \{
21   \textcolor{keywordflow}{if} (index >= (\textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{int})ConnectionCloseReason::kMAX\_REASON) \{
22     index = (\textcolor{keywordtype}{unsigned} int)ConnectionCloseReason::kMAX\_REASON - 1;
23   \}
24 
25   \textcolor{keywordflow}{return} connectionCloseStrings[index];
26 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!get\+Current\+Time@{get\+Current\+Time}}
\index{get\+Current\+Time@{get\+Current\+Time}!proxygen@{proxygen}}
\subsubsection[{get\+Current\+Time()}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock\+Type  = Steady\+Clock$>$ std\+::chrono\+::time\+\_\+point$<$Clock\+Type$>$ proxygen\+::get\+Current\+Time (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_a09b325f9c0aa18197dfeebb7f0533a49}


Definition at line 41 of file Time.\+h.



Referenced by Test\+Async\+Transport\+::add\+Read\+Error(), proxygen\+::\+H\+T\+T\+P\+Connector\+::connect(), proxygen\+::\+H\+T\+T\+P\+Connector\+::connect\+S\+S\+L(), proxygen\+::\+H\+T\+T\+P\+Connector\+::connect\+Success(), Test\+Async\+Transport\+::fire\+Next\+Read\+Event(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::maybe\+Delay\+For\+Rate\+Limit(), proxygen\+::compress\+::\+Sim\+Streaming\+Callback\+::maybe\+Mark\+Hol\+Delay(), Test\+Async\+Transport\+::\+Write\+Event\+::new\+Event(), proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Ping\+Request(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::set\+Egress\+Rate\+Limit(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::set\+Latest\+Active(), Test\+Async\+Transport\+::set\+Read\+C\+B(), Test\+Async\+Transport\+::start\+Read\+Events(), T\+E\+S\+T(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
41                                                        \{
42   \textcolor{keywordflow}{return} ClockType::now();
43 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!get\+Date\+Offset\+Str@{get\+Date\+Offset\+Str}}
\index{get\+Date\+Offset\+Str@{get\+Date\+Offset\+Str}!proxygen@{proxygen}}
\subsubsection[{get\+Date\+Offset\+Str(char datebuf[32], int day\+Offset)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::get\+Date\+Offset\+Str (
\begin{DoxyParamCaption}
\item[{char}]{datebuf[32], }
\item[{int}]{day\+Offset}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_aa0441de2bd966ec7ccf1a273191c6584}
Get the current date + offset days in Y-\/m-\/d format. 

Definition at line 129 of file Time.\+h.



References to\+Time\+T().


\begin{DoxyCode}
129                                                               \{
130   time\_t t = toTimeT(getCurrentTime<SteadyClock>());
131   t += dayOffset * 24 * 60 * 60;
132   \textcolor{keyword}{struct }tm final\_tm;
133   localtime\_r(&t, &final\_tm);
134   strftime(datebuf, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char}) * 32, \textcolor{stringliteral}{"%Y-%m-%d"}, &final\_tm);
135 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!get\+Date\+Time\+Str@{get\+Date\+Time\+Str}}
\index{get\+Date\+Time\+Str@{get\+Date\+Time\+Str}!proxygen@{proxygen}}
\subsubsection[{get\+Date\+Time\+Str(const A\+S\+N1\+\_\+\+T\+I\+M\+E $\ast$const time)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string proxygen\+::get\+Date\+Time\+Str (
\begin{DoxyParamCaption}
\item[{const A\+S\+N1\+\_\+\+T\+I\+ME $\ast$const}]{time}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ae1116cdf5e6d553bd10784c95821ed09}
Helper method to convert to Open\+S\+SL type A\+S\+N1\+\_\+\+T\+I\+ME to a printable date and time string.


\begin{DoxyParams}{Parameters}
{\em time} & a pointer to the A\+S\+N1\+\_\+\+T\+I\+ME instance to be converted. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a human readable date and time string for the openssl type A\+S\+N1\+\_\+\+T\+I\+ME. If there is any error, returns empty string. 
\end{DoxyReturn}


Definition at line 17 of file Time.\+cpp.



Referenced by get\+Date\+Time\+Str(), and T\+E\+S\+T().


\begin{DoxyCode}
17                                                       \{
18   \textcolor{keywordflow}{if} (!time) \{
19     \textcolor{keywordflow}{return} \textcolor{stringliteral}{""};
20   \}
21 
22   constexpr \textcolor{keyword}{auto} bufSize = 32;
23   \textcolor{keywordtype}{char} buf[bufSize] = \{0\};
24 
25   \textcolor{keyword}{auto} bio = BIO\_new(BIO\_s\_mem());
26   \textcolor{keywordflow}{if} (!bio) \{
27     \textcolor{keywordflow}{return} \textcolor{stringliteral}{""};
28   \}
29 
30   ASN1\_TIME\_print(bio, time);
31   \textcolor{keyword}{const} \textcolor{keyword}{auto} readResult = BIO\_read(bio, buf, bufSize - 1);
32   BIO\_free(bio);
33 
34   \textcolor{keywordflow}{return} ((readResult <= 0) ? \textcolor{stringliteral}{""} : std::string(buf));
35 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!get\+Date\+Time\+Str@{get\+Date\+Time\+Str}}
\index{get\+Date\+Time\+Str@{get\+Date\+Time\+Str}!proxygen@{proxygen}}
\subsubsection[{get\+Date\+Time\+Str(char datebuf[32], char timebuf[32])}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::get\+Date\+Time\+Str (
\begin{DoxyParamCaption}
\item[{char}]{datebuf[32], }
\item[{char}]{timebuf[32]}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_af33696d52d6ed80db6871c75ec22f464}
Get the current date and time in string formats\+: Y-\/m-\/d and H\+:M\+:S. 

Definition at line 114 of file Time.\+h.



References to\+Time\+T().


\begin{DoxyCode}
114                                                                \{
115   time\_t now = toTimeT(getCurrentTime<SteadyClock>());
116   \textcolor{keyword}{struct }tm now\_tm;
117   localtime\_r(&now, &now\_tm);
118   \textcolor{keywordflow}{if} (datebuf) \{
119     strftime(datebuf, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char}) * 32, \textcolor{stringliteral}{"%Y-%m-%d"}, &now\_tm);
120   \}
121   \textcolor{keywordflow}{if} (timebuf) \{
122     strftime(timebuf, \textcolor{keyword}{sizeof}(\textcolor{keywordtype}{char}) * 32, \textcolor{stringliteral}{"%H:%M:%S"}, &now\_tm);
123   \}
124 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!get\+Date\+Time\+Str@{get\+Date\+Time\+Str}}
\index{get\+Date\+Time\+Str@{get\+Date\+Time\+Str}!proxygen@{proxygen}}
\subsubsection[{get\+Date\+Time\+Str(\+Time\+Point tp)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string proxygen\+::get\+Date\+Time\+Str (
\begin{DoxyParamCaption}
\item[{{\bf Time\+Point}}]{tp}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_a1f8ee233c52cfca17601c0a862bf7f49}
Helper method to convert Time\+Point to a printable date and time string. It will convert static time to system time.


\begin{DoxyParams}{Parameters}
{\em time} & Time\+Point \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
a human readable date and time string at U\+TC timezone. If there is any error, returns empty string. 
\end{DoxyReturn}


Definition at line 145 of file Time.\+h.



References get\+Date\+Time\+Str(), and to\+Time\+T().


\begin{DoxyCode}
145                                               \{
146   time\_t t = toTimeT(tp);
147   \textcolor{keyword}{struct }tm final\_tm;
148   gmtime\_r(&t, &final\_tm);
149   \textcolor{keywordtype}{char} buf[256];
150   \textcolor{keywordflow}{if} (strftime(buf, \textcolor{keyword}{sizeof}(buf), \textcolor{stringliteral}{"%Y-%m-%dT%H:%M:%S %z"}, &final\_tm) > 0) \{
151     \textcolor{keywordflow}{return} std::string(buf);
152   \}
153   \textcolor{keywordflow}{return} \textcolor{stringliteral}{""};
154 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!get\+Error\+Code\+String@{get\+Error\+Code\+String}}
\index{get\+Error\+Code\+String@{get\+Error\+Code\+String}!proxygen@{proxygen}}
\subsubsection[{get\+Error\+Code\+String(\+Error\+Code error)}]{\setlength{\rightskip}{0pt plus 5cm}const char $\ast$ proxygen\+::get\+Error\+Code\+String (
\begin{DoxyParamCaption}
\item[{{\bf Error\+Code}}]{error}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a000e83246d338052187588fb60069f31}
Returns a string representation of the error code. 

Definition at line 18 of file Error\+Code.\+cpp.



References \+\_\+\+S\+P\+D\+Y\+\_\+\+I\+N\+V\+A\+L\+I\+D\+\_\+\+S\+T\+R\+E\+AM, C\+A\+N\+C\+EL, C\+O\+M\+P\+R\+E\+S\+S\+I\+O\+N\+\_\+\+E\+R\+R\+OR, C\+O\+N\+N\+E\+C\+T\+\_\+\+E\+R\+R\+OR, E\+N\+H\+A\+N\+C\+E\+\_\+\+Y\+O\+U\+R\+\_\+\+C\+A\+LM, F\+L\+O\+W\+\_\+\+C\+O\+N\+T\+R\+O\+L\+\_\+\+E\+R\+R\+OR, F\+R\+A\+M\+E\+\_\+\+S\+I\+Z\+E\+\_\+\+E\+R\+R\+OR, H\+T\+T\+P\+\_\+1\+\_\+1\+\_\+\+R\+E\+Q\+U\+I\+R\+ED, I\+N\+A\+D\+E\+Q\+U\+A\+T\+E\+\_\+\+S\+E\+C\+U\+R\+I\+TY, I\+N\+T\+E\+R\+N\+A\+L\+\_\+\+E\+R\+R\+OR, N\+O\+\_\+\+E\+R\+R\+OR, P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, R\+E\+F\+U\+S\+E\+D\+\_\+\+S\+T\+R\+E\+AM, S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+T\+I\+M\+E\+O\+UT, and S\+T\+R\+E\+A\+M\+\_\+\+C\+L\+O\+S\+ED.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::check\+Connection\+Error(), proxygen\+::\+S\+P\+D\+Y\+Codec\+::generate\+Goaway(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Goaway(), proxygen\+::\+S\+P\+D\+Y\+Codec\+::generate\+Rst\+Stream(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Rst\+Stream(), proxygen\+::\+H\+T\+T\+P\+Codec\+Printer\+::on\+Abort(), proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Abort(), proxygen\+::\+H\+T\+T\+P\+Codec\+Printer\+::on\+Goaway(), proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Goaway(), operator$<$$<$(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Goaway(), and proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Rst\+Stream().


\begin{DoxyCode}
18                                                 \{
19   \textcolor{keywordflow}{switch} (error) \{
20     \textcolor{keywordflow}{case} ErrorCode::NO\_ERROR: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"NO\_ERROR"};
21     \textcolor{keywordflow}{case} ErrorCode::PROTOCOL\_ERROR: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"PROTOCOL\_ERROR"};
22     \textcolor{keywordflow}{case} ErrorCode::INTERNAL\_ERROR: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"INTERNAL\_ERROR"};
23     \textcolor{keywordflow}{case} ErrorCode::FLOW\_CONTROL\_ERROR: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"FLOW\_CONTROL\_ERROR"};
24     \textcolor{keywordflow}{case} ErrorCode::SETTINGS\_TIMEOUT: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"SETTINGS\_TIMEOUT"};
25     \textcolor{keywordflow}{case} ErrorCode::STREAM\_CLOSED: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"STREAM\_CLOSED"};
26     \textcolor{keywordflow}{case} ErrorCode::FRAME\_SIZE\_ERROR: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"FRAME\_SIZE\_ERROR"};
27     \textcolor{keywordflow}{case} ErrorCode::REFUSED\_STREAM: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"REFUSED\_STREAM"};
28     \textcolor{keywordflow}{case} ErrorCode::CANCEL: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"CANCEL"};
29     \textcolor{keywordflow}{case} ErrorCode::COMPRESSION\_ERROR: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"COMPRESSION\_ERROR"};
30     \textcolor{keywordflow}{case} ErrorCode::CONNECT\_ERROR: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"CONNECT\_ERROR"};
31     \textcolor{keywordflow}{case} ErrorCode::ENHANCE\_YOUR\_CALM: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"ENHANCE\_YOUR\_CALM"};
32     \textcolor{keywordflow}{case} ErrorCode::INADEQUATE\_SECURITY: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"INADEQUATE\_SECURITY"};
33     \textcolor{keywordflow}{case} ErrorCode::HTTP\_1\_1\_REQUIRED: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"HTTP\_1\_1\_REQUIRED"};
34     \textcolor{keywordflow}{case} ErrorCode::\_SPDY\_INVALID\_STREAM: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"\_SPDY\_INVALID\_STREAM"};
35   \}
36   LOG(FATAL) << \textcolor{stringliteral}{"Unreachable"};
37   \textcolor{keywordflow}{return} \textcolor{stringliteral}{""};
38 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!get\+Error\+String@{get\+Error\+String}}
\index{get\+Error\+String@{get\+Error\+String}!proxygen@{proxygen}}
\subsubsection[{get\+Error\+String(\+Proxygen\+Error error)}]{\setlength{\rightskip}{0pt plus 5cm}const char $\ast$ proxygen\+::get\+Error\+String (
\begin{DoxyParamCaption}
\item[{{\bf Proxygen\+Error}}]{error}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a8d8e670251d6f1b9c63431fd2d9d912e}


Definition at line 25 of file Proxygen\+Error\+Enum.\+cpp.



References k\+Error\+Max.



Referenced by proxygen\+::\+H\+T\+T\+P\+Session\+::error\+On\+Transaction\+Ids(), Proxy\+Service\+::\+Proxy\+Handler\+::on\+Error(), proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Goaway(), operator$<$$<$(), and proxygen\+::\+H\+T\+T\+P\+Session\+::shutdown\+Transport().


\begin{DoxyCode}
25                                                 \{
26   \textcolor{keywordflow}{if} (error < kErrorNone || error >= kErrorMax) \{
27     \textcolor{keywordflow}{return} errorStrings[kErrorMax];
28   \} \textcolor{keywordflow}{else} \{
29     \textcolor{keywordflow}{return} errorStrings[error];
30   \}
31 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!get\+Error\+String\+By\+Index@{get\+Error\+String\+By\+Index}}
\index{get\+Error\+String\+By\+Index@{get\+Error\+String\+By\+Index}!proxygen@{proxygen}}
\subsubsection[{get\+Error\+String\+By\+Index(int i)}]{\setlength{\rightskip}{0pt plus 5cm}const char $\ast$ proxygen\+::get\+Error\+String\+By\+Index (
\begin{DoxyParamCaption}
\item[{int}]{i}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a4cf6dfed5b3e383456459acf187ee976}


Definition at line 33 of file Proxygen\+Error\+Enum.\+cpp.


\begin{DoxyCode}
33                                          \{
34   \textcolor{keywordflow}{return} errorStrings[i];
35 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!get\+Get\+Request@{get\+Get\+Request}}
\index{get\+Get\+Request@{get\+Get\+Request}!proxygen@{proxygen}}
\subsubsection[{get\+Get\+Request(const std\+::string \&url)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Message} proxygen\+::get\+Get\+Request (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{url}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ac94313b3a860ee1efa0939b0c8664798}


Definition at line 76 of file Test\+Utils.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), proxygen\+::\+H\+T\+T\+P\+Headers\+::set(), proxygen\+::\+H\+T\+T\+P\+Message\+::set\+H\+T\+T\+P\+Version(), proxygen\+::\+H\+T\+T\+P\+Message\+::set\+Method(), and proxygen\+::\+H\+T\+T\+P\+Message\+::set\+U\+R\+L().



Referenced by get\+Upgrade\+Request(), make\+Get\+Request(), M\+A\+T\+C\+H\+E\+R\+\_\+\+P(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::send\+Request(), H\+T\+T\+P\+Downstream\+Test$<$ S\+P\+D\+Y3\+\_\+1\+Codec\+Pair $>$\+::send\+Request(), T\+E\+S\+T(), T\+E\+S\+T\+\_\+\+F(), H\+T\+T\+P\+Upstream\+Test$<$ C $>$\+::test\+Basic\+Request\+Http10(), H\+T\+T\+P2\+Codec\+Test\+::test\+Header\+List\+Size(), and T\+Y\+P\+E\+D\+\_\+\+T\+E\+S\+T\+\_\+\+P().


\begin{DoxyCode}
76                                                 \{
77   HTTPMessage req;
78   req.setMethod(\textcolor{stringliteral}{"GET"});
79   req.setURL(url);
80   req.setHTTPVersion(1, 1);
81   req.getHeaders().set(HTTP\_HEADER\_HOST, \textcolor{stringliteral}{"www.foo.com"});
82   \textcolor{keywordflow}{return} req;
83 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!get\+Post\+Request@{get\+Post\+Request}}
\index{get\+Post\+Request@{get\+Post\+Request}!proxygen@{proxygen}}
\subsubsection[{get\+Post\+Request(uint32\+\_\+t content\+Length)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Message} proxygen\+::get\+Post\+Request (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{content\+Length}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_af16eb8d30001d0218f2db703f3f541d7}


Definition at line 102 of file Test\+Utils.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), proxygen\+::\+H\+T\+T\+P\+Headers\+::set(), proxygen\+::\+H\+T\+T\+P\+Message\+::set\+H\+T\+T\+P\+Version(), proxygen\+::\+H\+T\+T\+P\+Message\+::set\+Method(), and proxygen\+::\+H\+T\+T\+P\+Message\+::set\+U\+R\+L().



Referenced by Test\+Priority\+Map\+Builder\+::create\+Virtual\+Streams(), Test\+Abort\+Post$<$ stage $>$\+::do\+Abort\+Test(), make\+Post\+Request(), M\+A\+T\+C\+H\+E\+R\+\_\+\+P(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
102                                                    \{
103   HTTPMessage req;
104   req.setMethod(\textcolor{stringliteral}{"POST"});
105   req.setURL<\textcolor{keywordtype}{string}>(\textcolor{stringliteral}{"/"});
106   req.setHTTPVersion(1, 1);
107   req.getHeaders().set(HTTP\_HEADER\_HOST, \textcolor{stringliteral}{"www.foo.com"});
108   req.getHeaders().set(HTTP\_HEADER\_CONTENT\_LENGTH,
109                        folly::to<string>(contentLength));
110   \textcolor{keywordflow}{return} req;
111 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!get\+Priority\+Message@{get\+Priority\+Message}}
\index{get\+Priority\+Message@{get\+Priority\+Message}!proxygen@{proxygen}}
\subsubsection[{get\+Priority\+Message(uint8\+\_\+t priority)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Message} $>$ proxygen\+::get\+Priority\+Message (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{priority}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a03e00913107207af477ccfb0ff40768b}


Definition at line 29 of file Test\+Utils.\+cpp.



References proxygen\+::spdy\+::k\+Version\+Strv2.



Referenced by M\+A\+T\+C\+H\+E\+R\+\_\+\+P().


\begin{DoxyCode}
29                                                                 \{
30   \textcolor{keyword}{auto} ret = std::make\_unique<HTTPMessage>();
31   ret->setAdvancedProtocolString(spdy::kVersionStrv2);
32   ret->setPriority(priority);
33   \textcolor{keywordflow}{return} ret;
34 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!get\+Pub\+Request@{get\+Pub\+Request}}
\index{get\+Pub\+Request@{get\+Pub\+Request}!proxygen@{proxygen}}
\subsubsection[{get\+Pub\+Request(const std\+::string \&url)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Message} proxygen\+::get\+Pub\+Request (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{url}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_afa682d73f50539d066da3e934bea241b}


Definition at line 128 of file Test\+Utils.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), proxygen\+::\+H\+T\+T\+P\+Headers\+::set(), proxygen\+::\+H\+T\+T\+P\+Message\+::set\+H\+T\+T\+P\+Version(), proxygen\+::\+H\+T\+T\+P\+Message\+::set\+Method(), and proxygen\+::\+H\+T\+T\+P\+Message\+::set\+U\+R\+L().



Referenced by M\+A\+T\+C\+H\+E\+R\+\_\+\+P().


\begin{DoxyCode}
128                                                 \{
129   HTTPMessage req;
130   req.setMethod(\textcolor{stringliteral}{"PUB"});
131   req.setURL(url);
132   req.setHTTPVersion(1, 1);
133   req.getHeaders().set(HTTP\_HEADER\_HOST, \textcolor{stringliteral}{"www.foo.com"});
134   \textcolor{keywordflow}{return} req;
135 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!get\+Response@{get\+Response}}
\index{get\+Response@{get\+Response}!proxygen@{proxygen}}
\subsubsection[{get\+Response(uint32\+\_\+t code, uint32\+\_\+t body\+Len)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Message} proxygen\+::get\+Response (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{code, }
\item[{uint32\+\_\+t}]{body\+Len}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_acaa7a2d87f18eeca3074f96a5a61d8ec}


Definition at line 137 of file Test\+Utils.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), proxygen\+::\+H\+T\+T\+P\+Headers\+::set(), and proxygen\+::\+H\+T\+T\+P\+Message\+::set\+Status\+Code().



Referenced by Test\+Priority\+Map\+Builder\+::create\+Virtual\+Streams(), M\+A\+T\+C\+H\+E\+R\+\_\+\+P(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
137                                                          \{
138   HTTPMessage resp;
139   resp.setStatusCode(code);
140   \textcolor{keywordflow}{if} (bodyLen > 0) \{
141     resp.getHeaders().set(HTTP\_HEADER\_CONTENT\_LENGTH,
142                           folly::to<string>(bodyLen));
143   \}
144   \textcolor{keywordflow}{return} resp;
145 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!get\+Timeout\+Clock@{get\+Timeout\+Clock}}
\index{get\+Timeout\+Clock@{get\+Timeout\+Clock}!proxygen@{proxygen}}
\subsubsection[{get\+Timeout\+Clock()}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Async\+Timeout\+Set\+::\+Timeout\+Clock}\& proxygen\+::get\+Timeout\+Clock (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a8ba6ab7c466c6a84b86cb0710055a87f}


Definition at line 26 of file Async\+Timeout\+Set.\+cpp.



Referenced by proxygen\+::\+Async\+Timeout\+Set\+::\+Callback\+::cancel\+Timeout\+Impl().


\begin{DoxyCode}
26                                                \{
27   \textcolor{keyword}{static} SimpleTimeoutClock timeoutClock;
28 
29   \textcolor{keywordflow}{return} timeoutClock;
30 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!get\+Transport\+Direction\+String@{get\+Transport\+Direction\+String}}
\index{get\+Transport\+Direction\+String@{get\+Transport\+Direction\+String}!proxygen@{proxygen}}
\subsubsection[{get\+Transport\+Direction\+String(\+Transport\+Direction dir)}]{\setlength{\rightskip}{0pt plus 5cm}const char $\ast$ proxygen\+::get\+Transport\+Direction\+String (
\begin{DoxyParamCaption}
\item[{{\bf Transport\+Direction}}]{dir}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a517490c4bcdb49b242ad9c1aa87e8254}


Definition at line 16 of file Transport\+Direction.\+cpp.



References D\+O\+W\+N\+S\+T\+R\+E\+AM, and U\+P\+S\+T\+R\+E\+AM.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Settings(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Settings\+Ack(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::handle\+Settings(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::\+H\+T\+T\+P2\+Codec(), and operator$<$$<$().


\begin{DoxyCode}
16                                                                 \{
17   \textcolor{keywordflow}{switch} (dir) \{
18     \textcolor{keywordflow}{case} TransportDirection::UPSTREAM: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"upstream"};
19     \textcolor{keywordflow}{case} TransportDirection::DOWNSTREAM: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"downstream"};
20   \}
21   \textcolor{comment}{// unreachable}
22   \textcolor{keywordflow}{return} \textcolor{stringliteral}{""};
23 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!get\+Upgrade\+Request@{get\+Upgrade\+Request}}
\index{get\+Upgrade\+Request@{get\+Upgrade\+Request}!proxygen@{proxygen}}
\subsubsection[{get\+Upgrade\+Request(const std\+::string \&upgrade\+Header, H\+T\+T\+P\+Method method, uint32\+\_\+t body\+Len)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Message} proxygen\+::get\+Upgrade\+Request (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{upgrade\+Header, }
\item[{{\bf H\+T\+T\+P\+Method}}]{method, }
\item[{uint32\+\_\+t}]{body\+Len}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a8a99c30fe4d83fe3ff501b801f8ab3ad}


Definition at line 161 of file Test\+Utils.\+cpp.



References get\+Get\+Request(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), proxygen\+::\+H\+T\+T\+P\+Headers\+::set(), and proxygen\+::\+H\+T\+T\+P\+Message\+::set\+Method().



Referenced by M\+A\+T\+C\+H\+E\+R\+\_\+\+P(), T\+E\+S\+T\+\_\+\+F(), H\+T\+T\+P\+Downstream\+Test$<$ C $>$\+::test\+Simple\+Upgrade(), and H\+T\+T\+P\+Upstream\+Test$<$ C $>$\+::test\+Simple\+Upgrade().


\begin{DoxyCode}
162                                                                    \{
163   HTTPMessage req = getGetRequest();
164   req.setMethod(method);
165   req.getHeaders().set(HTTP\_HEADER\_UPGRADE, upgradeHeader);
166   \textcolor{keywordflow}{if} (bodyLen > 0) \{
167     req.getHeaders().set(HTTP\_HEADER\_CONTENT\_LENGTH,
168                          folly::to<std::string>(bodyLen));
169   \}
170   \textcolor{keywordflow}{return} req;
171 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!Has\+H\+T\+T\+P\+Header@{Has\+H\+T\+T\+P\+Header}}
\index{Has\+H\+T\+T\+P\+Header@{Has\+H\+T\+T\+P\+Header}!proxygen@{proxygen}}
\subsubsection[{Has\+H\+T\+T\+P\+Header(std\+::string name)}]{\setlength{\rightskip}{0pt plus 5cm}inline \+::testing\+::\+Matcher$<${\bf H\+T\+T\+P\+Headers}\&$>$ proxygen\+::\+Has\+H\+T\+T\+P\+Header (
\begin{DoxyParamCaption}
\item[{std\+::string}]{name}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_aa8646d27e3921d15cec593a2ce3d83c8}


Definition at line 80 of file Mock\+H\+T\+T\+P\+Headers.\+h.



References proxygen\+::\+Has\+H\+T\+T\+P\+Header\+Matcher\+Impl\+::\+Has\+H\+T\+T\+P\+Header\+Matcher\+Impl().


\begin{DoxyCode}
80                               \{
81   return ::testing::MakeMatcher(\textcolor{keyword}{new} HasHTTPHeaderMatcherImpl(name));
82 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!Has\+H\+T\+T\+P\+Header@{Has\+H\+T\+T\+P\+Header}}
\index{Has\+H\+T\+T\+P\+Header@{Has\+H\+T\+T\+P\+Header}!proxygen@{proxygen}}
\subsubsection[{Has\+H\+T\+T\+P\+Header(std\+::string name, std\+::string value)}]{\setlength{\rightskip}{0pt plus 5cm}inline \+::testing\+::\+Matcher$<${\bf H\+T\+T\+P\+Headers}\&$>$ proxygen\+::\+Has\+H\+T\+T\+P\+Header (
\begin{DoxyParamCaption}
\item[{std\+::string}]{name, }
\item[{std\+::string}]{value}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a0e89d4bbeaf0c08d25b41b0c97a9459e}


Definition at line 88 of file Mock\+H\+T\+T\+P\+Headers.\+h.



References proxygen\+::\+Has\+H\+T\+T\+P\+Header\+Matcher\+Impl\+::\+Has\+H\+T\+T\+P\+Header\+Matcher\+Impl().


\begin{DoxyCode}
88                                                \{
89   return ::testing::MakeMatcher(\textcolor{keyword}{new} HasHTTPHeaderMatcherImpl(name, value));
90 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!hex\+Str@{hex\+Str}}
\index{hex\+Str@{hex\+Str}!proxygen@{proxygen}}
\subsubsection[{hex\+Str(\+String\+Piece sp)}]{\setlength{\rightskip}{0pt plus 5cm}string proxygen\+::hex\+Str (
\begin{DoxyParamCaption}
\item[{String\+Piece}]{sp}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a8ae9e901fcd77ca52a40fd46fec7889d}


Definition at line 48 of file Logging.\+cpp.



Referenced by T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
48                               \{
49   \textcolor{keywordtype}{string} out;
50   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ch : sp) \{
51     out.append(folly::sformat(\textcolor{stringliteral}{"\{:02x\}"}, (uint8\_t) ch));
52   \}
53   \textcolor{keywordflow}{return} out;
54 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!hex\+Str@{hex\+Str}}
\index{hex\+Str@{hex\+Str}!proxygen@{proxygen}}
\subsubsection[{hex\+Str(folly\+::\+String\+Piece sp)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string proxygen\+::hex\+Str (
\begin{DoxyParamCaption}
\item[{folly\+::\+String\+Piece}]{sp}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a7369dacb471c5e7adf8e63ea8bfb8c4b}
helper functions for printing in hex a byte array see unit test for example \index{proxygen@{proxygen}!I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P@{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P}}
\index{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P@{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P}!proxygen@{proxygen}}
\subsubsection[{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+P(\+Value\+Test, R\+F\+C1867\+C\+R,\+::testing\+::\+Values(string(""zyx\textbackslash{}r\textbackslash{}nwvu"", 8), string(""\textbackslash{}rzyxwvut"", 8), string(""zyxwvut\textbackslash{}r"", 8), string(""\textbackslash{}nzyxwvut"", 8), string(""zyxwvut\textbackslash{}n"", 8), string(""\textbackslash{}r\textbackslash{}n\textbackslash{}r\textbackslash{}n\textbackslash{}r\textbackslash{}n\textbackslash{}r\textbackslash{}n"", 8), string(""\textbackslash{}r\textbackslash{}r\textbackslash{}r\textbackslash{}r\textbackslash{}r\textbackslash{}r\textbackslash{}r\textbackslash{}r"", 8)))}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P (
\begin{DoxyParamCaption}
\item[{Value\+Test}]{, }
\item[{{\bf R\+F\+C1867\+CR}}]{, }
\item[{\+::testing\+::\+Values(string(\char`\"{}zyx\textbackslash{}r\textbackslash{}nwvu\char`\"{}, 8), string(\char`\"{}\textbackslash{}rzyxwvut\char`\"{}, 8), string(\char`\"{}zyxwvut\textbackslash{}r\char`\"{}, 8), string(\char`\"{}\textbackslash{}nzyxwvut\char`\"{}, 8), string(\char`\"{}zyxwvut\textbackslash{}n\char`\"{}, 8), string(\char`\"{}\textbackslash{}r\textbackslash{}n\textbackslash{}r\textbackslash{}n\textbackslash{}r\textbackslash{}n\textbackslash{}r\textbackslash{}n\char`\"{}, 8), string(\char`\"{}\textbackslash{}r\textbackslash{}r\textbackslash{}r\textbackslash{}r\textbackslash{}r\textbackslash{}r\textbackslash{}r\textbackslash{}r\char`\"{}, 8))}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ad26d54cea6eea744bde4f85b0b9a98bb}


Referenced by T\+E\+S\+T\+\_\+\+P(), and T\+E\+S\+T\+\_\+\+P().

\index{proxygen@{proxygen}!I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P@{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P}}
\index{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P@{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P}!proxygen@{proxygen}}
\subsubsection[{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+P(\+Test\+Legal\+Strings, Legal\+String\+Tests,\+::testing\+::\+Values\+In(k\+Legal\+String\+Tests))}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P (
\begin{DoxyParamCaption}
\item[{Test\+Legal\+Strings}]{, }
\item[{{\bf Legal\+String\+Tests}}]{, }
\item[{\+::testing\+::\+Values\+In({\bf k\+Legal\+String\+Tests})}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a32e7e9677e3f39449137b6f72d3daf6f}
\index{proxygen@{proxygen}!I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P@{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P}}
\index{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P@{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P}!proxygen@{proxygen}}
\subsubsection[{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+P(\+Test\+Legal\+Binary\+Content, Legal\+Binary\+Content\+Tests,\+::testing\+::\+Values\+In(k\+Legal\+Bin\+Content\+Tests))}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P (
\begin{DoxyParamCaption}
\item[{Test\+Legal\+Binary\+Content}]{, }
\item[{{\bf Legal\+Binary\+Content\+Tests}}]{, }
\item[{\+::testing\+::\+Values\+In({\bf k\+Legal\+Bin\+Content\+Tests})}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a5ebadbcf13f602bfa6567cc6da269a22}
\index{proxygen@{proxygen}!I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P@{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P}}
\index{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P@{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P}!proxygen@{proxygen}}
\subsubsection[{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+P(\+Test\+Legal\+Ints, Legal\+Integer\+Tests,\+::testing\+::\+Values\+In(k\+Legal\+Int\+Tests))}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P (
\begin{DoxyParamCaption}
\item[{Test\+Legal\+Ints}]{, }
\item[{{\bf Legal\+Integer\+Tests}}]{, }
\item[{\+::testing\+::\+Values\+In({\bf k\+Legal\+Int\+Tests})}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a3fd218f9d0ead896805a5d6de89c5320}
\index{proxygen@{proxygen}!I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P@{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P}}
\index{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P@{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P}!proxygen@{proxygen}}
\subsubsection[{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+P(\+Test\+Legal\+Floats, Legal\+Float\+Tests,\+::testing\+::\+Values\+In(k\+Legal\+Float\+Tests))}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P (
\begin{DoxyParamCaption}
\item[{Test\+Legal\+Floats}]{, }
\item[{{\bf Legal\+Float\+Tests}}]{, }
\item[{\+::testing\+::\+Values\+In({\bf k\+Legal\+Float\+Tests})}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a6623a9bbeb1d76e1f5bf329a9fb3b8e8}
\index{proxygen@{proxygen}!I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P@{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P}}
\index{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P@{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P}!proxygen@{proxygen}}
\subsubsection[{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+P(\+Test\+Illegal\+Items, Illegal\+Item\+Test,\+::testing\+::\+Values\+In(k\+Illegal\+Item\+Tests))}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P (
\begin{DoxyParamCaption}
\item[{Test\+Illegal\+Items}]{, }
\item[{{\bf Illegal\+Item\+Test}}]{, }
\item[{\+::testing\+::\+Values\+In({\bf k\+Illegal\+Item\+Tests})}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a36170248bc78896da44328233869766c}
\index{proxygen@{proxygen}!I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P@{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P}}
\index{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P@{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P}!proxygen@{proxygen}}
\subsubsection[{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+P(\+Test\+Illegal\+Lists, Illegal\+List\+Test,\+::testing\+::\+Values\+In(k\+Illegal\+List\+Tests))}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P (
\begin{DoxyParamCaption}
\item[{Test\+Illegal\+Lists}]{, }
\item[{{\bf Illegal\+List\+Test}}]{, }
\item[{\+::testing\+::\+Values\+In({\bf k\+Illegal\+List\+Tests})}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a12c9a4d4c489e3587819bd945fee909a}
\index{proxygen@{proxygen}!is\+H\+Q\+Codec\+Protocol@{is\+H\+Q\+Codec\+Protocol}}
\index{is\+H\+Q\+Codec\+Protocol@{is\+H\+Q\+Codec\+Protocol}!proxygen@{proxygen}}
\subsubsection[{is\+H\+Q\+Codec\+Protocol(\+Codec\+Protocol protocol)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::is\+H\+Q\+Codec\+Protocol (
\begin{DoxyParamCaption}
\item[{{\bf Codec\+Protocol}}]{protocol}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ac5d7ab5f3365d8b81c2608368997ad1c}
Check if the given protocol is HQ 

Definition at line 82 of file Codec\+Protocol.\+cpp.



References HQ.


\begin{DoxyCode}
82                                                       \{
83   \textcolor{keywordflow}{return} protocol == CodecProtocol::HQ;
84 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!is\+H\+T\+T\+P2\+Codec\+Protocol@{is\+H\+T\+T\+P2\+Codec\+Protocol}}
\index{is\+H\+T\+T\+P2\+Codec\+Protocol@{is\+H\+T\+T\+P2\+Codec\+Protocol}!proxygen@{proxygen}}
\subsubsection[{is\+H\+T\+T\+P2\+Codec\+Protocol(\+Codec\+Protocol protocol)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::is\+H\+T\+T\+P2\+Codec\+Protocol (
\begin{DoxyParamCaption}
\item[{{\bf Codec\+Protocol}}]{protocol}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a805a889c6d02d3310e7f45ab5174f0b5}
Check if the given protocol is H\+T\+T\+P2. 

Definition at line 78 of file Codec\+Protocol.\+cpp.



References H\+T\+T\+P\+\_\+2.



Referenced by proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::init\+Codec\+Header\+Indexing\+Strategy(), is\+Parallel\+Codec\+Protocol(), proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Session\+Parse\+Error(), proxygen\+::\+H\+T\+T\+P\+Session\+::send\+E\+O\+M(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().


\begin{DoxyCode}
78                                                          \{
79   \textcolor{keywordflow}{return} protocol == CodecProtocol::HTTP\_2;
80 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!is\+L\+WS@{is\+L\+WS}}
\index{is\+L\+WS@{is\+L\+WS}!proxygen@{proxygen}}
\subsubsection[{is\+L\+W\+S(char c)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::is\+L\+WS (
\begin{DoxyParamCaption}
\item[{char}]{c}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_a6e852c21ea2c718f2aaa9434e854508d}
Return true if the character is linear whitespace, as defined by the L\+WS definition in R\+FC 2616, and false otherwise 

Definition at line 31 of file H\+T\+T\+P\+Headers.\+h.



Referenced by proxygen\+::\+H\+T\+T\+P\+Message\+::do\+Header\+Token\+Check(), and proxygen\+::\+H\+T\+T\+P\+Headers\+::strip\+Per\+Hop\+Headers().


\begin{DoxyCode}
31                           \{
32   \textcolor{comment}{// Technically \(\backslash\)r and \(\backslash\)n are only allowed in LWS if they appear together.}
33   \textcolor{keywordflow}{if} (c == \textcolor{charliteral}{' '} || c == \textcolor{charliteral}{'\(\backslash\)t'} || c == \textcolor{charliteral}{'\(\backslash\)r'} || c == \textcolor{charliteral}{'\(\backslash\)n'}) \{
34     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
35   \}
36   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
37 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!is\+Parallel\+Codec\+Protocol@{is\+Parallel\+Codec\+Protocol}}
\index{is\+Parallel\+Codec\+Protocol@{is\+Parallel\+Codec\+Protocol}!proxygen@{proxygen}}
\subsubsection[{is\+Parallel\+Codec\+Protocol(\+Codec\+Protocol protocol)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::is\+Parallel\+Codec\+Protocol (
\begin{DoxyParamCaption}
\item[{{\bf Codec\+Protocol}}]{protocol}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a310dc42e3f7c61f50f8ab80a79ba19e8}
Check if the given protocol supports paraellel requests 

Definition at line 86 of file Codec\+Protocol.\+cpp.



References is\+H\+T\+T\+P2\+Codec\+Protocol(), and is\+Spdy\+Codec\+Protocol().



Referenced by H\+T\+T\+P\+Downstream\+Test$<$ S\+P\+D\+Y3\+\_\+1\+Codec\+Pair $>$\+::expect\+Responses().


\begin{DoxyCode}
86                                                             \{
87   \textcolor{keywordflow}{return} isSpdyCodecProtocol(protocol) || isHTTP2CodecProtocol(protocol);
88 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!is\+Spdy\+Codec\+Protocol@{is\+Spdy\+Codec\+Protocol}}
\index{is\+Spdy\+Codec\+Protocol@{is\+Spdy\+Codec\+Protocol}!proxygen@{proxygen}}
\subsubsection[{is\+Spdy\+Codec\+Protocol(\+Codec\+Protocol protocol)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf F\+B\+\_\+\+E\+X\+P\+O\+RT} bool proxygen\+::is\+Spdy\+Codec\+Protocol (
\begin{DoxyParamCaption}
\item[{{\bf Codec\+Protocol}}]{protocol}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_adcd52a34fee2fd8cd930e4d1865e7dd7}
Check if the given protocol is S\+P\+DY. 

Definition at line 73 of file Codec\+Protocol.\+cpp.



References S\+P\+D\+Y\+\_\+3, and S\+P\+D\+Y\+\_\+3\+\_\+1.



Referenced by proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Next\+To\+Send(), and is\+Parallel\+Codec\+Protocol().


\begin{DoxyCode}
73                                                         \{
74   \textcolor{keywordflow}{return} protocol == CodecProtocol::SPDY\_3 ||
75          protocol == CodecProtocol::SPDY\_3\_1;
76 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!is\+Valid\+Codec\+Protocol\+Str@{is\+Valid\+Codec\+Protocol\+Str}}
\index{is\+Valid\+Codec\+Protocol\+Str@{is\+Valid\+Codec\+Protocol\+Str}!proxygen@{proxygen}}
\subsubsection[{is\+Valid\+Codec\+Protocol\+Str(const std\+::string \&protocol\+Str)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::is\+Valid\+Codec\+Protocol\+Str (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{protocol\+Str}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a6f81002be154f2eaa38ad06f3c395dd3}
Check if given debugging name refers to a valid protocol. 

Definition at line 59 of file Codec\+Protocol.\+cpp.



References proxygen\+::http2\+::k\+Protocol\+Cleartext\+String, and proxygen\+::http2\+::k\+Protocol\+String.


\begin{DoxyCode}
59                                                                   \{
60   \textcolor{keywordflow}{return} protocolStr == http\_1\_1 ||
61          protocolStr == spdy\_3 ||
62          protocolStr == spdy\_3\_1 ||
63          protocolStr == http2::kProtocolString ||
64          protocolStr == http2::kProtocolCleartextString ||
65          protocolStr == http\_2 ||
66          protocolStr == hq;
67 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!make\+Buf@{make\+Buf}}
\index{make\+Buf@{make\+Buf}!proxygen@{proxygen}}
\subsubsection[{make\+Buf(uint32\+\_\+t size)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ proxygen\+::make\+Buf (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{size}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a21fad80d69e955d236f54a54683399f5}


Definition at line 36 of file Test\+Utils.\+cpp.



Referenced by M\+A\+T\+C\+H\+E\+R\+\_\+\+P(), Flow\+Control\+Filter\+Test$<$ init\+Size $>$\+::\+Set\+Up(), Downstream\+Transaction\+Test\+::setup\+Request\+Response\+Flow(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
36                                                  \{
37   \textcolor{keyword}{auto} out = folly::IOBuf::create(size);
38   out->append(size);
39   \textcolor{comment}{// fill with random junk}
40   RWPrivateCursor cursor(out.get());
41   \textcolor{keywordflow}{while} (cursor.length() >= 8) \{
42     cursor.write<uint64\_t>(folly::Random::rand64());
43   \}
44   \textcolor{keywordflow}{while} (cursor.length()) \{
45     cursor.write<uint8\_t>((uint8\_t)folly::Random::rand32());
46   \}
47   \textcolor{keywordflow}{return} out;
48 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!make\+Downstream\+Parallel\+Codec@{make\+Downstream\+Parallel\+Codec}}
\index{make\+Downstream\+Parallel\+Codec@{make\+Downstream\+Parallel\+Codec}!proxygen@{proxygen}}
\subsubsection[{make\+Downstream\+Parallel\+Codec()}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<$ testing\+::\+Nice\+Mock$<$ {\bf Mock\+H\+T\+T\+P\+Codec} $>$ $>$ proxygen\+::make\+Downstream\+Parallel\+Codec (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a947f46853e78246f6a4eed6a59b830e7}


Definition at line 67 of file Test\+Utils.\+cpp.



References make\+Mock\+Parallel\+Codec().



Referenced by M\+A\+T\+C\+H\+E\+R\+\_\+\+P(), and T\+E\+S\+T().


\begin{DoxyCode}
67                               \{
68   \textcolor{keywordflow}{return} makeMockParallelCodec(TransportDirection::DOWNSTREAM);
69 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!make\+Get\+Request@{make\+Get\+Request}}
\index{make\+Get\+Request@{make\+Get\+Request}!proxygen@{proxygen}}
\subsubsection[{make\+Get\+Request()}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Message} $>$ proxygen\+::make\+Get\+Request (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_afc43b556ee7df9b95cc51698005cb3e9}


Definition at line 98 of file Test\+Utils.\+cpp.



References get\+Get\+Request().



Referenced by M\+A\+T\+C\+H\+E\+R\+\_\+\+P(), T\+E\+S\+T\+\_\+\+F(), Mock\+Codec\+Downstream\+Test\+::test\+Conn\+Flow\+Control\+Blocked(), and Mock\+Codec\+Downstream\+Test\+::test\+Goaway().


\begin{DoxyCode}
98                                             \{
99   \textcolor{keywordflow}{return} std::make\_unique<HTTPMessage>(getGetRequest());
100 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!make\+Internal\+Timeout\+Set@{make\+Internal\+Timeout\+Set}}
\index{make\+Internal\+Timeout\+Set@{make\+Internal\+Timeout\+Set}!proxygen@{proxygen}}
\subsubsection[{make\+Internal\+Timeout\+Set(\+Event\+Base $\ast$evb)}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+H\+H\+Wheel\+Timer\+::\+Unique\+Ptr proxygen\+::make\+Internal\+Timeout\+Set (
\begin{DoxyParamCaption}
\item[{Event\+Base $\ast$}]{evb}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a498805e0cc2d1e180da1c85e5e87c38c}


Definition at line 22 of file Test\+Utils.\+cpp.



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
22                                                                   \{
23   folly::HHWheelTimer::UniquePtr t(folly::HHWheelTimer::newTimer(
24       evb,
25       std::chrono::milliseconds(folly::HHWheelTimer::DEFAULT\_TICK\_INTERVAL),
26       TimeoutManager::InternalEnum::INTERNAL,
27       std::chrono::milliseconds(500)));
28   \textcolor{keywordflow}{return} t;
29 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!make\+Internal\+Timeout\+Set@{make\+Internal\+Timeout\+Set}}
\index{make\+Internal\+Timeout\+Set@{make\+Internal\+Timeout\+Set}!proxygen@{proxygen}}
\subsubsection[{make\+Internal\+Timeout\+Set(folly\+::\+Event\+Base $\ast$evb)}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+H\+H\+Wheel\+Timer\+::\+Unique\+Ptr proxygen\+::make\+Internal\+Timeout\+Set (
\begin{DoxyParamCaption}
\item[{folly\+::\+Event\+Base $\ast$}]{evb}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a3794f432db398f2fb0d8d7ab21a2a147}
\index{proxygen@{proxygen}!make\+Mock\+Parallel\+Codec@{make\+Mock\+Parallel\+Codec}}
\index{make\+Mock\+Parallel\+Codec@{make\+Mock\+Parallel\+Codec}!proxygen@{proxygen}}
\subsubsection[{make\+Mock\+Parallel\+Codec(\+Transport\+Direction dir)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<$testing\+::\+Nice\+Mock$<${\bf Mock\+H\+T\+T\+P\+Codec}$>$ $>$ proxygen\+::make\+Mock\+Parallel\+Codec (
\begin{DoxyParamCaption}
\item[{{\bf Transport\+Direction}}]{dir}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_aa14eb0037b07859fcec35f08ccf543f6}


Definition at line 51 of file Test\+Utils.\+cpp.



References k\+Default\+Ingress\+Settings.



Referenced by make\+Downstream\+Parallel\+Codec(), and make\+Upstream\+Parallel\+Codec().


\begin{DoxyCode}
51                                               \{
52   \textcolor{keyword}{auto} codec = std::make\_unique<testing::NiceMock<MockHTTPCodec>>();
53   EXPECT\_CALL(*codec, supportsParallelRequests())
54     .WillRepeatedly(testing::Return(\textcolor{keyword}{true}));
55   EXPECT\_CALL(*codec, getProtocol())
56     .WillRepeatedly(testing::Return(CodecProtocol::SPDY\_3\_1));
57   EXPECT\_CALL(*codec, isReusable())
58     .WillRepeatedly(testing::Return(\textcolor{keyword}{true}));
59   EXPECT\_CALL(*codec, getTransportDirection())
60     .WillRepeatedly(testing::Return(dir));
61   EXPECT\_CALL(*codec, getIngressSettings())
62     .WillRepeatedly(testing::Return(&kDefaultIngressSettings));
63   \textcolor{keywordflow}{return} codec;
64 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!make\+Post\+Request@{make\+Post\+Request}}
\index{make\+Post\+Request@{make\+Post\+Request}!proxygen@{proxygen}}
\subsubsection[{make\+Post\+Request(uint32\+\_\+t content\+Length)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Message} $>$ proxygen\+::make\+Post\+Request (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{content\+Length}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ab0a393f7c0889bff7326d2296e3e7265}


Definition at line 124 of file Test\+Utils.\+cpp.



References get\+Post\+Request().



Referenced by M\+A\+T\+C\+H\+E\+R\+\_\+\+P(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
124                                                                    \{
125   \textcolor{keywordflow}{return} std::make\_unique<HTTPMessage>(getPostRequest(contentLength));
126 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!make\+Response@{make\+Response}}
\index{make\+Response@{make\+Response}!proxygen@{proxygen}}
\subsubsection[{make\+Response(uint16\+\_\+t status\+Code)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Message} $>$ proxygen\+::make\+Response (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{status\+Code}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a7165f0188b00e9ada52356662465a7ca}


Definition at line 147 of file Test\+Utils.\+cpp.



Referenced by Test\+Abort\+Post$<$ stage $>$\+::do\+Abort\+Test(), M\+A\+T\+C\+H\+E\+R\+\_\+\+P(), Downstream\+Transaction\+Test\+::setup\+Request\+Response\+Flow(), T\+E\+S\+T\+\_\+\+F(), and Mock\+Codec\+Downstream\+Test\+::test\+Conn\+Flow\+Control\+Blocked().


\begin{DoxyCode}
147                                                              \{
148   \textcolor{keyword}{auto} resp = std::make\_unique<HTTPMessage>();
149   resp->setStatusCode(statusCode);
150   resp->setHTTPVersion(1, 1);
151   \textcolor{keywordflow}{return} resp;
152 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!make\+Response@{make\+Response}}
\index{make\+Response@{make\+Response}!proxygen@{proxygen}}
\subsubsection[{make\+Response(uint16\+\_\+t status\+Code, size\+\_\+t len)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::tuple$<$ std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Message} $>$, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ $>$ proxygen\+::make\+Response (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{status\+Code, }
\item[{size\+\_\+t}]{len}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ad10202c41202b9593a06e801aa01e70d}


Definition at line 155 of file Test\+Utils.\+cpp.



References make\+Buf().


\begin{DoxyCode}
155                                               \{
156   \textcolor{keyword}{auto} resp = makeResponse(statusCode);
157   resp->getHeaders().set(HTTP\_HEADER\_CONTENT\_LENGTH, folly::to<string>(len));
158   \textcolor{keywordflow}{return} std::make\_pair(std::move(resp), makeBuf(len));
159 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!make\+Timeout\+Set@{make\+Timeout\+Set}}
\index{make\+Timeout\+Set@{make\+Timeout\+Set}!proxygen@{proxygen}}
\subsubsection[{make\+Timeout\+Set(\+Event\+Base $\ast$evb)}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+H\+H\+Wheel\+Timer\+::\+Unique\+Ptr proxygen\+::make\+Timeout\+Set (
\begin{DoxyParamCaption}
\item[{Event\+Base $\ast$}]{evb}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ac2b4652e12eeb4d55706d7a0d0ada475}


Definition at line 31 of file Test\+Utils.\+cpp.



Referenced by H\+T\+T\+P\+Downstream\+Test$<$ S\+P\+D\+Y3\+\_\+1\+Codec\+Pair $>$\+::\+H\+T\+T\+P\+Downstream\+Test().


\begin{DoxyCode}
31                                                           \{
32   folly::HHWheelTimer::UniquePtr t(folly::HHWheelTimer::newTimer(
33       evb,
34       std::chrono::milliseconds(folly::HHWheelTimer::DEFAULT\_TICK\_INTERVAL),
35       folly::AsyncTimeout::InternalEnum::NORMAL,
36       std::chrono::milliseconds(500)));
37   \textcolor{keywordflow}{return} t;
38 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!make\+Timeout\+Set@{make\+Timeout\+Set}}
\index{make\+Timeout\+Set@{make\+Timeout\+Set}!proxygen@{proxygen}}
\subsubsection[{make\+Timeout\+Set(folly\+::\+Event\+Base $\ast$evb)}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+H\+H\+Wheel\+Timer\+::\+Unique\+Ptr proxygen\+::make\+Timeout\+Set (
\begin{DoxyParamCaption}
\item[{folly\+::\+Event\+Base $\ast$}]{evb}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_adbda7e99069175fd312e3f885f9ec799}
\index{proxygen@{proxygen}!make\+Upstream\+Parallel\+Codec@{make\+Upstream\+Parallel\+Codec}}
\index{make\+Upstream\+Parallel\+Codec@{make\+Upstream\+Parallel\+Codec}!proxygen@{proxygen}}
\subsubsection[{make\+Upstream\+Parallel\+Codec()}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<$ testing\+::\+Nice\+Mock$<$ {\bf Mock\+H\+T\+T\+P\+Codec} $>$ $>$ proxygen\+::make\+Upstream\+Parallel\+Codec (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a80019037bce30f8ce06cb1e8245aee50}


Definition at line 72 of file Test\+Utils.\+cpp.



References make\+Mock\+Parallel\+Codec().



Referenced by M\+A\+T\+C\+H\+E\+R\+\_\+\+P().


\begin{DoxyCode}
72                             \{
73   \textcolor{keywordflow}{return} makeMockParallelCodec(TransportDirection::UPSTREAM);
74 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!M\+A\+T\+C\+H\+E\+R\+\_\+P@{M\+A\+T\+C\+H\+E\+R\+\_\+P}}
\index{M\+A\+T\+C\+H\+E\+R\+\_\+P@{M\+A\+T\+C\+H\+E\+R\+\_\+P}!proxygen@{proxygen}}
\subsubsection[{M\+A\+T\+C\+H\+E\+R\+\_\+\+P(\+Ptr\+Buf\+Has\+Len, n,"""")}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+M\+A\+T\+C\+H\+E\+R\+\_\+P (
\begin{DoxyParamCaption}
\item[{Ptr\+Buf\+Has\+Len}]{, }
\item[{n}]{, }
\item[{\char`\"{}\char`\"{}}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a81d9df06994362df62cb2d68db7cd6cc}


Definition at line 410 of file Test\+Utils.\+h.



References fake\+Mock\+Codec(), G\+ET, get\+Big\+Get\+Request(), get\+Chunked\+Post\+Request(), get\+Get\+Request(), get\+Post\+Request(), get\+Priority\+Message(), get\+Pub\+Request(), get\+Response(), get\+Upgrade\+Request(), make\+Buf(), make\+Downstream\+Parallel\+Codec(), make\+Get\+Request(), make\+Post\+Request(), make\+Response(), make\+Upstream\+Parallel\+Codec(), proxygen\+::\+Fake\+H\+T\+T\+P\+Codec\+Callback\+::priority, and status\+Code.


\begin{DoxyCode}
410                                \{
411   \textcolor{keywordflow}{return} arg->computeChainDataLength() == n;
412 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!md5\+Encode@{md5\+Encode}}
\index{md5\+Encode@{md5\+Encode}!proxygen@{proxygen}}
\subsubsection[{md5\+Encode(folly\+::\+Byte\+Range text)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string proxygen\+::md5\+Encode (
\begin{DoxyParamCaption}
\item[{folly\+::\+Byte\+Range}]{text}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a0724d3547a8bf94940882ea609b175d0}


Definition at line 60 of file Crypt\+Util.\+cpp.



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
60                                          \{
61   static\_assert(MD5\_DIGEST\_LENGTH == 16, \textcolor{stringliteral}{""});
62 
63   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} digest[MD5\_DIGEST\_LENGTH];
64   MD5(text.begin(), text.size(), digest);
65 
66   \textcolor{comment}{// convert digest to hex string}
67   std::ostringstream ss;
68   ss << std::hex << std::setfill(\textcolor{charliteral}{'0'});
69   \textcolor{keywordflow}{for}(\textcolor{keywordtype}{int} i = 0; i < MD5\_DIGEST\_LENGTH; i++) \{
70     ss << std::setw(2) << (\textcolor{keywordtype}{unsigned} int)digest[i];
71   \}
72   \textcolor{keywordflow}{return} ss.str();
73 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!method\+To\+String@{method\+To\+String}}
\index{method\+To\+String@{method\+To\+String}!proxygen@{proxygen}}
\subsubsection[{method\+To\+String(\+H\+T\+T\+P\+Method method)}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string \& proxygen\+::method\+To\+String (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Method}}]{method}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a3103418dcba11cd110ecee0dd0a52385}
Returns a string representation of the method. If E\+X\+T\+E\+N\+S\+I\+O\+N\+\_\+\+M\+E\+T\+H\+OD is passed, then an empty string is returned 

Definition at line 46 of file H\+T\+T\+P\+Method.\+cpp.



Referenced by proxygen\+::\+H\+T\+T\+P1x\+Codec\+::generate\+Header(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Method\+String(), operator$<$$<$(), and proxygen\+::\+Codec\+Util\+::prepare\+Message\+For\+Compression().


\begin{DoxyCode}
46                                                    \{
47   \textcolor{keywordflow}{return} getMethodStrings()[\textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}(method)];
48 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!microseconds\+Between@{microseconds\+Between}}
\index{microseconds\+Between@{microseconds\+Between}!proxygen@{proxygen}}
\subsubsection[{microseconds\+Between(std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$ finish, std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$ start)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock\+Type  = Steady\+Clock$>$ std\+::chrono\+::microseconds proxygen\+::microseconds\+Between (
\begin{DoxyParamCaption}
\item[{std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$}]{finish, }
\item[{std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$}]{start}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_aeefc28ec8418ee65236f72c6d70cddd5}


Definition at line 77 of file Time.\+h.


\begin{DoxyCode}
79                                           \{
80   \textcolor{keywordflow}{return} std::chrono::duration\_cast<std::chrono::microseconds>(
81     finish - start);
82 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!milliseconds\+Between@{milliseconds\+Between}}
\index{milliseconds\+Between@{milliseconds\+Between}!proxygen@{proxygen}}
\subsubsection[{milliseconds\+Between(std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$ finish, std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$ start)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock\+Type  = Steady\+Clock$>$ std\+::chrono\+::milliseconds proxygen\+::milliseconds\+Between (
\begin{DoxyParamCaption}
\item[{std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$}]{finish, }
\item[{std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$}]{start}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_ae94f36adf5ce28528d9e34c9ba9cc5f8}


Definition at line 85 of file Time.\+h.



Referenced by proxygen\+::\+H\+T\+T\+P\+Transaction\+::maybe\+Delay\+For\+Rate\+Limit(), milliseconds\+Since(), proxygen\+::compress\+::\+Compression\+Simulator\+::read\+Input\+From\+File\+And\+Schedule(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
87                                           \{
88   \textcolor{keywordflow}{return} std::chrono::duration\_cast<std::chrono::milliseconds>(
89     finish - start);
90 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!milliseconds\+Since@{milliseconds\+Since}}
\index{milliseconds\+Since@{milliseconds\+Since}!proxygen@{proxygen}}
\subsubsection[{milliseconds\+Since(std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$ t)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock\+Type  = Steady\+Clock$>$ std\+::chrono\+::milliseconds proxygen\+::milliseconds\+Since (
\begin{DoxyParamCaption}
\item[{std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$}]{t}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_ac9e744f404571e4d7832aa3e88ae7159}


Definition at line 101 of file Time.\+h.



References milliseconds\+Between().



Referenced by proxygen\+::\+H\+T\+T\+P\+Connector\+::connect\+Success(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::get\+Idle\+Time(), proxygen\+::\+Ping\+Byte\+Event\+::get\+Latency(), proxygen\+::compress\+::\+Sim\+Streaming\+Callback\+::on\+Headers\+Complete(), and proxygen\+::\+H\+T\+T\+P\+Connector\+::time\+Elapsed().


\begin{DoxyCode}
102                                       \{
103   \textcolor{keywordflow}{return} millisecondsBetween(getCurrentTime<ClockType>(), t);
104 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!milliseconds\+Since\+Epoch@{milliseconds\+Since\+Epoch}}
\index{milliseconds\+Since\+Epoch@{milliseconds\+Since\+Epoch}!proxygen@{proxygen}}
\subsubsection[{milliseconds\+Since\+Epoch()}]{\setlength{\rightskip}{0pt plus 5cm}std\+::chrono\+::milliseconds proxygen\+::milliseconds\+Since\+Epoch (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_a0dc7643deaaf51b65b867d5fa0a82754}


Definition at line 56 of file Time.\+h.



Referenced by proxygen\+::\+Simple\+Timeout\+Clock\+::milliseconds\+Since\+Epoch(), Mock\+Timeout\+Clock\+::\+Mock\+Timeout\+Clock(), proxygen\+::\+Time\+Util\+Generic$<$ Clock\+Type $>$\+::ms\+Since\+Epoch(), Timeout\+Test\+::set\+Clock(), and proxygen\+::\+Async\+Timeout\+Set\+::\+Timeout\+Clock\+::$\sim$\+Timeout\+Clock().


\begin{DoxyCode}
56                                                       \{
57   \textcolor{keywordflow}{return} std::chrono::duration\_cast<std::chrono::milliseconds>(
58     std::chrono::system\_clock::now().time\_since\_epoch());
59 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!milliseconds\+Since\+Epoch@{milliseconds\+Since\+Epoch}}
\index{milliseconds\+Since\+Epoch@{milliseconds\+Since\+Epoch}!proxygen@{proxygen}}
\subsubsection[{milliseconds\+Since\+Epoch(\+Time\+Point t)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::chrono\+::milliseconds proxygen\+::milliseconds\+Since\+Epoch (
\begin{DoxyParamCaption}
\item[{{\bf Time\+Point}}]{t}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_a3942c4c4e3c21598a1d942d97a9bcf79}


Definition at line 66 of file Time.\+h.



References to\+System\+Time\+Point().


\begin{DoxyCode}
66                                                                  \{
67   \textcolor{keywordflow}{return} std::chrono::duration\_cast<std::chrono::milliseconds>(
68     toSystemTimePoint(t).time\_since\_epoch());
69 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!new\+Mock\+Transport@{new\+Mock\+Transport}}
\index{new\+Mock\+Transport@{new\+Mock\+Transport}!proxygen@{proxygen}}
\subsubsection[{new\+Mock\+Transport(folly\+::\+Event\+Base $\ast$evb)}]{\setlength{\rightskip}{0pt plus 5cm}testing\+::\+Nice\+Mock$<$folly\+::test\+::\+Mock\+Async\+Transport$>$$\ast$ proxygen\+::new\+Mock\+Transport (
\begin{DoxyParamCaption}
\item[{folly\+::\+Event\+Base $\ast$}]{evb}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a9f6c94a5b131d782576a28dbb4abfd5a}
\index{proxygen@{proxygen}!new\+Mock\+Transport@{new\+Mock\+Transport}}
\index{new\+Mock\+Transport@{new\+Mock\+Transport}!proxygen@{proxygen}}
\subsubsection[{new\+Mock\+Transport(\+Event\+Base $\ast$evb)}]{\setlength{\rightskip}{0pt plus 5cm}testing\+::\+Nice\+Mock$<$Mock\+Async\+Transport$>$$\ast$ proxygen\+::new\+Mock\+Transport (
\begin{DoxyParamCaption}
\item[{Event\+Base $\ast$}]{evb}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_af7ddcf9c7c2c63755bc7709d65674727}


Definition at line 40 of file Test\+Utils.\+cpp.



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
40                                                                       \{
41   \textcolor{keyword}{auto} transport = \textcolor{keyword}{new} testing::NiceMock<MockAsyncTransport>();
42   EXPECT\_CALL(*transport, getEventBase())
43     .WillRepeatedly(testing::Return(evb));
44   \textcolor{keywordflow}{return} transport;
45 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator"!@{operator"!}}
\index{operator"!@{operator"!}!proxygen@{proxygen}}
\subsubsection[{operator"!(\+Transport\+Direction dir)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Transport\+Direction} proxygen\+::operator! (
\begin{DoxyParamCaption}
\item[{{\bf Transport\+Direction}}]{dir}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a4d87bb71f07c20205450f72a2632f6a0}


Definition at line 25 of file Transport\+Direction.\+cpp.



References D\+O\+W\+N\+S\+T\+R\+E\+AM, and U\+P\+S\+T\+R\+E\+AM.


\begin{DoxyCode}
25                                                      \{
26   \textcolor{keywordflow}{return} dir == TransportDirection::DOWNSTREAM ?
27     TransportDirection::UPSTREAM : TransportDirection::DOWNSTREAM;
28 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$@{operator$<$}}
\index{operator$<$@{operator$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$(const Acceptor\+Address \&lv, const Acceptor\+Address \&rv)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::operator$<$ (
\begin{DoxyParamCaption}
\item[{const {\bf Acceptor\+Address} \&}]{lv, }
\item[{const {\bf Acceptor\+Address} \&}]{rv}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_aaf4f283bde34062dce19057694b0147c}


Definition at line 28 of file Acceptor\+Address.\+h.



References proxygen\+::\+Acceptor\+Address\+::address, and proxygen\+::\+Acceptor\+Address\+::protocol.


\begin{DoxyCode}
28                                                                             \{
29   \textcolor{keywordflow}{if} (lv.address < rv.address) \{
30     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
31   \}
32   \textcolor{keywordflow}{if} (rv.address < lv.address) \{
33     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
34   \}
35   \textcolor{keywordflow}{return} lv.protocol < rv.protocol;
36 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(std\+::ostream \&os, const H\+P\+A\+C\+K\+Header \&h)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream \& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{const {\bf H\+P\+A\+C\+K\+Header} \&}]{h}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_aa16c6d20eaf1814e76312f4bb411a756}


Definition at line 14 of file H\+P\+A\+C\+K\+Header.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Header\+::name, and proxygen\+::\+H\+P\+A\+C\+K\+Header\+::value.


\begin{DoxyCode}
14                                                              \{
15   os << h.name << \textcolor{stringliteral}{": "} << h.value;
16   \textcolor{keywordflow}{return} os;
17 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(std\+::ostream \&os, H\+T\+T\+P\+Event\+::\+Type e)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream \& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{{\bf H\+T\+T\+P\+Event\+::\+Type}}]{e}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a7c28fe90cf13af515bb4a0a01a06e6a5}


Definition at line 16 of file H\+T\+T\+P\+Event.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Event\+::\+B\+O\+DY, proxygen\+::\+H\+T\+T\+P\+Event\+::\+C\+H\+U\+N\+K\+\_\+\+C\+O\+M\+P\+L\+E\+TE, proxygen\+::\+H\+T\+T\+P\+Event\+::\+C\+H\+U\+N\+K\+\_\+\+H\+E\+A\+D\+ER, proxygen\+::\+H\+T\+T\+P\+Event\+::\+H\+E\+A\+D\+E\+R\+S\+\_\+\+C\+O\+M\+P\+L\+E\+TE, proxygen\+::\+H\+T\+T\+P\+Event\+::\+M\+E\+S\+S\+A\+G\+E\+\_\+\+B\+E\+G\+IN, proxygen\+::\+H\+T\+T\+P\+Event\+::\+M\+E\+S\+S\+A\+G\+E\+\_\+\+C\+O\+M\+P\+L\+E\+TE, proxygen\+::\+H\+T\+T\+P\+Event\+::\+T\+R\+A\+I\+L\+E\+R\+S\+\_\+\+C\+O\+M\+P\+L\+E\+TE, and proxygen\+::\+H\+T\+T\+P\+Event\+::\+U\+P\+G\+R\+A\+DE.


\begin{DoxyCode}
16                                                         \{
17   \textcolor{keywordflow}{switch} (e) \{
18     \textcolor{keywordflow}{case} HTTPEvent::Type::MESSAGE\_BEGIN:
19       os << \textcolor{stringliteral}{"message\_begin"};
20       \textcolor{keywordflow}{break};
21     \textcolor{keywordflow}{case} HTTPEvent::Type::HEADERS\_COMPLETE:
22       os << \textcolor{stringliteral}{"headers\_complete"};
23       \textcolor{keywordflow}{break};
24     \textcolor{keywordflow}{case} HTTPEvent::Type::BODY:
25       os << \textcolor{stringliteral}{"body"};
26       \textcolor{keywordflow}{break};
27     \textcolor{keywordflow}{case} HTTPEvent::Type::CHUNK\_HEADER:
28       os << \textcolor{stringliteral}{"chunk\_header"};
29       \textcolor{keywordflow}{break};
30     \textcolor{keywordflow}{case} HTTPEvent::Type::CHUNK\_COMPLETE:
31       os << \textcolor{stringliteral}{"chunk\_complete"};
32       \textcolor{keywordflow}{break};
33     \textcolor{keywordflow}{case} HTTPEvent::Type::TRAILERS\_COMPLETE:
34       os << \textcolor{stringliteral}{"trailers\_complete"};
35       \textcolor{keywordflow}{break};
36     \textcolor{keywordflow}{case} HTTPEvent::Type::MESSAGE\_COMPLETE:
37       os << \textcolor{stringliteral}{"message\_complete"};
38       \textcolor{keywordflow}{break};
39     \textcolor{keywordflow}{case} HTTPEvent::Type::UPGRADE:
40       os << \textcolor{stringliteral}{"uprade"};
41       \textcolor{keywordflow}{break};
42   \}
43 
44   \textcolor{keywordflow}{return} os;
45 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(std\+::ostream \&os, Trace\+Event\+Type event\+Type)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf F\+B\+\_\+\+E\+X\+P\+O\+RT} std\+::ostream \& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{Trace\+Event\+Type}]{event\+Type}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a573b17dcf8eee91c64b2d2792380d84b}


Definition at line 20 of file Trace\+Event.\+cpp.


\begin{DoxyCode}
20                                                                  \{
21   os << getTraceEventTypeString(eventType);
22   \textcolor{keywordflow}{return} os;
23 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(ostream \&os, const std\+::list$<$ uint32\+\_\+t $>$ $\ast$refset)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream \& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{ostream \&}]{os, }
\item[{const std\+::list$<$ uint32\+\_\+t $>$ $\ast$}]{refset}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ad3243aac295b4b88401bb70ab31f7297}


Definition at line 21 of file Logging.\+cpp.


\begin{DoxyCode}
21                                                                   \{
22   os << std::endl << \textcolor{charliteral}{'['};
23   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}& ref : *refset) \{
24     os << ref << \textcolor{charliteral}{' '};
25   \}
26   os << \textcolor{charliteral}{']'} << std::endl;
27   \textcolor{keywordflow}{return} os;
28 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(std\+::ostream \&os, const Byte\+Event \&be)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream \& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{const {\bf Byte\+Event} \&}]{be}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_aced38395e69fbc6549efe628d21c5b2f}


Definition at line 23 of file Byte\+Events.\+cpp.



References proxygen\+::\+Byte\+Event\+::byte\+Offset\+\_\+, and proxygen\+::\+Byte\+Event\+::event\+Type\+\_\+.


\begin{DoxyCode}
23                                                             \{
24   os << folly::to<std::string>(
25     \textcolor{stringliteral}{"("}, kTypeStrings[be.eventType\_], \textcolor{stringliteral}{", "}, be.byteOffset\_, \textcolor{stringliteral}{")"});
26   \textcolor{keywordflow}{return} os;
27 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(std\+::ostream \&os, const H\+T\+T\+P\+Exception \&ex)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream \& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{const {\bf H\+T\+T\+P\+Exception} \&}]{ex}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a4ce0aa8119f4d6829fa6ff0de4e961f7}


Definition at line 24 of file H\+T\+T\+P\+Exception.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Exception\+::get\+Codec\+Status\+Code(), proxygen\+::\+H\+T\+T\+P\+Exception\+::get\+Direction(), get\+Error\+Code\+String(), get\+Error\+String(), proxygen\+::\+H\+T\+T\+P\+Exception\+::get\+Http\+Status\+Code(), proxygen\+::\+Exception\+::get\+Proxygen\+Error(), proxygen\+::\+H\+T\+T\+P\+Exception\+::has\+Codec\+Status\+Code(), and proxygen\+::\+Exception\+::what().


\begin{DoxyCode}
24                                                                 \{
25   os << \textcolor{stringliteral}{"what=\(\backslash\)""} << ex.what()
26      << \textcolor{stringliteral}{"\(\backslash\)", direction="} << \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(ex.getDirection())
27      << \textcolor{stringliteral}{", proxygenError="} << getErrorString(ex.getProxygenError())
28      << \textcolor{stringliteral}{", codecStatusCode="} << (ex.hasCodecStatusCode() ?
29                                  getErrorCodeString(ex.getCodecStatusCode()) :
30                                  \textcolor{stringliteral}{"-1"})
31      << \textcolor{stringliteral}{", httpStatusCode="} << ex.getHttpStatusCode();
32   \textcolor{keywordflow}{return} os;
33 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(std\+::ostream \&os, Trace\+Field\+Type field\+Type)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf F\+B\+\_\+\+E\+X\+P\+O\+RT} std\+::ostream \& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{Trace\+Field\+Type}]{field\+Type}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_abc5b21c052d95b202a71b4d2b1b077bf}


Definition at line 25 of file Trace\+Event.\+cpp.


\begin{DoxyCode}
25                                                                  \{
26   os << getTraceFieldTypeString(fieldType);
27   \textcolor{keywordflow}{return} os;
28 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(std\+::ostream \&os, const Transport\+Direction dir)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream \& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{const {\bf Transport\+Direction}}]{dir}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ac0ebdc57f150f98f26000ce0df4ade78}


Definition at line 30 of file Transport\+Direction.\+cpp.



References get\+Transport\+Direction\+String().


\begin{DoxyCode}
30                                                                      \{
31   os << getTransportDirectionString(dir);
32   \textcolor{keywordflow}{return} os;
33 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(std\+::ostream \&os, const std\+::vector$<$ H\+P\+A\+C\+K\+Header $>$ \&v)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream \& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{const std\+::vector$<$ {\bf H\+P\+A\+C\+K\+Header} $>$ \&}]{v}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_aa8795cf92fb2ea7397f36f13c694740a}


Definition at line 30 of file Logging.\+cpp.


\begin{DoxyCode}
30                                                                         \{
31   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto} &h : v) \{
32     os << h.name << \textcolor{stringliteral}{": "} << h.value << std::endl;
33   \}
34   os << std::endl;
35   \textcolor{keywordflow}{return} os;
36 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(std\+::ostream \&os, const Acceptor\+Address\+::\+Acceptor\+Type \&acc\+Type)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{const {\bf Acceptor\+Address\+::\+Acceptor\+Type} \&}]{acc\+Type}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_aec3dd07313f04b66eda9fa7ef34a568c}


Definition at line 38 of file Acceptor\+Address.\+h.



References proxygen\+::\+Acceptor\+Address\+::\+T\+CP, and proxygen\+::\+Acceptor\+Address\+::\+U\+DP.


\begin{DoxyCode}
39                                                                             \{
40   \textcolor{keywordflow}{switch} (accType) \{
41     \textcolor{keywordflow}{case} AcceptorAddress::AcceptorType::TCP:
42       os << \textcolor{stringliteral}{"TCP"};
43       \textcolor{keywordflow}{break};
44     \textcolor{keywordflow}{case} AcceptorAddress::AcceptorType::UDP:
45       os << \textcolor{stringliteral}{"UDP"};
46       \textcolor{keywordflow}{break};
47     \textcolor{keywordflow}{default}:
48       LOG(FATAL) << \textcolor{stringliteral}{"Unknown Acceptor type."};
49   \}
50   \textcolor{keywordflow}{return} os;
51 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(std\+::ostream \&os, const Q\+P\+A\+C\+K\+Context \&context)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream \& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{const {\bf Q\+P\+A\+C\+K\+Context} \&}]{context}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a2dc2e3119b63c0d53f74a399383646a1}


Definition at line 43 of file Q\+P\+A\+C\+K\+Context.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Context\+::describe().


\begin{DoxyCode}
43                                                                     \{
44   context.describe(os);
45   \textcolor{keywordflow}{return} os;
46 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(std\+::ostream \&out, H\+T\+T\+P\+Method method)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream \& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{{\bf H\+T\+T\+P\+Method}}]{method}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ab1e758d7562b31352fca9410fc32b308}


Definition at line 50 of file H\+T\+T\+P\+Method.\+cpp.



References method\+To\+String().


\begin{DoxyCode}
50                                                             \{
51   out << methodToString(method);
52   \textcolor{keywordflow}{return} out;
53 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(std\+::ostream \&os, const Acceptor\+Address \&acc\+Addr)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{const {\bf Acceptor\+Address} \&}]{acc\+Addr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_aa91ad7ca361de4549a1a6be1d065443b}


Definition at line 53 of file Acceptor\+Address.\+h.



References proxygen\+::\+Acceptor\+Address\+::address, and proxygen\+::\+Acceptor\+Address\+::protocol.


\begin{DoxyCode}
54                                                                 \{
55   os << accAddr.address << \textcolor{stringliteral}{"<"} << accAddr.protocol << \textcolor{stringliteral}{">"};
56   \textcolor{keywordflow}{return} os;
57 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(std\+::ostream \&os, const Q\+P\+A\+C\+K\+Codec \&codec)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream \& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{const {\bf Q\+P\+A\+C\+K\+Codec} \&}]{codec}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a87e326817f9bcea19c49a22553efc280}


Definition at line 75 of file Q\+P\+A\+C\+K\+Codec.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Codec\+::describe().


\begin{DoxyCode}
75                                                                 \{
76   codec.describe(os);
77   \textcolor{keywordflow}{return} os;
78 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(std\+::ostream \&os, H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data\+::\+State s)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream \& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{{\bf H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data\+::\+State}}]{s}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a5aa532123eedf2d2f815c3c1f62f97ed}


Definition at line 77 of file H\+T\+T\+P\+Transaction\+Egress\+S\+M.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data\+::\+Chunk\+Body\+Sent, proxygen\+::\+H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data\+::\+Chunk\+Header\+Sent, proxygen\+::\+H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data\+::\+Chunk\+Terminator\+Sent, proxygen\+::\+H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data\+::\+E\+O\+M\+Queued, proxygen\+::\+H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data\+::\+Headers\+Sent, proxygen\+::\+H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data\+::\+Regular\+Body\+Sent, proxygen\+::\+H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data\+::\+Sending\+Done, proxygen\+::\+H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data\+::\+Start, and proxygen\+::\+H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data\+::\+Trailers\+Sent.


\begin{DoxyCode}
78                                                              \{
79   \textcolor{keywordflow}{switch} (s) \{
80     \textcolor{keywordflow}{case} HTTPTransactionEgressSMData::State::Start:
81       os << \textcolor{stringliteral}{"Start"};
82       \textcolor{keywordflow}{break};
83     \textcolor{keywordflow}{case} HTTPTransactionEgressSMData::State::HeadersSent:
84       os << \textcolor{stringliteral}{"HeadersSent"};
85       \textcolor{keywordflow}{break};
86     \textcolor{keywordflow}{case} HTTPTransactionEgressSMData::State::RegularBodySent:
87       os << \textcolor{stringliteral}{"RegularBodySent"};
88       \textcolor{keywordflow}{break};
89     \textcolor{keywordflow}{case} HTTPTransactionEgressSMData::State::ChunkHeaderSent:
90       os << \textcolor{stringliteral}{"ChunkHeaderSent"};
91       \textcolor{keywordflow}{break};
92     \textcolor{keywordflow}{case} HTTPTransactionEgressSMData::State::ChunkBodySent:
93       os << \textcolor{stringliteral}{"ChunkBodySent"};
94       \textcolor{keywordflow}{break};
95     \textcolor{keywordflow}{case} HTTPTransactionEgressSMData::State::ChunkTerminatorSent:
96       os << \textcolor{stringliteral}{"ChunkTerminatorSent"};
97       \textcolor{keywordflow}{break};
98     \textcolor{keywordflow}{case} HTTPTransactionEgressSMData::State::TrailersSent:
99       os << \textcolor{stringliteral}{"TrailersSent"};
100       \textcolor{keywordflow}{break};
101     \textcolor{keywordflow}{case} HTTPTransactionEgressSMData::State::EOMQueued:
102       os << \textcolor{stringliteral}{"EOMQueued"};
103       \textcolor{keywordflow}{break};
104     \textcolor{keywordflow}{case} HTTPTransactionEgressSMData::State::SendingDone:
105       os << \textcolor{stringliteral}{"SendingDone"};
106       \textcolor{keywordflow}{break};
107   \}
108 
109   \textcolor{keywordflow}{return} os;
110 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(\+Null\+Stream \&ns, const T \&)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ {\bf Null\+Stream}\& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{{\bf Null\+Stream} \&}]{ns, }
\item[{const {\bf T} \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_ad6f4816bd3d9c20ef7b61ba650297743}


Definition at line 78 of file Logging.\+h.


\begin{DoxyCode}
78                                                            \{
79   \textcolor{keywordflow}{return} ns;
80 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(std\+::ostream \&os, const H\+P\+A\+C\+K\+Codec \&codec)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream \& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{const {\bf H\+P\+A\+C\+K\+Codec} \&}]{codec}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_af4597cf39a9ccb3cb904076e5ecd502e}


Definition at line 80 of file H\+P\+A\+C\+K\+Codec.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Codec\+::describe().


\begin{DoxyCode}
80                                                                 \{
81   codec.describe(os);
82   \textcolor{keywordflow}{return} os;
83 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(std\+::ostream \&os, H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::\+State s)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream \& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{{\bf H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::\+State}}]{s}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_af97479a852a25c4b8c058b9c27b9b572}


Definition at line 84 of file H\+T\+T\+P\+Transaction\+Ingress\+S\+M.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::\+Chunk\+Body\+Received, proxygen\+::\+H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::\+Chunk\+Completed, proxygen\+::\+H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::\+Chunk\+Header\+Received, proxygen\+::\+H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::\+E\+O\+M\+Queued, proxygen\+::\+H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::\+Headers\+Received, proxygen\+::\+H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::\+Receiving\+Done, proxygen\+::\+H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::\+Regular\+Body\+Received, proxygen\+::\+H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::\+Start, proxygen\+::\+H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::\+Trailers\+Received, and proxygen\+::\+H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::\+Upgrade\+Complete.


\begin{DoxyCode}
85                                                               \{
86   \textcolor{keywordflow}{switch} (s) \{
87     \textcolor{keywordflow}{case} HTTPTransactionIngressSMData::State::Start:
88       os << \textcolor{stringliteral}{"Start"};
89       \textcolor{keywordflow}{break};
90     \textcolor{keywordflow}{case} HTTPTransactionIngressSMData::State::HeadersReceived:
91       os << \textcolor{stringliteral}{"HeadersReceived"};
92       \textcolor{keywordflow}{break};
93     \textcolor{keywordflow}{case} HTTPTransactionIngressSMData::State::RegularBodyReceived:
94       os << \textcolor{stringliteral}{"RegularBodyReceived"};
95       \textcolor{keywordflow}{break};
96     \textcolor{keywordflow}{case} HTTPTransactionIngressSMData::State::ChunkHeaderReceived:
97       os << \textcolor{stringliteral}{"ChunkHeaderReceived"};
98       \textcolor{keywordflow}{break};
99     \textcolor{keywordflow}{case} HTTPTransactionIngressSMData::State::ChunkBodyReceived:
100       os << \textcolor{stringliteral}{"ChunkBodyReceived"};
101       \textcolor{keywordflow}{break};
102     \textcolor{keywordflow}{case} HTTPTransactionIngressSMData::State::ChunkCompleted:
103       os << \textcolor{stringliteral}{"ChunkCompleted"};
104       \textcolor{keywordflow}{break};
105     \textcolor{keywordflow}{case} HTTPTransactionIngressSMData::State::TrailersReceived:
106       os << \textcolor{stringliteral}{"TrailersReceived"};
107       \textcolor{keywordflow}{break};
108     \textcolor{keywordflow}{case} HTTPTransactionIngressSMData::State::UpgradeComplete:
109       os << \textcolor{stringliteral}{"UpgradeComplete"};
110       \textcolor{keywordflow}{break};
111     \textcolor{keywordflow}{case} HTTPTransactionIngressSMData::State::EOMQueued:
112       os << \textcolor{stringliteral}{"EOMQueued"};
113       \textcolor{keywordflow}{break};
114     \textcolor{keywordflow}{case} HTTPTransactionIngressSMData::State::ReceivingDone:
115       os << \textcolor{stringliteral}{"ReceivingDone"};
116       \textcolor{keywordflow}{break};
117   \}
118 
119   \textcolor{keywordflow}{return} os;
120 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(std\+::ostream \&os, const H\+P\+A\+C\+K\+Context \&context)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream \& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{const {\bf H\+P\+A\+C\+K\+Context} \&}]{context}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a2b3040f37c615c1ece30345a7d9fac96}


Definition at line 86 of file H\+P\+A\+C\+K\+Context.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Context\+::describe().


\begin{DoxyCode}
86                                                                     \{
87   context.describe(os);
88   \textcolor{keywordflow}{return} os;
89 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(std\+::ostream \&os, H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data\+::\+Event e)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream \& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{{\bf H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data\+::\+Event}}]{e}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a32f56dc5b58904c4244e518ffbf78612}


Definition at line 112 of file H\+T\+T\+P\+Transaction\+Egress\+S\+M.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data\+::eom\+Flushed, proxygen\+::\+H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data\+::send\+Body, proxygen\+::\+H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data\+::send\+Chunk\+Header, proxygen\+::\+H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data\+::send\+Chunk\+Terminator, proxygen\+::\+H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data\+::send\+E\+OM, proxygen\+::\+H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data\+::send\+Headers, and proxygen\+::\+H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data\+::send\+Trailers.


\begin{DoxyCode}
113                                                              \{
114   \textcolor{keywordflow}{switch} (e) \{
115     \textcolor{keywordflow}{case} HTTPTransactionEgressSMData::Event::sendHeaders:
116       os << \textcolor{stringliteral}{"sendHeaders"};
117       \textcolor{keywordflow}{break};
118     \textcolor{keywordflow}{case} HTTPTransactionEgressSMData::Event::sendBody:
119       os << \textcolor{stringliteral}{"sendBody"};
120       \textcolor{keywordflow}{break};
121     \textcolor{keywordflow}{case} HTTPTransactionEgressSMData::Event::sendChunkHeader:
122       os << \textcolor{stringliteral}{"sendChunkHeader"};
123       \textcolor{keywordflow}{break};
124     \textcolor{keywordflow}{case} HTTPTransactionEgressSMData::Event::sendChunkTerminator:
125       os << \textcolor{stringliteral}{"sendChunkTerminator"};
126       \textcolor{keywordflow}{break};
127     \textcolor{keywordflow}{case} HTTPTransactionEgressSMData::Event::sendTrailers:
128       os << \textcolor{stringliteral}{"sendTrailers"};
129       \textcolor{keywordflow}{break};
130     \textcolor{keywordflow}{case} HTTPTransactionEgressSMData::Event::sendEOM:
131       os << \textcolor{stringliteral}{"sendEOM"};
132       \textcolor{keywordflow}{break};
133     \textcolor{keywordflow}{case} HTTPTransactionEgressSMData::Event::eomFlushed:
134       os << \textcolor{stringliteral}{"eomFlushed"};
135       \textcolor{keywordflow}{break};
136   \}
137 
138   \textcolor{keywordflow}{return} os;
139 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(std\+::ostream \&out, const Trace\+Event \&event)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{out, }
\item[{const {\bf Trace\+Event} \&}]{event}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_acadeadd0de3db644e9d121a9fbf165bc}


Definition at line 116 of file Trace\+Event.\+cpp.


\begin{DoxyCode}
116                                                                    \{
117   out << \textcolor{keyword}{event}.toString();
118   \textcolor{keywordflow}{return} out;
119 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(std\+::ostream \&os, H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::\+Event e)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream \& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{{\bf H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::\+Event}}]{e}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_af6dae96808a8d40993928fdcf5825437}


Definition at line 122 of file H\+T\+T\+P\+Transaction\+Ingress\+S\+M.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::eom\+Flushed, proxygen\+::\+H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::on\+Body, proxygen\+::\+H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::on\+Chunk\+Complete, proxygen\+::\+H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::on\+Chunk\+Header, proxygen\+::\+H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::on\+E\+OM, proxygen\+::\+H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::on\+Headers, proxygen\+::\+H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::on\+Trailers, and proxygen\+::\+H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::on\+Upgrade.


\begin{DoxyCode}
123                                                               \{
124   \textcolor{keywordflow}{switch} (e) \{
125     \textcolor{keywordflow}{case} HTTPTransactionIngressSMData::Event::onHeaders:
126       os << \textcolor{stringliteral}{"onHeaders"};
127       \textcolor{keywordflow}{break};
128     \textcolor{keywordflow}{case} HTTPTransactionIngressSMData::Event::onBody:
129       os << \textcolor{stringliteral}{"onBody"};
130       \textcolor{keywordflow}{break};
131     \textcolor{keywordflow}{case} HTTPTransactionIngressSMData::Event::onChunkHeader:
132       os << \textcolor{stringliteral}{"onChunkHeader"};
133       \textcolor{keywordflow}{break};
134     \textcolor{keywordflow}{case} HTTPTransactionIngressSMData::Event::onChunkComplete:
135       os << \textcolor{stringliteral}{"onChunkComplete"};
136       \textcolor{keywordflow}{break};
137     \textcolor{keywordflow}{case} HTTPTransactionIngressSMData::Event::onTrailers:
138       os << \textcolor{stringliteral}{"onTrailers"};
139       \textcolor{keywordflow}{break};
140     \textcolor{keywordflow}{case} HTTPTransactionIngressSMData::Event::onUpgrade:
141       os << \textcolor{stringliteral}{"onUpgrade"};
142       \textcolor{keywordflow}{break};
143     \textcolor{keywordflow}{case} HTTPTransactionIngressSMData::Event::onEOM:
144       os << \textcolor{stringliteral}{"onEOM"};
145       \textcolor{keywordflow}{break};
146     \textcolor{keywordflow}{case} HTTPTransactionIngressSMData::Event::eomFlushed:
147       os << \textcolor{stringliteral}{"eomFlushed"};
148       \textcolor{keywordflow}{break};
149   \}
150 
151   \textcolor{keywordflow}{return} os;
152 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(std\+::ostream \&os, const H\+P\+A\+C\+K\+Header\+Name \&name)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream\& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{const {\bf H\+P\+A\+C\+K\+Header\+Name} \&}]{name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_a5d911c39fd53918b69743b3a6454bcdb}


Definition at line 203 of file H\+P\+A\+C\+K\+Header\+Name.\+h.



References proxygen\+::\+H\+P\+A\+C\+K\+Header\+Name\+::get().


\begin{DoxyCode}
203                                                                            \{
204   os << name.get();
205   \textcolor{keywordflow}{return} os;
206 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(std\+::ostream \&os, const Header\+Table \&table)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream \& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{const {\bf Header\+Table} \&}]{table}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a1617cb8241e173bf5635c01eae5cc12f}


Definition at line 254 of file Header\+Table.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Header\+::bytes(), proxygen\+::\+Header\+Table\+::bytes(), proxygen\+::\+Header\+Table\+::get\+Header(), proxygen\+::\+H\+P\+A\+C\+K\+Header\+::name, proxygen\+::\+Header\+Table\+::size(), and proxygen\+::\+H\+P\+A\+C\+K\+Header\+::value.



Referenced by proxygen\+::\+H\+T\+T\+P\+Transaction\+Egress\+S\+M\+Data\+::get\+Name(), and proxygen\+::\+H\+T\+T\+P\+Transaction\+Ingress\+S\+M\+Data\+::get\+Name().


\begin{DoxyCode}
254                                                                  \{
255   os << std::endl;
256   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 1; i <= table.size(); i++) \{
257     \textcolor{keyword}{const} HPACKHeader& h = table.getHeader(i);
258     os << \textcolor{charliteral}{'['} << i << \textcolor{stringliteral}{"] (s="} << h.bytes() << \textcolor{stringliteral}{") "}
259        << h.name << \textcolor{stringliteral}{": "} << h.value << std::endl;
260   \}
261   os << \textcolor{stringliteral}{"total size: "} << table.bytes() << std::endl;
262   \textcolor{keywordflow}{return} os;
263 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(std\+::ostream \&os, const H\+T\+T\+P\+Message \&msg)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream \& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{const {\bf H\+T\+T\+P\+Message} \&}]{msg}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ac2c607e67f74dd08ce32c5a0fd558ba9}


Definition at line 671 of file H\+T\+T\+P\+Message.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Message\+::describe().


\begin{DoxyCode}
671                                                                \{
672   msg.describe(os);
673   \textcolor{keywordflow}{return} os;
674 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator$<$$<$@{operator$<$$<$}}
\index{operator$<$$<$@{operator$<$$<$}!proxygen@{proxygen}}
\subsubsection[{operator$<$$<$(std\+::ostream \&os, const H\+T\+T\+P\+Transaction \&txn)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::ostream \& proxygen\+::operator$<$$<$ (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os, }
\item[{const {\bf H\+T\+T\+P\+Transaction} \&}]{txn}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_af3a8b69029292653a760cb3f5795a092}
Write a description of an \doxyref{H\+T\+T\+P\+Transaction}{p.}{classproxygen_1_1HTTPTransaction} to an ostream 

Definition at line 1365 of file H\+T\+T\+P\+Transaction.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Transaction\+::describe().


\begin{DoxyCode}
1365                                                        \{
1366   txn.describe(os);
1367   \textcolor{keywordflow}{return} os;
1368 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!operator==@{operator==}}
\index{operator==@{operator==}!proxygen@{proxygen}}
\subsubsection[{operator==(const H\+T\+T\+P\+Message \&msg1, const H\+T\+T\+P\+Message \&msg2)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf H\+T\+T\+P\+Message} \&}]{msg1, }
\item[{const {\bf H\+T\+T\+P\+Message} \&}]{msg2}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_aae93fb71ce66cfb8e6332dea00e628c9}


Definition at line 132 of file Compression\+Utils.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Method\+String(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+U\+R\+L(), and proxygen\+::\+H\+T\+T\+P\+Message\+::is\+Secure().


\begin{DoxyCode}
132                                                                   \{
133   \textcolor{keywordflow}{return} (msg1.getMethodString() == msg2.getMethodString() &&
134           msg1.getURL() == msg2.getURL() &&
135           msg1.isSecure() == msg2.isSecure() &&
136           containsAllHeaders(msg1.getHeaders(), msg2.getHeaders()) &&
137           containsAllHeaders(msg2.getHeaders(), msg1.getHeaders()));
138 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!parse@{parse}}
\index{parse@{parse}!proxygen@{proxygen}}
\subsubsection[{parse(\+T $\ast$codec, const uint8\+\_\+t $\ast$input\+Data, uint32\+\_\+t length, int32\+\_\+t at\+Once=0, std\+::function$<$ bool()$>$ stop\+Fn=[]\lcurly{}return false;\rcurly{})}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ size\+\_\+t proxygen\+::parse (
\begin{DoxyParamCaption}
\item[{{\bf T} $\ast$}]{codec, }
\item[{const uint8\+\_\+t $\ast$}]{input\+Data, }
\item[{uint32\+\_\+t}]{length, }
\item[{int32\+\_\+t}]{at\+Once = {\ttfamily 0}, }
\item[{std\+::function$<$ bool()$>$}]{stop\+Fn = {\ttfamily []~\{~return~false;~\}}}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a9e09733d471402b01bef4740e8262715}
parse the input data using codec, using at\+Once to determine how much data should go through the parser at one time

at\+Once $<$ 0\+: use random chunk lengths at\+Once = 0\+: single chunk at\+Once $>$ 0\+: use specified chunk length 

Definition at line 28 of file Test\+Utils.\+h.



Referenced by T\+E\+S\+T\+\_\+\+F(), H\+T\+T\+P2\+Codec\+Test\+::test\+Frame\+Size\+Limit(), and H\+T\+T\+P2\+Codec\+Test\+::test\+Header\+List\+Size().


\begin{DoxyCode}
32                                              \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}) \{
33 
34   \textcolor{keyword}{const} uint8\_t* start = inputData;
35   \textcolor{keywordtype}{size\_t} consumed = 0;
36   std::uniform\_int\_distribution<uint32\_t> lenDistribution(1, length / 2 + 1);
37   std::mt19937 rng;
38 
39   \textcolor{keywordflow}{if} (atOnce == 0) \{
40     atOnce = length;
41   \}
42 
43   folly::IOBufQueue input(folly::IOBufQueue::cacheChainLength());
44   \textcolor{keywordflow}{while} (length > 0 && !stopFn()) \{
45     \textcolor{keywordflow}{if} (consumed == 0) \{
46       \textcolor{comment}{// Parser wants more data}
47       uint32\_t len = atOnce;
48       \textcolor{keywordflow}{if} (atOnce < 0) \{
49         \textcolor{comment}{// use random chunks}
50         len = lenDistribution(rng);
51       \}
52       uint32\_t chunkLen = std::min(length, len);
53       input.append(folly::IOBuf::copyBuffer(start, chunkLen));
54       start += chunkLen;
55       length -= chunkLen;
56     \}
57     consumed = codec->onIngress(*input.front());
58     input.split(consumed);
59     \textcolor{keywordflow}{if} (input.front() == \textcolor{keyword}{nullptr} && consumed > 0) \{
60       consumed = 0;
61     \}
62   \}
63   \textcolor{keywordflow}{return} input.chainLength();
64 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!parse\+H\+T\+T\+P\+Date\+Time@{parse\+H\+T\+T\+P\+Date\+Time}}
\index{parse\+H\+T\+T\+P\+Date\+Time@{parse\+H\+T\+T\+P\+Date\+Time}!proxygen@{proxygen}}
\subsubsection[{parse\+H\+T\+T\+P\+Date\+Time(const std\+::string \&s)}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+Optional$<$ int64\+\_\+t $>$ proxygen\+::parse\+H\+T\+T\+P\+Date\+Time (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{s}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a34483f01f93fc7a85f995768639f077c}


Definition at line 18 of file H\+T\+T\+P\+Time.\+cpp.



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
18                                                              \{
19   \textcolor{keyword}{struct }tm tm = \{\};
20 
21   \textcolor{keywordflow}{if} (s.empty()) \{
22     \textcolor{keywordflow}{return} folly::none;
23   \}
24 
25   \textcolor{comment}{// Sun, 06 Nov 1994 08:49:37 GMT  ; RFC 822, updated by RFC 1123}
26   \textcolor{comment}{// Sunday, 06-Nov-94 08:49:37 GMT ; RFC 850, obsoleted by RFC 1036}
27   \textcolor{comment}{// Sun Nov 6 08:49:37 1994        ; ANSI C's asctime() format}
28   \textcolor{comment}{//    Assume GMT as per rfc2616 (see HTTP-date):}
29   \textcolor{comment}{//       - https://www.w3.org/Protocols/rfc2616/rfc2616-sec3.html}
30   \textcolor{keywordflow}{if} (strptime(s.c\_str(), \textcolor{stringliteral}{"%a, %d %b %Y %H:%M:%S GMT"}, &tm) != \textcolor{keyword}{nullptr} ||
31       strptime(s.c\_str(), \textcolor{stringliteral}{"%a, %d-%b-%y %H:%M:%S GMT"}, &tm) != \textcolor{keyword}{nullptr} ||
32       strptime(s.c\_str(), \textcolor{stringliteral}{"%a %b %d %H:%M:%S %Y"}, &tm) != \textcolor{keyword}{nullptr}) \{
33     \textcolor{keywordflow}{return} folly::Optional<int64\_t>(timegm(&tm));
34   \}
35 
36   LOG(INFO) << \textcolor{stringliteral}{"Invalid http time: "} << s;
37   \textcolor{keywordflow}{return} folly::none;
38 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!parse\+Unidirectional@{parse\+Unidirectional}}
\index{parse\+Unidirectional@{parse\+Unidirectional}!proxygen@{proxygen}}
\subsubsection[{parse\+Unidirectional(\+T $\ast$codec, const uint8\+\_\+t $\ast$input\+Data, uint32\+\_\+t length, int32\+\_\+t at\+Once=0, std\+::function$<$ bool()$>$ stop\+Fn=[]\lcurly{}return false;\rcurly{})}]{\setlength{\rightskip}{0pt plus 5cm}template$<$class T $>$ size\+\_\+t proxygen\+::parse\+Unidirectional (
\begin{DoxyParamCaption}
\item[{{\bf T} $\ast$}]{codec, }
\item[{const uint8\+\_\+t $\ast$}]{input\+Data, }
\item[{uint32\+\_\+t}]{length, }
\item[{int32\+\_\+t}]{at\+Once = {\ttfamily 0}, }
\item[{std\+::function$<$ bool()$>$}]{stop\+Fn = {\ttfamily []~\{~return~false;~\}}}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a486c274cb9c9a32dc0db40544cc74e15}


Definition at line 67 of file Test\+Utils.\+h.


\begin{DoxyCode}
71                                                            \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}) \{
72 
73   \textcolor{keyword}{const} uint8\_t* start = inputData;
74   \textcolor{keywordtype}{size\_t} consumed = 0;
75   std::uniform\_int\_distribution<uint32\_t> lenDistribution(1, length / 2 + 1);
76   std::mt19937 rng;
77 
78   \textcolor{keywordflow}{if} (atOnce == 0) \{
79     atOnce = length;
80   \}
81 
82   folly::IOBufQueue input(folly::IOBufQueue::cacheChainLength());
83   \textcolor{keywordflow}{while} (length > 0 && !stopFn()) \{
84     \textcolor{keywordflow}{if} (consumed == 0) \{
85       \textcolor{comment}{// Parser wants more data}
86       uint32\_t len = atOnce;
87       \textcolor{keywordflow}{if} (atOnce < 0) \{
88         \textcolor{comment}{// use random chunks}
89         len = lenDistribution(rng);
90       \}
91       uint32\_t chunkLen = std::min(length, len);
92       input.append(folly::IOBuf::copyBuffer(start, chunkLen));
93       start += chunkLen;
94       length -= chunkLen;
95     \}
96     \textcolor{keyword}{auto} initialLength = input.chainLength();
97     \textcolor{keyword}{auto} ret = codec->onUnidirectionalIngress(input.move());
98     input.append(std::move(ret));
99     consumed = initialLength - input.chainLength();
100     \textcolor{keywordflow}{if} (input.front() == \textcolor{keyword}{nullptr} && consumed > 0) \{
101       consumed = 0;
102     \}
103   \}
104   \textcolor{keywordflow}{return} input.chainLength();
105 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!print\+Delta@{print\+Delta}}
\index{print\+Delta@{print\+Delta}!proxygen@{proxygen}}
\subsubsection[{print\+Delta(const vector$<$ H\+P\+A\+C\+K\+Header $>$ \&v1, const vector$<$ H\+P\+A\+C\+K\+Header $>$ \&v2)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string proxygen\+::print\+Delta (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ {\bf H\+P\+A\+C\+K\+Header} $>$ \&}]{v1, }
\item[{const std\+::vector$<$ {\bf H\+P\+A\+C\+K\+Header} $>$ \&}]{v2}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a40bfdb098bc1a4bb1be22aa00e96944e}
print the difference between 2 sorted list of headers 

Definition at line 38 of file Logging.\+cpp.



Referenced by T\+E\+S\+T\+\_\+\+F(), and proxygen\+::hpack\+::verify\+Headers().


\begin{DoxyCode}
39                                                  \{
40   stringstream out;
41   \textcolor{comment}{// similar with merge operation}
42   \textcolor{keywordtype}{size\_t} i = 0;
43   \textcolor{keywordtype}{size\_t} j = 0;
44   out << std::endl;
45   \textcolor{keywordflow}{while} (i < v1.size() && j < v2.size()) \{
46     \textcolor{keywordflow}{if} (v1[i] < v2[j]) \{
47       \textcolor{keywordflow}{if} (i > 0 && v1[i - 1] == v1[i]) \{
48         out << \textcolor{stringliteral}{" duplicate "} << v1[i] << std::endl;
49       \} \textcolor{keywordflow}{else} \{
50         out << \textcolor{stringliteral}{" + "} << v1[i] << std::endl;
51       \}
52       i++;
53     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (v1[i] > v2[j]) \{
54       out << \textcolor{stringliteral}{" - "} << v2[j] << std::endl;
55       j++;
56     \} \textcolor{keywordflow}{else} \{
57       i++;
58       j++;
59     \}
60   \}
61   \textcolor{keywordflow}{while} (i < v1.size()) \{
62     out << \textcolor{stringliteral}{" + "} << v1[i];
63     \textcolor{keywordflow}{if} (i > 0 && v1[i - 1] == v1[i]) \{
64       out << \textcolor{stringliteral}{" (duplicate)"};
65     \}
66     out << std::endl;
67     i++;
68   \}
69   \textcolor{keywordflow}{while} (j < v2.size()) \{
70     out << \textcolor{stringliteral}{" - "} << v2[j] << std::endl;
71     j++;
72   \}
73   \textcolor{keywordflow}{return} out.str();
74 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!read\+File\+To\+I\+O\+Buf@{read\+File\+To\+I\+O\+Buf}}
\index{read\+File\+To\+I\+O\+Buf@{read\+File\+To\+I\+O\+Buf}!proxygen@{proxygen}}
\subsubsection[{read\+File\+To\+I\+O\+Buf(const std\+::string \&filename)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<$I\+O\+Buf$>$ proxygen\+::read\+File\+To\+I\+O\+Buf (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{filename}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a5dbd3abbd46f19453c9552f15df699f1}


Definition at line 122 of file H\+T\+T\+P\+Archive.\+cpp.



References E\+R\+R\+OR.



Referenced by proxygen\+::\+H\+T\+T\+P\+Archive\+::from\+File(), and proxygen\+::\+H\+T\+T\+P\+Archive\+::from\+Public\+File().


\begin{DoxyCode}
122                                                                 \{
123   \textcolor{comment}{// read the contents of the file}
124   ifstream file(filename);
125   \textcolor{keywordflow}{if} (!file.is\_open()) \{
126     LOG(ERROR) << \textcolor{stringliteral}{"could not open file '"} << filename << \textcolor{stringliteral}{"'"};
127     \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};
128   \}
129   file.seekg(0, ios::end);
130   int64\_t size = file.tellg();
131   \textcolor{keywordflow}{if} (size < 0) \{
132     LOG(ERROR) << \textcolor{stringliteral}{"failed to fetch the position at the end of the file"};
133     \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};
134   \}
135   file.seekg(0, ios::beg);
136   unique\_ptr<IOBuf> buffer = IOBuf::create(size + 1);
137   file.read((\textcolor{keywordtype}{char} *)buffer->writableData(), size);
138   buffer->writableData()[size] = 0;
139   buffer->append(size + 1);
140   \textcolor{keywordflow}{if} (!file) \{
141     LOG(ERROR) << \textcolor{stringliteral}{"error occurred, was able to read only "}
142                << file.gcount() << \textcolor{stringliteral}{" bytes out of "} << size;
143     \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};
144   \}
145   \textcolor{keywordflow}{return} buffer;
146 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!Scoped\+H\+T\+T\+P\+Server\+::start$<$ std\+::unique\+\_\+ptr$<$ Request\+Handler\+Factory $>$ $>$@{Scoped\+H\+T\+T\+P\+Server\+::start$<$ std\+::unique\+\_\+ptr$<$ Request\+Handler\+Factory $>$ $>$}}
\index{Scoped\+H\+T\+T\+P\+Server\+::start$<$ std\+::unique\+\_\+ptr$<$ Request\+Handler\+Factory $>$ $>$@{Scoped\+H\+T\+T\+P\+Server\+::start$<$ std\+::unique\+\_\+ptr$<$ Request\+Handler\+Factory $>$ $>$}!proxygen@{proxygen}}
\subsubsection[{Scoped\+H\+T\+T\+P\+Server\+::start$<$ std\+::unique\+\_\+ptr$<$ Request\+Handler\+Factory $>$ $>$(std\+::unique\+\_\+ptr$<$ Request\+Handler\+Factory $>$ f, int port, int num\+Threads, std\+::unique\+\_\+ptr$<$ wangle\+::\+S\+S\+L\+Context\+Config $>$ ssl\+Cfg)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$$>$ std\+::unique\+\_\+ptr$<${\bf Scoped\+H\+T\+T\+P\+Server}$>$ {\bf proxygen\+::\+Scoped\+H\+T\+T\+P\+Server\+::start}$<$ std\+::unique\+\_\+ptr$<$ {\bf Request\+Handler\+Factory} $>$ $>$ (
\begin{DoxyParamCaption}
\item[{std\+::unique\+\_\+ptr$<$ {\bf Request\+Handler\+Factory} $>$}]{f, }
\item[{int}]{port, }
\item[{int}]{num\+Threads, }
\item[{std\+::unique\+\_\+ptr$<$ wangle\+::\+S\+S\+L\+Context\+Config $>$}]{ssl\+Cfg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_a78cd720a3ece32f43fc11d76d0370e03}


Definition at line 154 of file Scoped\+H\+T\+T\+P\+Server.\+h.



References proxygen\+::\+H\+T\+T\+P\+Server\+Options\+::handler\+Factories, proxygen\+::\+H\+T\+T\+P\+Server\+::\+H\+T\+TP, and proxygen\+::\+H\+T\+T\+P\+Server\+Options\+::threads.


\begin{DoxyCode}
158                                                   \{
159   \textcolor{comment}{// This will handle both IPv4 and IPv6 cases}
160   folly::SocketAddress addr;
161   addr.setFromLocalPort(port);
162 
163   HTTPServer::IPConfig cfg \{
164     addr,
165     HTTPServer::Protocol::HTTP
166   \};
167 
168   \textcolor{keywordflow}{if} (sslCfg) \{
169     cfg.sslConfigs.push\_back(*sslCfg);
170   \}
171 
172   HTTPServerOptions options;
173   options.threads = numThreads;
174   options.handlerFactories.push\_back(std::move(f));
175   \textcolor{keywordflow}{return} start(std::move(cfg), std::move(options));
176 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!seconds\+Between@{seconds\+Between}}
\index{seconds\+Between@{seconds\+Between}!proxygen@{proxygen}}
\subsubsection[{seconds\+Between(std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$ finish, std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$ start)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock\+Type  = Steady\+Clock$>$ std\+::chrono\+::seconds proxygen\+::seconds\+Between (
\begin{DoxyParamCaption}
\item[{std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$}]{finish, }
\item[{std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$}]{start}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_aefa80ff652febfc8faeec2a2f8219b4e}


Definition at line 93 of file Time.\+h.



Referenced by seconds\+Since().


\begin{DoxyCode}
95                                           \{
96   \textcolor{keywordflow}{return} std::chrono::duration\_cast<std::chrono::seconds>(
97     finish - start);
98 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!seconds\+Since@{seconds\+Since}}
\index{seconds\+Since@{seconds\+Since}!proxygen@{proxygen}}
\subsubsection[{seconds\+Since(std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$ t)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Clock\+Type  = Steady\+Clock$>$ std\+::chrono\+::seconds proxygen\+::seconds\+Since (
\begin{DoxyParamCaption}
\item[{std\+::chrono\+::time\+\_\+point$<$ Clock\+Type $>$}]{t}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_ab8bbfb7951488a75d07af4ab593c5b1d}


Definition at line 107 of file Time.\+h.



References seconds\+Between().



Referenced by proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::on\+Create\+Transaction().


\begin{DoxyCode}
107                                                                        \{
108   \textcolor{keywordflow}{return} secondsBetween(getCurrentTime<ClockType>(), t);
109 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!seconds\+Since\+Epoch@{seconds\+Since\+Epoch}}
\index{seconds\+Since\+Epoch@{seconds\+Since\+Epoch}!proxygen@{proxygen}}
\subsubsection[{seconds\+Since\+Epoch()}]{\setlength{\rightskip}{0pt plus 5cm}std\+::chrono\+::seconds proxygen\+::seconds\+Since\+Epoch (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_a4b230cfaebf3beebff413040560544d8}


Definition at line 61 of file Time.\+h.


\begin{DoxyCode}
61                                             \{
62   \textcolor{keywordflow}{return} std::chrono::duration\_cast<std::chrono::seconds>(
63     std::chrono::system\_clock::now().time\_since\_epoch());
64 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!seconds\+Since\+Epoch@{seconds\+Since\+Epoch}}
\index{seconds\+Since\+Epoch@{seconds\+Since\+Epoch}!proxygen@{proxygen}}
\subsubsection[{seconds\+Since\+Epoch(\+Time\+Point t)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::chrono\+::seconds proxygen\+::seconds\+Since\+Epoch (
\begin{DoxyParamCaption}
\item[{{\bf Time\+Point}}]{t}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_aefd606cbab0e05b749c867f5f605c3b9}


Definition at line 71 of file Time.\+h.



References to\+System\+Time\+Point().


\begin{DoxyCode}
71                                                        \{
72   \textcolor{keywordflow}{return} std::chrono::duration\_cast<std::chrono::seconds>(
73     toSystemTimePoint(t).time\_since\_epoch());
74 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!string\+To\+Method@{string\+To\+Method}}
\index{string\+To\+Method@{string\+To\+Method}!proxygen@{proxygen}}
\subsubsection[{string\+To\+Method(folly\+::\+String\+Piece method)}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+Optional$<$ {\bf H\+T\+T\+P\+Method} $>$ proxygen\+::string\+To\+Method (
\begin{DoxyParamCaption}
\item[{folly\+::\+String\+Piece}]{method}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a40eefc133bcd9a7f21c1374a9cc5b7e1}
Returns the H\+T\+T\+P\+Method that matches the method. Although \doxyref{R\+F\+C2616}{p.}{namespaceproxygen_1_1RFC2616} 5.\+1.\+1 says methods are case-\/sensitive, we ignore case here since most programmers probably really meant \char`\"{}\+G\+E\+T\char`\"{} not \char`\"{}get\char`\"{}. If the method is not recognized, the return value will be None 

Definition at line 37 of file H\+T\+T\+P\+Method.\+cpp.



References case\+Insensitive\+Equal().



Referenced by main(), and proxygen\+::\+H\+T\+T\+P\+Message\+::set\+Method().


\begin{DoxyCode}
37                                                                   \{
38   FOR\_EACH\_ENUMERATE(index, cur, getMethodStrings()) \{
39     \textcolor{keywordflow}{if} (caseInsensitiveEqual(*cur, method)) \{
40       \textcolor{keywordflow}{return} HTTPMethod(index);
41     \}
42   \}
43   \textcolor{keywordflow}{return} folly::none;
44 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!strip\+Cntrl\+Chars@{strip\+Cntrl\+Chars}}
\index{strip\+Cntrl\+Chars@{strip\+Cntrl\+Chars}!proxygen@{proxygen}}
\subsubsection[{strip\+Cntrl\+Chars(const Str \&str)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename Str $>$ std\+::string proxygen\+::strip\+Cntrl\+Chars (
\begin{DoxyParamCaption}
\item[{const Str \&}]{str}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_af97dbf0d2353302566be279f1b2c9d9d}
Returns a std\+::string that has the control characters removed from the input string. 

Definition at line 849 of file H\+T\+T\+P\+Message.\+h.



Referenced by proxygen\+::\+H\+T\+T\+P\+Message\+::describe().


\begin{DoxyCode}
849                                           \{
850   std::string res;
851   res.reserve(str.length());
852   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < str.size(); ++i) \{
853     \textcolor{keywordflow}{if} (!(str[i] <= 0x1F || str[i] == 0x7F)) \{
854       res += str[i];
855     \}
856   \}
857   \textcolor{keywordflow}{return} res;
858 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Decoder\+Test, Test\+Item)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Decoder\+Test}}]{, }
\item[{Test\+Item}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_abee29f4dd61f12b3effd2548bd4528f8}


Definition at line 19 of file Structured\+Headers\+Decoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+Item(), and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag.


\begin{DoxyCode}
19                                                \{
20   std::string input = \textcolor{stringliteral}{"645643"};
21   StructuredHeadersDecoder shd(input);
22 
23   StructuredHeaderItem item;
24   shd.decodeItem(item);
25 
26   EXPECT\_EQ(item.tag, StructuredHeaderItem::Type::INT64);
27   EXPECT\_EQ(item, int64\_t(645643));
28 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+Integer)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+Integer}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a20638ca121d74505edd66caec73e2867}


Definition at line 22 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Item(), proxygen\+::\+Structured\+Headers\+Encoder\+::get(), proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
22                                                   \{
23   StructuredHeaderItem item;
24   int64\_t val = 2018;
25   item.tag = StructuredHeaderItem::Type::INT64;
26   item.value = val;
27 
28   StructuredHeadersEncoder encoder;
29   \textcolor{keyword}{auto} err = encoder.encodeItem(item);
30 
31   EXPECT\_EQ(err, EncodeError::OK);
32   EXPECT\_EQ(encoder.get(), \textcolor{stringliteral}{"2018"});
33 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Binary\+Content)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Binary\+Content}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a363f2d9a42b8f0f04ac68ccbbbf497e2}


Definition at line 23 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item(), and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag.


\begin{DoxyCode}
23                                                        \{
24   std::string input = \textcolor{stringliteral}{"*bWF4aW0gaXMgdGhlIGJlc3Q=*"};
25   StructuredHeadersBuffer shd(input);
26   StructuredHeaderItem output;
27   \textcolor{keyword}{auto} err = shd.parseItem(output);
28   EXPECT\_EQ(err, StructuredHeaders::DecodeError::OK);
29   EXPECT\_EQ(output.tag, StructuredHeaderItem::Type::BINARYCONTENT);
30   EXPECT\_EQ(output, std::string(\textcolor{stringliteral}{"maxim is the best"}));
31 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Q\+P\+A\+C\+K\+Header\+Table\+Tests, Indexing)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Q\+P\+A\+C\+K\+Header\+Table\+Tests}}]{, }
\item[{Indexing}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ab0a13e9c59a8bf9f4e71a5a327d3217b}


Definition at line 28 of file Q\+P\+A\+C\+K\+Header\+Table\+Tests.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Header\+::copy().


\begin{DoxyCode}
28                                         \{
29   HPACKHeader accept(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"gzip"});
30   HPACKHeader agent(\textcolor{stringliteral}{"user-agent"}, \textcolor{stringliteral}{"SeaMonkey"});
31 
32   EXPECT\_EQ(table\_.getBaseIndex(), 0);
33   table\_.add(accept.copy());
34   EXPECT\_EQ(table\_.getBaseIndex(), 1);
35   \textcolor{comment}{// Vulnerable - in the table}
36   EXPECT\_EQ(table\_.getIndex(accept, \textcolor{keyword}{false}),
37             std::numeric\_limits<uint32\_t>::max());
38   \textcolor{comment}{// Allow vulnerable, get the index}
39   EXPECT\_EQ(table\_.getIndex(accept, \textcolor{keyword}{true}), 1);
40   EXPECT\_TRUE(table\_.onTableStateSync(1));
41   EXPECT\_EQ(table\_.getIndex(accept, \textcolor{keyword}{false}), 1);
42   table\_.add(agent.copy());
43   \textcolor{comment}{// Indexes move}
44   EXPECT\_EQ(table\_.getIndex(agent, \textcolor{keyword}{true}), 1);
45   EXPECT\_EQ(table\_.getIndex(accept, \textcolor{keyword}{true}), 2);
46 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Decoder\+Test, Test\+List)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Decoder\+Test}}]{, }
\item[{Test\+List}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a21df31fca994ededce8439dd080bcbcd}


Definition at line 30 of file Structured\+Headers\+Decoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+List().


\begin{DoxyCode}
30                                                \{
31   std::string input = \textcolor{stringliteral}{"\(\backslash\)"cookies\(\backslash\)", 3.1415    , 74657"};
32   StructuredHeadersDecoder shd(input);
33 
34   std::vector<StructuredHeaderItem> v;
35   shd.decodeList(v);
36   EXPECT\_EQ(v.size(), 3);
37 
38   EXPECT\_EQ(v[0].tag, StructuredHeaderItem::Type::STRING);
39   EXPECT\_EQ(v[1].tag, StructuredHeaderItem::Type::DOUBLE);
40   EXPECT\_EQ(v[2].tag, StructuredHeaderItem::Type::INT64);
41 
42   EXPECT\_EQ(v[0], std::string(\textcolor{stringliteral}{"cookies"}));
43   EXPECT\_EQ(v[1], 3.1415);
44   EXPECT\_EQ(v[2], int64\_t(74657));
45 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Binary\+Content\+Illegal\+Characters)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Binary\+Content\+Illegal\+Characters}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ac95c0e58ab8da9f2042cf8e379bd1ddc}


Definition at line 33 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, and proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item().


\begin{DoxyCode}
33                                                                         \{
34   std::string input = \textcolor{stringliteral}{"*()645\(\backslash\)t  this is not a b64 encoded string (((\{]\}\}\}))*"};
35   StructuredHeadersBuffer shd(input);
36   StructuredHeaderItem output;
37   \textcolor{keyword}{auto} err = shd.parseItem(output);
38   EXPECT\_NE(err, StructuredHeaders::DecodeError::OK);
39 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+Integer\+Negative)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+Integer\+Negative}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_adfc428791da6d405d8adf260b08c5bff}


Definition at line 35 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Item(), proxygen\+::\+Structured\+Headers\+Encoder\+::get(), proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
35                                                           \{
36   StructuredHeaderItem item;
37   int64\_t val = -2018;
38   item.tag = StructuredHeaderItem::Type::INT64;
39   item.value = val;
40 
41   StructuredHeadersEncoder encoder;
42   \textcolor{keyword}{auto} err = encoder.encodeItem(item);
43 
44   EXPECT\_EQ(err, EncodeError::OK);
45   EXPECT\_EQ(encoder.get(), \textcolor{stringliteral}{"-2018"});
46 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Binary\+Content\+No\+Ending\+Asterisk)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Binary\+Content\+No\+Ending\+Asterisk}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a33afcc45d5cfe73ffe18053d17c31aff}


Definition at line 41 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, and proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item().


\begin{DoxyCode}
41                                                                        \{
42   std::string input = \textcolor{stringliteral}{"*seattle"};
43   StructuredHeadersBuffer shd(input);
44   StructuredHeaderItem output;
45   \textcolor{keyword}{auto} err = shd.parseItem(output);
46   EXPECT\_NE(err, StructuredHeaders::DecodeError::OK);
47 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Decoder\+Test, Test\+List\+Beginning\+Whitespace)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Decoder\+Test}}]{, }
\item[{Test\+List\+Beginning\+Whitespace}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a434abcf3626cd12767cc8d0f2d8a8952}


Definition at line 47 of file Structured\+Headers\+Decoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+List().


\begin{DoxyCode}
47                                                                   \{
48   std::string input = \textcolor{stringliteral}{"   19   , 95"};
49   StructuredHeadersDecoder shd(input);
50 
51   std::vector<StructuredHeaderItem> v;
52   shd.decodeList(v);
53   EXPECT\_EQ(v.size(), 2);
54 
55   EXPECT\_EQ(v[0].tag, StructuredHeaderItem::Type::INT64);
56   EXPECT\_EQ(v[1].tag, StructuredHeaderItem::Type::INT64);
57 
58   EXPECT\_EQ(v[0], int64\_t(19));
59   EXPECT\_EQ(v[1], int64\_t(95));
60 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Q\+P\+A\+C\+K\+Header\+Table\+Tests, Eviction)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Q\+P\+A\+C\+K\+Header\+Table\+Tests}}]{, }
\item[{Eviction}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a0ed853ade270b1a374c4df9fd2a15741}


Definition at line 48 of file Q\+P\+A\+C\+K\+Header\+Table\+Tests.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Header\+::bytes(), and proxygen\+::\+H\+P\+A\+C\+K\+Header\+::copy().


\begin{DoxyCode}
48                                         \{
49   HPACKHeader accept(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"gzip"});
50 
51   int32\_t max = 4;
52   uint32\_t capacity = accept.bytes() * max;
53   table\_.setCapacity(capacity);
54 
55   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = 0; i < max; i++) \{
56     EXPECT\_TRUE(table\_.add(accept.copy()));
57   \}
58   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = 1; i <= max; i++) \{
59     table\_.addRef(i);
60   \}
61   table\_.setMaxAcked(max);
62   EXPECT\_FALSE(table\_.canIndex(accept));
63   EXPECT\_FALSE(table\_.add(accept.copy()));
64   table\_.subRef(1);
65   EXPECT\_TRUE(table\_.canIndex(accept));
66   EXPECT\_TRUE(table\_.add(accept.copy()));
67 
68   table\_.subRef(3);
69   EXPECT\_FALSE(table\_.canIndex(accept));
70   table\_.subRef(2);
71   EXPECT\_TRUE(table\_.canIndex(accept));
72 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+Float)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+Float}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a2aba51be99ae43f2990c9726f0f39f88}


Definition at line 48 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Item(), proxygen\+::\+Structured\+Headers\+Encoder\+::get(), proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
48                                                 \{
49   StructuredHeaderItem item;
50   \textcolor{keywordtype}{double} val = 3.1415926535;
51   item.tag = StructuredHeaderItem::Type::DOUBLE;
52   item.value = val;
53 
54   StructuredHeadersEncoder encoder;
55   \textcolor{keyword}{auto} err = encoder.encodeItem(item);
56 
57   EXPECT\_EQ(err, EncodeError::OK);
58   EXPECT\_EQ(encoder.get(), \textcolor{stringliteral}{"3.1415926535"});
59 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Binary\+Content\+Empty)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Binary\+Content\+Empty}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a984887b0570a097df68bb8f4c3b7c68b}


Definition at line 49 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item(), and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag.


\begin{DoxyCode}
49                                                             \{
50   std::string input = \textcolor{stringliteral}{"**"};
51   StructuredHeadersBuffer shd(input);
52   StructuredHeaderItem output;
53   \textcolor{keyword}{auto} err = shd.parseItem(output);
54   EXPECT\_EQ(err, StructuredHeaders::DecodeError::OK);
55   EXPECT\_EQ(output.tag, StructuredHeaderItem::Type::BINARYCONTENT);
56   EXPECT\_EQ(output, std::string(\textcolor{stringliteral}{""}));
57 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Header\+Table\+Tests, Index\+Translation)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Header\+Table\+Tests}}]{, }
\item[{Index\+Translation}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_adbb096301b39f6348fc28f7c95a12828}


Definition at line 54 of file Header\+Table\+Tests.\+cpp.


\begin{DoxyCode}
54                                            \{
55   \textcolor{comment}{// simple cases}
56   length\_ = 10;
57   head\_ = 5;
58   xcheck(0, 6);
59   xcheck(3, 3);
60   xcheck(5, 1);
61 
62   \textcolor{comment}{// wrap}
63   head\_ = 1;
64   xcheck(0, 2);
65   xcheck(8, 4);
66   xcheck(5, 7);
67 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Identifier)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Identifier}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a83a2650554a5fdb4e87bbf56ba3ba8a0}


Definition at line 59 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Identifier(), and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag.


\begin{DoxyCode}
59                                                     \{
60   std::string input = \textcolor{stringliteral}{"abcdefg"};
61   StructuredHeadersBuffer shd(input);
62   StructuredHeaderItem output;
63   \textcolor{keyword}{auto} err = shd.parseIdentifier(output);
64   EXPECT\_EQ(err, StructuredHeaders::DecodeError::OK);
65   EXPECT\_EQ(output.tag, StructuredHeaderItem::Type::IDENTIFIER);
66   EXPECT\_EQ(output, std::string(\textcolor{stringliteral}{"abcdefg"}));
67 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+Float\+Too\+Much\+Precision)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+Float\+Too\+Much\+Precision}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_aacdc42bc32b96467f3846a7e258d454c}


Definition at line 61 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Item(), proxygen\+::\+Structured\+Headers\+Encoder\+::get(), proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
61                                                                 \{
62   StructuredHeadersEncoder encoder;
63   StructuredHeaderItem item;
64   \textcolor{keywordtype}{double} val = 100000.8392758372647; \textcolor{comment}{// has 20 characters}
65   item.tag = StructuredHeaderItem::Type::DOUBLE;
66   item.value = val;
67 
68   \textcolor{keyword}{auto} err = encoder.encodeItem(item);
69 
70   EXPECT\_EQ(err, EncodeError::OK);
71   EXPECT\_EQ(encoder.get(), \textcolor{stringliteral}{"100000.839275837"});
72 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Decoder\+Test, Test\+List\+Ending\+Whitespace)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Decoder\+Test}}]{, }
\item[{Test\+List\+Ending\+Whitespace}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ad777ab852129091ab216d692893107aa}


Definition at line 62 of file Structured\+Headers\+Decoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+List().


\begin{DoxyCode}
62                                                                \{
63   std::string input = \textcolor{stringliteral}{"19   , 95    "};
64   StructuredHeadersDecoder shd(input);
65 
66   std::vector<StructuredHeaderItem> v;
67   shd.decodeList(v);
68   EXPECT\_EQ(v.size(), 2);
69 
70   EXPECT\_EQ(v[0].tag, StructuredHeaderItem::Type::INT64);
71   EXPECT\_EQ(v[1].tag, StructuredHeaderItem::Type::INT64);
72 
73   EXPECT\_EQ(v[0], int64\_t(19));
74   EXPECT\_EQ(v[1], int64\_t(95));
75 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Identifier\+All\+Legal\+Characters)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Identifier\+All\+Legal\+Characters}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a63e1312150ebc743100afe15a2b0f3e4}


Definition at line 69 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Identifier(), and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag.


\begin{DoxyCode}
69                                                                       \{
70   std::string input = \textcolor{stringliteral}{"a0\_-*/"};
71   StructuredHeadersBuffer shd(input);
72   StructuredHeaderItem output;
73   \textcolor{keyword}{auto} err = shd.parseIdentifier(output);
74   EXPECT\_EQ(err, StructuredHeaders::DecodeError::OK);
75   EXPECT\_EQ(output.tag, StructuredHeaderItem::Type::IDENTIFIER);
76   EXPECT\_EQ(output, std::string(\textcolor{stringliteral}{"a0\_-*/"}));
77 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Header\+Table\+Tests, Add)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Header\+Table\+Tests}}]{, }
\item[{Add}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a26269ffdb3cfd75827e485f6a31e7f42}


Definition at line 69 of file Header\+Table\+Tests.\+cpp.



References proxygen\+::\+Header\+Table\+::add(), proxygen\+::\+H\+P\+A\+C\+K\+Header\+::copy(), proxygen\+::\+Header\+Table\+::has\+Name(), proxygen\+::\+H\+P\+A\+C\+K\+Header\+::name, proxygen\+::\+Header\+Table\+::name\+Index(), and proxygen\+::\+Header\+Table\+::names().


\begin{DoxyCode}
69                               \{
70   HeaderTable table(4096);
71   HPACKHeader header(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"gzip"});
72   table.add(header.copy());
73   table.add(header.copy());
74   table.add(header.copy());
75   EXPECT\_EQ(table.names().size(), 1);
76   EXPECT\_EQ(table.hasName(header.name), \textcolor{keyword}{true});
77   \textcolor{keyword}{auto} it = table.names().find(header.name);
78   EXPECT\_EQ(it->second.size(), 3);
79   EXPECT\_EQ(table.nameIndex(header.name), 1);
80 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Q\+P\+A\+C\+K\+Header\+Table\+Tests, Bad\+Eviction)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Q\+P\+A\+C\+K\+Header\+Table\+Tests}}]{, }
\item[{Bad\+Eviction}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ad8321273147a822ddeae904c892508b3}


Definition at line 74 of file Q\+P\+A\+C\+K\+Header\+Table\+Tests.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Header\+::bytes(), and proxygen\+::\+H\+P\+A\+C\+K\+Header\+::copy().


\begin{DoxyCode}
74                                            \{
75   HPACKHeader accept(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"gzip"});
76 
77   int32\_t max = 4;
78   uint32\_t capacity = accept.bytes() * max;
79   table\_.setCapacity(capacity);
80 
81   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = 0; i < max; i++) \{
82     EXPECT\_TRUE(table\_.add(accept.copy()));
83   \}
84   EXPECT\_EQ(table\_.size(), max);
85   EXPECT\_FALSE(table\_.setCapacity(capacity / 2));
86   EXPECT\_EQ(table\_.size(), max);
87 
88   \textcolor{comment}{// Ack all headers but mark the first as in use}
89   table\_.setMaxAcked(max);
90   table\_.addRef(1);
91   EXPECT\_FALSE(table\_.setCapacity(capacity / 2));
92 
93   \textcolor{comment}{// Clear all refs}
94   table\_.subRef(1);
95   EXPECT\_TRUE(table\_.setCapacity(capacity / 2));
96   EXPECT\_EQ(table\_.size(), max / 2);
97 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+Float\+Negative)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+Float\+Negative}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_aba6bfb868e403781d080f64b91823374}


Definition at line 74 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Item(), proxygen\+::\+Structured\+Headers\+Encoder\+::get(), proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
74                                                         \{
75   StructuredHeaderItem item;
76   \textcolor{keywordtype}{double} val = -3.141;
77   item.tag = StructuredHeaderItem::Type::DOUBLE;
78   item.value = val;
79 
80   StructuredHeadersEncoder encoder;
81   \textcolor{keyword}{auto} err = encoder.encodeItem(item);
82 
83   EXPECT\_EQ(err, EncodeError::OK);
84   EXPECT\_EQ(encoder.get(), \textcolor{stringliteral}{"-3.141"});
85 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Decoder\+Test, Test\+List\+No\+Whitespace)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Decoder\+Test}}]{, }
\item[{Test\+List\+No\+Whitespace}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a2e6ce1efab3b5bc848a83a7aeba8d1fb}


Definition at line 77 of file Structured\+Headers\+Decoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+List().


\begin{DoxyCode}
77                                                            \{
78   std::string input = \textcolor{stringliteral}{"19,95"};
79   StructuredHeadersDecoder shd(input);
80 
81   std::vector<StructuredHeaderItem> v;
82   shd.decodeList(v);
83   EXPECT\_EQ(v.size(), 2);
84 
85   EXPECT\_EQ(v[0].tag, StructuredHeaderItem::Type::INT64);
86   EXPECT\_EQ(v[1].tag, StructuredHeaderItem::Type::INT64);
87 
88   EXPECT\_EQ(v[0], int64\_t(19));
89   EXPECT\_EQ(v[1], int64\_t(95));
90 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Identifier\+Beginning\+Underscore)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Identifier\+Beginning\+Underscore}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a02f95f9e3219611205988f33bf79f1ae}


Definition at line 79 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, and proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Identifier().


\begin{DoxyCode}
79                                                                        \{
80   std::string input = \textcolor{stringliteral}{"\_af09d\_\_\_\_****"};
81   StructuredHeadersBuffer shd(input);
82   StructuredHeaderItem output;
83   \textcolor{keyword}{auto} err = shd.parseIdentifier(output);
84   EXPECT\_NE(err, StructuredHeaders::DecodeError::OK);
85 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Header\+Table\+Tests, Evict)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Header\+Table\+Tests}}]{, }
\item[{Evict}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a524e6d3f96bc4b5d9b0e292dd3107931}


Definition at line 82 of file Header\+Table\+Tests.\+cpp.



References proxygen\+::\+Header\+Table\+::add(), proxygen\+::\+H\+P\+A\+C\+K\+Header\+::bytes(), proxygen\+::\+H\+P\+A\+C\+K\+Header\+::copy(), proxygen\+::\+Header\+Table\+::get\+Header(), name, proxygen\+::\+Header\+Table\+::names(), and proxygen\+::\+Header\+Table\+::size().


\begin{DoxyCode}
82                                 \{
83   HPACKHeaderName name(\textcolor{stringliteral}{"accept-encoding"});
84   HPACKHeader accept(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"gzip"});
85   HPACKHeader accept2(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"----"}); \textcolor{comment}{// same size, different header}
86   HPACKHeader accept3(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"third"}); \textcolor{comment}{// size is larger with 1 byte}
87   uint32\_t max = 10;
88   uint32\_t capacity = accept.bytes() * max;
89   HeaderTable table(capacity);
90   \textcolor{comment}{// fill the table}
91   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < max; i++) \{
92     EXPECT\_EQ(table.add(accept.copy()), \textcolor{keyword}{true});
93   \}
94   EXPECT\_EQ(table.size(), max);
95   EXPECT\_EQ(table.add(accept2.copy()), \textcolor{keyword}{true});
96   \textcolor{comment}{// evict the first one}
97   EXPECT\_EQ(table.getHeader(1), accept2);
98   \textcolor{keyword}{auto} ilist = table.names().find(name)->second;
99   EXPECT\_EQ(ilist.size(), max);
100   \textcolor{comment}{// evict all the 'accept' headers}
101   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < max - 1; i++) \{
102     EXPECT\_EQ(table.add(accept2.copy()), \textcolor{keyword}{true});
103   \}
104   EXPECT\_EQ(table.size(), max);
105   EXPECT\_EQ(table.getHeader(max), accept2);
106   EXPECT\_EQ(table.names().size(), 1);
107   \textcolor{comment}{// add an entry that will cause 2 evictions}
108   EXPECT\_EQ(table.add(accept3.copy()), \textcolor{keyword}{true});
109   EXPECT\_EQ(table.getHeader(1), accept3);
110   EXPECT\_EQ(table.size(), max - 1);
111 
112   \textcolor{comment}{// add a super huge header}
113   \textcolor{keywordtype}{string} bigvalue;
114   bigvalue.append(capacity, \textcolor{charliteral}{'x'});
115   HPACKHeader bigheader(\textcolor{stringliteral}{"user-agent"}, bigvalue);
116   EXPECT\_EQ(table.add(bigheader.copy()), \textcolor{keyword}{false});
117   EXPECT\_EQ(table.size(), 0);
118   EXPECT\_EQ(table.names().size(), 0);
119 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+String)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+String}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a948ee6fd338ce647bf095081ea643594}


Definition at line 87 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item(), and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag.


\begin{DoxyCode}
87                                                 \{
88   std::string input = \textcolor{stringliteral}{"\(\backslash\)"fsdfsdf\(\backslash\)"sdfsdf\(\backslash\)""};
89   StructuredHeadersBuffer shd(input);
90   StructuredHeaderItem output;
91   \textcolor{keyword}{auto} err = shd.parseItem(output);
92   EXPECT\_EQ(err, StructuredHeaders::DecodeError::OK);
93   EXPECT\_EQ(output.tag, StructuredHeaderItem::Type::STRING);
94   EXPECT\_EQ(output, std::string(\textcolor{stringliteral}{"fsdfsdf"}));
95 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+String)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+String}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_acbe31e4e9d9458da6f90b15157b2c9d3}


Definition at line 87 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Item(), proxygen\+::\+Structured\+Headers\+Encoder\+::get(), proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
87                                                  \{
88   StructuredHeaderItem item;
89   std::string val = \textcolor{stringliteral}{"seattle is the best"};
90   item.tag = StructuredHeaderItem::Type::STRING;
91   item.value = val;
92 
93   StructuredHeadersEncoder encoder;
94   \textcolor{keyword}{auto} err = encoder.encodeItem(item);
95 
96   EXPECT\_EQ(err, EncodeError::OK);
97   EXPECT\_EQ(encoder.get(), \textcolor{stringliteral}{"\(\backslash\)"seattle is the best\(\backslash\)""});
98 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Decoder\+Test, Test\+List\+One\+Item)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Decoder\+Test}}]{, }
\item[{Test\+List\+One\+Item}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_aa6e6889866528d8d747e49923d218ea7}


Definition at line 92 of file Structured\+Headers\+Decoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+List().


\begin{DoxyCode}
92                                                       \{
93   std::string input = \textcolor{stringliteral}{"*Zm9vZA==*"};
94   StructuredHeadersDecoder shd(input);
95 
96   std::vector<StructuredHeaderItem> v;
97   shd.decodeList(v);
98   EXPECT\_EQ(v.size(), 1);
99 
100   EXPECT\_EQ(v[0].tag, StructuredHeaderItem::Type::BINARYCONTENT);
101 
102   EXPECT\_EQ(v[0], std::string(\textcolor{stringliteral}{"food"}));
103 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+String\+Escaped\+Quote)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+String\+Escaped\+Quote}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a30554847f32a13836eed4b65e507460d}


Definition at line 97 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item(), and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag.


\begin{DoxyCode}
97                                                             \{
98   std::string input = \textcolor{stringliteral}{"\(\backslash\)"abc\(\backslash\)\(\backslash\)\(\backslash\)"def\(\backslash\)""};
99   StructuredHeadersBuffer shd(input);
100   StructuredHeaderItem output;
101   \textcolor{keyword}{auto} err = shd.parseItem(output);
102   EXPECT\_EQ(err, StructuredHeaders::DecodeError::OK);
103   EXPECT\_EQ(output.tag, StructuredHeaderItem::Type::STRING);
104   EXPECT\_EQ(output, std::string(\textcolor{stringliteral}{"abc\(\backslash\)"def"}));
105 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Q\+P\+A\+C\+K\+Header\+Table\+Tests, Wrapcount)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Q\+P\+A\+C\+K\+Header\+Table\+Tests}}]{, }
\item[{Wrapcount}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a44757457703ff7a9168c5dc313ca3dc7}


Definition at line 99 of file Q\+P\+A\+C\+K\+Header\+Table\+Tests.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Header\+::copy().


\begin{DoxyCode}
99                                          \{
100   HPACKHeader accept(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"gzip"});
101   HPACKHeader agent(\textcolor{stringliteral}{"user-agent"}, \textcolor{stringliteral}{"SeaMonkey"});
102   HPACKHeader cookie(\textcolor{stringliteral}{"Cookie"}, \textcolor{stringliteral}{"choco=chip"});
103 
104   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = 0; i < 10; i++) \{
105     EXPECT\_TRUE(table\_.add(accept.copy()));
106     table\_.setMaxAcked(i + 1);
107   \}
108   EXPECT\_TRUE(table\_.add(cookie.copy()));
109   EXPECT\_TRUE(table\_.add(agent.copy()));
110 
111   EXPECT\_EQ(table\_.getBaseIndex(), 12);
112   EXPECT\_EQ(table\_.getIndex(agent, \textcolor{keyword}{true}), 1);
113   EXPECT\_EQ(table\_.getIndex(cookie, \textcolor{keyword}{true}), 2);
114   EXPECT\_EQ(table\_.getIndex(accept, \textcolor{keyword}{true}), 3);
115   EXPECT\_EQ(table\_.getHeader(1, table\_.getBaseIndex()), agent);
116   EXPECT\_EQ(table\_.getHeader(2, table\_.getBaseIndex()), cookie);
117   EXPECT\_EQ(table\_.getHeader(table\_.size(), table\_.getBaseIndex()), accept);
118 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+String\+Bad\+Content)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+String\+Bad\+Content}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a265fe73f3d19fe63ed60a51f064a721a}


Definition at line 100 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Item(), proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
100                                                            \{
101   StructuredHeaderItem item;
102   std::string val = \textcolor{stringliteral}{"seattle \(\backslash\)n is the best"};
103   item.tag = StructuredHeaderItem::Type::STRING;
104   item.value = val;
105 
106   StructuredHeadersEncoder encoder;
107   \textcolor{keyword}{auto} err = encoder.encodeItem(item);
108 
109   EXPECT\_NE(err, EncodeError::OK);
110 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Decoder\+Test, Test\+Dictionary\+Many\+Elts)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Decoder\+Test}}]{, }
\item[{Test\+Dictionary\+Many\+Elts}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_aff60de88eb6f91e8f5f7ee53b79ad4f2}


Definition at line 105 of file Structured\+Headers\+Decoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+Dictionary().


\begin{DoxyCode}
105                                                              \{
106   std::string input = \textcolor{stringliteral}{"age=87  ,  weight=150.8 ,   name=\(\backslash\)"John Doe\(\backslash\)""};
107   StructuredHeadersDecoder shd(input);
108 
109   std::unordered\_map<std::string, StructuredHeaderItem> m;
110   shd.decodeDictionary(m);
111   EXPECT\_EQ(m.size(), 3);
112 
113   EXPECT\_EQ(m[\textcolor{stringliteral}{"age"}].tag, StructuredHeaderItem::Type::INT64);
114   EXPECT\_EQ(m[\textcolor{stringliteral}{"weight"}].tag, StructuredHeaderItem::Type::DOUBLE);
115   EXPECT\_EQ(m[\textcolor{stringliteral}{"name"}].tag, StructuredHeaderItem::Type::STRING);
116 
117   EXPECT\_EQ(m[\textcolor{stringliteral}{"age"}], int64\_t(87));
118   EXPECT\_EQ(m[\textcolor{stringliteral}{"weight"}], 150.8);
119   EXPECT\_EQ(m[\textcolor{stringliteral}{"name"}], std::string(\textcolor{stringliteral}{"John Doe"}));
120 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+String\+Escaped\+Backslash)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+String\+Escaped\+Backslash}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a77f3b5757c24a4aa6975cae6bb6ca8da}


Definition at line 107 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item(), and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag.


\begin{DoxyCode}
107                                                                 \{
108   std::string input = \textcolor{stringliteral}{"\(\backslash\)"abc\(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)def\(\backslash\)""};
109   StructuredHeadersBuffer shd(input);
110   StructuredHeaderItem output;
111   \textcolor{keyword}{auto} err = shd.parseItem(output);
112   EXPECT\_EQ(err, StructuredHeaders::DecodeError::OK);
113   EXPECT\_EQ(output.tag, StructuredHeaderItem::Type::STRING);
114   EXPECT\_EQ(output, std::string(\textcolor{stringliteral}{"abc\(\backslash\)\(\backslash\)def"}));
115 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+String\+Backslash)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+String\+Backslash}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a92dab78ab40753e073cb1ee01bf632c8}


Definition at line 112 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Item(), proxygen\+::\+Structured\+Headers\+Encoder\+::get(), proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
112                                                           \{
113   StructuredHeaderItem item;
114   std::string val = \textcolor{stringliteral}{"seattle \(\backslash\)\(\backslash\)is the best"};
115   item.tag = StructuredHeaderItem::Type::STRING;
116   item.value = val;
117 
118   StructuredHeadersEncoder encoder;
119   \textcolor{keyword}{auto} err = encoder.encodeItem(item);
120 
121   EXPECT\_EQ(err, EncodeError::OK);
122   EXPECT\_EQ(encoder.get(), \textcolor{stringliteral}{"\(\backslash\)"seattle \(\backslash\)\(\backslash\)\(\backslash\)\(\backslash\)is the best\(\backslash\)""});
123 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+String\+Stray\+Backslash)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+String\+Stray\+Backslash}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ac960c4cc4ba22b4ac1bdc7b3c8b16bf6}


Definition at line 117 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, and proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item().


\begin{DoxyCode}
117                                                               \{
118   std::string input = \textcolor{stringliteral}{"\(\backslash\)"abc\(\backslash\)\(\backslash\)def\(\backslash\)""};
119   StructuredHeadersBuffer shd(input);
120   StructuredHeaderItem output;
121   \textcolor{keyword}{auto} err = shd.parseItem(output);
122   EXPECT\_NE(err, StructuredHeaders::DecodeError::OK);
123 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Q\+P\+A\+C\+K\+Header\+Table\+Tests, Name\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Q\+P\+A\+C\+K\+Header\+Table\+Tests}}]{, }
\item[{Name\+Index}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a91646a931eaa8591f239e8a9dfd25e18}


Definition at line 120 of file Q\+P\+A\+C\+K\+Header\+Table\+Tests.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Header\+::copy(), and proxygen\+::\+H\+P\+A\+C\+K\+Header\+::name.


\begin{DoxyCode}
120                                          \{
121   HPACKHeader accept(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"gzip"});
122   EXPECT\_EQ(table\_.nameIndex(accept.name), 0);
123   EXPECT\_TRUE(table\_.add(accept.copy()));
124   EXPECT\_EQ(table\_.nameIndex(accept.name), 1);
125 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Header\+Table\+Tests, Reduce\+Capacity)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Header\+Table\+Tests}}]{, }
\item[{Reduce\+Capacity}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_aafa51df236092fbbabe7dea00dd8e82e}


Definition at line 121 of file Header\+Table\+Tests.\+cpp.



References proxygen\+::\+Header\+Table\+::add(), proxygen\+::\+H\+P\+A\+C\+K\+Header\+::bytes(), proxygen\+::\+Header\+Table\+::bytes(), proxygen\+::\+H\+P\+A\+C\+K\+Header\+::copy(), proxygen\+::\+Header\+Table\+::get\+Max\+Table\+Length(), proxygen\+::\+Header\+Table\+::length(), proxygen\+::\+Header\+Table\+::set\+Capacity(), and proxygen\+::\+Header\+Table\+::size().


\begin{DoxyCode}
121                                          \{
122   HPACKHeader accept(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"gzip"});
123   uint32\_t max = 10;
124   uint32\_t capacity = accept.bytes() * max;
125   HeaderTable table(capacity);
126   EXPECT\_LE(table.length(), table.getMaxTableLength(capacity));
127 
128   \textcolor{comment}{// fill the table}
129   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < max; i++) \{
130     EXPECT\_EQ(table.add(accept.copy()), \textcolor{keyword}{true});
131   \}
132   \textcolor{comment}{// change capacity}
133   table.setCapacity(capacity / 2);
134   EXPECT\_EQ(table.size(), max / 2);
135   EXPECT\_EQ(table.bytes(), capacity / 2);
136 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Decoder\+Test, Test\+Dictionary\+One\+Elt)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Decoder\+Test}}]{, }
\item[{Test\+Dictionary\+One\+Elt}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_af7c09e6a7a4105e7c21c68292f07288d}


Definition at line 122 of file Structured\+Headers\+Decoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+Dictionary().


\begin{DoxyCode}
122                                                            \{
123   std::string input = \textcolor{stringliteral}{"bagel=*YXZvY2Fkbw==*"};
124   StructuredHeadersDecoder shd(input);
125 
126   std::unordered\_map<std::string, StructuredHeaderItem> m;
127   shd.decodeDictionary(m);
128   EXPECT\_EQ(m.size(), 1);
129 
130   EXPECT\_EQ(m[\textcolor{stringliteral}{"bagel"}].tag, StructuredHeaderItem::Type::BINARYCONTENT);
131   EXPECT\_EQ(m[\textcolor{stringliteral}{"bagel"}], std::string(\textcolor{stringliteral}{"avocado"}));
132 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+String\+Invalid\+Character)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+String\+Invalid\+Character}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a2d8e9f4602a20670491b14191c1230c9}


Definition at line 125 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, and proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item().


\begin{DoxyCode}
125                                                                 \{
126   std::string input = \textcolor{stringliteral}{"\(\backslash\)"abcdefg\(\backslash\)thij\(\backslash\)""};
127   StructuredHeadersBuffer shd(input);
128   StructuredHeaderItem output;
129   \textcolor{keyword}{auto} err = shd.parseItem(output);
130   EXPECT\_NE(err, StructuredHeaders::DecodeError::OK);
131 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+String\+Quote)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+String\+Quote}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a0c4acb2e3de1d6efedfa4896fd5d8397}


Definition at line 125 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Item(), proxygen\+::\+Structured\+Headers\+Encoder\+::get(), proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
125                                                       \{
126   StructuredHeaderItem item;
127   std::string val = \textcolor{stringliteral}{"seattle \(\backslash\)"is the best"};
128   item.tag = StructuredHeaderItem::Type::STRING;
129   item.value = val;
130 
131   StructuredHeadersEncoder encoder;
132   \textcolor{keyword}{auto} err = encoder.encodeItem(item);
133 
134   EXPECT\_EQ(err, EncodeError::OK);
135   EXPECT\_EQ(encoder.get(), \textcolor{stringliteral}{"\(\backslash\)"seattle \(\backslash\)\(\backslash\)\(\backslash\)"is the best\(\backslash\)""});
136 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Q\+P\+A\+C\+K\+Header\+Table\+Tests, Get\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Q\+P\+A\+C\+K\+Header\+Table\+Tests}}]{, }
\item[{Get\+Index}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a930df37df6272143550bcd127b2d7bae}


Definition at line 127 of file Q\+P\+A\+C\+K\+Header\+Table\+Tests.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Header\+::copy().


\begin{DoxyCode}
127                                         \{
128   HPACKHeader accept1(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"gzip"});
129   HPACKHeader accept2(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"blarf"});
130   EXPECT\_EQ(table\_.getIndex(accept1), 0);
131   EXPECT\_TRUE(table\_.add(accept1.copy()));
132   EXPECT\_EQ(table\_.getIndex(accept1), 1);
133   EXPECT\_EQ(table\_.getIndex(accept2), 0);
134 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Basic)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Basic}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a30a2263b5df41ffe8a7bcc1917487238}


Definition at line 131 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
131                          \{
132   buildSimpleTree();
133   dump();
134   EXPECT\_EQ(nodes\_, IDList(\{\{0, 100\}, \{3, 25\}, \{5, 25\}, \{9, 100\}, \{7, 50\}\}));
135 
136   \textcolor{comment}{// Add another node, make sure we get the correct depth.}
137   uint64\_t depth;
138   addTransaction(11, \{7, \textcolor{keyword}{false}, 15\}, \textcolor{keyword}{false}, &depth);
139   EXPECT\_EQ(depth, 3);
140 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+String\+Parsing\+Repeated)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+String\+Parsing\+Repeated}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_aa8eb475ab7246ea9a2c57a468cfb9bb5}


Definition at line 133 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item(), and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag.


\begin{DoxyCode}
133                                                                \{
134   std::string input = \textcolor{stringliteral}{"\(\backslash\)"proxy\(\backslash\)"\(\backslash\)"gen\(\backslash\)""};
135   StructuredHeadersBuffer shd(input);
136   StructuredHeaderItem output;
137   \textcolor{keyword}{auto} err = shd.parseItem(output);
138   EXPECT\_EQ(err, StructuredHeaders::DecodeError::OK);
139   EXPECT\_EQ(output.tag, StructuredHeaderItem::Type::STRING);
140   EXPECT\_EQ(output, std::string(\textcolor{stringliteral}{"proxy"}));
141 
142   err = shd.parseItem(output);
143   EXPECT\_EQ(err, StructuredHeaders::DecodeError::OK);
144   EXPECT\_EQ(output.tag, StructuredHeaderItem::Type::STRING);
145   EXPECT\_EQ(output, std::string(\textcolor{stringliteral}{"gen"}));
146 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Decoder\+Test, Test\+Param\+List\+One\+Elt)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Decoder\+Test}}]{, }
\item[{Test\+Param\+List\+One\+Elt}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_abd0c64f34346720297188b524bd0d902}


Definition at line 134 of file Structured\+Headers\+Decoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+Parameterised\+List().


\begin{DoxyCode}
134                                                           \{
135   std::string input = \textcolor{stringliteral}{"abc\_123;a=1;b=2"};
136   StructuredHeadersDecoder shd(input);
137 
138   ParameterisedList pl;
139   shd.decodeParameterisedList(pl);
140   EXPECT\_EQ(pl.size(), 1);
141   EXPECT\_EQ(pl[0].identifier, \textcolor{stringliteral}{"abc\_123"});
142   EXPECT\_EQ(pl[0].parameterMap.size(), 2);
143   EXPECT\_EQ(pl[0].parameterMap[\textcolor{stringliteral}{"a"}], int64\_t(1));
144   EXPECT\_EQ(pl[0].parameterMap[\textcolor{stringliteral}{"b"}], int64\_t(2));
145 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Q\+P\+A\+C\+K\+Header\+Table\+Tests, Duplication)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Q\+P\+A\+C\+K\+Header\+Table\+Tests}}]{, }
\item[{Duplication}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_aaf7f6c2440f538777eb0185ee6499f10}


Definition at line 136 of file Q\+P\+A\+C\+K\+Header\+Table\+Tests.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Header\+::copy().


\begin{DoxyCode}
136                                            \{
137   HPACKHeader accept(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"gzip"});
138 
139   EXPECT\_TRUE(table\_.add(accept.copy()));
140 
141   \textcolor{comment}{// Unnecessary duplicate}
142   \textcolor{keyword}{auto} res = table\_.maybeDuplicate(1, \textcolor{keyword}{true});
143   EXPECT\_FALSE(res.first);
144   EXPECT\_EQ(res.second, 1);
145 
146   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = 0; i < 6; i++) \{
147     EXPECT\_TRUE(table\_.add(accept.copy()));
148     \textcolor{comment}{// Ack the first few entries so they can be evicted}
149     table\_.setMaxAcked(std::min(3u, table\_.getBaseIndex()));
150   \}
151 
152   \textcolor{comment}{// successful duplicate, vulnerable allowed}
153   EXPECT\_TRUE(table\_.isDraining(table\_.size()));
154   res = table\_.maybeDuplicate(table\_.size(), \textcolor{keyword}{true});
155   EXPECT\_TRUE(res.first);
156   EXPECT\_EQ(res.second, 8);
157   EXPECT\_EQ(table\_.size(), 6); \textcolor{comment}{// evicted 1}
158 
159   \textcolor{comment}{// successful duplicate, vulnerable disallowed}
160   EXPECT\_TRUE(table\_.onTableStateSync(3));
161   res = table\_.maybeDuplicate(table\_.size(), \textcolor{keyword}{false});
162   EXPECT\_TRUE(res.first);
163   EXPECT\_EQ(res.second, 0);
164   EXPECT\_EQ(table\_.size(), 6); \textcolor{comment}{// evicted 2}
165 
166   \textcolor{comment}{// Attempt to duplicate UNACKED}
167   res = table\_.maybeDuplicate(QPACKHeaderTable::UNACKED, \textcolor{keyword}{true});
168   EXPECT\_FALSE(res.first);
169   EXPECT\_EQ(res.second, 0);
170   EXPECT\_EQ(table\_.size(), 6); \textcolor{comment}{// nothing changed}
171   EXPECT\_EQ(table\_.getBaseIndex(), 9);
172 
173   \textcolor{comment}{// Hold a ref to oldest entry, prevents eviction}
174   \textcolor{keyword}{auto} oldestAbsolute = table\_.getBaseIndex() - table\_.size() + 1;
175   table\_.addRef(oldestAbsolute);
176 
177   \textcolor{comment}{// Table should be full}
178   EXPECT\_FALSE(table\_.canIndex(accept));
179 
180   res = table\_.maybeDuplicate(table\_.size(), \textcolor{keyword}{true});
181   EXPECT\_FALSE(res.first);
182   EXPECT\_EQ(res.second, 0);
183 
184 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+Binary\+Content)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+Binary\+Content}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ab7df719ec755f2ac9f46404bd05cebd6}


Definition at line 138 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Item(), proxygen\+::\+Structured\+Headers\+Encoder\+::get(), proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
138                                                         \{
139   StructuredHeaderItem item;
140   std::string val = \textcolor{stringliteral}{"seattle <3"};
141   item.tag = StructuredHeaderItem::Type::BINARYCONTENT;
142   item.value = val;
143 
144   StructuredHeadersEncoder encoder;
145   \textcolor{keyword}{auto} err = encoder.encodeItem(item);
146 
147   EXPECT\_EQ(err, EncodeError::OK);
148   EXPECT\_EQ(encoder.get(), \textcolor{stringliteral}{"*c2VhdHRsZSA8Mw==*"});
149 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Header\+Table\+Tests, Comparison)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Header\+Table\+Tests}}]{, }
\item[{Comparison}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a2c21115544fd6267229c0d8884de0729}


Definition at line 138 of file Header\+Table\+Tests.\+cpp.



References proxygen\+::\+Header\+Table\+::add(), and proxygen\+::\+H\+P\+A\+C\+K\+Header\+::copy().


\begin{DoxyCode}
138                                      \{
139   uint32\_t capacity = 128;
140   HeaderTable t1(capacity);
141   HeaderTable t2(capacity);
142 
143   HPACKHeader h1(\textcolor{stringliteral}{"Content-Encoding"}, \textcolor{stringliteral}{"gzip"});
144   HPACKHeader h2(\textcolor{stringliteral}{"Content-Encoding"}, \textcolor{stringliteral}{"deflate"});
145   \textcolor{comment}{// different in number of elements}
146   t1.add(h1.copy());
147   EXPECT\_FALSE(t1 == t2);
148   \textcolor{comment}{// different in size (bytes)}
149   t2.add(h2.copy());
150   EXPECT\_FALSE(t1 == t2);
151 
152   \textcolor{comment}{// make them the same}
153   t1.add(h2.copy());
154   t2.add(h1.copy());
155   EXPECT\_TRUE(t1 == t2);
156 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Remove\+Leaf)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Remove\+Leaf}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a5c00d6814776ade3cdc09bf9e3c7b427}


Definition at line 142 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
142                               \{
143   buildSimpleTree();
144 
145   removeTransaction(3);
146   dump();
147 
148   EXPECT\_EQ(nodes\_, IDList(\{\{0, 100\}, \{5, 33\}, \{9, 100\}, \{7, 66\}\}));
149 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Decoder\+Test, Test\+Param\+List\+Many\+Elts)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Decoder\+Test}}]{, }
\item[{Test\+Param\+List\+Many\+Elts}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_aae3979ea4d4bccc032aac86765765d80}


Definition at line 147 of file Structured\+Headers\+Decoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+Parameterised\+List().


\begin{DoxyCode}
147                                                             \{
148   std::string input = \textcolor{stringliteral}{"a\_13;a=1;b=2; c\_4, ghi;q=\(\backslash\)"9\(\backslash\)";r=*bWF4IGlzIGF3ZXNvbWU=*"};
149   StructuredHeadersDecoder shd(input);
150 
151   ParameterisedList pl;
152   shd.decodeParameterisedList(pl);
153   EXPECT\_EQ(pl.size(), 2);
154 
155   EXPECT\_EQ(pl[0].identifier, \textcolor{stringliteral}{"a\_13"});
156   EXPECT\_EQ(pl[0].parameterMap.size(), 3);
157   EXPECT\_EQ(pl[0].parameterMap[\textcolor{stringliteral}{"a"}].tag, StructuredHeaderItem::Type::INT64);
158   EXPECT\_EQ(pl[0].parameterMap[\textcolor{stringliteral}{"b"}].tag, StructuredHeaderItem::Type::INT64);
159   EXPECT\_EQ(pl[0].parameterMap[\textcolor{stringliteral}{"c\_4"}].tag, StructuredHeaderItem::Type::NONE);
160   EXPECT\_EQ(pl[0].parameterMap[\textcolor{stringliteral}{"a"}], int64\_t(1));
161   EXPECT\_EQ(pl[0].parameterMap[\textcolor{stringliteral}{"b"}], int64\_t(2));
162 
163   EXPECT\_EQ(pl[1].identifier, \textcolor{stringliteral}{"ghi"});
164   EXPECT\_EQ(pl[1].parameterMap.size(), 2);
165   EXPECT\_EQ(pl[1].parameterMap[\textcolor{stringliteral}{"q"}].tag, StructuredHeaderItem::Type::STRING);
166   EXPECT\_EQ(pl[1].parameterMap[\textcolor{stringliteral}{"r"}].tag,
167     StructuredHeaderItem::Type::BINARYCONTENT);
168   EXPECT\_EQ(pl[1].parameterMap[\textcolor{stringliteral}{"q"}], std::string(\textcolor{stringliteral}{"9"}));
169   EXPECT\_EQ(pl[1].parameterMap[\textcolor{stringliteral}{"r"}], std::string(\textcolor{stringliteral}{"max is awesome"}));
170 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Integer)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Integer}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a379bf1a900b8eea9ccf56a9ca4879b93}


Definition at line 148 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item(), and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag.


\begin{DoxyCode}
148                                                  \{
149   std::string input = \textcolor{stringliteral}{"843593"};
150   StructuredHeadersBuffer shd(input);
151   StructuredHeaderItem output;
152   \textcolor{keyword}{auto} err = shd.parseItem(output);
153   EXPECT\_EQ(err, StructuredHeaders::DecodeError::OK);
154   EXPECT\_EQ(output.tag, StructuredHeaderItem::Type::INT64);
155   EXPECT\_EQ(output, int64\_t(843593));
156 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+Identifier)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+Identifier}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a6048e860070338cd223d83c5fd665e09}


Definition at line 151 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Identifier(), and proxygen\+::\+Structured\+Headers\+Encoder\+::get().


\begin{DoxyCode}
151                                                      \{
152   std::string result;
153   std::string val = \textcolor{stringliteral}{"abc\_00123"};
154 
155   StructuredHeadersEncoder encoder;
156   \textcolor{keyword}{auto} err = encoder.encodeIdentifier(val);
157 
158   EXPECT\_EQ(err, EncodeError::OK);
159   EXPECT\_EQ(encoder.get(), \textcolor{stringliteral}{"abc\_00123"});
160 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Remove\+Parent)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Remove\+Parent}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a2159b9698ce5e4eeaa6322be6abbc09c}


Definition at line 151 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
151                                 \{
152   buildSimpleTree();
153 
154   removeTransaction(5);
155   dump();
156 
157   EXPECT\_EQ(nodes\_, IDList(\{\{0, 100\}, \{3, 25\}, \{7, 50\}, \{9, 25\}\}));
158 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Integer\+Two\+Negatives)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Integer\+Two\+Negatives}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ab43882da5d33e07f53913adbf6648d48}


Definition at line 158 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, and proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item().


\begin{DoxyCode}
158                                                              \{
159   std::string input = \textcolor{stringliteral}{"--843593"};
160   StructuredHeadersBuffer shd(input);
161   StructuredHeaderItem output;
162   \textcolor{keyword}{auto} err = shd.parseItem(output);
163   EXPECT\_NE(err, StructuredHeaders::DecodeError::OK);
164 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Header\+Table\+Tests, Print)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Header\+Table\+Tests}}]{, }
\item[{Print}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_acbae795f2ae88bb30da40ed0aee12316}


Definition at line 158 of file Header\+Table\+Tests.\+cpp.



References proxygen\+::\+Header\+Table\+::add().


\begin{DoxyCode}
158                                 \{
159   stringstream out;
160   HeaderTable t(128);
161   t.add(HPACKHeader(\textcolor{stringliteral}{"Accept-Encoding"}, \textcolor{stringliteral}{"gzip"}));
162   out << t;
163   EXPECT\_EQ(out.str(),
164   \textcolor{stringliteral}{"\(\backslash\)n[1] (s=51) accept-encoding: gzip\(\backslash\)ntotal size: 51\(\backslash\)n"});
165 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Remove\+Parent\+Weights)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Remove\+Parent\+Weights}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a77e720cd4c7afc7e0628523739dfc223}


Definition at line 160 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
160                                        \{
161   \textcolor{comment}{// weight\_ / totalChildWeight\_ < 1}
162   addTransaction(0, \{kRootNodeId, \textcolor{keyword}{false}, 0\});
163   addTransaction(3, \{0, \textcolor{keyword}{false}, 255\});
164   addTransaction(5, \{0, \textcolor{keyword}{false}, 255\});
165 
166   removeTransaction(0);
167   dump();
168 
169   EXPECT\_EQ(nodes\_, IDList(\{\{3, 50\}, \{5, 50\}\}));
170 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+Identifier\+Bad\+Content)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+Identifier\+Bad\+Content}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a29036cb805ee0492894dbbd4f7d7e907}


Definition at line 162 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Identifier().


\begin{DoxyCode}
162                                                                \{
163   std::string result;
164   std::string val = \textcolor{stringliteral}{"\_abc\_00123"};
165 
166   StructuredHeadersEncoder encoder;
167   \textcolor{keyword}{auto} err = encoder.encodeIdentifier(val);
168 
169   EXPECT\_NE(err, EncodeError::OK);
170 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Integer\+Empty\+After\+Negative)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Integer\+Empty\+After\+Negative}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a04a91b6d91bd9590734c93d24d8a8150}


Definition at line 166 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, and proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item().


\begin{DoxyCode}
166                                                                    \{
167   std::string input = \textcolor{stringliteral}{"-"};
168   StructuredHeadersBuffer shd(input);
169   StructuredHeaderItem output;
170   \textcolor{keyword}{auto} err = shd.parseItem(output);
171   EXPECT\_NE(err, StructuredHeaders::DecodeError::OK);
172 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Header\+Table\+Tests, Increase\+Capacity)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Header\+Table\+Tests}}]{, }
\item[{Increase\+Capacity}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a0cf661be1becea8a798fc6ca67c39e19}


Definition at line 167 of file Header\+Table\+Tests.\+cpp.



References proxygen\+::\+Header\+Table\+::add(), proxygen\+::\+H\+P\+A\+C\+K\+Header\+::bytes(), proxygen\+::\+H\+P\+A\+C\+K\+Header\+::copy(), proxygen\+::\+Header\+Table\+::get\+Index(), proxygen\+::\+Header\+Table\+::get\+Max\+Table\+Length(), proxygen\+::\+Header\+Table\+::length(), proxygen\+::\+Header\+Table\+::set\+Capacity(), and proxygen\+::\+Header\+Table\+::size().


\begin{DoxyCode}
167                                            \{
168   HPACKHeader accept(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"gzip"});
169   uint32\_t max = 4;
170   uint32\_t capacity = accept.bytes() * max;
171   HeaderTable table(capacity);
172   EXPECT\_LE(table.length(), table.getMaxTableLength(capacity));
173 
174   \textcolor{comment}{// fill the table}
175   uint32\_t length = table.length() + 1;
176   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < length; i++) \{
177     EXPECT\_EQ(table.add(accept.copy()), \textcolor{keyword}{true});
178   \}
179   EXPECT\_EQ(table.size(), max);
180   EXPECT\_EQ(table.getIndex(accept), 1);
181   \textcolor{comment}{// head should be 0, tail should be 2}
182   max = 8;
183   capacity = accept.bytes() * max;
184   table.setCapacity(capacity);
185 
186   EXPECT\_LE(table.length(), table.getMaxTableLength(capacity));
187   \textcolor{comment}{// external index didn't change}
188   EXPECT\_EQ(table.getIndex(accept), 1);
189 
190 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Decoder\+Test, Test\+Param\+List\+No\+Params)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Decoder\+Test}}]{, }
\item[{Test\+Param\+List\+No\+Params}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ad9c11023dc9c5cd2be1dd552609427fe}


Definition at line 172 of file Structured\+Headers\+Decoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+Parameterised\+List().


\begin{DoxyCode}
172                                                             \{
173   std::string input = \textcolor{stringliteral}{"apple12, cat14, dog22"};
174   StructuredHeadersDecoder shd(input);
175 
176   ParameterisedList pl;
177   shd.decodeParameterisedList(pl);
178   EXPECT\_EQ(pl.size(), 3);
179   EXPECT\_EQ(pl[0].identifier, \textcolor{stringliteral}{"apple12"});
180   EXPECT\_EQ(pl[0].parameterMap.size(), 0);
181 
182   EXPECT\_EQ(pl[1].identifier, \textcolor{stringliteral}{"cat14"});
183   EXPECT\_EQ(pl[1].parameterMap.size(), 0);
184 
185   EXPECT\_EQ(pl[2].identifier, \textcolor{stringliteral}{"dog22"});
186   EXPECT\_EQ(pl[2].parameterMap.size(), 0);
187 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Node\+Depth)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Node\+Depth}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a1b56e9641f3b56245f9f2f47c2271b47}


Definition at line 172 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
172                              \{
173   uint64\_t depth\{33\}; \textcolor{comment}{// initialize to some wrong value}
174   addTransaction(0, \{kRootNodeId, \textcolor{keyword}{false}, 15\}, \textcolor{keyword}{false}, &depth);
175   EXPECT\_EQ(depth, 1);
176 
177   addTransaction(3, \{0, \textcolor{keyword}{false}, 3\}, \textcolor{keyword}{false}, &depth);
178   EXPECT\_EQ(depth, 2);
179 
180   addTransaction(5, \{3, \textcolor{keyword}{true}, 7\}, \textcolor{keyword}{false}, &depth);
181   EXPECT\_EQ(depth, 3);
182 
183   addTransaction(9, \{0, \textcolor{keyword}{false}, 3\}, \textcolor{keyword}{true}, &depth);
184   EXPECT\_EQ(depth, 2);
185   EXPECT\_EQ(q\_.numPendingEgress(), 3);
186   EXPECT\_EQ(q\_.numVirtualNodes(), 1);
187 
188   depth = 55; \textcolor{comment}{// some unlikely depth}
189   addTransaction(9, \{0, \textcolor{keyword}{false}, 31\}, \textcolor{keyword}{false}, &depth);
190   EXPECT\_EQ(depth, 2);
191   EXPECT\_EQ(q\_.numPendingEgress(), 4);
192   EXPECT\_EQ(q\_.numVirtualNodes(), 0);
193 
194   addTransaction(11, \{0, \textcolor{keyword}{true}, 7\}, \textcolor{keyword}{false}, &depth);
195   EXPECT\_EQ(depth, 2);
196   EXPECT\_EQ(q\_.numPendingEgress(), 5);
197   EXPECT\_EQ(q\_.numVirtualNodes(), 0);
198 
199   addTransaction(13, \{kRootNodeId, \textcolor{keyword}{true}, 23\}, \textcolor{keyword}{true}, &depth);
200   EXPECT\_EQ(depth, 1);
201   EXPECT\_EQ(q\_.numPendingEgress(), 5);
202   EXPECT\_EQ(q\_.numVirtualNodes(), 1);
203 
204   depth = 77; \textcolor{comment}{// some unlikely depth}
205   addTransaction(13, \{kRootNodeId, \textcolor{keyword}{true}, 33\}, \textcolor{keyword}{false}, &depth);
206   EXPECT\_EQ(depth, 1);
207   EXPECT\_EQ(q\_.numPendingEgress(), 6);
208   EXPECT\_EQ(q\_.numVirtualNodes(), 0);
209 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+Wrong\+Type)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+Wrong\+Type}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_acad9d11278e3d2ca93612ba9eda8e2a1}


Definition at line 172 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Item(), proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
172                                                     \{
173   StructuredHeaderItem item;
174   \textcolor{keywordtype}{double} val = 3.1415;
175   item.tag = StructuredHeaderItem::Type::INT64;
176   item.value = val;
177 
178   StructuredHeadersEncoder encoder;
179   \textcolor{keyword}{auto} err = encoder.encodeItem(item);
180 
181   EXPECT\_NE(err, EncodeError::OK);
182 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Integer\+Negative)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Integer\+Negative}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a1db1f9aed613c29327c1fbe94c64fef9}


Definition at line 174 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item(), and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag.


\begin{DoxyCode}
174                                                          \{
175   std::string input = \textcolor{stringliteral}{"-843593"};
176   StructuredHeadersBuffer shd(input);
177   StructuredHeaderItem output;
178   \textcolor{keyword}{auto} err = shd.parseItem(output);
179   EXPECT\_EQ(err, StructuredHeaders::DecodeError::OK);
180   EXPECT\_EQ(output.tag, StructuredHeaderItem::Type::INT64);
181   EXPECT\_EQ(output, int64\_t(-843593));
182 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Integer\+Overflow)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Integer\+Overflow}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a946fd9699f0690f9e97cd6d83b78d621}


Definition at line 184 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, and proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item().


\begin{DoxyCode}
184                                                          \{
185   std::string input = \textcolor{stringliteral}{"9223372036854775808"};
186   StructuredHeadersBuffer shd(input);
187   StructuredHeaderItem output;
188   \textcolor{keyword}{auto} err = shd.parseItem(output);
189   EXPECT\_NE(err, StructuredHeaders::DecodeError::OK);
190 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+List\+Many\+Elts)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+List\+Many\+Elts}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ab5f2236d2d9f9da6ba19f7397ee0cca0}


Definition at line 184 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+List(), proxygen\+::\+Structured\+Headers\+Encoder\+::get(), proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
184                                                        \{
185   std::vector<StructuredHeaderItem> vec;
186   StructuredHeaderItem item;
187 
188   item.tag = StructuredHeaderItem::Type::DOUBLE;
189   \textcolor{keywordtype}{double} val1 = 3.14;
190   item.value = val1;
191   vec.push\_back(item);
192 
193   item.tag = StructuredHeaderItem::Type::BINARYCONTENT;
194   std::string val2 = \textcolor{stringliteral}{"pizza"};
195   item.value = val2;
196   vec.push\_back(item);
197 
198   item.tag = StructuredHeaderItem::Type::INT64;
199   int64\_t val3 = 65;
200   item.value = val3;
201   vec.push\_back(item);
202 
203   StructuredHeadersEncoder encoder;
204   \textcolor{keyword}{auto} err = encoder.encodeList(vec);
205 
206   EXPECT\_EQ(err, EncodeError::OK);
207   EXPECT\_EQ(encoder.get(), \textcolor{stringliteral}{"3.14, *cGl6emE=*, 65"});
208 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Q\+P\+A\+C\+K\+Header\+Table\+Tests, Can\+Evict\+With\+Room)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Q\+P\+A\+C\+K\+Header\+Table\+Tests}}]{, }
\item[{Can\+Evict\+With\+Room}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_afe73973ffcc21c14f37a5b3206f1d35c}


Definition at line 186 of file Q\+P\+A\+C\+K\+Header\+Table\+Tests.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Header\+::copy().


\begin{DoxyCode}
186                                                 \{
187   HPACKHeader thirtyNineBytes(\textcolor{stringliteral}{"abcd"}, \textcolor{stringliteral}{"efg"});
188   HPACKHeader fortySevenBytes(\textcolor{stringliteral}{"abcd"}, \textcolor{stringliteral}{"efghijklmno"});
189   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = 0; i < 8; i++) \{
190     EXPECT\_TRUE(table\_.add(thirtyNineBytes.copy()));
191   \}
192   table\_.setMaxAcked(table\_.getBaseIndex());
193   \textcolor{comment}{// abs index = 1 is evictable, but index = 2 is referenced, so we can}
194   \textcolor{comment}{// insert up to (320 - 8 * 39) + 39 = 47}
195   table\_.addRef(2);
196   EXPECT\_TRUE(table\_.canIndex(fortySevenBytes));
197   EXPECT\_TRUE(table\_.add(fortySevenBytes.copy()));
198 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Decoder\+Test, Test\+Param\+List\+Whitespace)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Decoder\+Test}}]{, }
\item[{Test\+Param\+List\+Whitespace}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a588dbae85883533bc1630cb6fb68f57a}


Definition at line 189 of file Structured\+Headers\+Decoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+Parameterised\+List().


\begin{DoxyCode}
189                                                               \{
190   std::string input = \textcolor{stringliteral}{"am\_95    ;    abc=11.8   ,    foo      "};
191   StructuredHeadersDecoder shd(input);
192 
193   ParameterisedList pl;
194   shd.decodeParameterisedList(pl);
195   EXPECT\_EQ(pl.size(), 2);
196 
197   EXPECT\_EQ(pl[0].identifier, \textcolor{stringliteral}{"am\_95"});
198   EXPECT\_EQ(pl[0].parameterMap.size(), 1);
199   EXPECT\_EQ(pl[0].parameterMap[\textcolor{stringliteral}{"abc"}].tag, StructuredHeaderItem::Type::DOUBLE);
200   EXPECT\_EQ(pl[0].parameterMap[\textcolor{stringliteral}{"abc"}], 11.8);
201 
202   EXPECT\_EQ(pl[1].identifier, \textcolor{stringliteral}{"foo"});
203   EXPECT\_EQ(pl[1].parameterMap.size(), 0);
204 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Integer\+High\+Borderline)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Integer\+High\+Borderline}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ae9d7c2a88216a938a44b3cf0c896945b}


Definition at line 192 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item(), and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag.


\begin{DoxyCode}
192                                                                \{
193   std::string input = \textcolor{stringliteral}{"9223372036854775807"};
194   StructuredHeadersBuffer shd(input);
195   StructuredHeaderItem output;
196   \textcolor{keyword}{auto} err = shd.parseItem(output);
197   EXPECT\_EQ(err, StructuredHeaders::DecodeError::OK);
198   EXPECT\_EQ(output.tag, StructuredHeaderItem::Type::INT64);
199   EXPECT\_EQ(output, std::numeric\_limits<int64\_t>::max());
200 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Header\+Table\+Tests, Vary\+Capacity)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Header\+Table\+Tests}}]{, }
\item[{Vary\+Capacity}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a214096b7fda0a53c92e03472921fc0d9}


Definition at line 192 of file Header\+Table\+Tests.\+cpp.



References proxygen\+::\+Header\+Table\+::add(), proxygen\+::\+H\+P\+A\+C\+K\+Header\+::bytes(), proxygen\+::\+H\+P\+A\+C\+K\+Header\+::copy(), proxygen\+::\+Header\+Table\+::length(), and proxygen\+::\+Header\+Table\+::size().


\begin{DoxyCode}
192                                        \{
193   HPACKHeader accept(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"gzip"});
194   uint32\_t max = 6;
195   uint32\_t capacity = accept.bytes() * max;
196   HeaderTable table(capacity);
197 
198   \textcolor{comment}{// Fill the table (extra) and make sure we haven't violated our}
199   \textcolor{comment}{// size (bytes) limits (expected one entry to be evicted)}
200   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i <= table.length(); ++i) \{
201     EXPECT\_EQ(table.add(accept.copy()), \textcolor{keyword}{true});
202   \}
203   EXPECT\_EQ(table.size(), max);
204 
205   \textcolor{comment}{// Size down the table and verify we are still honoring our size (bytes)}
206   \textcolor{comment}{// limits}
207   resizeAndFillTable(table, accept, 4, 5);
208 
209   \textcolor{comment}{// Size up the table (in between previous max and min within test) and verify}
210   \textcolor{comment}{// we are still horing our size (bytes) limits}
211   resizeAndFillTable(table, accept, 5, 6);
212 
213   \textcolor{comment}{// Finally reize up one last timestamps}
214   resizeAndFillTable(table, accept, 8, 9);
215 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+R\+F\+C1867\+Test, Test\+Simple\+Post)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf R\+F\+C1867\+Test}}]{, }
\item[{Test\+Simple\+Post}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a331afcd38f0a894ebe68631ee2fae338}


Definition at line 195 of file R\+F\+C1867\+Test.\+cpp.


\begin{DoxyCode}
195                                     \{
196   \textcolor{keywordtype}{size\_t} fileSize = 17;
197   \textcolor{keyword}{auto} data = makePost(
198       \{\{\textcolor{stringliteral}{"foo"}, \textcolor{stringliteral}{"bar"}\}, \{\textcolor{stringliteral}{"jojo"}, \textcolor{stringliteral}{"binky"}\}\}, \{\}, \{\{\textcolor{stringliteral}{"file1"}, \{\textcolor{stringliteral}{""}, fileSize\}\}\});
199   testSimple(std::move(data), 3 + 5 + fileSize, 0, 3);
200 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Q\+P\+A\+C\+K\+Header\+Table\+Tests, Evict\+Non\+Drained)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Q\+P\+A\+C\+K\+Header\+Table\+Tests}}]{, }
\item[{Evict\+Non\+Drained}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a06f4f5306dc0ff311246fefd4953f78b}


Definition at line 200 of file Q\+P\+A\+C\+K\+Header\+Table\+Tests.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Header\+::copy().


\begin{DoxyCode}
200                                                \{
201   HPACKHeader small(\textcolor{stringliteral}{"ab"}, \textcolor{stringliteral}{"cd"}); \textcolor{comment}{// 36 bytes}
202   HPACKHeader small2(\textcolor{stringliteral}{"abcd"}, std::string(14, \textcolor{charliteral}{'b'})); \textcolor{comment}{// 50 bytes}
203   HPACKHeader med(std::string(20, \textcolor{charliteral}{'a'}), std::string(20, \textcolor{charliteral}{'b'})); \textcolor{comment}{// 72}
204   HPACKHeader large(std::string(34, \textcolor{charliteral}{'a'}), std::string(34, \textcolor{charliteral}{'b'})); \textcolor{comment}{// 100}
205 
206   table\_.setCapacity(220);
207   EXPECT\_TRUE(table\_.add(small.copy()));
208   EXPECT\_TRUE(table\_.add(med.copy()));
209   EXPECT\_TRUE(table\_.add(large.copy()));
210   EXPECT\_TRUE(table\_.isDraining(3));
211   EXPECT\_FALSE(table\_.isDraining(2));
212 
213   table\_.setMaxAcked(3);
214   \textcolor{comment}{// Evicts small and med}
215   EXPECT\_TRUE(table\_.add(small2.copy()));
216   EXPECT\_EQ(table\_.size(), 2);
217   EXPECT\_FALSE(table\_.isDraining(1));
218   EXPECT\_FALSE(table\_.isDraining(2));
219 
220   \textcolor{comment}{// Now lg should be draining}
221   EXPECT\_TRUE(table\_.add(small.copy()));
222   EXPECT\_TRUE(table\_.isDraining(3));
223 
224   \textcolor{comment}{// Evict large}
225   EXPECT\_TRUE(table\_.add(small.copy()));
226 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+R\+F\+C1867\+Test, Test\+Splits)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf R\+F\+C1867\+Test}}]{, }
\item[{Test\+Splits}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a6af1d9f3bfe3b59483d5375f48d974a8}


Definition at line 202 of file R\+F\+C1867\+Test.\+cpp.


\begin{DoxyCode}
202                                 \{
203   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 1; i < 500; i++) \{
204     \textcolor{keywordtype}{size\_t} fileSize = 1000 + i;
205     \textcolor{keyword}{auto} data = makePost(
206         \{\{\textcolor{stringliteral}{"foo"}, \textcolor{stringliteral}{"bar"}\}, \{\textcolor{stringliteral}{"jojo"}, \textcolor{stringliteral}{"binky"}\}\}, \{\}, \{\{\textcolor{stringliteral}{"file1"}, \{\textcolor{stringliteral}{""}, fileSize\}\}\});
207     testSimple(std::move(data), 3 + 5 + fileSize, i, 3);
208   \}
209 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Integer\+Low\+Borderline)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Integer\+Low\+Borderline}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ad47b27051950abff87d9b8154ab206dc}


Definition at line 202 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item(), and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag.


\begin{DoxyCode}
202                                                               \{
203   std::string input = \textcolor{stringliteral}{"-9223372036854775808"};
204   StructuredHeadersBuffer shd(input);
205   StructuredHeaderItem output;
206   \textcolor{keyword}{auto} err = shd.parseItem(output);
207   EXPECT\_EQ(err, StructuredHeaders::DecodeError::OK);
208   EXPECT\_EQ(output.tag, StructuredHeaderItem::Type::INT64);
209   EXPECT\_EQ(output, std::numeric\_limits<int64\_t>::min());
210 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Decoder\+Test, Test\+Param\+List\+Null\+Values)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Decoder\+Test}}]{, }
\item[{Test\+Param\+List\+Null\+Values}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a665b1979cea5ceb1738f1173b1973f0b}


Definition at line 206 of file Structured\+Headers\+Decoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+Parameterised\+List().


\begin{DoxyCode}
206                                                               \{
207   std::string input = \textcolor{stringliteral}{"beverages;water;juice, food;pizza;burger"};
208   StructuredHeadersDecoder shd(input);
209 
210   ParameterisedList pl;
211   shd.decodeParameterisedList(pl);
212   EXPECT\_EQ(pl.size(), 2);
213 
214   EXPECT\_EQ(pl[0].identifier, \textcolor{stringliteral}{"beverages"});
215   EXPECT\_EQ(pl[0].parameterMap.size(), 2);
216   EXPECT\_EQ(pl[0].parameterMap[\textcolor{stringliteral}{"water"}].tag, StructuredHeaderItem::Type::NONE);
217   EXPECT\_EQ(pl[0].parameterMap[\textcolor{stringliteral}{"juice"}].tag, StructuredHeaderItem::Type::NONE);
218 
219   EXPECT\_EQ(pl[1].identifier, \textcolor{stringliteral}{"food"});
220   EXPECT\_EQ(pl[1].parameterMap.size(), 2);
221   EXPECT\_EQ(pl[1].parameterMap[\textcolor{stringliteral}{"pizza"}].tag, StructuredHeaderItem::Type::NONE);
222   EXPECT\_EQ(pl[1].parameterMap[\textcolor{stringliteral}{"burger"}].tag, StructuredHeaderItem::Type::NONE);
223 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+List\+One\+Elt)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+List\+One\+Elt}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_aeb89a12db78af7eca0c82b55a5a97ed7}


Definition at line 210 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+List(), proxygen\+::\+Structured\+Headers\+Encoder\+::get(), proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
210                                                      \{
211   std::vector<StructuredHeaderItem> vec;
212   StructuredHeaderItem item;
213 
214   item.tag = StructuredHeaderItem::Type::STRING;
215   std::string val1 = \textcolor{stringliteral}{"hello world"};
216   item.value = val1;
217   vec.push\_back(item);
218 
219   StructuredHeadersEncoder encoder;
220   \textcolor{keyword}{auto} err = encoder.encodeList(vec);
221 
222   EXPECT\_EQ(err, EncodeError::OK);
223   EXPECT\_EQ(encoder.get(), \textcolor{stringliteral}{"\(\backslash\)"hello world\(\backslash\)""});
224 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+R\+F\+C1867\+Test, Test\+Splits\+With\+Filename)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf R\+F\+C1867\+Test}}]{, }
\item[{Test\+Splits\+With\+Filename}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a5463ce87ca5a584402b3ef49b516c346}


Definition at line 211 of file R\+F\+C1867\+Test.\+cpp.


\begin{DoxyCode}
211                                             \{
212   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 1; i < 500; i++) \{
213     \textcolor{keywordtype}{size\_t} fileSize = 1000 + i;
214     \textcolor{keyword}{auto} data = makePost(\{\{\textcolor{stringliteral}{"foo"}, \textcolor{stringliteral}{"bar"}\}, \{\textcolor{stringliteral}{"jojo"}, \textcolor{stringliteral}{"binky"}\}\},
215                          \{\},
216                          \{\{\textcolor{stringliteral}{"file1"}, \{\textcolor{stringliteral}{"file1.txt"}, fileSize\}\}\});
217     testSimple(std::move(data), 3 + 5 + fileSize, i, 3);
218   \}
219 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Update\+Weight)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Update\+Weight}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a12ad26c53c550b92d3bacbb16538c5ac}


Definition at line 211 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
211                                 \{
212   buildSimpleTree();
213 
214   uint64\_t depth = 0;
215   updatePriority(5, \{0, \textcolor{keyword}{false}, 7\}, &depth);
216   dump();
217 
218   EXPECT\_EQ(nodes\_, IDList(\{\{0, 100\}, \{3, 20\}, \{5, 40\}, \{9, 100\}, \{7, 40\}\}));
219   EXPECT\_EQ(depth, 2);
220 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Integer\+Underflow)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Integer\+Underflow}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ab34fa9a46ce6dafa92e546a63ba18820}


Definition at line 212 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, and proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item().


\begin{DoxyCode}
212                                                           \{
213   std::string input = \textcolor{stringliteral}{"-9223372036854775809"};
214   StructuredHeadersBuffer shd(input);
215   StructuredHeaderItem output;
216   \textcolor{keyword}{auto} err = shd.parseItem(output);
217   EXPECT\_NE(err, StructuredHeaders::DecodeError::OK);
218 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Header\+Table\+Tests, Vary\+Capacity\+Malign\+Head\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Header\+Table\+Tests}}]{, }
\item[{Vary\+Capacity\+Malign\+Head\+Index}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ac34aae6090a1b12c58a9521395bcbf71}


Definition at line 217 of file Header\+Table\+Tests.\+cpp.



References proxygen\+::\+Header\+Table\+::add(), proxygen\+::\+H\+P\+A\+C\+K\+Header\+::bytes(), proxygen\+::\+Header\+Table\+::bytes(), proxygen\+::\+H\+P\+A\+C\+K\+Header\+::copy(), proxygen\+::\+Header\+Table\+::get\+Max\+Table\+Length(), proxygen\+::\+Header\+Table\+::length(), and proxygen\+::\+Header\+Table\+::size().


\begin{DoxyCode}
217                                                       \{
218   \textcolor{comment}{// Test checks for a previous bug/crash condition where due to resizing}
219   \textcolor{comment}{// the underlying table to a size lower than a previous max but up from the}
220   \textcolor{comment}{// current size and the position of the head\_ index an out of bounds index}
221   \textcolor{comment}{// would occur}
222 
223   \textcolor{comment}{// Initialize header table}
224   HPACKHeader accept(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"gzip"});
225   uint32\_t max = 6;
226   uint32\_t capacity = accept.bytes() * max;
227   HeaderTable table(capacity);
228 
229   \textcolor{comment}{// Push head\_ to last index in underlying table before potential wrap}
230   \textcolor{comment}{// This is our max table size for the duration of the test}
231   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < table.getMaxTableLength(capacity); ++i) \{
232     EXPECT\_EQ(table.add(accept.copy()), \textcolor{keyword}{true});
233   \}
234   EXPECT\_EQ(table.size(), max);
235   EXPECT\_EQ(table.bytes(), capacity);
236 
237   \textcolor{comment}{// Flush underlying table (head\_ remains the same at the previous max index)}
238   \textcolor{comment}{// Header guranteed to cause a flush as header itself requires 32 bytes plus}
239   \textcolor{comment}{// the sizes of the name and value anyways (which themselves would cause a}
240   \textcolor{comment}{// flush)}
241   \textcolor{keywordtype}{string} strLargerThanTableCapacity = string(capacity + 1, \textcolor{charliteral}{'a'});
242   HPACKHeader flush(\textcolor{stringliteral}{"flush"}, strLargerThanTableCapacity);
243   EXPECT\_EQ(table.add(flush.copy()), \textcolor{keyword}{false});
244   EXPECT\_EQ(table.size(), 0);
245 
246   \textcolor{comment}{// Now reduce capacity of table (in functional terms table.size() is lowered}
247   \textcolor{comment}{// but currently table.length() remains the same)}
248   max = 3;
249   resizeTable(table, accept.bytes() * max, max);
250 
251   \textcolor{comment}{// Increase capacity of table (but smaller than all time max; head\_ still at}
252   \textcolor{comment}{// previous max index).  Previously (now fixed) this size up resulted in}
253   \textcolor{comment}{// incorrect resizing semantics}
254   max = 4;
255   resizeTable(table, accept.bytes() * max, max);
256 
257   \textcolor{comment}{// Now try and add headers; there should be no crash with current position of}
258   \textcolor{comment}{// head\_ in the underlying table.  Note this is merely one possible way we}
259   \textcolor{comment}{// could force the test to crash as a result of the resize bug this test was}
260   \textcolor{comment}{// added for}
261   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i <= table.length(); ++i) \{
262     EXPECT\_EQ(table.add(accept.copy()), \textcolor{keyword}{true});
263   \}
264   EXPECT\_EQ(table.size(), max);
265 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Float)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Float}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_aae234daae4525d354ea41451e304e920}


Definition at line 220 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item(), and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag.


\begin{DoxyCode}
220                                                \{
221   std::string input = \textcolor{stringliteral}{"3.1415926536"};
222   StructuredHeadersBuffer shd(input);
223   StructuredHeaderItem output;
224   \textcolor{keyword}{auto} err = shd.parseItem(output);
225   EXPECT\_EQ(err, StructuredHeaders::DecodeError::OK);
226   EXPECT\_EQ(output.tag, StructuredHeaderItem::Type::DOUBLE);
227   EXPECT\_EQ(output, 3.1415926536);
228 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+R\+F\+C1867\+Test, Test\+Headers\+Chunk\+Extra\+Cr)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf R\+F\+C1867\+Test}}]{, }
\item[{Test\+Headers\+Chunk\+Extra\+Cr}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a1aa40b50feac210de617c9695111f5c8}


Definition at line 221 of file R\+F\+C1867\+Test.\+cpp.


\begin{DoxyCode}
221                                              \{
222   \textcolor{comment}{// We are testing here that we correctly chunk when the parser has just}
223   \textcolor{comment}{// finished parsing a CR.}
224   \textcolor{keyword}{auto} numCRs = 5;
225   \textcolor{keyword}{auto} headerEndingSeq = \textcolor{stringliteral}{"--"} + string(numCRs, \textcolor{charliteral}{'\(\backslash\)r'}) + \textcolor{stringliteral}{"\(\backslash\)n"};
226   \textcolor{keyword}{auto} fileSize = 10;
227   \textcolor{keyword}{auto} data = makePost(\{\{\textcolor{stringliteral}{"foo"}, \textcolor{stringliteral}{"bar"}\}, \{\textcolor{stringliteral}{"jojo"}, \textcolor{stringliteral}{"binky"}\}\},
228                        \{\},
229                        \{\{\textcolor{stringliteral}{"file1"}, \{\textcolor{stringliteral}{""}, fileSize\}\}\},
230                        headerEndingSeq);
231   \textcolor{comment}{// Math ensures we the parser will chunk at a '\(\backslash\)r' with a numCRs-1}
232   testSimple(std::move(data), 3 + 5 + fileSize, numCRs - 1, 3);
233 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Duplicate\+I\+D)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Duplicate\+ID}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a32fbf8e996355339609a5fe57a53f9da}


Definition at line 224 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
224                                \{
225   q\_.addOrUpdatePriorityNode(0, \{kRootNodeId, \textcolor{keyword}{false}, 15\});
226   addTransaction(0, \{kRootNodeId, \textcolor{keyword}{true}, 15\});
227   q\_.addOrUpdatePriorityNode(3, \{0, \textcolor{keyword}{false}, 15\});
228   addTransaction(5, \{3, \textcolor{keyword}{false}, 15\});
229   addTransaction(3, \{5, \textcolor{keyword}{false}, 15\});
230   removeTransaction(5);
231   \textcolor{keyword}{auto} stopFn = [] \{
232     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
233   \};
234 
235   dumpBFS(stopFn);
236   EXPECT\_EQ(nodes\_, IDList(\{\{0, 100\}, \{3, 100\}\}));
237 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+List\+Empty)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+List\+Empty}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a7dccbaf163796ced0ffa89b2eb3eef88}


Definition at line 226 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+List().


\begin{DoxyCode}
226                                                     \{
227   std::vector<StructuredHeaderItem> vec;
228 
229   StructuredHeadersEncoder encoder;
230   \textcolor{keyword}{auto} err = encoder.encodeList(vec);
231 
232   EXPECT\_NE(err, EncodeError::OK);
233 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Q\+P\+A\+C\+K\+Header\+Table\+Tests, Bad\+Sync)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Q\+P\+A\+C\+K\+Header\+Table\+Tests}}]{, }
\item[{Bad\+Sync}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ad2c131b8efc2c9000c7427bb6f58ff25}


Definition at line 228 of file Q\+P\+A\+C\+K\+Header\+Table\+Tests.\+cpp.


\begin{DoxyCode}
228                                        \{
229   \textcolor{comment}{// Can't ack more than is in the table}
230   EXPECT\_FALSE(table\_.onTableStateSync(1));
231 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Float\+Preceding\+Whitespace)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Float\+Preceding\+Whitespace}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a12cc8db1e273b97fea8733dabb9283b3}


Definition at line 230 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item(), and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag.


\begin{DoxyCode}
230                                                                   \{
231   std::string input = \textcolor{stringliteral}{"         \(\backslash\)t\(\backslash\)t    66000.5645"};
232   StructuredHeadersBuffer shd(input);
233   StructuredHeaderItem output;
234   \textcolor{keyword}{auto} err = shd.parseItem(output);
235   EXPECT\_EQ(err, StructuredHeaders::DecodeError::OK);
236   EXPECT\_EQ(output.tag, StructuredHeaderItem::Type::DOUBLE);
237   EXPECT\_EQ(output, 66000.5645);
238 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+List\+Bad\+Item)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+List\+Bad\+Item}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_af15e0c68069b3da5c879016b7629d6b6}


Definition at line 235 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+List(), proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
235                                                       \{
236   std::vector<StructuredHeaderItem> vec;
237   StructuredHeaderItem item;
238 
239   item.tag = StructuredHeaderItem::Type::STRING;
240   std::string val1 = \textcolor{stringliteral}{"hello \(\backslash\)x10world"};
241   item.value = val1;
242   vec.push\_back(item);
243 
244   StructuredHeadersEncoder encoder;
245   \textcolor{keyword}{auto} err = encoder.encodeList(vec);
246 
247   EXPECT\_NE(err, EncodeError::OK);
248 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Update\+Weight\+Not\+Enqueued)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Update\+Weight\+Not\+Enqueued}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_aa5e98772468985704f8a005bc3e5fe47}


Definition at line 239 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
239                                            \{
240   addTransaction(0, \{kRootNodeId, \textcolor{keyword}{false}, 7\});
241   addTransaction(3, \{0, \textcolor{keyword}{false}, 7\});
242 
243   signalEgress(0, \textcolor{keyword}{false});
244   signalEgress(3, \textcolor{keyword}{false});
245   uint64\_t depth = 0;
246   updatePriority(0, \{3, \textcolor{keyword}{false}, 7\}, &depth);
247   dump();
248 
249   EXPECT\_EQ(nodes\_, IDList(\{\{3, 100\}, \{0, 100\}\}));
250   EXPECT\_EQ(depth, 2);
251 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Float\+No\+Digit\+Preceding\+Decimal)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Float\+No\+Digit\+Preceding\+Decimal}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a2652a8cd5d31936d5175c320e58f9782}


Definition at line 240 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, and proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item().


\begin{DoxyCode}
240                                                                       \{
241   std::string input = \textcolor{stringliteral}{".1415926536"};
242   StructuredHeadersBuffer shd(input);
243   StructuredHeaderItem output;
244   \textcolor{keyword}{auto} err = shd.parseItem(output);
245   EXPECT\_NE(err, StructuredHeaders::DecodeError::OK);
246 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Integer\+Too\+Many\+Chars)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Integer\+Too\+Many\+Chars}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ab7723653c8c9fc2129afb39ea1f7abe4}


Definition at line 248 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, and proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item().


\begin{DoxyCode}
248                                                              \{
249   std::string input = \textcolor{stringliteral}{"10000000000000000000"}; \textcolor{comment}{// has 20 characters}
250   StructuredHeadersBuffer shd(input);
251   StructuredHeaderItem output;
252   \textcolor{keyword}{auto} err = shd.parseItem(output);
253   EXPECT\_NE(err, StructuredHeaders::DecodeError::OK);
254 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+Dictionary\+One\+Elt)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+Dictionary\+One\+Elt}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a77493e027b8cdcb6e6be6846a882db6c}


Definition at line 250 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Dictionary(), proxygen\+::\+Structured\+Headers\+Encoder\+::get(), proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
250                                                            \{
251   StructuredHeaders::Dictionary dict;
252 
253   StructuredHeaderItem item1;
254   item1.tag = StructuredHeaderItem::Type::DOUBLE;
255   \textcolor{keywordtype}{double} val1 = 2.71;
256   item1.value = val1;
257 
258   dict[\textcolor{stringliteral}{"e"}] = item1;
259 
260   StructuredHeadersEncoder encoder;
261   \textcolor{keyword}{auto} err = encoder.encodeDictionary(dict);
262 
263   EXPECT\_EQ(err, EncodeError::OK);
264   EXPECT\_EQ(encoder.get(), \textcolor{stringliteral}{"e=2.71"});
265 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Update\+Weight\+Excl)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Update\+Weight\+Excl}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a5e917a94748e5d4ec542ecc0634523a9}


Definition at line 253 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
253                                     \{
254   buildSimpleTree();
255 
256   updatePriority(5, \{0, \textcolor{keyword}{true}, 7\});
257   dump();
258 
259   EXPECT\_EQ(nodes\_, IDList(\{\{0, 100\}, \{5, 100\}, \{9, 40\}, \{3, 20\}, \{7, 40\}\}));
260   signalEgress(0, \textcolor{keyword}{false});
261   nextEgress();
262   EXPECT\_EQ(nodes\_, IDList(\{\{5, 100\}\}));
263 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Float\+Too\+Many\+Chars)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Float\+Too\+Many\+Chars}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_abfccd25a762094ff76df846f59f953e6}


Definition at line 256 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, and proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item().


\begin{DoxyCode}
256                                                            \{
257   std::string input = \textcolor{stringliteral}{"111111111.1111111"}; \textcolor{comment}{// has 17 characters}
258   StructuredHeadersBuffer shd(input);
259   StructuredHeaderItem output;
260   \textcolor{keyword}{auto} err = shd.parseItem(output);
261   EXPECT\_NE(err, StructuredHeaders::DecodeError::OK);
262 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Float\+Borderline\+Num\+Chars)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Float\+Borderline\+Num\+Chars}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a4b42feb4734d048780ddddb5517eadc4}


Definition at line 264 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item(), and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag.


\begin{DoxyCode}
264                                                                  \{
265   std::string input = \textcolor{stringliteral}{"111111111.111111"}; \textcolor{comment}{// has 16 characters}
266   StructuredHeadersBuffer shd(input);
267   StructuredHeaderItem output;
268   \textcolor{keyword}{auto} err = shd.parseItem(output);
269   EXPECT\_EQ(output.tag, StructuredHeaderItem::Type::DOUBLE);
270   EXPECT\_EQ(err, StructuredHeaders::DecodeError::OK);
271 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Update\+Weight\+Excl\+Dequeued)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Update\+Weight\+Excl\+Dequeued}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a521a3d1cbdc3d0afa465034bd58d8b11}


Definition at line 265 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
265                                             \{
266   buildSimpleTree();
267 
268   signalEgress(5, \textcolor{keyword}{false});
269   updatePriority(5, \{0, \textcolor{keyword}{true}, 7\});
270   signalEgress(0, \textcolor{keyword}{false});
271   nextEgress();
272 
273   EXPECT\_EQ(nodes\_, IDList(\{\{9, 40\}, \{7, 40\}, \{3, 20\}\}));
274 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+Dictionary\+Many\+Elts)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+Dictionary\+Many\+Elts}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a551fdc07a4fcf603708fa8d8d40e108e}


Definition at line 267 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Dictionary(), proxygen\+::\+Structured\+Headers\+Encoder\+::get(), proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
267                                                              \{
268   StructuredHeaders::Dictionary dict;
269   StructuredHeaderItem item;
270 
271   item.tag = StructuredHeaderItem::Type::INT64;
272   int64\_t val1 = 87;
273   item.value = val1;
274   dict[\textcolor{stringliteral}{"age"}] = item;
275 
276   item.tag = StructuredHeaderItem::Type::STRING;
277   std::string val2 = \textcolor{stringliteral}{"John Doe"};
278   item.value = val2;
279   dict[\textcolor{stringliteral}{"name"}] = item;
280 
281   item.tag = StructuredHeaderItem::Type::BINARYCONTENT;
282   std::string val3 = \textcolor{stringliteral}{"password"};
283   item.value = val3;
284   dict[\textcolor{stringliteral}{"password"}] = item;
285 
286   StructuredHeadersEncoder encoder;
287   \textcolor{keyword}{auto} err = encoder.encodeDictionary(dict);
288 
289   EXPECT\_EQ(err, EncodeError::OK);
290 
291   \textcolor{comment}{// A dictionary is an unordered mapping, so the ordering of specific elements}
292   \textcolor{comment}{// within the dictionary doesn't matter}
293   EXPECT\_THAT(encoder.get(), AnyOf(
294     Eq(\textcolor{stringliteral}{"age=87, name=\(\backslash\)"John Doe\(\backslash\)", password=*cGFzc3dvcmQ=*"}),
295     Eq(\textcolor{stringliteral}{"age=87, password=*cGFzc3dvcmQ=*, name=\(\backslash\)"John Doe\(\backslash\)""}),
296     Eq(\textcolor{stringliteral}{"name=\(\backslash\)"John Doe\(\backslash\)", age=87, password=*cGFzc3dvcmQ=*"}),
297     Eq(\textcolor{stringliteral}{"name=\(\backslash\)"John Doe\(\backslash\)", password=*cGFzc3dvcmQ=*, age=87"}),
298     Eq(\textcolor{stringliteral}{"password=*cGFzc3dvcmQ=*, name=\(\backslash\)"John Doe\(\backslash\)", age=87"}),
299     Eq(\textcolor{stringliteral}{"password=*cGFzc3dvcmQ=*, age=87, name=\(\backslash\)"John Doe\(\backslash\)""})
300   ));
301 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Header\+Table\+Tests, Add\+Larger\+Than\+Table)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Header\+Table\+Tests}}]{, }
\item[{Add\+Larger\+Than\+Table}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ad1d5673b471437a46650d075ffe540e5}


Definition at line 267 of file Header\+Table\+Tests.\+cpp.



References proxygen\+::\+Header\+Table\+::add(), proxygen\+::\+Header\+Table\+::has\+Name(), name, proxygen\+::\+Header\+Table\+::name\+Index(), and proxygen\+::\+Header\+Table\+::names().


\begin{DoxyCode}
267                                              \{
268   \textcolor{comment}{// Construct a smallish table}
269   uint32\_t capacityBytes = 256;
270   HeaderTable table(capacityBytes);
271   HPACKHeaderName name(\textcolor{stringliteral}{"accept-encoding"});
272   table.add(HPACKHeader(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"gzip"}));  \textcolor{comment}{// internal index = 0}
273   table.add(HPACKHeader(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"gzip"}));  \textcolor{comment}{// internal index = 1}
274   table.add(HPACKHeader(\textcolor{stringliteral}{"test-encoding"}, \textcolor{stringliteral}{"gzip"}));    \textcolor{comment}{// internal index = 2}
275   EXPECT\_EQ(table.names().size(), 2);
276 
277   \textcolor{comment}{// Attempt to add a header that is larger than our specified table capacity}
278   \textcolor{comment}{// bytes.  This should result in a table flush.}
279   table.add(HPACKHeader(std::string(capacityBytes, \textcolor{charliteral}{'a'}), \textcolor{stringliteral}{"gzip"}));
280   EXPECT\_EQ(table.names().size(), 0);
281 
282   \textcolor{comment}{// Add the previous headers to the table again}
283   table.add(HPACKHeader(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"gzip"}));  \textcolor{comment}{// internal index = 3}
284   table.add(HPACKHeader(\textcolor{stringliteral}{"accept-encoding"}, \textcolor{stringliteral}{"gzip"}));  \textcolor{comment}{// internal index = 4}
285   table.add(HPACKHeader(\textcolor{stringliteral}{"test-encoding"}, \textcolor{stringliteral}{"gzip"}));    \textcolor{comment}{// internal index = 5}
286   EXPECT\_EQ(table.names().size(), 2);
287 
288   EXPECT\_EQ(table.hasName(name), \textcolor{keyword}{true});
289   \textcolor{keyword}{auto} it = table.names().find(name);
290   EXPECT\_EQ(it->second.size(), 2);
291   \textcolor{comment}{// As nameIndex takes the last index added, we have head = 5, index = 4}
292   \textcolor{comment}{// and so yields a difference of one and as external indexing is 1 based,}
293   \textcolor{comment}{// we expect 2 here}
294   EXPECT\_EQ(table.nameIndex(name), 2);
295 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Float\+Ends\+With\+Decimal)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Float\+Ends\+With\+Decimal}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a4a71d0fdcc91ab09a8facf3fdf8f9b39}


Definition at line 273 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, and proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item().


\begin{DoxyCode}
273                                                               \{
274   std::string input = \textcolor{stringliteral}{"100."};
275   StructuredHeadersBuffer shd(input);
276   StructuredHeaderItem output;
277   \textcolor{keyword}{auto} err = shd.parseItem(output);
278   EXPECT\_NE(err, StructuredHeaders::DecodeError::OK);
279 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Update\+Weight\+Unknown\+Parent)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Update\+Weight\+Unknown\+Parent}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a34404080d97d5a3fc7299dc7cc1db888}


Definition at line 276 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
276                                              \{
277   buildSimpleTree();
278 
279   uint64\_t depth = 0;
280   updatePriority(5, \{97, \textcolor{keyword}{false}, 15\}, &depth);
281   dump();
282 
283   EXPECT\_EQ(
284     nodes\_,
285     IDList(\{\{0, 50\}, \{3, 33\}, \{7, 66\}, \{97, 50\}, \{5, 100\}, \{9, 100\}\})
286   );
287   EXPECT\_EQ(depth, 2);
288 
289   depth = 0;
290   updatePriority(9, \{99, \textcolor{keyword}{false}, 15\}, &depth);
291   dump();
292 
293   EXPECT\_EQ(
294     nodes\_,
295     IDList(\{\{0, 33\}, \{3, 33\}, \{7, 66\}, \{97, 33\}, \{5, 100\}, \{99, 33\}, \{9, 100\}\})
296   );
297   EXPECT\_EQ(depth, 2);
298 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Consume\+Comma)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Consume\+Comma}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a27bac549c0a8a86a84cdd034684fe467}


Definition at line 281 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item(), proxygen\+::\+Structured\+Headers\+Buffer\+::remove\+Symbol(), and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag.


\begin{DoxyCode}
281                                                       \{
282   std::string input = \textcolor{stringliteral}{",5345346"};
283   StructuredHeadersBuffer shd(input);
284   StructuredHeaderItem output;
285   shd.removeSymbol(\textcolor{stringliteral}{","}, \textcolor{keyword}{true});
286   \textcolor{keyword}{auto} err = shd.parseItem(output);
287   EXPECT\_EQ(err, StructuredHeaders::DecodeError::OK);
288   EXPECT\_EQ(output.tag, StructuredHeaderItem::Type::INT64);
289   EXPECT\_EQ(output, int64\_t(5345346));
290 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Consume\+Equals)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Consume\+Equals}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_aa23ef14b5e872ffa06f6506deba0cb52}


Definition at line 292 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Item(), proxygen\+::\+Structured\+Headers\+Buffer\+::remove\+Symbol(), and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag.


\begin{DoxyCode}
292                                                        \{
293   std::string input = \textcolor{stringliteral}{"=456346.646"};
294   StructuredHeadersBuffer shd(input);
295   StructuredHeaderItem output;
296   shd.removeSymbol(\textcolor{stringliteral}{"="}, \textcolor{keyword}{true});
297   \textcolor{keyword}{auto} err = shd.parseItem(output);
298   EXPECT\_EQ(err, StructuredHeaders::DecodeError::OK);
299   EXPECT\_EQ(output.tag, StructuredHeaderItem::Type::DOUBLE);
300   EXPECT\_EQ(output, 456346.646);
301 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Standard\+Test, Test\+Basic\+List)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Standard\+Test}}]{, }
\item[{Test\+Basic\+List}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ab50bd328611302ada7a9b4b17154e401}


Definition at line 296 of file Structured\+Headers\+Standard\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+List().


\begin{DoxyCode}
296                                                      \{
297   std::string input(\textcolor{stringliteral}{"1, 42"});
298   StructuredHeadersDecoder shd(input);
299 
300   std::vector<StructuredHeaderItem> v;
301   \textcolor{keyword}{auto} err = shd.decodeList(v);
302   EXPECT\_EQ(err, DecodeError::OK);
303 
304   EXPECT\_EQ(v.size(), 2);
305 
306   EXPECT\_EQ(v[0].tag, StructuredHeaderItem::Type::INT64);
307   EXPECT\_EQ(v[1].tag, StructuredHeaderItem::Type::INT64);
308 
309   EXPECT\_EQ(v[0], int64\_t(1));
310   EXPECT\_EQ(v[1], int64\_t(42));
311 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Header\+Table\+Tests, Increase\+Length\+Of\+Full\+Table)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Header\+Table\+Tests}}]{, }
\item[{Increase\+Length\+Of\+Full\+Table}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a35eddf18b2e3d8966bbb74eaf03c822c}


Definition at line 297 of file Header\+Table\+Tests.\+cpp.



References proxygen\+::\+Header\+Table\+::add(), proxygen\+::\+H\+P\+A\+C\+K\+Header\+::copy(), proxygen\+::\+Header\+Table\+::get\+Header(), and proxygen\+::\+Header\+Table\+::length().


\begin{DoxyCode}
297                                                     \{
298   HPACKHeader largeHeader(\textcolor{stringliteral}{"Access-Control-Allow-Credentials"}, \textcolor{stringliteral}{"true"});
299   HPACKHeader smallHeader(\textcolor{stringliteral}{"Accept"}, \textcolor{stringliteral}{"All-Content"});
300 
301   HeaderTable table(448);
302   CHECK\_EQ(table.length(), 7);
303 
304   \textcolor{keywordflow}{for} (uint8\_t count = 0; count < 3; count++) \{
305     table.add(largeHeader.copy());
306     table.add(smallHeader.copy());
307   \} \textcolor{comment}{// tail is at index 0}
308   CHECK\_EQ(table.length(), 7);
309 
310   table.add(smallHeader.copy());
311   table.add(smallHeader.copy()); \textcolor{comment}{// tail is at index 1}
312   table.add(smallHeader.copy()); \textcolor{comment}{// resize on this add}
313   EXPECT\_EQ(table.length(), 11);
314 
315   \textcolor{comment}{// Check table is correct after resize}
316   CHECK\_EQ(table.getHeader(1), smallHeader);
317   CHECK\_EQ(table.getHeader(2), smallHeader);
318   CHECK\_EQ(table.getHeader(3), smallHeader);
319   CHECK\_EQ(table.getHeader(4), smallHeader);
320   CHECK\_EQ(table.getHeader(5), largeHeader);
321   CHECK\_EQ(table.getHeader(6), smallHeader);
322   CHECK\_EQ(table.getHeader(7), largeHeader);
323   CHECK\_EQ(table.getHeader(8), smallHeader);
324 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Update\+Parent\+Sibling)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Update\+Parent\+Sibling}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a8c240aba7957ad2e3833dfee7c2c8872}


Definition at line 300 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
300                                        \{
301   buildSimpleTree();
302 
303   updatePriority(5, \{3, \textcolor{keyword}{false}, 3\});
304   dump();
305 
306   EXPECT\_EQ(nodes\_, IDList(\{\{0, 100\}, \{3, 33\}, \{5, 100\},
307                                \{9, 100\}, \{7, 66\}\}));
308   signalEgress(0, \textcolor{keyword}{false});
309   nextEgress();
310   EXPECT\_EQ(nodes\_, IDList(\{\{7, 66\}, \{3, 33\}\}));
311 
312   \textcolor{comment}{// Clear 5's egress (so it is only in the tree because 9 has egress) and move}
313   \textcolor{comment}{// it back.  Hit's a slightly different code path in reparent}
314   signalEgress(5, \textcolor{keyword}{false});
315   updatePriority(5, \{0, \textcolor{keyword}{false}, 3\});
316   dump();
317 
318   EXPECT\_EQ(nodes\_, IDList(\{\{0, 100\}, \{3, 25\}, \{7, 50\}, \{5, 25\}, \{9, 100\}\}));
319 
320   nextEgress();
321   EXPECT\_EQ(nodes\_, IDList(\{\{7, 50\}, \{3, 25\}, \{9, 25\}\}));
322 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Consume\+Messy)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Consume\+Messy}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a8157ce7911fd5c33000f555380cfd97a}


Definition at line 303 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+Buffer\+::parse\+Identifier(), proxygen\+::\+Structured\+Headers\+Buffer\+::remove\+Symbol(), and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag.


\begin{DoxyCode}
303                                                       \{
304   std::string input = \textcolor{stringliteral}{"asfgsdfg,asfgsdfg,"};
305   StructuredHeadersBuffer shd(input);
306   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 2; i++) \{
307     StructuredHeaderItem output;
308     \textcolor{keyword}{auto} err = shd.parseIdentifier(output);
309     EXPECT\_EQ(err, StructuredHeaders::DecodeError::OK);
310     EXPECT\_EQ(output.tag, StructuredHeaderItem::Type::IDENTIFIER);
311     EXPECT\_EQ(output, std::string(\textcolor{stringliteral}{"asfgsdfg"}));
312     shd.removeSymbol(\textcolor{stringliteral}{","}, \textcolor{keyword}{true});
313   \}
314 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+Dictionary\+Empty)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+Dictionary\+Empty}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a8318408437510da303dbd48d99576b4a}


Definition at line 303 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Dictionary().


\begin{DoxyCode}
303                                                           \{
304   StructuredHeaders::Dictionary dict;
305 
306   StructuredHeadersEncoder encoder;
307   \textcolor{keyword}{auto} err = encoder.encodeDictionary(dict);
308 
309   EXPECT\_NE(err, EncodeError::OK);
310 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+Dictionary\+Bad\+Item)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+Dictionary\+Bad\+Item}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ace8f779590e9aa330460452bf9af9b7f}


Definition at line 312 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Dictionary(), proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
312                                                             \{
313   StructuredHeaders::Dictionary dict;
314 
315   StructuredHeaderItem item1;
316   item1.tag = StructuredHeaderItem::Type::STRING;
317   std::string val1 = \textcolor{stringliteral}{"hi\(\backslash\)nmy name is bob"};
318   item1.value = val1;
319 
320   dict[\textcolor{stringliteral}{"e"}] = item1;
321 
322   StructuredHeadersEncoder encoder;
323   \textcolor{keyword}{auto} err = encoder.encodeDictionary(dict);
324 
325   EXPECT\_NE(err, EncodeError::OK);
326 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Standard\+Test, Test\+Single\+Item\+List)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Standard\+Test}}]{, }
\item[{Test\+Single\+Item\+List}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a22cc1c56d2e2f1b9400c7491aea95ae6}


Definition at line 313 of file Structured\+Headers\+Standard\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+List().


\begin{DoxyCode}
313                                                           \{
314   std::string input(\textcolor{stringliteral}{"42"});
315   StructuredHeadersDecoder shd(input);
316 
317   std::vector<StructuredHeaderItem> v;
318   \textcolor{keyword}{auto} err = shd.decodeList(v);
319   EXPECT\_EQ(err, DecodeError::OK);
320 
321   EXPECT\_EQ(v.size(), 1);
322 
323   EXPECT\_EQ(v[0].tag, StructuredHeaderItem::Type::INT64);
324 
325   EXPECT\_EQ(v[0], int64\_t(42));
326 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Buffer\+Test, Test\+Inequality\+Operator)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Buffer\+Test}}]{, }
\item[{Test\+Inequality\+Operator}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_af82c562b8398d8954a3fe3abff1edd3f}


Definition at line 316 of file Structured\+Headers\+Buffer\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
316                                                             \{
317   StructuredHeaderItem integerItem;
318   integerItem.value = int64\_t(999);
319 
320   StructuredHeaderItem doubleItem;
321   doubleItem.value = 11.43;
322 
323   StructuredHeaderItem stringItem;
324   stringItem.value = std::string(\textcolor{stringliteral}{"hi"});
325 
326   EXPECT\_NE(integerItem, int64\_t(998));
327   EXPECT\_NE(doubleItem, \textcolor{keywordtype}{double}(11.44));
328   EXPECT\_NE(stringItem, std::string(\textcolor{stringliteral}{"bye"}));
329 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Update\+Parent\+Sibling\+Excl)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Update\+Parent\+Sibling\+Excl}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a219c997f6d6b686d5017cc49bd37a93e}


Definition at line 324 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
324                                            \{
325   buildSimpleTree();
326 
327   updatePriority(7, \{5, \textcolor{keyword}{true}, 3\});
328   dump();
329 
330   EXPECT\_EQ(nodes\_, IDList(\{\{0, 100\}, \{3, 50\}, \{5, 50\},
331                               \{7, 100\}, \{9, 100\}\}));
332   signalEgress(0, \textcolor{keyword}{false});
333   signalEgress(3, \textcolor{keyword}{false});
334   signalEgress(5, \textcolor{keyword}{false});
335   nextEgress();
336   EXPECT\_EQ(nodes\_, IDList(\{\{7, 100\}\}));
337 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Header\+Table\+Tests, Small\+Table)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Header\+Table\+Tests}}]{, }
\item[{Small\+Table}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a3faa18f21c216d1bc60be1a2f1e5d1bf}


Definition at line 326 of file Header\+Table\+Tests.\+cpp.



References proxygen\+::\+Header\+Table\+::add(), proxygen\+::\+H\+P\+A\+C\+K\+Header\+::copy(), proxygen\+::\+Header\+Table\+::length(), and proxygen\+::\+Header\+Table\+::size().


\begin{DoxyCode}
326                                      \{
327   HeaderTable table(80);
328   HPACKHeader foo(\textcolor{stringliteral}{"Foo"}, \textcolor{stringliteral}{"bar"});
329   EXPECT\_TRUE(table.add(foo.copy()));
330   EXPECT\_TRUE(table.add(foo.copy()));
331   EXPECT\_EQ(table.size(), 2);
332   EXPECT\_EQ(table.length(), 2);
333 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+Dictionary\+Bad\+Identifier)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+Dictionary\+Bad\+Identifier}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_afe512767050b295903ec818d58fdc40c}


Definition at line 328 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Dictionary(), proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
328                                                                   \{
329   StructuredHeaders::Dictionary dict;
330 
331   StructuredHeaderItem item1;
332   item1.tag = StructuredHeaderItem::Type::STRING;
333   std::string val1 = \textcolor{stringliteral}{"hi"};
334   item1.value = val1;
335 
336   dict[\textcolor{stringliteral}{"\_bad\_identifier"}] = item1;
337 
338   StructuredHeadersEncoder encoder;
339   \textcolor{keyword}{auto} err = encoder.encodeDictionary(dict);
340 
341   EXPECT\_NE(err, EncodeError::OK);
342 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Standard\+Test, Test\+No\+Whitespace\+List)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Standard\+Test}}]{, }
\item[{Test\+No\+Whitespace\+List}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a3db4a6bf1f2f4a3d1d274726f128744c}


Definition at line 328 of file Structured\+Headers\+Standard\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+List().


\begin{DoxyCode}
328                                                             \{
329   std::string input(\textcolor{stringliteral}{"1,42"});
330   StructuredHeadersDecoder shd(input);
331 
332   std::vector<StructuredHeaderItem> v;
333   \textcolor{keyword}{auto} err = shd.decodeList(v);
334   EXPECT\_EQ(err, DecodeError::OK);
335 
336   EXPECT\_EQ(v.size(), 2);
337 
338   EXPECT\_EQ(v[0].tag, StructuredHeaderItem::Type::INT64);
339   EXPECT\_EQ(v[1].tag, StructuredHeaderItem::Type::INT64);
340 
341   EXPECT\_EQ(v[0], int64\_t(1));
342   EXPECT\_EQ(v[1], int64\_t(42));
343 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Update\+Parent\+Ancestor)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Update\+Parent\+Ancestor}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a7b89987ee300ef068c5547dc06de7136}


Definition at line 339 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
339                                         \{
340   buildSimpleTree();
341 
342   updatePriority(9, \{kRootNodeId, \textcolor{keyword}{false}, 15\});
343   dump();
344 
345   EXPECT\_EQ(nodes\_, IDList(\{\{0, 50\}, \{3, 25\}, \{5, 25\}, \{7, 50\}, \{9, 50\}\}));
346   nextEgress();
347   EXPECT\_EQ(nodes\_, IDList(\{\{0, 50\}, \{9, 50\}\}));
348 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+Param\+List\+One\+Elt)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+Param\+List\+One\+Elt}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a749779b2edeff0947231fe504b72a8a9}


Definition at line 344 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Parameterised\+List(), proxygen\+::\+Structured\+Headers\+Encoder\+::get(), proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
344                                                           \{
345   ParameterisedList pl;
346   std::unordered\_map<std::string, StructuredHeaderItem> m;
347 
348   StructuredHeaderItem item;
349 
350   item.tag = StructuredHeaderItem::Type::INT64;
351   int64\_t val1 = 1;
352   item.value = val1;
353   m[\textcolor{stringliteral}{"abc"}] = item;
354 
355   ParameterisedIdentifier pident = \{\textcolor{stringliteral}{"foo"}, m\};
356 
357   pl.emplace\_back(pident);
358 
359   StructuredHeadersEncoder encoder;
360   \textcolor{keyword}{auto} err = encoder.encodeParameterisedList(pl);
361 
362   EXPECT\_EQ(err, EncodeError::OK);
363 
364   EXPECT\_EQ(encoder.get(), \textcolor{stringliteral}{"foo; abc=1"});
365 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Standard\+Test, Test\+Extra\+Whitespace\+List)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Standard\+Test}}]{, }
\item[{Test\+Extra\+Whitespace\+List}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a9ba00287ef60ef6fd05e220f890ec95d}


Definition at line 345 of file Structured\+Headers\+Standard\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+List().


\begin{DoxyCode}
345                                                                \{
346   std::string input(\textcolor{stringliteral}{"1 , 42"});
347   StructuredHeadersDecoder shd(input);
348 
349   std::vector<StructuredHeaderItem> v;
350   \textcolor{keyword}{auto} err = shd.decodeList(v);
351   EXPECT\_EQ(err, DecodeError::OK);
352 
353   EXPECT\_EQ(v.size(), 2);
354 
355   EXPECT\_EQ(v[0].tag, StructuredHeaderItem::Type::INT64);
356   EXPECT\_EQ(v[1].tag, StructuredHeaderItem::Type::INT64);
357 
358   EXPECT\_EQ(v[0], int64\_t(1));
359   EXPECT\_EQ(v[1], int64\_t(42));
360 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Update\+Parent\+Ancestor\+Excl)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Update\+Parent\+Ancestor\+Excl}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a5f83f17eed8b3a0637f615b6fb61e7bd}


Definition at line 350 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
350                                             \{
351   buildSimpleTree();
352 
353   updatePriority(9, \{kRootNodeId, \textcolor{keyword}{true}, 15\});
354   dump();
355 
356   EXPECT\_EQ(nodes\_, IDList(\{\{9, 100\}, \{0, 100\}, \{3, 25\}, \{5, 25\}, \{7, 50\}\}));
357   nextEgress();
358   EXPECT\_EQ(nodes\_, IDList(\{\{9, 100\}\}));
359 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Update\+Parent\+Descendant)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Update\+Parent\+Descendant}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_aeb2def164a22390c8ec527ea31fd2441}


Definition at line 361 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
361                                           \{
362   buildSimpleTree();
363 
364   updatePriority(0, \{5, \textcolor{keyword}{false}, 7\});
365   dump();
366 
367   EXPECT\_EQ(nodes\_, IDList(\{\{5, 100\}, \{9, 50\}, \{0, 50\}, \{3, 33\}, \{7, 66\}\}));
368   nextEgress();
369   EXPECT\_EQ(nodes\_, IDList(\{\{5, 100\}\}));
370   signalEgress(5, \textcolor{keyword}{false});
371   nextEgress();
372   EXPECT\_EQ(nodes\_, IDList(\{\{9, 50\}, \{0, 50\}\}));
373 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+Param\+List\+Successive\+Nulls)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+Param\+List\+Successive\+Nulls}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_aeaaf9a92efb9821dd81cb01ccc29bdef}


Definition at line 367 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Parameterised\+List(), proxygen\+::\+Structured\+Headers\+Encoder\+::get(), and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag.


\begin{DoxyCode}
367                                                                    \{
368   ParameterisedList pl;
369   std::unordered\_map<std::string, StructuredHeaderItem> m;
370 
371   StructuredHeaderItem item;
372 
373   item.tag = StructuredHeaderItem::Type::NONE;
374   m[\textcolor{stringliteral}{"a"}] = item;
375   m[\textcolor{stringliteral}{"b"}] = item;
376 
377   ParameterisedIdentifier pident = \{\textcolor{stringliteral}{"foo"}, m\};
378 
379   pl.emplace\_back(pident);
380 
381   StructuredHeadersEncoder encoder;
382   \textcolor{keyword}{auto} err = encoder.encodeParameterisedList(pl);
383 
384   EXPECT\_EQ(err, EncodeError::OK);
385 
386   EXPECT\_THAT(encoder.get(), AnyOf(
387     Eq(\textcolor{stringliteral}{"foo; a; b"}),
388     Eq(\textcolor{stringliteral}{"foo; b; a"})
389   ));
390 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Update\+Parent\+Descendant\+Excl)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Update\+Parent\+Descendant\+Excl}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a907e45bea931a8fd297e40f87c1caf9b}


Definition at line 375 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
375                                               \{
376   buildSimpleTree();
377 
378   updatePriority(0, \{5, \textcolor{keyword}{true}, 7\});
379   dump();
380 
381   EXPECT\_EQ(nodes\_, IDList(\{\{5, 100\}, \{0, 100\}, \{3, 20\}, \{7, 40\}, \{9, 40\}\}));
382   nextEgress();
383   EXPECT\_EQ(nodes\_, IDList(\{\{5, 100\}\}));
384   signalEgress(5, \textcolor{keyword}{false});
385   signalEgress(0, \textcolor{keyword}{false});
386   nextEgress();
387   EXPECT\_EQ(nodes\_, IDList(\{\{7, 40\}, \{9, 40\}, \{3, 20\}\}));
388 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Exclusive\+Add)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Exclusive\+Add}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a323b5b4146b5536beb614fd6a2602f77}


Definition at line 390 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
390                                 \{
391   buildSimpleTree();
392 
393   addTransaction(11, \{0, \textcolor{keyword}{true}, 100\});
394 
395   dump();
396   EXPECT\_EQ(nodes\_, IDList(\{
397         \{0, 100\}, \{11, 100\}, \{3, 25\}, \{5, 25\}, \{9, 100\}, \{7, 50\}
398       \}));
399 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+Param\+List\+Many\+Elts)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+Param\+List\+Many\+Elts}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a887a85b0db6b316f9c33b89def043139}


Definition at line 392 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Parameterised\+List(), proxygen\+::\+Structured\+Headers\+Encoder\+::get(), proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
392                                                             \{
393   ParameterisedList pl;
394   std::unordered\_map<std::string, StructuredHeaderItem> m1;
395 
396   StructuredHeaderItem item;
397 
398   item.tag = StructuredHeaderItem::Type::DOUBLE;
399   \textcolor{keywordtype}{double} val1 = 4234.234;
400   item.value = val1;
401   m1[\textcolor{stringliteral}{"foo"}] = item;
402 
403   item.tag = StructuredHeaderItem::Type::BINARYCONTENT;
404   std::string val2 = \textcolor{stringliteral}{"+++!"};
405   item.value = val2;
406   m1[\textcolor{stringliteral}{"goo"}] = item;
407 
408   ParameterisedIdentifier pident1 = \{\textcolor{stringliteral}{"bar"}, m1\};
409 
410   pl.emplace\_back(pident1);
411 
412   std::unordered\_map<std::string, StructuredHeaderItem> m2;
413 
414   item.tag = StructuredHeaderItem::Type::NONE;
415   m2[\textcolor{stringliteral}{"foo"}] = item;
416 
417   item.tag = StructuredHeaderItem::Type::INT64;
418   int64\_t val4 = 100;
419   item.value = val4;
420   m2[\textcolor{stringliteral}{"goo"}] = item;
421 
422   ParameterisedIdentifier pident2 = \{\textcolor{stringliteral}{"far"}, m2\};
423 
424   pl.emplace\_back(pident2);
425 
426   StructuredHeadersEncoder encoder;
427   \textcolor{keyword}{auto} err = encoder.encodeParameterisedList(pl);
428 
429   EXPECT\_EQ(err, EncodeError::OK);
430 
431   \textcolor{comment}{// The order of the parameters of a particular identifier doesn't matter,}
432   \textcolor{comment}{// so any of these permutations is acceptable}
433   EXPECT\_THAT(encoder.get(), AnyOf(
434     Eq(\textcolor{stringliteral}{"bar; foo=4234.234; goo=*KysrIQ==*, far; foo; goo=100"}),
435     Eq(\textcolor{stringliteral}{"bar; foo=4234.234; goo=*KysrIQ==*, far; goo=100; foo"}),
436     Eq(\textcolor{stringliteral}{"bar; goo=*KysrIQ==*; foo=4234.234, far; foo; goo=100"}),
437     Eq(\textcolor{stringliteral}{"bar; goo=*KysrIQ==*; foo=4234.234, far; goo=100; foo"}),
438     Eq(\textcolor{stringliteral}{"far; foo; goo=100, bar; foo=4234.234; goo=*KysrIQ==*"}),
439     Eq(\textcolor{stringliteral}{"far; foo; goo=100, bar; goo=*KysrIQ==*; foo=4234.234"}),
440     Eq(\textcolor{stringliteral}{"far; goo=100; foo, bar; foo=4234.234; goo=*KysrIQ==*"}),
441     Eq(\textcolor{stringliteral}{"far; goo=100; foo, bar; goo=*KysrIQ==*; foo=4234.234"})
442   ));
443 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Add\+Unknown)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Add\+Unknown}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a38b7577e4ea31c8165f378ab9cead7dd}


Definition at line 401 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
401                               \{
402   buildSimpleTree();
403 
404   addTransaction(11, \{75, \textcolor{keyword}{false}, 15\});
405 
406   dump();
407   EXPECT\_EQ(nodes\_, IDList(\{
408         \{0, 50\}, \{3, 25\}, \{5, 25\}, \{9, 100\}, \{7, 50\}, \{75, 50\}, \{11, 100\}
409       \}));
410 
411   \textcolor{comment}{// Now let's add the missing parent node and check if it was}
412   \textcolor{comment}{// relocated properly}
413   addTransaction(75, \{0, \textcolor{keyword}{false}, 7\});
414 
415   dump();
416   EXPECT\_EQ(nodes\_, IDList(\{
417         \{0, 100\}, \{3, 16\}, \{5, 16\}, \{9, 100\}, \{7, 33\}, \{75, 33\}, \{11, 100\}
418       \}));
419 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Add\+Max)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Add\+Max}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a54121772afea8f7e53c52e3c2f8bb35c}


Definition at line 421 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
421                           \{
422   addTransaction(0, \{kRootNodeId, \textcolor{keyword}{false}, 255\});
423 
424   nextEgress();
425   EXPECT\_EQ(nodes\_, IDList(\{\{0, 100\}\}));
426 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Misc)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Misc}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a13ef033e3b205d556c7121894997a2fc}


Definition at line 428 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
428                         \{
429   buildSimpleTree();
430 
431   EXPECT\_FALSE(q\_.empty());
432   EXPECT\_EQ(q\_.numPendingEgress(), 5);
433   signalEgress(0, \textcolor{keyword}{false});
434   EXPECT\_EQ(q\_.numPendingEgress(), 4);
435   EXPECT\_FALSE(q\_.empty());
436   removeTransaction(9);
437   removeTransaction(0);
438   dump();
439   EXPECT\_EQ(nodes\_, IDList(\{\{3, 25\}, \{5, 25\}, \{7, 50\}\}));
440 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Iterate\+B\+F\+S)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Iterate\+B\+FS}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a4a1eb6014a87292692e9c97c3a82ec2c}


Definition at line 442 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
442                               \{
443   buildSimpleTree();
444 
445   \textcolor{keyword}{auto} stopFn = [\textcolor{keyword}{this}] \{
446     \textcolor{keywordflow}{return} nodes\_.size() > 2;
447   \};
448 
449   dumpBFS(stopFn);
450   EXPECT\_EQ(nodes\_, IDList(\{\{0, 100\}, \{3, 25\}, \{5, 25\}, \{7, 50\}\}));
451 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+Param\+List\+Empty)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+Param\+List\+Empty}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_aff91d2919772a8472c67b710dcb559e4}


Definition at line 445 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Parameterised\+List().


\begin{DoxyCode}
445                                                          \{
446   ParameterisedList pl;
447   StructuredHeadersEncoder encoder;
448   \textcolor{keyword}{auto} err = encoder.encodeParameterisedList(pl);
449 
450   EXPECT\_NE(err, EncodeError::OK);
451 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+Param\+List\+Bad\+Secondary\+Identifier)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+Param\+List\+Bad\+Secondary\+Identifier}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ae16a08566f50d41033a02c6c59dc89f7}


Definition at line 453 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Parameterised\+List(), proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
453                                                                           \{
454   ParameterisedList pl;
455   std::unordered\_map<std::string, StructuredHeaderItem> m;
456 
457   StructuredHeaderItem item;
458 
459   item.tag = StructuredHeaderItem::Type::STRING;
460   std::string val1 = \textcolor{stringliteral}{"ABC"};
461   item.value = val1;
462   m[\textcolor{stringliteral}{"\(\backslash\)nbbb"}] = item;
463 
464   ParameterisedIdentifier pident = \{\textcolor{stringliteral}{"foo"}, m\};
465 
466   pl.emplace\_back(pident);
467 
468   StructuredHeadersEncoder encoder;
469   \textcolor{keyword}{auto} err = encoder.encodeParameterisedList(pl);
470 
471   EXPECT\_NE(err, EncodeError::OK);
472 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Next\+Egress)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Next\+Egress}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a08e13e71203377b98c54cc0a4f73dec9}


Definition at line 453 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
453                               \{
454   buildSimpleTree();
455 
456   nextEgress();
457   EXPECT\_EQ(nodes\_, IDList(\{\{0, 100\}\}));
458 
459   addTransaction(11, \{7, \textcolor{keyword}{false}, 15\});
460   signalEgress(0, \textcolor{keyword}{false});
461 
462   nextEgress();
463   EXPECT\_EQ(nodes\_, IDList(\{\{7, 50\}, \{3, 25\}, \{5, 25\}\}));
464 
465   signalEgress(5, \textcolor{keyword}{false});
466   nextEgress();
467   EXPECT\_EQ(nodes\_, IDList(\{\{7, 50\}, \{3, 25\}, \{9, 25\}\}));
468   signalEgress(5, \textcolor{keyword}{true});
469 
470   signalEgress(3, \textcolor{keyword}{false});
471   nextEgress();
472   EXPECT\_EQ(nodes\_, IDList(\{\{7, 66\}, \{5, 33\}\}));
473 
474   signalEgress(5, \textcolor{keyword}{false});
475   nextEgress();
476   EXPECT\_EQ(nodes\_, IDList(\{\{7, 66\}, \{9, 33\}\}));
477 
478   signalEgress(7, \textcolor{keyword}{false});
479   nextEgress();
480   EXPECT\_EQ(nodes\_, IDList(\{\{11, 66\}, \{9, 33\}\}));
481 
482   signalEgress(9, \textcolor{keyword}{false});
483   nextEgress();
484   EXPECT\_EQ(nodes\_, IDList(\{\{11, 100\}\}));
485 
486   signalEgress(3, \textcolor{keyword}{true});
487   signalEgress(7, \textcolor{keyword}{true});
488   signalEgress(9, \textcolor{keyword}{true});
489   nextEgress();
490   EXPECT\_EQ(nodes\_, IDList(\{\{7, 50\}, \{3, 25\}, \{9, 25\}\}));
491 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+Param\+List\+Bad\+Primary\+Identifier)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+Param\+List\+Bad\+Primary\+Identifier}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_acbc9adacb3b5135246e7651474596754}


Definition at line 474 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Parameterised\+List(), proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
474                                                                         \{
475   ParameterisedList pl;
476   std::unordered\_map<std::string, StructuredHeaderItem> m;
477 
478   StructuredHeaderItem item;
479 
480   item.tag = StructuredHeaderItem::Type::INT64;
481   int64\_t val1 = 143;
482   item.value = val1;
483   m[\textcolor{stringliteral}{"abc"}] = item;
484 
485   ParameterisedIdentifier pident = \{\textcolor{stringliteral}{"a+++"}, m\};
486 
487   pl.emplace\_back(pident);
488 
489   StructuredHeadersEncoder encoder;
490   \textcolor{keyword}{auto} err = encoder.encodeParameterisedList(pl);
491 
492   EXPECT\_NE(err, EncodeError::OK);
493 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Next\+Egress\+Exclusive\+Add)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Next\+Egress\+Exclusive\+Add}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ab4490bec1d8fcf9ff7b39d2de189d2af}


Definition at line 493 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
493                                           \{
494   buildSimpleTree();
495 
496   \textcolor{comment}{// clear all egress}
497   signalEgress(0, \textcolor{keyword}{false});
498   signalEgress(3, \textcolor{keyword}{false});
499   signalEgress(5, \textcolor{keyword}{false});
500   signalEgress(7, \textcolor{keyword}{false});
501   signalEgress(9, \textcolor{keyword}{false});
502 
503   \textcolor{comment}{// Add a transaction with exclusive dependency, clear its egress}
504   addTransaction(11, \{0, \textcolor{keyword}{true}, 100\});
505   signalEgress(11, \textcolor{keyword}{false});
506 
507   \textcolor{comment}{// signal egress for a child that got moved via exclusive dep}
508   signalEgress(3, \textcolor{keyword}{true});
509   nextEgress();
510   EXPECT\_EQ(nodes\_, IDList(\{\{3, 100\}\}));
511   EXPECT\_EQ(q\_.numPendingEgress(), 1);
512 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Structured\+Headers\+Encoder\+Test, Test\+Param\+List\+Bad\+Items)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Headers\+Encoder\+Test}}]{, }
\item[{Test\+Param\+List\+Bad\+Items}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a4387ecb78dd2f1aaf0d73bbf38b85aee}


Definition at line 495 of file Structured\+Headers\+Encoder\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Encoder\+::encode\+Parameterised\+List(), proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::value.


\begin{DoxyCode}
495                                                             \{
496   ParameterisedList pl;
497   std::unordered\_map<std::string, StructuredHeaderItem> m;
498 
499   StructuredHeaderItem item;
500 
501   item.tag = StructuredHeaderItem::Type::STRING;
502   std::string val1 = \textcolor{stringliteral}{"AB\(\backslash\)nC"};
503   item.value = val1;
504   m[\textcolor{stringliteral}{"bbb"}] = item;
505 
506   ParameterisedIdentifier pident = \{\textcolor{stringliteral}{"foo"}, m\};
507 
508   pl.emplace\_back(pident);
509 
510   StructuredHeadersEncoder encoder;
511   \textcolor{keyword}{auto} err = encoder.encodeParameterisedList(pl);
512 
513   EXPECT\_NE(err, EncodeError::OK);
514 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Next\+Egress\+Exclusive\+Add\+With\+Egress)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Next\+Egress\+Exclusive\+Add\+With\+Egress}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ad4d1f3947faff002b94ff552b94b6f18}


Definition at line 514 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
514                                                     \{
515   buildSimpleTree();
516 
517   \textcolor{comment}{// clear all egress, except 3}
518   signalEgress(0, \textcolor{keyword}{false});
519   signalEgress(5, \textcolor{keyword}{false});
520   signalEgress(7, \textcolor{keyword}{false});
521   signalEgress(9, \textcolor{keyword}{false});
522 
523   \textcolor{comment}{// Add a transaction with exclusive dependency, clear its egress}
524   addTransaction(11, \{0, \textcolor{keyword}{true}, 100\});
525   signalEgress(11, \textcolor{keyword}{false});
526   nextEgress();
527   EXPECT\_EQ(nodes\_, IDList(\{\{3, 100\}\}));
528   EXPECT\_EQ(q\_.numPendingEgress(), 1);
529 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Update\+Priority\+Reparent\+Subtree)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Update\+Priority\+Reparent\+Subtree}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_aa447a4963e010c99a1d26d7917e002b0}


Definition at line 531 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
531                                                  \{
532   buildSimpleTree();
533 
534   \textcolor{comment}{// clear all egress, except 9}
535   signalEgress(0, \textcolor{keyword}{false});
536   signalEgress(3, \textcolor{keyword}{false});
537   signalEgress(5, \textcolor{keyword}{false});
538   signalEgress(7, \textcolor{keyword}{false});
539 
540   \textcolor{comment}{// Update priority of non-enqueued but in egress tree node}
541   updatePriority(5, \{0, \textcolor{keyword}{false}, 14\}, \textcolor{keyword}{nullptr});
542 
543   \textcolor{comment}{// update 9's weight and reparent}
544   updatePriority(9, \{3, \textcolor{keyword}{false}, 14\}, \textcolor{keyword}{nullptr});
545 
546   nextEgress();
547   EXPECT\_EQ(nodes\_, IDList(\{\{9, 100\}\}));
548 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Next\+Egress\+Remove\+Parent)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Next\+Egress\+Remove\+Parent}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_aaf83f75a190160d6977cb5df9e9e337c}


Definition at line 550 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
550                                           \{
551   buildSimpleTree();
552 
553   \textcolor{comment}{// Clear egress for all except txn=9}
554   signalEgress(0, \textcolor{keyword}{false});
555   signalEgress(3, \textcolor{keyword}{false});
556   signalEgress(5, \textcolor{keyword}{false});
557   signalEgress(7, \textcolor{keyword}{false});
558 
559   \textcolor{comment}{// Remove parent of 9 (5)}
560   removeTransaction(5);
561   nextEgress();
562   EXPECT\_EQ(nodes\_, IDList(\{\{9, 100\}\}));
563 
564   \textcolor{comment}{// signal egress for 9's new siblings to verify weights}
565   signalEgress(3, \textcolor{keyword}{true});
566   signalEgress(7, \textcolor{keyword}{true});
567 
568   nextEgress();
569   EXPECT\_EQ(nodes\_, IDList(\{\{7, 50\}, \{9, 25\}, \{3, 25\}\}));
570 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Add\+Exclusive\+Descendant\+Enqueued)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Add\+Exclusive\+Descendant\+Enqueued}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a40aea6c0bb739e558e824755b56f2e09}


Definition at line 572 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
572                                                   \{
573   addTransaction(0, \{kRootNodeId, \textcolor{keyword}{false}, 100\});
574   addTransaction(3, \{0, \textcolor{keyword}{false}, 100\});
575   addTransaction(5, \{3, \textcolor{keyword}{false}, 100\});
576   signalEgress(0, \textcolor{keyword}{false});
577   signalEgress(3, \textcolor{keyword}{false});
578   \textcolor{comment}{// add a new exclusive child of 1.  1's child 3 is not enqueued but is in the}
579   \textcolor{comment}{// the egress tree.}
580   addTransaction(7, \{0, \textcolor{keyword}{true}, 100\});
581   nextEgress();
582   EXPECT\_EQ(nodes\_, IDList(\{\{7, 100\}\}));
583 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Next\+Egress\+Remove\+Parent\+Enqueued)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Next\+Egress\+Remove\+Parent\+Enqueued}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a5e6463a2472004267764c23271eb3fbe}


Definition at line 585 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
585                                                   \{
586   addTransaction(0, \{kRootNodeId, \textcolor{keyword}{false}, 100\});
587   addTransaction(3, \{0, \textcolor{keyword}{false}, 100\});
588   addTransaction(5, \{3, \textcolor{keyword}{false}, 100\});
589   signalEgress(3, \textcolor{keyword}{false});
590   \textcolor{comment}{// When 3's children (5) are added to 1, both are already in the egress tree}
591   \textcolor{comment}{// and the signal does not need to propagate}
592   removeTransaction(3);
593   signalEgress(0, \textcolor{keyword}{false});
594   nextEgress();
595   EXPECT\_EQ(nodes\_, IDList(\{\{5, 100\}\}));
596 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Next\+Egress\+Remove\+Parent\+Enqueued\+Indirect)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Next\+Egress\+Remove\+Parent\+Enqueued\+Indirect}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ade89619a24dc9ce1c618a197a33b9407}


Definition at line 598 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
598                                                           \{
599   addTransaction(0, \{kRootNodeId, \textcolor{keyword}{false}, 100\});
600   addTransaction(3, \{0, \textcolor{keyword}{false}, 100\});
601   addTransaction(5, \{3, \textcolor{keyword}{false}, 100\});
602   addTransaction(7, \{0, \textcolor{keyword}{false}, 100\});
603   signalEgress(3, \textcolor{keyword}{false});
604   signalEgress(0, \textcolor{keyword}{false});
605   \textcolor{comment}{// When 3's children (5) are added to 1, both are already in the egress tree}
606   \textcolor{comment}{// and the signal does not need to propagate}
607   removeTransaction(3);
608   nextEgress();
609   EXPECT\_EQ(nodes\_, IDList(\{\{7, 50\}, \{5, 50\}\}));
610 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Chrome\+Test)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Chrome\+Test}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_adf3c6019e0dd4f12f08a1f2b3d445893}


Definition at line 612 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
612                               \{
613   \textcolor{comment}{// Tries to simulate Chrome's current behavior by performing pseudo-random}
614   \textcolor{comment}{// add-exclusive, signal, clear and remove with 3 insertion points}
615   \textcolor{comment}{// (hi,mid,low).  Note the test uses rand32() with a particular seed so the}
616   \textcolor{comment}{// output is predictable.}
617   HTTPCodec::StreamID pris[3] = \{0, 3, 5\};
618   addTransaction(0, \{kRootNodeId, \textcolor{keyword}{true}, 99\});
619   signalEgress(0, \textcolor{keyword}{false});
620   addTransaction(3, \{0, \textcolor{keyword}{true}, 99\});
621   signalEgress(3, \textcolor{keyword}{false});
622   addTransaction(5, \{3, \textcolor{keyword}{true}, 99\});
623   signalEgress(5, \textcolor{keyword}{false});
624 
625   std::vector<HTTPCodec::StreamID> txns;
626   std::vector<HTTPCodec::StreamID> active;
627   std::vector<HTTPCodec::StreamID> inactive;
628   HTTPCodec::StreamID txn = 0;
629   uint64\_t idx = 0;
630   HTTPCodec::StreamID nextId = 7;
631   \textcolor{keyword}{auto} gen = Random::create();
632   gen.seed(12345); \textcolor{comment}{// luggage combo}
633   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = 4; i < 1000; i++) \{
634     uint8\_t action = rand32(4, gen);
635     \textcolor{keywordflow}{if} (action == 0) \{
636       \textcolor{comment}{// add exclusive on pseudo-random priority anchor}
637       uint8\_t pri = rand32(3, gen);
638       HTTPCodec::StreamID dep = pris[pri];
639       txn = nextId;
640       nextId += 2;
641       VLOG(2) << \textcolor{stringliteral}{"Adding txn="} << txn << \textcolor{stringliteral}{" with dep="} << dep;
642       addTransaction(txn, \{(uint32\_t)dep, \textcolor{keyword}{true}, 99\});
643       txns.push\_back(txn);
644       active.push\_back(txn);
645     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (action == 1 && !inactive.empty()) \{
646       \textcolor{comment}{// signal an inactive txn}
647       idx = rand32(inactive.size(), gen);
648       txn = inactive[idx];
649       VLOG(2) << \textcolor{stringliteral}{"Activating txn="} << txn;
650       signalEgress(txn, \textcolor{keyword}{true});
651       inactive.erase(inactive.begin() + idx);
652       active.push\_back(txn);
653     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (action == 2 && !active.empty()) \{
654       \textcolor{comment}{// clear an active transaction}
655       idx = rand32(active.size(), gen);
656       txn = active[idx];
657       VLOG(2) << \textcolor{stringliteral}{"Deactivating txn="} << txn;
658       signalEgress(txn, \textcolor{keyword}{false});
659       active.erase(active.begin() + idx);
660       inactive.push\_back(txn);
661     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (action == 3 && !txns.empty()) \{
662       \textcolor{comment}{// remove a transaction}
663       idx = rand32(txns.size(), gen);
664       txn = txns[idx];
665       VLOG(2) << \textcolor{stringliteral}{"Removing txn="} << txn;
666       removeTransaction(txn);
667       txns.erase(txns.begin() + idx);
668       \textcolor{keyword}{auto} it = std::find(active.begin(), active.end(), txn);
669       \textcolor{keywordflow}{if} (it != active.end()) \{
670         active.erase(it);
671       \}
672       it = std::find(inactive.begin(), inactive.end(), txn);
673       \textcolor{keywordflow}{if} (it != inactive.end()) \{
674         inactive.erase(it);
675       \}
676     \}
677     VLOG(2) << \textcolor{stringliteral}{"Active nodes="} << q\_.numPendingEgress();
678     \textcolor{keywordflow}{if} (!q\_.empty()) \{
679       nextEgress();
680       EXPECT\_GT(nodes\_.size(), 0);
681     \}
682 
683   \}
684 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Next\+Egress\+Spdy)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Next\+Egress\+Spdy}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_aa834c997d9ef9156ca6b71851a4bdbbd}


Definition at line 686 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
686                                   \{
687   \textcolor{comment}{// 0 and 3 are vnodes representing pri 0 and 1}
688   addTransaction(0, \{kRootNodeId, \textcolor{keyword}{false}, 0\}, \textcolor{keyword}{true});
689   addTransaction(3, \{0, \textcolor{keyword}{false}, 0\}, \textcolor{keyword}{true});
690 
691   \textcolor{comment}{// 7 and 9 are pri 0, 11 and 13 are pri 1}
692   addTransaction(7, \{0, \textcolor{keyword}{false}, 15\});
693   addTransaction(9, \{0, \textcolor{keyword}{false}, 15\});
694   addTransaction(11, \{3, \textcolor{keyword}{false}, 15\});
695   addTransaction(13, \{3, \textcolor{keyword}{false}, 15\});
696 
697   nextEgress(\textcolor{keyword}{true});
698   EXPECT\_EQ(nodes\_, IDList(\{\{7, 50\}, \{9, 50\}\}));
699 
700   signalEgress(7, \textcolor{keyword}{false});
701   nextEgress(\textcolor{keyword}{true});
702   EXPECT\_EQ(nodes\_, IDList(\{\{9, 100\}\}));
703 
704   signalEgress(9, \textcolor{keyword}{false});
705   nextEgress(\textcolor{keyword}{true});
706   EXPECT\_EQ(nodes\_, IDList(\{\{11, 50\}, \{13, 50\}\}));
707 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Add\+Or\+Update)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Add\+Or\+Update}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a802641562b01049dc60803e2cd0afae1}


Definition at line 709 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
709                                \{
710   q\_.addOrUpdatePriorityNode(0, \{kRootNodeId, \textcolor{keyword}{false}, 15\});
711   q\_.addOrUpdatePriorityNode(3, \{kRootNodeId, \textcolor{keyword}{false}, 15\});
712   dump();
713   EXPECT\_EQ(nodes\_, IDList(\{\{0, 50\}, \{3, 50\}\}));
714   q\_.addOrUpdatePriorityNode(0, \{kRootNodeId, \textcolor{keyword}{false}, 3\});
715   dump();
716   EXPECT\_EQ(nodes\_, IDList(\{\{0, 20\}, \{3, 80\}\}));
717 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Dangling\+Queue\+Test, Basic)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Dangling\+Queue\+Test}}]{, }
\item[{Basic}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_abaa1f492d7507778245ecb9f9edf04ff}


Definition at line 766 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
766                                  \{
767   addTransaction(0, \{kRootNodeId, \textcolor{keyword}{false}, 15\});
768   removeTransaction(0);
769   dump();
770   EXPECT\_EQ(nodes\_, IDList(\{\{0, 100\}\}));
771   expireNodes();
772   dump();
773   EXPECT\_EQ(nodes\_, IDList(\{\}));
774 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Dangling\+Queue\+Test, Chain)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Dangling\+Queue\+Test}}]{, }
\item[{Chain}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a51ef38b37af0331f47fd5a710a49d70d}


Definition at line 776 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
776                                  \{
777   addTransaction(0, \{kRootNodeId, \textcolor{keyword}{false}, 15\}, \textcolor{keyword}{true});
778   addTransaction(3, \{0, \textcolor{keyword}{false}, 15\}, \textcolor{keyword}{true});
779   addTransaction(5, \{3, \textcolor{keyword}{false}, 15\}, \textcolor{keyword}{true});
780   dump();
781   EXPECT\_EQ(nodes\_, IDList(\{\{0, 100\}, \{3, 100\}, \{5, 100\}\}));
782   expireNodes();
783   dump();
784   EXPECT\_EQ(nodes\_, IDList(\{\{0, 100\}, \{3, 100\}\}));
785   expireNodes();
786   dump();
787   EXPECT\_EQ(nodes\_, IDList(\{\{0, 100\}\}));
788   expireNodes();
789   dump();
790   EXPECT\_EQ(nodes\_, IDList(\{\}));
791 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Dangling\+Queue\+Test, Drop)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Dangling\+Queue\+Test}}]{, }
\item[{Drop}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a1a3687e7a856cd063268d9910f3bf15d}


Definition at line 793 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
793                                 \{
794   addTransaction(0, \{kRootNodeId, \textcolor{keyword}{false}, 15\}, \textcolor{keyword}{true});
795   addTransaction(3, \{0, \textcolor{keyword}{false}, 15\}, \textcolor{keyword}{true});
796   addTransaction(5, \{0, \textcolor{keyword}{false}, 15\}, \textcolor{keyword}{true});
797   dump();
798   q\_.dropPriorityNodes();
799   dump();
800   EXPECT\_EQ(nodes\_, IDList(\{\}));
801 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Dangling\+Queue\+Test, Expire\+Parent\+Of\+Mismatched\+Twins)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Dangling\+Queue\+Test}}]{, }
\item[{Expire\+Parent\+Of\+Mismatched\+Twins}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ab33c187559983d1f7b0dc8339f7e29c1}


Definition at line 803 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
803                                                          \{
804   addTransaction(0, \{kRootNodeId, \textcolor{keyword}{true}, 219\}, \textcolor{keyword}{false});
805   addTransaction(3, \{0, \textcolor{keyword}{false}, 146\}, \textcolor{keyword}{false});
806   addTransaction(5, \{0, \textcolor{keyword}{false}, 146\}, \textcolor{keyword}{false});
807   signalEgress(3, \textcolor{keyword}{false});
808   signalEgress(5, \textcolor{keyword}{true});
809   removeTransaction(0);
810   dump();
811   tick();
812   expireNodes();
813   dump();
814   EXPECT\_EQ(nodes\_, IDList(\{\{3, 50\}, \{5, 50\}\}));
815 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Dangling\+Queue\+Test, Refresh)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Dangling\+Queue\+Test}}]{, }
\item[{Refresh}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a794cab4edadbd96071f048c1bf0d4325}


Definition at line 823 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
823                                    \{
824   \textcolor{comment}{// Having a long running timeout prevents HHWheelTimer::Callback::setScheduled}
825   \textcolor{comment}{// from checking the real time}
826   DummyTimeout t;
827   timer\_.scheduleTimeout(&t, std::chrono::seconds(300));
828   addTransaction(0, \{kRootNodeId, \textcolor{keyword}{false}, 15\});
829   addTransaction(3, \{kRootNodeId, \textcolor{keyword}{false}, 15\});
830   \textcolor{comment}{// 0 is now virtual}
831   removeTransaction(0);
832   dump();
833   EXPECT\_EQ(nodes\_, IDList(\{\{0, 50\}, \{3, 50\}\}));
834   tick();
835   \textcolor{comment}{// before 0 times out, change it's priority, should still be there}
836   updatePriority(0, \{kRootNodeId, \textcolor{keyword}{false}, 3\});
837   dump();
838   EXPECT\_EQ(nodes\_, IDList(\{\{0, 20\}, \{3, 80\}\}));
839 
840   tick();
841   dump();
842   EXPECT\_EQ(nodes\_, IDList(\{\{0, 20\}, \{3, 80\}\}));
843   expireNodes();
844   dump();
845   EXPECT\_EQ(nodes\_, IDList(\{\{3, 100\}\}));
846 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Dangling\+Queue\+Test, Max)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Dangling\+Queue\+Test}}]{, }
\item[{Max}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_afd2ae8ed9a4cdcc2cbb2b961686c5c72}


Definition at line 848 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
848                                \{
849   buildSimpleTree();
850   q\_.setMaxVirtualNodes(3);
851   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i = 1; i <= 9; i += 2) \{
852     removeTransaction(i == 1 ? 0 : i);
853   \}
854   dump();
855   EXPECT\_EQ(nodes\_, IDList(\{\{0, 100\}, \{3, 50\}, \{5, 50\}\}));
856   \textcolor{comment}{// 0 expires first and it re-weights 3 and 5, which extends their lifetime}
857   expireNodes();
858   dump();
859   EXPECT\_EQ(nodes\_, IDList(\{\{3, 50\}, \{5, 50\}\}));
860   expireNodes();
861   dump();
862   EXPECT\_EQ(nodes\_, IDList());
863 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Queue\+Test, Rebuild)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Queue\+Test}}]{, }
\item[{Rebuild}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a2975366cbc7c54c62e18feb831d88982}


Definition at line 865 of file H\+T\+T\+P2\+Priority\+Queue\+Test.\+cpp.


\begin{DoxyCode}
865                            \{
866   buildSimpleTree();
867   q\_.rebuildTree();
868   dump();
869   EXPECT\_EQ(nodes\_, IDList(\{\{3, 20\}, \{9, 20\}, \{5, 20\}, \{7, 20\}, \{0, 20\}\}));
870 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+P@{T\+E\+S\+T\+\_\+P}}
\index{T\+E\+S\+T\+\_\+P@{T\+E\+S\+T\+\_\+P}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+P(\+Legal\+String\+Tests, Legal\+Strings)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+P (
\begin{DoxyParamCaption}
\item[{{\bf Legal\+String\+Tests}}]{, }
\item[{Legal\+Strings}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_ac6281568f2d8ba3f494f8e838de82c8b}


Definition at line 220 of file Structured\+Headers\+Standard\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+Item(), proxygen\+::\+Structured\+Headers\+::\+OK, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag.


\begin{DoxyCode}
220                                        \{
221   std::string input(GetParam().first);
222   StructuredHeadersDecoder shd(input);
223   StructuredHeaderItem output;
224   \textcolor{keyword}{auto} err = shd.decodeItem(output);
225   EXPECT\_EQ(err, StructuredHeaders::DecodeError::OK);
226   EXPECT\_EQ(output.tag, StructuredHeaderItem::Type::STRING);
227   EXPECT\_EQ(output, GetParam().second);
228 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+P@{T\+E\+S\+T\+\_\+P}}
\index{T\+E\+S\+T\+\_\+P@{T\+E\+S\+T\+\_\+P}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+P(\+Legal\+Binary\+Content\+Tests, Legal\+Binary\+Content)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+P (
\begin{DoxyParamCaption}
\item[{{\bf Legal\+Binary\+Content\+Tests}}]{, }
\item[{Legal\+Binary\+Content}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_accdaa47e84bb3e7bca9234deef8e85fe}


Definition at line 230 of file Structured\+Headers\+Standard\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Standard\+Test\+::decode32(), proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+Item(), proxygen\+::\+Structured\+Headers\+::\+OK, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag.


\begin{DoxyCode}
230                                                     \{
231   std::string input(GetParam().first);
232   std::string expectedOutputInBase32(GetParam().second);
233   std::string expectedOutput;
234   decode32(expectedOutputInBase32, expectedOutput);
235 
236   StructuredHeadersDecoder shd(input);
237   StructuredHeaderItem output;
238   \textcolor{keyword}{auto} err = shd.decodeItem(output);
239   EXPECT\_EQ(err, StructuredHeaders::DecodeError::OK);
240   EXPECT\_EQ(output.tag, StructuredHeaderItem::Type::BINARYCONTENT);
241   EXPECT\_EQ(output, expectedOutput);
242 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+P@{T\+E\+S\+T\+\_\+P}}
\index{T\+E\+S\+T\+\_\+P@{T\+E\+S\+T\+\_\+P}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+P(\+R\+F\+C1867\+C\+R, Test)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+P (
\begin{DoxyParamCaption}
\item[{{\bf R\+F\+C1867\+CR}}]{, }
\item[{Test}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_acdc190ff8525cca6119fd72da89633b9}


Definition at line 243 of file R\+F\+C1867\+Test.\+cpp.



References I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+P().


\begin{DoxyCode}
243                         \{
244   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 1; i < GetParam().size(); i++) \{
245     \textcolor{keyword}{auto} data = makePost(\{\{\textcolor{stringliteral}{"foo"}, \textcolor{stringliteral}{"bar"}\}, \{\textcolor{stringliteral}{"jojo"}, \textcolor{stringliteral}{"binky"}\}\},
246                          \{\{\textcolor{stringliteral}{"file1"}, \{\textcolor{stringliteral}{"dummy file name"}, GetParam()\}\}\},
247                          \{\});
248     testSimple(std::move(data), 3 + 5 + GetParam().size(), i, 3);
249   \}
250 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+P@{T\+E\+S\+T\+\_\+P}}
\index{T\+E\+S\+T\+\_\+P@{T\+E\+S\+T\+\_\+P}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+P(\+Legal\+Integer\+Tests, Legal\+Integers)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+P (
\begin{DoxyParamCaption}
\item[{{\bf Legal\+Integer\+Tests}}]{, }
\item[{Legal\+Integers}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_adbfa986df0eb74efd33e04a023f830b8}


Definition at line 244 of file Structured\+Headers\+Standard\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+Item(), proxygen\+::\+Structured\+Headers\+::\+OK, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag.


\begin{DoxyCode}
244                                          \{
245   std::string input(GetParam().first);
246   StructuredHeadersDecoder shd(input);
247   StructuredHeaderItem output;
248   \textcolor{keyword}{auto} err = shd.decodeItem(output);
249   EXPECT\_EQ(err, StructuredHeaders::DecodeError::OK);
250   EXPECT\_EQ(output.tag, StructuredHeaderItem::Type::INT64);
251   EXPECT\_EQ(output, GetParam().second);
252 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+P@{T\+E\+S\+T\+\_\+P}}
\index{T\+E\+S\+T\+\_\+P@{T\+E\+S\+T\+\_\+P}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+P(\+Legal\+Float\+Tests, Legal\+Floats)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+P (
\begin{DoxyParamCaption}
\item[{{\bf Legal\+Float\+Tests}}]{, }
\item[{Legal\+Floats}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a7cea3046cd23336d90fb7037d7bbf1b5}


Definition at line 254 of file Structured\+Headers\+Standard\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+Item(), proxygen\+::\+Structured\+Headers\+::\+OK, and proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag.


\begin{DoxyCode}
254                                      \{
255   std::string input(GetParam().first);
256   StructuredHeadersDecoder shd(input);
257   StructuredHeaderItem output;
258   \textcolor{keyword}{auto} err = shd.decodeItem(output);
259   EXPECT\_EQ(err, StructuredHeaders::DecodeError::OK);
260   EXPECT\_EQ(output.tag, StructuredHeaderItem::Type::DOUBLE);
261   EXPECT\_EQ(output, GetParam().second);
262 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+P@{T\+E\+S\+T\+\_\+P}}
\index{T\+E\+S\+T\+\_\+P@{T\+E\+S\+T\+\_\+P}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+P(\+Illegal\+Item\+Test, Illegal\+Item)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+P (
\begin{DoxyParamCaption}
\item[{{\bf Illegal\+Item\+Test}}]{, }
\item[{Illegal\+Item}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_abebe37303799c21dd14deb6aa66b2aa4}


Definition at line 264 of file Structured\+Headers\+Standard\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+Item(), and proxygen\+::\+Structured\+Headers\+::\+OK.


\begin{DoxyCode}
264                                      \{
265   StructuredHeadersDecoder shd(GetParam());
266   StructuredHeaderItem output;
267   \textcolor{keyword}{auto} err = shd.decodeItem(output);
268   EXPECT\_NE(err, StructuredHeaders::DecodeError::OK);
269 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!T\+E\+S\+T\+\_\+P@{T\+E\+S\+T\+\_\+P}}
\index{T\+E\+S\+T\+\_\+P@{T\+E\+S\+T\+\_\+P}!proxygen@{proxygen}}
\subsubsection[{T\+E\+S\+T\+\_\+\+P(\+Illegal\+List\+Test, Illegal\+List)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+T\+E\+S\+T\+\_\+P (
\begin{DoxyParamCaption}
\item[{{\bf Illegal\+List\+Test}}]{, }
\item[{Illegal\+List}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a87b187521ee5bf20347e2ed75163baa1}


Definition at line 271 of file Structured\+Headers\+Standard\+Test.\+cpp.



References proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+List(), I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+P(), k\+Legal\+Bin\+Content\+Tests, k\+Legal\+String\+Tests, and proxygen\+::\+Structured\+Headers\+::\+OK.


\begin{DoxyCode}
271                                      \{
272   StructuredHeadersDecoder shd(GetParam());
273   std::vector<StructuredHeaderItem> output;
274   \textcolor{keyword}{auto} err = shd.decodeList(output);
275   EXPECT\_NE(err, StructuredHeaders::DecodeError::OK);
276 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!time\+Point\+Initialized@{time\+Point\+Initialized}}
\index{time\+Point\+Initialized@{time\+Point\+Initialized}!proxygen@{proxygen}}
\subsubsection[{time\+Point\+Initialized(const T \&time)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ bool proxygen\+::time\+Point\+Initialized (
\begin{DoxyParamCaption}
\item[{const {\bf T} \&}]{time}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_a18e4e9b5cbf074eede73d78fdd7db5f1}


Definition at line 35 of file Time.\+h.



References T.



Referenced by Test\+Async\+Transport\+::add\+Read\+Error(), Test\+Async\+Transport\+::fire\+Next\+Read\+Event(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::get\+Idle\+Time(), Test\+Async\+Transport\+::set\+Read\+C\+B(), proxygen\+::\+Async\+Timeout\+Set\+::\+Callback\+::set\+Scheduled(), and proxygen\+::\+H\+T\+T\+P\+Connector\+::time\+Elapsed().


\begin{DoxyCode}
35                                          \{
36   \textcolor{keyword}{static} T epoch;
37   \textcolor{keywordflow}{return} time > epoch;
38 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!to\+System\+Time\+Point@{to\+System\+Time\+Point}}
\index{to\+System\+Time\+Point@{to\+System\+Time\+Point}!proxygen@{proxygen}}
\subsubsection[{to\+System\+Time\+Point(\+Time\+Point t)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::chrono\+::system\+\_\+clock\+::time\+\_\+point proxygen\+::to\+System\+Time\+Point (
\begin{DoxyParamCaption}
\item[{{\bf Time\+Point}}]{t}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_ad31d2b96b00129eb8079a50611643c87}


Definition at line 46 of file Time.\+h.



Referenced by milliseconds\+Since\+Epoch(), seconds\+Since\+Epoch(), and to\+Time\+T().


\begin{DoxyCode}
46                                \{
47   \textcolor{keywordflow}{return} std::chrono::system\_clock::now() +
48     std::chrono::duration\_cast<std::chrono::system\_clock::duration>(
49       t - SteadyClock::now());
50 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!to\+TimeT@{to\+TimeT}}
\index{to\+TimeT@{to\+TimeT}!proxygen@{proxygen}}
\subsubsection[{to\+Time\+T(\+Time\+Point t)}]{\setlength{\rightskip}{0pt plus 5cm}time\+\_\+t proxygen\+::to\+TimeT (
\begin{DoxyParamCaption}
\item[{{\bf Time\+Point}}]{t}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_a7edd642a092f3aa4a5e1138768aace03}


Definition at line 52 of file Time.\+h.



References to\+System\+Time\+Point().



Referenced by get\+Date\+Offset\+Str(), and get\+Date\+Time\+Str().


\begin{DoxyCode}
52                                    \{
53   \textcolor{keywordflow}{return} std::chrono::system\_clock::to\_time\_t(toSystemTimePoint(t));
54 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!validate\+Scheme@{validate\+Scheme}}
\index{validate\+Scheme@{validate\+Scheme}!proxygen@{proxygen}}
\subsubsection[{validate\+Scheme(folly\+::\+String\+Piece url)}]{\setlength{\rightskip}{0pt plus 5cm}static bool proxygen\+::validate\+Scheme (
\begin{DoxyParamCaption}
\item[{folly\+::\+String\+Piece}]{url}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{namespaceproxygen_a67707524f371404ecbc1cc3db0980f76}
According to R\+FC 3986, a generic H\+T\+TP \doxyref{U\+RL}{p.}{classproxygen_1_1URL} is of the form\+: scheme\+:[//[user[\+:password]@]host[\+:port]][/path][?query][\#fragment]

\doxyref{Parse\+U\+RL}{p.}{classproxygen_1_1ParseURL} use \doxyref{http\+\_\+parser}{p.}{structhttp__parser} to parse internet url, that supports internet sematic url use double slash\+: {\tt http\+://host/path} {\tt ftp\+://host/path} rtmp\+://host/path

It does not support special scheme like\+: mailto\+:user\+:port {\tt news\+:path}

And \doxyref{Parse\+U\+RL}{p.}{classproxygen_1_1ParseURL} support partial form (U\+RI reference)\+: host\+:port/path?query\+::fragment /path?query\+::fragment ?query \#fragment 

Definition at line 48 of file Parse\+U\+R\+L.\+cpp.



Referenced by proxygen\+::\+Parse\+U\+R\+L\+::parse().


\begin{DoxyCode}
48                                                  \{
49   \textcolor{keyword}{auto} schemeEnd = url.find(\textcolor{stringliteral}{"://"});
50   \textcolor{keywordflow}{if} (schemeEnd == std::string::npos || schemeEnd == 0) \{
51     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
52   \}
53 
54   \textcolor{keyword}{auto} scheme = url.subpiece(0, schemeEnd);
55   \textcolor{keywordflow}{return} std::all\_of(scheme.begin(), scheme.end(), [](\textcolor{keyword}{auto} \_) \{
56       \textcolor{keywordflow}{return} std::isalpha(\_);
57   \});
58 \}
\end{DoxyCode}
\index{proxygen@{proxygen}!validate\+U\+RL@{validate\+U\+RL}}
\index{validate\+U\+RL@{validate\+U\+RL}!proxygen@{proxygen}}
\subsubsection[{validate\+U\+R\+L(folly\+::\+Byte\+Range url)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::validate\+U\+RL (
\begin{DoxyParamCaption}
\item[{folly\+::\+Byte\+Range}]{url}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{namespaceproxygen_afae3062d0690e981b3ffd77f3efbf229}


Definition at line 49 of file Util\+Inl.\+h.



Referenced by proxygen\+::\+Parse\+U\+R\+L\+::parse\+Non\+Fully(), and proxygen\+::\+Codec\+Util\+::validate\+U\+R\+L().


\begin{DoxyCode}
49                                             \{
50   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} p: url) \{
51     \textcolor{keywordflow}{if} (p <= 0x20 || p == 0x7f) \{
52       \textcolor{comment}{// no controls or unescaped spaces}
53       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
54       \}
55   \}
56   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
57 \}
\end{DoxyCode}


\subsection{Variable Documentation}
\index{proxygen@{proxygen}!connection\+Close\+Strings@{connection\+Close\+Strings}}
\index{connection\+Close\+Strings@{connection\+Close\+Strings}!proxygen@{proxygen}}
\subsubsection[{connection\+Close\+Strings}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ proxygen\+::connection\+Close\+Strings[$\,$]}\label{namespaceproxygen_aef43525e40d5f9d250c11c2d50f009c2}
{\bfseries Initial value\+:}
\begin{DoxyCode}
= \{

\}
\end{DoxyCode}


Definition at line 15 of file H\+T\+T\+P\+Constants.\+cpp.

\index{proxygen@{proxygen}!empty\+\_\+string@{empty\+\_\+string}}
\index{empty\+\_\+string@{empty\+\_\+string}!proxygen@{proxygen}}
\subsubsection[{empty\+\_\+string}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string proxygen\+::empty\+\_\+string}\label{namespaceproxygen_a3f4273f8e692377e868735ce25d5fc02}


Definition at line 23 of file H\+T\+T\+P\+Headers.\+cpp.



Referenced by proxygen\+::\+Gzip\+Header\+Codec\+::encode(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Method\+String(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Query\+Param(), proxygen\+::\+H\+T\+T\+P\+Headers\+::get\+Single\+Or\+Empty(), proxygen\+::\+H\+T\+T\+P\+Direct\+Response\+Handler\+::on\+Headers\+Complete(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Goaway(), and T\+E\+S\+T().

\index{proxygen@{proxygen}!H\+T\+T\+P\+Header\+Code\+Common\+Offset@{H\+T\+T\+P\+Header\+Code\+Common\+Offset}}
\index{H\+T\+T\+P\+Header\+Code\+Common\+Offset@{H\+T\+T\+P\+Header\+Code\+Common\+Offset}!proxygen@{proxygen}}
\subsubsection[{H\+T\+T\+P\+Header\+Code\+Common\+Offset}]{\setlength{\rightskip}{0pt plus 5cm}const uint8\+\_\+t proxygen\+::\+H\+T\+T\+P\+Header\+Code\+Common\+Offset = 2}\label{namespaceproxygen_a42bf80dcc3a8f0d71bfef99d19c5aa58}


Definition at line 44 of file H\+T\+T\+P\+Common\+Headers.\+template.\+h.



Referenced by H\+T\+T\+P\+Common\+Headers\+Get\+Header\+Code\+From\+Table\+Common\+Header\+Name\+Bench(), proxygen\+::\+H\+T\+T\+P\+Common\+Headers\+::is\+Header\+Name\+From\+Table(), memchr\+Bench(), std\+Find\+Bench(), and T\+E\+S\+T\+\_\+\+F().

\index{proxygen@{proxygen}!k\+Default\+Ingress\+Settings@{k\+Default\+Ingress\+Settings}}
\index{k\+Default\+Ingress\+Settings@{k\+Default\+Ingress\+Settings}!proxygen@{proxygen}}
\subsubsection[{k\+Default\+Ingress\+Settings}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf H\+T\+T\+P\+Settings} proxygen\+::k\+Default\+Ingress\+Settings}\label{namespaceproxygen_a536ef0c0e2282729971f2fcfd5bf5925}
{\bfseries Initial value\+:}
\begin{DoxyCode}
\{
  \{SettingsId::INITIAL\_WINDOW\_SIZE, 65536\}
\}
\end{DoxyCode}


Definition at line 25 of file Test\+Utils.\+cpp.

\index{proxygen@{proxygen}!k\+Default\+Max\+Concurrent\+Outgoing\+Streams@{k\+Default\+Max\+Concurrent\+Outgoing\+Streams}}
\index{k\+Default\+Max\+Concurrent\+Outgoing\+Streams@{k\+Default\+Max\+Concurrent\+Outgoing\+Streams}!proxygen@{proxygen}}
\subsubsection[{k\+Default\+Max\+Concurrent\+Outgoing\+Streams}]{\setlength{\rightskip}{0pt plus 5cm}constexpr uint32\+\_\+t proxygen\+::k\+Default\+Max\+Concurrent\+Outgoing\+Streams = 100}\label{namespaceproxygen_ab5a4b426e019b10d7587fcf375c0caf5}


Definition at line 27 of file H\+T\+T\+P\+Session\+Base.\+h.

\index{proxygen@{proxygen}!k\+Illegal\+Item\+Tests@{k\+Illegal\+Item\+Tests}}
\index{k\+Illegal\+Item\+Tests@{k\+Illegal\+Item\+Tests}!proxygen@{proxygen}}
\subsubsection[{k\+Illegal\+Item\+Tests}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::vector$<$std\+::string$>$ proxygen\+::k\+Illegal\+Item\+Tests\hspace{0.3cm}{\ttfamily [static]}}\label{namespaceproxygen_acbd90dd1af5d5207125e51eb8dba0f46}
{\bfseries Initial value\+:}
\begin{DoxyCode}
=
  \{
    \textcolor{stringliteral}{"'foo'"},
    \textcolor{stringliteral}{"\(\backslash\)"foo"},
    \textcolor{stringliteral}{"\(\backslash\)"foo \(\backslash\)\(\backslash\),\(\backslash\)""},
    \textcolor{stringliteral}{"\(\backslash\)"foo \(\backslash\)\(\backslash\)"},
    \textcolor{stringliteral}{"*aGVsbG8*"},
    \textcolor{stringliteral}{"*aGVsbG8="},
    \textcolor{stringliteral}{"*aGVsb G8=*"},
    \textcolor{stringliteral}{"*aGVsbG!8=*"},
    \textcolor{stringliteral}{"*aGVsbG!8=!*"},
    \textcolor{stringliteral}{"*iZ==*"},
    \textcolor{stringliteral}{"a23"},
    \textcolor{stringliteral}{"2,3"},
    \textcolor{stringliteral}{"-a23"},
    \textcolor{stringliteral}{"4-2"},
    \textcolor{stringliteral}{"9223372036854775808"},
    \textcolor{stringliteral}{"-9223372036854775809"},
    \textcolor{stringliteral}{"1.5.4"},
    \textcolor{stringliteral}{"1..4"}
  \}
\end{DoxyCode}


Definition at line 58 of file Structured\+Headers\+Standard\+Test.\+cpp.

\index{proxygen@{proxygen}!k\+Illegal\+List\+Tests@{k\+Illegal\+List\+Tests}}
\index{k\+Illegal\+List\+Tests@{k\+Illegal\+List\+Tests}!proxygen@{proxygen}}
\subsubsection[{k\+Illegal\+List\+Tests}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::vector$<$std\+::string$>$ proxygen\+::k\+Illegal\+List\+Tests\hspace{0.3cm}{\ttfamily [static]}}\label{namespaceproxygen_a1b984d39e31d305cf7cfa3b89b8e4930}
{\bfseries Initial value\+:}
\begin{DoxyCode}
=
  \{
    \textcolor{stringliteral}{"1, 42,"},
    \textcolor{stringliteral}{"1,,42"}
  \}
\end{DoxyCode}


Definition at line 80 of file Structured\+Headers\+Standard\+Test.\+cpp.

\index{proxygen@{proxygen}!k\+Legal\+Bin\+Content\+Tests@{k\+Legal\+Bin\+Content\+Tests}}
\index{k\+Legal\+Bin\+Content\+Tests@{k\+Legal\+Bin\+Content\+Tests}!proxygen@{proxygen}}
\subsubsection[{k\+Legal\+Bin\+Content\+Tests}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::vector$<$std\+::pair$<$std\+::string, std\+::string$>$ $>$ proxygen\+::k\+Legal\+Bin\+Content\+Tests\hspace{0.3cm}{\ttfamily [static]}}\label{namespaceproxygen_ac59942b9fa139ee4c80a12ab1e9afc56}
{\bfseries Initial value\+:}
\begin{DoxyCode}
=
  \{
    \{\textcolor{stringliteral}{"*aGVsbG8=*"}, \textcolor{stringliteral}{"NBSWY3DP"}\},
    \{\textcolor{stringliteral}{"**"}, \textcolor{stringliteral}{""}\}
  \}
\end{DoxyCode}


Definition at line 33 of file Structured\+Headers\+Standard\+Test.\+cpp.



Referenced by T\+E\+S\+T\+\_\+\+P().

\index{proxygen@{proxygen}!k\+Legal\+Float\+Tests@{k\+Legal\+Float\+Tests}}
\index{k\+Legal\+Float\+Tests@{k\+Legal\+Float\+Tests}!proxygen@{proxygen}}
\subsubsection[{k\+Legal\+Float\+Tests}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::vector$<$std\+::pair$<$std\+::string, double$>$ $>$ proxygen\+::k\+Legal\+Float\+Tests\hspace{0.3cm}{\ttfamily [static]}}\label{namespaceproxygen_a74e2df0e201ca4026fad864124f2ae3a}
{\bfseries Initial value\+:}
\begin{DoxyCode}
=
  \{
    \{\textcolor{stringliteral}{"1.23"}, 1.23\},
    \{\textcolor{stringliteral}{"-1.23"}, -1.23\}
  \}
\end{DoxyCode}


Definition at line 52 of file Structured\+Headers\+Standard\+Test.\+cpp.

\index{proxygen@{proxygen}!k\+Legal\+Int\+Tests@{k\+Legal\+Int\+Tests}}
\index{k\+Legal\+Int\+Tests@{k\+Legal\+Int\+Tests}!proxygen@{proxygen}}
\subsubsection[{k\+Legal\+Int\+Tests}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::vector$<$std\+::pair$<$std\+::string, int64\+\_\+t$>$ $>$ proxygen\+::k\+Legal\+Int\+Tests\hspace{0.3cm}{\ttfamily [static]}}\label{namespaceproxygen_a4d63a6ff62c3864254fa4f8cae12f34e}
{\bfseries Initial value\+:}
\begin{DoxyCode}
=
  \{
    \{\textcolor{stringliteral}{"42"}, 42\},
    \{\textcolor{stringliteral}{"0"}, 0\},
    \{\textcolor{stringliteral}{"00"}, 0\},
    \{\textcolor{stringliteral}{"-0"}, 0\},
    \{\textcolor{stringliteral}{"-42"}, -42\},
    \{\textcolor{stringliteral}{"042"}, 42\},
    \{\textcolor{stringliteral}{"-042"}, -42\},
    \{\textcolor{stringliteral}{"9223372036854775807"}, std::numeric\_limits<int64\_t>::max()\},
    \{\textcolor{stringliteral}{"-9223372036854775808"}, std::numeric\_limits<int64\_t>::min()\}
  \}
\end{DoxyCode}


Definition at line 39 of file Structured\+Headers\+Standard\+Test.\+cpp.

\index{proxygen@{proxygen}!k\+Legal\+String\+Tests@{k\+Legal\+String\+Tests}}
\index{k\+Legal\+String\+Tests@{k\+Legal\+String\+Tests}!proxygen@{proxygen}}
\subsubsection[{k\+Legal\+String\+Tests}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::vector$<$std\+::pair$<$std\+::string, std\+::string$>$ $>$ proxygen\+::k\+Legal\+String\+Tests\hspace{0.3cm}{\ttfamily [static]}}\label{namespaceproxygen_af7f336782922f57be74326904d8e00f9}
{\bfseries Initial value\+:}
\begin{DoxyCode}
=
  \{
    \{\textcolor{stringliteral}{"\(\backslash\)"foo\(\backslash\)""}, \textcolor{stringliteral}{"foo"}\},
    \{\textcolor{stringliteral}{"\(\backslash\)"foo \(\backslash\)\(\backslash\)\(\backslash\)"bar\(\backslash\)\(\backslash\)\(\backslash\)"\(\backslash\)""}, \textcolor{stringliteral}{"foo \(\backslash\)"bar\(\backslash\)""}\}
  \}
\end{DoxyCode}


Definition at line 26 of file Structured\+Headers\+Standard\+Test.\+cpp.



Referenced by T\+E\+S\+T\+\_\+\+P().

\index{proxygen@{proxygen}!k\+Max\+Error\+Code@{k\+Max\+Error\+Code}}
\index{k\+Max\+Error\+Code@{k\+Max\+Error\+Code}!proxygen@{proxygen}}
\subsubsection[{k\+Max\+Error\+Code}]{\setlength{\rightskip}{0pt plus 5cm}const uint8\+\_\+t proxygen\+::k\+Max\+Error\+Code = 12}\label{namespaceproxygen_a56fa691485d3c82ca0eba22347ef805b}


Definition at line 16 of file Error\+Code.\+cpp.

\index{proxygen@{proxygen}!k\+Message\+Filter\+Default\+Name\+\_\+@{k\+Message\+Filter\+Default\+Name\+\_\+}}
\index{k\+Message\+Filter\+Default\+Name\+\_\+@{k\+Message\+Filter\+Default\+Name\+\_\+}!proxygen@{proxygen}}
\subsubsection[{k\+Message\+Filter\+Default\+Name\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string proxygen\+::k\+Message\+Filter\+Default\+Name\+\_\+ = \char`\"{}Unknown\char`\"{}\hspace{0.3cm}{\ttfamily [static]}}\label{namespaceproxygen_a4d2429f72d67334685fdb5c7615c65ff}


Definition at line 18 of file H\+T\+T\+P\+Message\+Filters.\+h.



Referenced by proxygen\+::\+H\+T\+T\+P\+Message\+Filter\+::get\+Filter\+Name().

\index{proxygen@{proxygen}!k\+Mock\+Filter\+Name@{k\+Mock\+Filter\+Name}}
\index{k\+Mock\+Filter\+Name@{k\+Mock\+Filter\+Name}!proxygen@{proxygen}}
\subsubsection[{k\+Mock\+Filter\+Name}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string proxygen\+::k\+Mock\+Filter\+Name = \char`\"{}Mock\+Filter\char`\"{}\hspace{0.3cm}{\ttfamily [static]}}\label{namespaceproxygen_abea47bd670249438d39288ec40dc723f}


Definition at line 16 of file Mock\+H\+T\+T\+P\+Message\+Filter.\+h.



Referenced by proxygen\+::\+Mock\+H\+T\+T\+P\+Message\+Filter\+::get\+Filter\+Name().

\index{proxygen@{proxygen}!k\+S\+P\+D\+Yv2\+Dictionary@{k\+S\+P\+D\+Yv2\+Dictionary}}
\index{k\+S\+P\+D\+Yv2\+Dictionary@{k\+S\+P\+D\+Yv2\+Dictionary}!proxygen@{proxygen}}
\subsubsection[{k\+S\+P\+D\+Yv2\+Dictionary}]{\setlength{\rightskip}{0pt plus 5cm}const char proxygen\+::k\+S\+P\+D\+Yv2\+Dictionary[$\,$]}\label{namespaceproxygen_a0dd38791adf6c0a87a581777f0254b39}
{\bfseries Initial value\+:}
\begin{DoxyCode}
=
    \textcolor{stringliteral}{"optionsgetheadpostputdeletetraceacceptaccept-charsetaccept-encodingaccept-"}
    \textcolor{stringliteral}{"languageauthorizationexpectfromhostif-modified-sinceif-matchif-none-matchi"}
    \textcolor{stringliteral}{"f-rangeif-unmodifiedsincemax-forwardsproxy-authorizationrangerefererteuser"}
    \textcolor{stringliteral}{"-agent10010120020120220320420520630030130230330430530630740040140240340440"}
    \textcolor{stringliteral}{"5406407408409410411412413414415416417500501502503504505accept-rangesageeta"}
    \textcolor{stringliteral}{"glocationproxy-authenticatepublicretry-afterservervarywarningwww-authentic"}
    \textcolor{stringliteral}{"ateallowcontent-basecontent-encodingcache-controlconnectiondatetrailertran"}
    \textcolor{stringliteral}{"sfer-encodingupgradeviawarningcontent-languagecontent-lengthcontent-locati"}
    \textcolor{stringliteral}{"oncontent-md5content-rangecontent-typeetagexpireslast-modifiedset-cookieMo"}
    \textcolor{stringliteral}{"ndayTuesdayWednesdayThursdayFridaySaturdaySundayJanFebMarAprMayJunJulAugSe"}
    \textcolor{stringliteral}{"pOctNovDecchunkedtext/htmlimage/pngimage/jpgimage/gifapplication/xmlapplic"}
    \textcolor{stringliteral}{"ation/xhtmltext/plainpublicmax-agecharset=iso-8859-1utf-8gzipdeflateHTTP/1"}
    \textcolor{stringliteral}{".1statusversionurl"}
\end{DoxyCode}
Compression dictionary for S\+P\+D\+Yv2; note that the trailing null is included. From {\tt http\+://www.\+chromium.\+org/spdy/spdy-\/protocol/spdy-\/protocol-\/draft2} 

Definition at line 18 of file Codec\+Dictionaries.\+h.

\index{proxygen@{proxygen}!k\+S\+P\+D\+Yv3\+Dictionary@{k\+S\+P\+D\+Yv3\+Dictionary}}
\index{k\+S\+P\+D\+Yv3\+Dictionary@{k\+S\+P\+D\+Yv3\+Dictionary}!proxygen@{proxygen}}
\subsubsection[{k\+S\+P\+D\+Yv3\+Dictionary}]{\setlength{\rightskip}{0pt plus 5cm}const unsigned char proxygen\+::k\+S\+P\+D\+Yv3\+Dictionary[$\,$]}\label{namespaceproxygen_a0929e0d3df9cf3158f2b0e2ea4ccd8ee}
Compression dictionary for S\+P\+D\+Yv3. Copied from\+: {\tt http\+://www.\+chromium.\+org/spdy/spdy-\/protocol/spdy-\/protocol-\/draft3} 

Definition at line 37 of file Codec\+Dictionaries.\+h.



Referenced by proxygen\+::\+S\+P\+D\+Y\+Codec\+::get\+Version\+Settings().

\index{proxygen@{proxygen}!k\+Type\+Strings@{k\+Type\+Strings}}
\index{k\+Type\+Strings@{k\+Type\+Strings}!proxygen@{proxygen}}
\subsubsection[{k\+Type\+Strings}]{\setlength{\rightskip}{0pt plus 5cm}const char$\ast$ const proxygen\+::k\+Type\+Strings[$\,$]}\label{namespaceproxygen_ae8e0ec823f05af0a8d00ea1557754005}
{\bfseries Initial value\+:}
\begin{DoxyCode}
=  \{
  \textcolor{stringliteral}{"FIRST\_BYTE"},
  \textcolor{stringliteral}{"LAST\_BYTE"},
  \textcolor{stringliteral}{"PING\_REPLY\_SENT"},
  \textcolor{stringliteral}{"FIRST\_HEADER\_BYTE"},
\}
\end{DoxyCode}


Definition at line 16 of file Byte\+Events.\+cpp.

\index{proxygen@{proxygen}!k\+Upgrade\+Connection\+Token@{k\+Upgrade\+Connection\+Token}}
\index{k\+Upgrade\+Connection\+Token@{k\+Upgrade\+Connection\+Token}!proxygen@{proxygen}}
\subsubsection[{k\+Upgrade\+Connection\+Token}]{\setlength{\rightskip}{0pt plus 5cm}constexpr folly\+::\+String\+Piece proxygen\+::k\+Upgrade\+Connection\+Token = \char`\"{}Upgrade\char`\"{}}\label{namespaceproxygen_ac0f87d02f60a9cd665d6aea7186ca7dd}


Definition at line 313 of file H\+T\+T\+P1x\+Codec.\+cpp.

\index{proxygen@{proxygen}!k\+Upgrade\+Token@{k\+Upgrade\+Token}}
\index{k\+Upgrade\+Token@{k\+Upgrade\+Token}!proxygen@{proxygen}}
\subsubsection[{k\+Upgrade\+Token}]{\setlength{\rightskip}{0pt plus 5cm}constexpr folly\+::\+String\+Piece proxygen\+::k\+Upgrade\+Token = \char`\"{}websocket\char`\"{}}\label{namespaceproxygen_aa11afc3ba098e4d88cea6432ef321c80}


Definition at line 312 of file H\+T\+T\+P1x\+Codec.\+cpp.

\index{proxygen@{proxygen}!k\+W\+S\+Magic\+String@{k\+W\+S\+Magic\+String}}
\index{k\+W\+S\+Magic\+String@{k\+W\+S\+Magic\+String}!proxygen@{proxygen}}
\subsubsection[{k\+W\+S\+Magic\+String}]{\setlength{\rightskip}{0pt plus 5cm}constexpr folly\+::\+String\+Piece proxygen\+::k\+W\+S\+Magic\+String = \char`\"{}258\+E\+A\+F\+A5-\/\+E914-\/47\+D\+A-\/95\+C\+A-\/\+C5\+A\+B0\+D\+C85\+B11\char`\"{}}\label{namespaceproxygen_a446fa76d2425c8f7e41b822ebdefab2b}


Definition at line 316 of file H\+T\+T\+P1x\+Codec.\+cpp.



Referenced by proxygen\+::\+H\+T\+T\+P1x\+Codec\+::generate\+Websocket\+Accept().

\index{proxygen@{proxygen}!local\+Addr@{local\+Addr}}
\index{local\+Addr@{local\+Addr}!proxygen@{proxygen}}
\subsubsection[{local\+Addr}]{\setlength{\rightskip}{0pt plus 5cm}const folly\+::\+Socket\+Address proxygen\+::local\+Addr \{\char`\"{}127.\+0.\+0.\+1\char`\"{}, 80\}}\label{namespaceproxygen_ad837ab655543e4211b38011fb932d77a}


Definition at line 19 of file Test\+Utils.\+cpp.



Referenced by proxygen\+::\+H\+T\+T\+P\+Session\+::conn\+Close\+By\+Remote(), H\+T\+T\+P\+Downstream\+Test$<$ S\+P\+D\+Y3\+\_\+1\+Codec\+Pair $>$\+::\+H\+T\+T\+P\+Downstream\+Test(), Mock\+Codec\+Downstream\+Test\+::\+Mock\+Codec\+Downstream\+Test(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Settings\+Ack(), T\+E\+S\+T(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().

\index{proxygen@{proxygen}!mock\+Transport\+Info@{mock\+Transport\+Info}}
\index{mock\+Transport\+Info@{mock\+Transport\+Info}!proxygen@{proxygen}}
\subsubsection[{mock\+Transport\+Info}]{\setlength{\rightskip}{0pt plus 5cm}const wangle\+::\+Transport\+Info proxygen\+::mock\+Transport\+Info = wangle\+::\+Transport\+Info()}\label{namespaceproxygen_a30e7387405c00c352e49cccda0584fae}


Definition at line 18 of file Test\+Utils.\+cpp.



Referenced by H\+T\+T\+P\+Downstream\+Test$<$ S\+P\+D\+Y3\+\_\+1\+Codec\+Pair $>$\+::\+H\+T\+T\+P\+Downstream\+Test(), Mock\+Codec\+Downstream\+Test\+::\+Mock\+Codec\+Downstream\+Test(), and T\+E\+S\+T().

\index{proxygen@{proxygen}!peer\+Addr@{peer\+Addr}}
\index{peer\+Addr@{peer\+Addr}!proxygen@{proxygen}}
\subsubsection[{peer\+Addr}]{\setlength{\rightskip}{0pt plus 5cm}const folly\+::\+Socket\+Address proxygen\+::peer\+Addr \{\char`\"{}127.\+0.\+0.\+1\char`\"{}, 12345\}}\label{namespaceproxygen_a7e97e63571b9ca17de27bd219d3b0e18}


Definition at line 20 of file Test\+Utils.\+cpp.



Referenced by proxygen\+::\+H\+T\+T\+P\+Session\+::conn\+Close\+By\+Remote(), H\+T\+T\+P\+Downstream\+Test$<$ S\+P\+D\+Y3\+\_\+1\+Codec\+Pair $>$\+::\+H\+T\+T\+P\+Downstream\+Test(), Mock\+Codec\+Downstream\+Test\+::\+Mock\+Codec\+Downstream\+Test(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Settings\+Ack(), T\+E\+S\+T(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().

