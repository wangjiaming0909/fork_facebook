\section{Zlib\+Server\+Filter\+Test Class Reference}
\label{classZlibServerFilterTest}\index{Zlib\+Server\+Filter\+Test@{Zlib\+Server\+Filter\+Test}}
Inheritance diagram for Zlib\+Server\+Filter\+Test\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classZlibServerFilterTest}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void {\bf Set\+Up} () override
\item 
void {\bf Tear\+Down} () override
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
void {\bf exercise\+\_\+compression} (bool expect\+Compression, std\+::string url, std\+::string accepted\+Encoding, std\+::string expected\+Encoding, std\+::string original\+Request\+Body, std\+::string response\+Content\+Type, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ original\+Response\+Body, int32\+\_\+t compression\+Level=4, uint32\+\_\+t minimum\+Compression\+Size=1)
\item 
std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ {\bf create\+Response\+Chain} (std\+::vector$<$ std\+::string $>$ const \&body\+Strings)
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
{\bf Zlib\+Server\+Filter} $\ast$ {\bf filter\+\_\+} \{{\bf nullptr}\}
\item 
{\bf Mock\+Request\+Handler} $\ast$ {\bf request\+Handler\+\_\+}
\item 
std\+::unique\+\_\+ptr$<$ {\bf Mock\+Response\+Handler} $>$ {\bf response\+Handler\+\_\+}
\item 
std\+::unique\+\_\+ptr$<$ {\bf Zlib\+Stream\+Decompressor} $>$ {\bf zd\+\_\+}
\item 
{\bf Response\+Handler} $\ast$ {\bf downstream\+\_\+} \{{\bf nullptr}\}
\end{DoxyCompactItemize}


\subsection{Detailed Description}


Definition at line 35 of file Zlib\+Server\+Filter\+Test.\+cpp.



\subsection{Member Function Documentation}
\index{Zlib\+Server\+Filter\+Test@{Zlib\+Server\+Filter\+Test}!create\+Response\+Chain@{create\+Response\+Chain}}
\index{create\+Response\+Chain@{create\+Response\+Chain}!Zlib\+Server\+Filter\+Test@{Zlib\+Server\+Filter\+Test}}
\subsubsection[{create\+Response\+Chain(std\+::vector$<$ std\+::string $>$ const \&body\+Strings)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<$folly\+::\+I\+O\+Buf$>$ Zlib\+Server\+Filter\+Test\+::create\+Response\+Chain (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ std\+::string $>$ const \&}]{body\+Strings}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classZlibServerFilterTest_af10b2e12d37dbcb68bed0de4535785b1}


Definition at line 193 of file Zlib\+Server\+Filter\+Test.\+cpp.


\begin{DoxyCode}
194                                                \{
195 
196     std::unique\_ptr<folly::IOBuf> responseBodyChain;
197 
198     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}& s : bodyStrings) \{
199       \textcolor{keyword}{auto} nextBody = folly::IOBuf::copyBuffer(s.c\_str());
200       \textcolor{keywordflow}{if} (responseBodyChain) \{
201         responseBodyChain->prependChain(std::move(nextBody));
202       \} \textcolor{keywordflow}{else} \{
203         responseBodyChain = std::move(nextBody);
204       \}
205     \}
206 
207     \textcolor{keywordflow}{return} responseBodyChain;
208   \}
\end{DoxyCode}
\index{Zlib\+Server\+Filter\+Test@{Zlib\+Server\+Filter\+Test}!exercise\+\_\+compression@{exercise\+\_\+compression}}
\index{exercise\+\_\+compression@{exercise\+\_\+compression}!Zlib\+Server\+Filter\+Test@{Zlib\+Server\+Filter\+Test}}
\subsubsection[{exercise\+\_\+compression(bool expect\+Compression, std\+::string url, std\+::string accepted\+Encoding, std\+::string expected\+Encoding, std\+::string original\+Request\+Body, std\+::string response\+Content\+Type, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ original\+Response\+Body, int32\+\_\+t compression\+Level=4, uint32\+\_\+t minimum\+Compression\+Size=1)}]{\setlength{\rightskip}{0pt plus 5cm}void Zlib\+Server\+Filter\+Test\+::exercise\+\_\+compression (
\begin{DoxyParamCaption}
\item[{bool}]{expect\+Compression, }
\item[{std\+::string}]{url, }
\item[{std\+::string}]{accepted\+Encoding, }
\item[{std\+::string}]{expected\+Encoding, }
\item[{std\+::string}]{original\+Request\+Body, }
\item[{std\+::string}]{response\+Content\+Type, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{original\+Response\+Body, }
\item[{int32\+\_\+t}]{compression\+Level = {\ttfamily 4}, }
\item[{uint32\+\_\+t}]{minimum\+Compression\+Size = {\ttfamily 1}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classZlibServerFilterTest_a03cfd1a3a7d07cec70c7ba9f984a2a33}


Definition at line 58 of file Zlib\+Server\+Filter\+Test.\+cpp.



References proxygen\+::\+Response\+Builder\+::body(), proxygen\+::\+H\+T\+T\+P\+Message\+::check\+For\+Header\+Token(), proxygen\+::\+Zlib\+Stream\+Decompressor\+::decompress(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Is\+Chunked(), proxygen\+::\+Zlib\+Stream\+Decompressor\+::get\+Status(), proxygen\+::\+Zlib\+Stream\+Decompressor\+::has\+Error(), proxygen\+::\+Response\+Builder\+::header(), proxygen\+::\+Response\+Builder\+::send(), proxygen\+::\+Response\+Builder\+::send\+With\+E\+O\+M(), proxygen\+::\+H\+T\+T\+P\+Headers\+::set(), proxygen\+::\+H\+T\+T\+P\+Message\+::set\+U\+R\+L(), and proxygen\+::\+Response\+Builder\+::status().


\begin{DoxyCode}
66                                                                  \{
67 
68     \textcolor{comment}{// If there is only one IOBuf, then it's not chunked.}
69     \textcolor{keywordtype}{bool} isResponseChunked = originalResponseBody->isChained();
70     \textcolor{keywordtype}{size\_t} chunkCount = originalResponseBody->countChainElements();
71 
72     \textcolor{comment}{// Chunked and compressed responses will have an extra block}
73     \textcolor{keywordflow}{if} (isResponseChunked && expectCompression) \{
74       chunkCount += 1;
75     \}
76 
77     \textcolor{comment}{// Request Handler Expectations}
78     EXPECT\_CALL(*requestHandler_, onBody(\_)).Times(1);
79     EXPECT\_CALL(*requestHandler_, onEOM()).Times(1);
80 
81     \textcolor{comment}{// Need to capture whatever the filter is for ResponseBuilder later}
82     EXPECT\_CALL(*requestHandler_, setResponseHandler(\_))
83         .WillOnce(DoAll(SaveArg<0>(&downstream_), Return()));
84 
85     \textcolor{comment}{// Response Handler Expectations}
86     \textcolor{comment}{// Headers are only sent once}
87     EXPECT\_CALL(*responseHandler_, sendHeaders(\_)).WillOnce(DoAll(
88         Invoke([&](HTTPMessage& msg) \{
89           \textcolor{keyword}{auto}& headers = msg.getHeaders();
90           \textcolor{keywordflow}{if} (expectCompression) \{
91             EXPECT\_TRUE(msg.checkForHeaderToken(
92                 HTTP\_HEADER\_CONTENT\_ENCODING, expectedEncoding.c\_str(), \textcolor{keyword}{false}));
93           \}
94 
95           \textcolor{keywordflow}{if} (msg.getIsChunked()) \{
96             EXPECT\_FALSE(headers.exists(\textcolor{stringliteral}{"Content-Length"}));
97           \} \textcolor{keywordflow}{else} \{
98             \textcolor{comment}{//Content-Length is not set on chunked messages}
99             EXPECT\_TRUE(headers.exists(\textcolor{stringliteral}{"Content-Length"}));
100           \}
101         \}),
102         Return()));
103 
104     \textcolor{keywordflow}{if} (isResponseChunked) \{
105       \textcolor{comment}{// The final chunk has 0 body}
106       EXPECT\_CALL(*responseHandler_, sendChunkHeader(\_)).Times(chunkCount);
107       EXPECT\_CALL(*responseHandler_, sendChunkTerminator()).Times(chunkCount);
108     \} \textcolor{keywordflow}{else} \{
109       EXPECT\_CALL(*responseHandler_, sendChunkHeader(\_)).Times(0);
110       EXPECT\_CALL(*responseHandler_, sendChunkTerminator()).Times(0);
111     \}
112 
113     \textcolor{comment}{// Accumulate the body, decompressing it if it's compressed}
114     std::unique\_ptr<folly::IOBuf> responseBody;
115     EXPECT\_CALL(*responseHandler_, sendBody(\_))
116         .Times(chunkCount)
117         .WillRepeatedly(DoAll(
118             Invoke([&](std::shared\_ptr<folly::IOBuf> body) \{
119 
120               std::unique\_ptr<folly::IOBuf> processedBody;
121 
122               \textcolor{keywordflow}{if} (expectCompression) \{
123                 processedBody = zd_->decompress(body.get());
124                 ASSERT\_FALSE(zd_->hasError())
125                     << \textcolor{stringliteral}{"Failed to decompress body. r="} << zd_->getStatus();
126               \} \textcolor{keywordflow}{else} \{
127                 processedBody = folly::IOBuf::copyBuffer(
128                     body->data(), body->length(), 0, 0);
129               \}
130 
131               \textcolor{keywordflow}{if} (responseBody) \{
132                 responseBody->prependChain(std::move(processedBody));
133               \} \textcolor{keywordflow}{else} \{
134                 responseBody = std::move(processedBody);
135               \}
136             \}),
137             Return()));
138 
139     EXPECT\_CALL(*responseHandler_, sendEOM()).Times(1);
140 
141     \textcolor{comment}{/* Simulate Request/Response  */}
142 
143     HTTPMessage msg;
144     msg.setURL(url);
145     msg.getHeaders().set(HTTP\_HEADER\_ACCEPT\_ENCODING, acceptedEncoding);
146 
147     std::set<std::string> compressibleTypes = \{\textcolor{stringliteral}{"text/html"}\};
148     \textcolor{keyword}{auto} filterFactory = std::make\_unique<ZlibServerFilterFactory>(
149         compressionLevel, minimumCompressionSize, compressibleTypes);
150 
151     \textcolor{keyword}{auto} filter = filterFactory->onRequest(requestHandler_, &msg);
152     filter->setResponseHandler(responseHandler_.get());
153 
154     \textcolor{comment}{// Send fake request}
155     filter->onBody(folly::IOBuf::copyBuffer(originalRequestBody));
156     filter->onEOM();
157 
158     \textcolor{comment}{// Send a fake Response}
159     \textcolor{keywordflow}{if} (isResponseChunked) \{
160 
161       ResponseBuilder(downstream_)
162         .status(200, \textcolor{stringliteral}{"OK"})
163         .header(HTTP\_HEADER\_CONTENT\_TYPE, responseContentType)
164         .send();
165 
166       folly::IOBuf* crtBuf;
167       crtBuf = originalResponseBody.get();
168 
169       \textcolor{keywordflow}{do} \{
170         ResponseBuilder(downstream_).body(crtBuf->cloneOne()).send();
171         crtBuf = crtBuf->next();
172       \} \textcolor{keywordflow}{while} (crtBuf != originalResponseBody.get());
173 
174       ResponseBuilder(downstream_).sendWithEOM();
175 
176     \} \textcolor{keywordflow}{else} \{
177 
178       \textcolor{comment}{// Send unchunked response}
179       ResponseBuilder(downstream_)
180           .status(200, \textcolor{stringliteral}{"OK"})
181           .header(HTTP\_HEADER\_CONTENT\_TYPE, responseContentType)
182           .body(originalResponseBody->clone())
183           .sendWithEOM();
184     \}
185 
186     filter->requestComplete();
187 
188     EXPECT\_THAT(responseBody, IOBufEquals(originalRequestBody));
189   \}
\end{DoxyCode}
\index{Zlib\+Server\+Filter\+Test@{Zlib\+Server\+Filter\+Test}!Set\+Up@{Set\+Up}}
\index{Set\+Up@{Set\+Up}!Zlib\+Server\+Filter\+Test@{Zlib\+Server\+Filter\+Test}}
\subsubsection[{Set\+Up() override}]{\setlength{\rightskip}{0pt plus 5cm}void Zlib\+Server\+Filter\+Test\+::\+Set\+Up (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}}\label{classZlibServerFilterTest_a7d7c6671e33971d9b9a83cc0fd9da6e3}


Definition at line 37 of file Zlib\+Server\+Filter\+Test.\+cpp.



References proxygen\+::\+G\+Z\+IP.


\begin{DoxyCode}
37                         \{
38     \textcolor{comment}{// requesthandler is the server, responsehandler is the client}
39     requestHandler_ = \textcolor{keyword}{new} MockRequestHandler();
40     responseHandler_ = std::make\_unique<MockResponseHandler>(requestHandler_);
41     zd_ = std::make\_unique<ZlibStreamDecompressor>(ZlibCompressionType::GZIP);
42   \}
\end{DoxyCode}
\index{Zlib\+Server\+Filter\+Test@{Zlib\+Server\+Filter\+Test}!Tear\+Down@{Tear\+Down}}
\index{Tear\+Down@{Tear\+Down}!Zlib\+Server\+Filter\+Test@{Zlib\+Server\+Filter\+Test}}
\subsubsection[{Tear\+Down() override}]{\setlength{\rightskip}{0pt plus 5cm}void Zlib\+Server\+Filter\+Test\+::\+Tear\+Down (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}}\label{classZlibServerFilterTest_a057bc1fff0b97cd957510ac41eae33ad}


Definition at line 44 of file Zlib\+Server\+Filter\+Test.\+cpp.


\begin{DoxyCode}
44                            \{
45     Mock::VerifyAndClear(requestHandler_);
46     Mock::VerifyAndClear(responseHandler_.get());
47 
48     \textcolor{keyword}{delete} requestHandler_;
49   \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{Zlib\+Server\+Filter\+Test@{Zlib\+Server\+Filter\+Test}!downstream\+\_\+@{downstream\+\_\+}}
\index{downstream\+\_\+@{downstream\+\_\+}!Zlib\+Server\+Filter\+Test@{Zlib\+Server\+Filter\+Test}}
\subsubsection[{downstream\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Response\+Handler}$\ast$ Zlib\+Server\+Filter\+Test\+::downstream\+\_\+ \{{\bf nullptr}\}\hspace{0.3cm}{\ttfamily [protected]}}\label{classZlibServerFilterTest_a77a89a456c695a029450d6d931fa8957}


Definition at line 56 of file Zlib\+Server\+Filter\+Test.\+cpp.

\index{Zlib\+Server\+Filter\+Test@{Zlib\+Server\+Filter\+Test}!filter\+\_\+@{filter\+\_\+}}
\index{filter\+\_\+@{filter\+\_\+}!Zlib\+Server\+Filter\+Test@{Zlib\+Server\+Filter\+Test}}
\subsubsection[{filter\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Zlib\+Server\+Filter}$\ast$ Zlib\+Server\+Filter\+Test\+::filter\+\_\+ \{{\bf nullptr}\}\hspace{0.3cm}{\ttfamily [protected]}}\label{classZlibServerFilterTest_aac3d73fab6b8540949f6685053d8097d}


Definition at line 52 of file Zlib\+Server\+Filter\+Test.\+cpp.

\index{Zlib\+Server\+Filter\+Test@{Zlib\+Server\+Filter\+Test}!request\+Handler\+\_\+@{request\+Handler\+\_\+}}
\index{request\+Handler\+\_\+@{request\+Handler\+\_\+}!Zlib\+Server\+Filter\+Test@{Zlib\+Server\+Filter\+Test}}
\subsubsection[{request\+Handler\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Mock\+Request\+Handler}$\ast$ Zlib\+Server\+Filter\+Test\+::request\+Handler\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classZlibServerFilterTest_a95afc028a61d4dd29d6c46245f763120}


Definition at line 53 of file Zlib\+Server\+Filter\+Test.\+cpp.

\index{Zlib\+Server\+Filter\+Test@{Zlib\+Server\+Filter\+Test}!response\+Handler\+\_\+@{response\+Handler\+\_\+}}
\index{response\+Handler\+\_\+@{response\+Handler\+\_\+}!Zlib\+Server\+Filter\+Test@{Zlib\+Server\+Filter\+Test}}
\subsubsection[{response\+Handler\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<${\bf Mock\+Response\+Handler}$>$ Zlib\+Server\+Filter\+Test\+::response\+Handler\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classZlibServerFilterTest_ad1456b567bb9076c6900a187adb2041b}


Definition at line 54 of file Zlib\+Server\+Filter\+Test.\+cpp.

\index{Zlib\+Server\+Filter\+Test@{Zlib\+Server\+Filter\+Test}!zd\+\_\+@{zd\+\_\+}}
\index{zd\+\_\+@{zd\+\_\+}!Zlib\+Server\+Filter\+Test@{Zlib\+Server\+Filter\+Test}}
\subsubsection[{zd\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<${\bf Zlib\+Stream\+Decompressor}$>$ Zlib\+Server\+Filter\+Test\+::zd\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classZlibServerFilterTest_a2547dd3c7203ff15bd08dc3d220de16c}


Definition at line 55 of file Zlib\+Server\+Filter\+Test.\+cpp.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
proxygen/httpserver/filters/tests/{\bf Zlib\+Server\+Filter\+Test.\+cpp}\end{DoxyCompactItemize}
