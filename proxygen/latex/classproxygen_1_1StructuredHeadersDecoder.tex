\section{proxygen\+:\+:Structured\+Headers\+Decoder Class Reference}
\label{classproxygen_1_1StructuredHeadersDecoder}\index{proxygen\+::\+Structured\+Headers\+Decoder@{proxygen\+::\+Structured\+Headers\+Decoder}}


{\ttfamily \#include $<$Structured\+Headers\+Decoder.\+h$>$}

\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Structured\+Headers\+Decoder} (const std\+::string \&s)
\item 
{\bf Structured\+Headers\+::\+Decode\+Error} {\bf decode\+Item} ({\bf Structured\+Header\+Item} \&result)
\item 
{\bf Structured\+Headers\+::\+Decode\+Error} {\bf decode\+List} (std\+::vector$<$ {\bf Structured\+Header\+Item} $>$ \&result)
\item 
{\bf Structured\+Headers\+::\+Decode\+Error} {\bf decode\+Dictionary} ({\bf Dictionary} \&result)
\item 
{\bf Structured\+Headers\+::\+Decode\+Error} {\bf decode\+Parameterised\+List} ({\bf Parameterised\+List} \&result)
\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
enum {\bf Map\+Type} \{ {\bf Map\+Type\+::\+D\+I\+C\+T\+I\+O\+N\+A\+RY} = 0, 
{\bf Map\+Type\+::\+P\+A\+R\+A\+M\+E\+T\+E\+R\+I\+S\+E\+D\+\_\+\+M\+AP} = 1
 \}
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Structured\+Headers\+::\+Decode\+Error} {\bf decode\+Map} (std\+::unordered\+\_\+map$<$ std\+::string, {\bf Structured\+Header\+Item} $>$ \&result, {\bf Map\+Type} map\+Type)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
{\bf Structured\+Headers\+Buffer} {\bf buf\+\_\+}
\end{DoxyCompactItemize}


\subsection{Detailed Description}


Definition at line 18 of file Structured\+Headers\+Decoder.\+h.



\subsection{Member Enumeration Documentation}
\index{proxygen\+::\+Structured\+Headers\+Decoder@{proxygen\+::\+Structured\+Headers\+Decoder}!Map\+Type@{Map\+Type}}
\index{Map\+Type@{Map\+Type}!proxygen\+::\+Structured\+Headers\+Decoder@{proxygen\+::\+Structured\+Headers\+Decoder}}
\subsubsection[{Map\+Type}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+Structured\+Headers\+Decoder\+::\+Map\+Type}\hspace{0.3cm}{\ttfamily [strong]}, {\ttfamily [private]}}\label{classproxygen_1_1StructuredHeadersDecoder_ac40fb452b8a017578bcee67c5dd6fcb1}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{D\+I\+C\+T\+I\+O\+N\+A\+RY@{D\+I\+C\+T\+I\+O\+N\+A\+RY}!proxygen\+::\+Structured\+Headers\+Decoder@{proxygen\+::\+Structured\+Headers\+Decoder}}\index{proxygen\+::\+Structured\+Headers\+Decoder@{proxygen\+::\+Structured\+Headers\+Decoder}!D\+I\+C\+T\+I\+O\+N\+A\+RY@{D\+I\+C\+T\+I\+O\+N\+A\+RY}}\item[{\em 
D\+I\+C\+T\+I\+O\+N\+A\+RY\label{classproxygen_1_1StructuredHeadersDecoder_ac40fb452b8a017578bcee67c5dd6fcb1a941b306e67df7bda6303f69eef2899fe}
}]\index{P\+A\+R\+A\+M\+E\+T\+E\+R\+I\+S\+E\+D\+\_\+\+M\+AP@{P\+A\+R\+A\+M\+E\+T\+E\+R\+I\+S\+E\+D\+\_\+\+M\+AP}!proxygen\+::\+Structured\+Headers\+Decoder@{proxygen\+::\+Structured\+Headers\+Decoder}}\index{proxygen\+::\+Structured\+Headers\+Decoder@{proxygen\+::\+Structured\+Headers\+Decoder}!P\+A\+R\+A\+M\+E\+T\+E\+R\+I\+S\+E\+D\+\_\+\+M\+AP@{P\+A\+R\+A\+M\+E\+T\+E\+R\+I\+S\+E\+D\+\_\+\+M\+AP}}\item[{\em 
P\+A\+R\+A\+M\+E\+T\+E\+R\+I\+S\+E\+D\+\_\+\+M\+AP\label{classproxygen_1_1StructuredHeadersDecoder_ac40fb452b8a017578bcee67c5dd6fcb1a82dbaeb92752a63212c0ca016bef1d4b}
}]\end{description}
\end{Desc}


Definition at line 34 of file Structured\+Headers\+Decoder.\+h.


\begin{DoxyCode}
34                      \{
35     DICTIONARY = 0,
36     PARAMETERISED\_MAP = 1
37   \};
\end{DoxyCode}


\subsection{Constructor \& Destructor Documentation}
\index{proxygen\+::\+Structured\+Headers\+Decoder@{proxygen\+::\+Structured\+Headers\+Decoder}!Structured\+Headers\+Decoder@{Structured\+Headers\+Decoder}}
\index{Structured\+Headers\+Decoder@{Structured\+Headers\+Decoder}!proxygen\+::\+Structured\+Headers\+Decoder@{proxygen\+::\+Structured\+Headers\+Decoder}}
\subsubsection[{Structured\+Headers\+Decoder(const std\+::string \&s)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+Structured\+Headers\+Decoder\+::\+Structured\+Headers\+Decoder (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{s}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}\label{classproxygen_1_1StructuredHeadersDecoder_a0dc5fb39d3cbd3caae55ea8536adeac6}


Definition at line 21 of file Structured\+Headers\+Decoder.\+h.



References decode\+Dictionary(), decode\+Item(), decode\+List(), and decode\+Parameterised\+List().


\begin{DoxyCode}
21 : buf_(s) \{\}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{proxygen\+::\+Structured\+Headers\+Decoder@{proxygen\+::\+Structured\+Headers\+Decoder}!decode\+Dictionary@{decode\+Dictionary}}
\index{decode\+Dictionary@{decode\+Dictionary}!proxygen\+::\+Structured\+Headers\+Decoder@{proxygen\+::\+Structured\+Headers\+Decoder}}
\subsubsection[{decode\+Dictionary(\+Dictionary \&result)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decode\+Error} proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+Dictionary (
\begin{DoxyParamCaption}
\item[{{\bf Dictionary} \&}]{result}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1StructuredHeadersDecoder_a7103842585700e8f755c0b92552e6b7a}


Definition at line 61 of file Structured\+Headers\+Decoder.\+cpp.



Referenced by Structured\+Headers\+Decoder(), and proxygen\+::\+T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
61                                                                          \{
62   \textcolor{keywordflow}{return} decodeMap(result, MapType::DICTIONARY);
63 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Decoder@{proxygen\+::\+Structured\+Headers\+Decoder}!decode\+Item@{decode\+Item}}
\index{decode\+Item@{decode\+Item}!proxygen\+::\+Structured\+Headers\+Decoder@{proxygen\+::\+Structured\+Headers\+Decoder}}
\subsubsection[{decode\+Item(\+Structured\+Header\+Item \&result)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decode\+Error} proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+Item (
\begin{DoxyParamCaption}
\item[{{\bf Structured\+Header\+Item} \&}]{result}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1StructuredHeadersDecoder_a70a19967df5f9a7602eb0be821d5b31b}


Definition at line 17 of file Structured\+Headers\+Decoder.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+I\+N\+V\+A\+L\+I\+D\+\_\+\+C\+H\+A\+R\+A\+C\+T\+ER, and proxygen\+::\+Structured\+Headers\+::\+OK.



Referenced by Structured\+Headers\+Decoder(), proxygen\+::\+T\+E\+S\+T\+\_\+\+F(), and proxygen\+::\+T\+E\+S\+T\+\_\+\+P().


\begin{DoxyCode}
18                                 \{
19     \textcolor{keyword}{auto} err = buf_.parseItem(result);
20     \textcolor{keywordflow}{if} (err != DecodeError::OK) \{
21       \textcolor{keywordflow}{return} err;
22     \}
23     \textcolor{keywordflow}{return} buf_.isEmpty() ?
24       DecodeError::OK : buf_.handleDecodeError(DecodeError::INVALID\_CHARACTER);
25 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Decoder@{proxygen\+::\+Structured\+Headers\+Decoder}!decode\+List@{decode\+List}}
\index{decode\+List@{decode\+List}!proxygen\+::\+Structured\+Headers\+Decoder@{proxygen\+::\+Structured\+Headers\+Decoder}}
\subsubsection[{decode\+List(std\+::vector$<$ Structured\+Header\+Item $>$ \&result)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decode\+Error} proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+List (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ {\bf Structured\+Header\+Item} $>$ \&}]{result}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1StructuredHeadersDecoder_a7dc58742127c11b201792c96509aa803}


Definition at line 27 of file Structured\+Headers\+Decoder.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+OK, and proxygen\+::\+Structured\+Headers\+::\+U\+N\+E\+X\+P\+E\+C\+T\+E\+D\+\_\+\+E\+N\+D\+\_\+\+O\+F\+\_\+\+B\+U\+F\+F\+ER.



Referenced by Structured\+Headers\+Decoder(), proxygen\+::\+T\+E\+S\+T\+\_\+\+F(), and proxygen\+::\+T\+E\+S\+T\+\_\+\+P().


\begin{DoxyCode}
28                                             \{
29 
30   \textcolor{keywordflow}{while} (!buf_.isEmpty()) \{
31 
32     StructuredHeaderItem item;
33     \textcolor{keyword}{auto} err = buf_.parseItem(item);
34     \textcolor{keywordflow}{if} (err != DecodeError::OK) \{
35       \textcolor{keywordflow}{return} err;
36     \}
37 
38     result.push\_back(item);
39 
40     buf_.removeOptionalWhitespace();
41 
42     \textcolor{keywordflow}{if} (buf_.isEmpty()) \{
43       \textcolor{keywordflow}{return} DecodeError::OK;
44     \}
45 
46     err = buf_.removeSymbol(\textcolor{stringliteral}{","}, \textcolor{keyword}{true});
47     \textcolor{keywordflow}{if} (err != DecodeError::OK) \{
48       \textcolor{keywordflow}{return} err;
49     \}
50 
51     buf_.removeOptionalWhitespace();
52 
53     \textcolor{keywordflow}{if} (buf_.isEmpty()) \{
54       \textcolor{keywordflow}{return} buf_.handleDecodeError(DecodeError::UNEXPECTED\_END\_OF\_BUFFER);
55     \}
56   \}
57 
58   \textcolor{keywordflow}{return} buf_.handleDecodeError(DecodeError::UNEXPECTED\_END\_OF\_BUFFER);
59 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Decoder@{proxygen\+::\+Structured\+Headers\+Decoder}!decode\+Map@{decode\+Map}}
\index{decode\+Map@{decode\+Map}!proxygen\+::\+Structured\+Headers\+Decoder@{proxygen\+::\+Structured\+Headers\+Decoder}}
\subsubsection[{decode\+Map(std\+::unordered\+\_\+map$<$ std\+::string, Structured\+Header\+Item $>$ \&result, Map\+Type map\+Type)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decode\+Error} proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+Map (
\begin{DoxyParamCaption}
\item[{std\+::unordered\+\_\+map$<$ std\+::string, {\bf Structured\+Header\+Item} $>$ \&}]{result, }
\item[{{\bf Map\+Type}}]{map\+Type}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1StructuredHeadersDecoder_aed29f3e4068e5336493812d0724bc4ce}


Definition at line 104 of file Structured\+Headers\+Decoder.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+D\+U\+P\+L\+I\+C\+A\+T\+E\+\_\+\+K\+EY, proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::\+N\+O\+NE, proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+::\+Structured\+Header\+Item\+::tag, and proxygen\+::\+Structured\+Headers\+::\+U\+N\+E\+X\+P\+E\+C\+T\+E\+D\+\_\+\+E\+N\+D\+\_\+\+O\+F\+\_\+\+B\+U\+F\+F\+ER.


\begin{DoxyCode}
106                    \{
107 
108   std::string delimiter = (mapType == MapType::PARAMETERISED_MAP) ? \textcolor{stringliteral}{";"} : \textcolor{stringliteral}{","};
109 
110   buf_.removeOptionalWhitespace();
111 
112   \textcolor{keywordflow}{if} ((mapType == MapType::PARAMETERISED_MAP) &&
113       (buf_.removeSymbol(delimiter, \textcolor{keyword}{false}) != DecodeError::OK)) \{
114     \textcolor{keywordflow}{return} DecodeError::OK;
115   \}
116 
117   \textcolor{keywordflow}{while} (!buf_.isEmpty()) \{
118 
119     buf_.removeOptionalWhitespace();
120 
121     std::string thisKey;
122     \textcolor{keyword}{auto} err = buf_.parseIdentifier(thisKey);
123     \textcolor{keywordflow}{if} (err != DecodeError::OK) \{
124       \textcolor{keywordflow}{return} err;
125     \}
126 
127     \textcolor{keywordflow}{if} (result.find(thisKey) != result.end()) \{
128       \textcolor{keywordflow}{return} buf_.handleDecodeError(DecodeError::DUPLICATE\_KEY);
129     \}
130 
131     err = buf_.removeSymbol(\textcolor{stringliteral}{"="}, mapType == MapType::DICTIONARY);
132     \textcolor{keywordflow}{if} (err != DecodeError::OK) \{
133       \textcolor{keywordflow}{if} (mapType == MapType::DICTIONARY) \{
134         \textcolor{keywordflow}{return} err;
135       \} \textcolor{keywordflow}{else} \{
136         StructuredHeaderItem value;
137         value.tag = StructuredHeaderItem::Type::NONE;
138         result[thisKey] = value;
139       \}
140     \} \textcolor{keywordflow}{else} \{
141       StructuredHeaderItem value;
142       err = buf_.parseItem(value);
143       \textcolor{keywordflow}{if} (err != DecodeError::OK) \{
144         \textcolor{keywordflow}{return} err;
145       \}
146 
147       result[thisKey] = value;
148     \}
149 
150     buf_.removeOptionalWhitespace();
151 
152     \textcolor{keywordflow}{if} (buf_.isEmpty()) \{
153       \textcolor{keywordflow}{return} DecodeError::OK;
154     \}
155 
156     err = buf_.removeSymbol(delimiter, mapType == MapType::DICTIONARY);
157     \textcolor{keywordflow}{if} (err != DecodeError::OK) \{
158       \textcolor{keywordflow}{if} (mapType == MapType::PARAMETERISED_MAP) \{
159         \textcolor{keywordflow}{return} DecodeError::OK;
160       \} \textcolor{keywordflow}{else} \{
161         \textcolor{keywordflow}{return} err;
162       \}
163     \}
164   \}
165 
166   \textcolor{keywordflow}{return} buf_.handleDecodeError(DecodeError::UNEXPECTED\_END\_OF\_BUFFER);
167 
168 \}
\end{DoxyCode}
\index{proxygen\+::\+Structured\+Headers\+Decoder@{proxygen\+::\+Structured\+Headers\+Decoder}!decode\+Parameterised\+List@{decode\+Parameterised\+List}}
\index{decode\+Parameterised\+List@{decode\+Parameterised\+List}!proxygen\+::\+Structured\+Headers\+Decoder@{proxygen\+::\+Structured\+Headers\+Decoder}}
\subsubsection[{decode\+Parameterised\+List(\+Parameterised\+List \&result)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Decode\+Error} proxygen\+::\+Structured\+Headers\+Decoder\+::decode\+Parameterised\+List (
\begin{DoxyParamCaption}
\item[{{\bf Parameterised\+List} \&}]{result}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1StructuredHeadersDecoder_aef0831a2a7799ab73b4b154811b5bd83}


Definition at line 65 of file Structured\+Headers\+Decoder.\+cpp.



References proxygen\+::\+Structured\+Headers\+::\+Parameterised\+Identifier\+::identifier, proxygen\+::\+Structured\+Headers\+::\+OK, proxygen\+::\+Structured\+Headers\+::\+Parameterised\+Identifier\+::parameter\+Map, and proxygen\+::\+Structured\+Headers\+::\+U\+N\+E\+X\+P\+E\+C\+T\+E\+D\+\_\+\+E\+N\+D\+\_\+\+O\+F\+\_\+\+B\+U\+F\+F\+ER.



Referenced by Structured\+Headers\+Decoder(), and proxygen\+::\+T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
66                              \{
67 
68   \textcolor{keywordflow}{while} (!buf_.isEmpty()) \{
69 
70     ParameterisedIdentifier primaryIdentifier;
71 
72     \textcolor{keyword}{auto} err = buf_.parseIdentifier(primaryIdentifier.identifier);
73     \textcolor{keywordflow}{if} (err != DecodeError::OK) \{
74       \textcolor{keywordflow}{return} err;
75     \}
76 
77     buf_.removeOptionalWhitespace();
78 
79     err = decodeMap(primaryIdentifier.parameterMap, MapType::PARAMETERISED_MAP);
80     \textcolor{keywordflow}{if} (err != DecodeError::OK) \{
81       \textcolor{keywordflow}{return} err;
82     \}
83 
84     result.emplace\_back(primaryIdentifier);
85 
86     buf_.removeOptionalWhitespace();
87 
88     \textcolor{keywordflow}{if} (buf_.isEmpty()) \{
89       \textcolor{keywordflow}{return} DecodeError::OK;
90     \}
91 
92     err = buf_.removeSymbol(\textcolor{stringliteral}{","}, \textcolor{keyword}{true});
93     \textcolor{keywordflow}{if} (err != DecodeError::OK) \{
94       \textcolor{keywordflow}{return} err;
95     \}
96 
97     buf_.removeOptionalWhitespace();
98 
99   \}
100 
101   \textcolor{keywordflow}{return} buf_.handleDecodeError(DecodeError::UNEXPECTED\_END\_OF\_BUFFER);
102 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{proxygen\+::\+Structured\+Headers\+Decoder@{proxygen\+::\+Structured\+Headers\+Decoder}!buf\+\_\+@{buf\+\_\+}}
\index{buf\+\_\+@{buf\+\_\+}!proxygen\+::\+Structured\+Headers\+Decoder@{proxygen\+::\+Structured\+Headers\+Decoder}}
\subsubsection[{buf\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Structured\+Headers\+Buffer} proxygen\+::\+Structured\+Headers\+Decoder\+::buf\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1StructuredHeadersDecoder_af142642618114656a1d55b5d62bd30e1}


Definition at line 43 of file Structured\+Headers\+Decoder.\+h.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
proxygen/lib/http/structuredheaders/{\bf Structured\+Headers\+Decoder.\+h}\item 
proxygen/lib/http/structuredheaders/{\bf Structured\+Headers\+Decoder.\+cpp}\end{DoxyCompactItemize}
