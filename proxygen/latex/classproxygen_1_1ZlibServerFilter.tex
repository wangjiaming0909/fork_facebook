\section{proxygen\+:\+:Zlib\+Server\+Filter Class Reference}
\label{classproxygen_1_1ZlibServerFilter}\index{proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}}


{\ttfamily \#include $<$Zlib\+Server\+Filter.\+h$>$}

Inheritance diagram for proxygen\+:\+:Zlib\+Server\+Filter\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{classproxygen_1_1ZlibServerFilter}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Zlib\+Server\+Filter} ({\bf Request\+Handler} $\ast$downstream, int32\+\_\+t compression\+Level, uint32\+\_\+t minimum\+Compression\+Size, const std\+::shared\+\_\+ptr$<$ std\+::set$<$ std\+::string $>$$>$ compressible\+Content\+Types)
\item 
void {\bf send\+Headers} ({\bf H\+T\+T\+P\+Message} \&msg) noexceptoverride
\item 
void {\bf send\+Chunk\+Header} (size\+\_\+t len) noexceptoverride
\item 
void {\bf send\+Body} (std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ body) noexceptoverride
\item 
void {\bf send\+E\+OM} () noexceptoverride
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
void {\bf fail} ()
\item 
bool {\bf is\+Minimum\+Compressible\+Size} (const {\bf H\+T\+T\+P\+Message} \&msg) const noexcept
\item 
bool {\bf is\+Compressible\+Content\+Type} (const {\bf H\+T\+T\+P\+Message} \&msg) const noexcept
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Message} $>$ {\bf response\+Message\+\_\+}
\item 
std\+::unique\+\_\+ptr$<$ {\bf Zlib\+Stream\+Compressor} $>$ {\bf compressor\+\_\+} \{{\bf nullptr}\}
\item 
int32\+\_\+t {\bf compression\+Level\+\_\+} \{4\}
\item 
uint32\+\_\+t {\bf minimum\+Compression\+Size\+\_\+} \{1000\}
\item 
const std\+::shared\+\_\+ptr$<$ std\+::set$<$ std\+::string $>$ $>$ {\bf compressible\+Content\+Types\+\_\+}
\item 
bool {\bf header\+\_\+} \{false\}
\item 
bool {\bf chunked\+\_\+} \{false\}
\item 
bool {\bf compress\+\_\+} \{false\}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
A Server filter to perform G\+Zip compression. If there are any errors it will fall back to sending uncompressed responses. 

Definition at line 25 of file Zlib\+Server\+Filter.\+h.



\subsection{Constructor \& Destructor Documentation}
\index{proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}!Zlib\+Server\+Filter@{Zlib\+Server\+Filter}}
\index{Zlib\+Server\+Filter@{Zlib\+Server\+Filter}!proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}}
\subsubsection[{Zlib\+Server\+Filter(\+Request\+Handler $\ast$downstream, int32\+\_\+t compression\+Level, uint32\+\_\+t minimum\+Compression\+Size, const std\+::shared\+\_\+ptr$<$ std\+::set$<$ std\+::string $>$$>$ compressible\+Content\+Types)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+Zlib\+Server\+Filter\+::\+Zlib\+Server\+Filter (
\begin{DoxyParamCaption}
\item[{{\bf Request\+Handler} $\ast$}]{downstream, }
\item[{int32\+\_\+t}]{compression\+Level, }
\item[{uint32\+\_\+t}]{minimum\+Compression\+Size, }
\item[{const std\+::shared\+\_\+ptr$<$ std\+::set$<$ std\+::string $>$$>$}]{compressible\+Content\+Types}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}\label{classproxygen_1_1ZlibServerFilter_a076bd6749ff1c3da0021b9d29a1d9a25}


Definition at line 27 of file Zlib\+Server\+Filter.\+h.



Referenced by proxygen\+::\+Zlib\+Server\+Filter\+Factory\+::on\+Request().


\begin{DoxyCode}
32       : Filter(downstream),
33         compressionLevel_(compressionLevel),
34         minimumCompressionSize_(minimumCompressionSize),
35         compressibleContentTypes_(compressibleContentTypes) \{\}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}!fail@{fail}}
\index{fail@{fail}!proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}}
\subsubsection[{fail()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Zlib\+Server\+Filter\+::fail (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classproxygen_1_1ZlibServerFilter_a4d0a90f5e0b66dd4e5c8f88c15a66bba}


Definition at line 147 of file Zlib\+Server\+Filter.\+h.



References proxygen\+::\+Filter\+::send\+Abort().



Referenced by send\+Body(), send\+E\+O\+M(), and send\+Headers().


\begin{DoxyCode}
147               \{
148     Filter::sendAbort();
149   \}
\end{DoxyCode}
\index{proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}!is\+Compressible\+Content\+Type@{is\+Compressible\+Content\+Type}}
\index{is\+Compressible\+Content\+Type@{is\+Compressible\+Content\+Type}!proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}}
\subsubsection[{is\+Compressible\+Content\+Type(const H\+T\+T\+P\+Message \&msg) const noexcept}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+Zlib\+Server\+Filter\+::is\+Compressible\+Content\+Type (
\begin{DoxyParamCaption}
\item[{const {\bf H\+T\+T\+P\+Message} \&}]{msg}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1ZlibServerFilter_a7b694bc0309ddd2a9b26685c3b3893c8}


Definition at line 165 of file Zlib\+Server\+Filter.\+h.



References compressible\+Content\+Types\+\_\+.



Referenced by send\+Headers().


\begin{DoxyCode}
165                                                                         \{
166 
167     \textcolor{keyword}{auto} responseContentType =
168         msg.getHeaders().getSingleOrEmpty(HTTP\_HEADER\_CONTENT\_TYPE);
169     folly::toLowerAscii(responseContentType);
170 
171     \textcolor{comment}{// Handle  text/html; encoding=utf-8 case}
172     \textcolor{keyword}{auto} parameter\_idx = responseContentType.find(\textcolor{charliteral}{';'});
173     \textcolor{keywordflow}{if} (parameter\_idx != std::string::npos) \{
174      responseContentType = responseContentType.substr(0, parameter\_idx);
175     \}
176 
177     \textcolor{keyword}{auto} idx = compressibleContentTypes_->find(responseContentType);
178 
179     \textcolor{keywordflow}{if} (idx != compressibleContentTypes_->end()) \{
180       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
181     \}
182 
183     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
184   \}
\end{DoxyCode}
\index{proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}!is\+Minimum\+Compressible\+Size@{is\+Minimum\+Compressible\+Size}}
\index{is\+Minimum\+Compressible\+Size@{is\+Minimum\+Compressible\+Size}!proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}}
\subsubsection[{is\+Minimum\+Compressible\+Size(const H\+T\+T\+P\+Message \&msg) const noexcept}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+Zlib\+Server\+Filter\+::is\+Minimum\+Compressible\+Size (
\begin{DoxyParamCaption}
\item[{const {\bf H\+T\+T\+P\+Message} \&}]{msg}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1ZlibServerFilter_a0c653efe06dd4c2a3438de2ad8030edb}


Definition at line 152 of file Zlib\+Server\+Filter.\+h.



References minimum\+Compression\+Size\+\_\+.



Referenced by send\+Headers().


\begin{DoxyCode}
152                                                                         \{
153     \textcolor{keyword}{auto} contentLengthHeader =
154         msg.getHeaders().getSingleOrEmpty(HTTP\_HEADER\_CONTENT\_LENGTH);
155 
156     uint32\_t contentLength = 0;
157     \textcolor{keywordflow}{if} (!contentLengthHeader.empty()) \{
158       contentLength = folly::to<uint32\_t>(contentLengthHeader);
159     \}
160 
161     \textcolor{keywordflow}{return} contentLength >= minimumCompressionSize_;
162   \}
\end{DoxyCode}
\index{proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}!send\+Body@{send\+Body}}
\index{send\+Body@{send\+Body}!proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}}
\subsubsection[{send\+Body(std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ body) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Zlib\+Server\+Filter\+::send\+Body (
\begin{DoxyParamCaption}
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{body}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1ZlibServerFilter_a8251b0a6992f8d72ec7796c54150907c}


Implements {\bf proxygen\+::\+Response\+Handler} \doxyref{}{p.}{classproxygen_1_1ResponseHandler_ad2f61f6816fe12e96945fef5cdcd2228}.



Definition at line 86 of file Zlib\+Server\+Filter.\+h.



References chunked\+\_\+, compress\+\_\+, compressor\+\_\+, fail(), header\+\_\+, response\+Message\+\_\+, proxygen\+::\+Filter\+::send\+Body(), proxygen\+::\+Filter\+::send\+Chunk\+Header(), and proxygen\+::\+Filter\+::send\+Headers().


\begin{DoxyCode}
86                                                                   \{
87     \textcolor{comment}{// If not compressing, pass the body through}
88     \textcolor{keywordflow}{if} (!compress_) \{
89       DCHECK(header_ == \textcolor{keyword}{true});
90       Filter::sendBody(std::move(body));
91       \textcolor{keywordflow}{return};
92     \}
93 
94     CHECK(compressor_ && !compressor_->hasError());
95 
96     \textcolor{comment}{// If it's chunked, never write the trailer, it will be written on EOM}
97     \textcolor{keyword}{auto} compressed = compressor_->compress(body.get(), !chunked_);
98     \textcolor{keywordflow}{if} (compressor_->hasError()) \{
99       \textcolor{keywordflow}{return} fail();
100     \}
101 
102     \textcolor{keyword}{auto} compressedBodyLength = compressed->computeChainDataLength();
103 
104     \textcolor{keywordflow}{if} (chunked_) \{
105         \textcolor{comment}{// Send on the swallowed chunk header.}
106         Filter::sendChunkHeader(compressedBodyLength);
107     \} \textcolor{keywordflow}{else} \{
108       \textcolor{comment}{//Send the content length on compressed, non-chunked messages}
109       DCHECK(header_ == \textcolor{keyword}{false});
110       DCHECK(compress_ == \textcolor{keyword}{true});
111       \textcolor{keyword}{auto}& headers = responseMessage_->getHeaders();
112       headers.set(HTTP\_HEADER\_CONTENT\_LENGTH,
113           folly::to<std::string>(compressedBodyLength));
114 
115       Filter::sendHeaders(*responseMessage_);
116       header_  = \textcolor{keyword}{true};
117     \}
118 
119     Filter::sendBody(std::move(compressed));
120   \}
\end{DoxyCode}
\index{proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}!send\+Chunk\+Header@{send\+Chunk\+Header}}
\index{send\+Chunk\+Header@{send\+Chunk\+Header}!proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}}
\subsubsection[{send\+Chunk\+Header(size\+\_\+t len) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Zlib\+Server\+Filter\+::send\+Chunk\+Header (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1ZlibServerFilter_a8b5126cf3f7f90074fc1d3ea779380ba}


Implements {\bf proxygen\+::\+Response\+Handler} \doxyref{}{p.}{classproxygen_1_1ResponseHandler_a37c5b3b070602f564d654cf016b35109}.



Definition at line 71 of file Zlib\+Server\+Filter.\+h.



References compress\+\_\+, header\+\_\+, and proxygen\+::\+Filter\+::send\+Chunk\+Header().


\begin{DoxyCode}
71                                                      \{
72     \textcolor{comment}{// The headers should have always been sent since the message is chunked}
73     DCHECK\_EQ(header_, \textcolor{keyword}{true}) << \textcolor{stringliteral}{"Headers should have already been sent."};
74 
75     \textcolor{comment}{// If not compressing, pass downstream, otherwise "swallow" it}
76     \textcolor{comment}{// to send after compressing the body.}
77     \textcolor{keywordflow}{if} (!compress_) \{
78       Filter::sendChunkHeader(len);
79     \}
80 
81     \textcolor{comment}{// Return without sending the chunk header.}
82     \textcolor{keywordflow}{return};
83   \}
\end{DoxyCode}
\index{proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}!send\+E\+OM@{send\+E\+OM}}
\index{send\+E\+OM@{send\+E\+OM}!proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}}
\subsubsection[{send\+E\+O\+M() noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Zlib\+Server\+Filter\+::send\+E\+OM (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1ZlibServerFilter_a7f32659c332904f5207db2291916b4f7}


Implements {\bf proxygen\+::\+Response\+Handler} \doxyref{}{p.}{classproxygen_1_1ResponseHandler_af40d7a5c1674bea892d2598df9cfba61}.



Definition at line 122 of file Zlib\+Server\+Filter.\+h.



References chunked\+\_\+, compress\+\_\+, compressor\+\_\+, fail(), proxygen\+::\+Filter\+::send\+Body(), proxygen\+::\+Filter\+::send\+Chunk\+Header(), proxygen\+::\+Filter\+::send\+Chunk\+Terminator(), and proxygen\+::\+Filter\+::send\+E\+O\+M().


\begin{DoxyCode}
122                                    \{
123 
124     \textcolor{comment}{// Need to send the gzip trailer for compressed chunked messages}
125     \textcolor{keywordflow}{if} (compress_ && chunked_) \{
126 
127       \textcolor{keyword}{auto} emptyBuffer = folly::IOBuf::copyBuffer(\textcolor{stringliteral}{""});
128       CHECK(compressor_ && !compressor_->hasError());
129       \textcolor{keyword}{auto} compressed = compressor_->compress(emptyBuffer.get(), \textcolor{keyword}{true});
130 
131       \textcolor{keywordflow}{if} (compressor_->hasError()) \{
132         fail();
133         \textcolor{keywordflow}{return};
134       \}
135 
136       \textcolor{comment}{// "Inject" a chunk with the gzip trailer.}
137       Filter::sendChunkHeader(compressed->computeChainDataLength());
138       Filter::sendBody(std::move(compressed));
139       Filter::sendChunkTerminator();
140     \}
141 
142     Filter::sendEOM();
143   \}
\end{DoxyCode}
\index{proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}!send\+Headers@{send\+Headers}}
\index{send\+Headers@{send\+Headers}!proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}}
\subsubsection[{send\+Headers(\+H\+T\+T\+P\+Message \&msg) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Zlib\+Server\+Filter\+::send\+Headers (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Message} \&}]{msg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1ZlibServerFilter_a99c51fe64d28f04634b550eb3afc8621}
N\+O\+TE\+: We take response message as non-\/const reference, to allow filters between your handler and client to be able to modify response if they want to.

eg. a compression filter might want to change the content-\/encoding 

Implements {\bf proxygen\+::\+Response\+Handler} \doxyref{}{p.}{classproxygen_1_1ResponseHandler_a20f98e57c8000a4af68483763f5fffb1}.



Definition at line 37 of file Zlib\+Server\+Filter.\+h.



References chunked\+\_\+, compress\+\_\+, compression\+Level\+\_\+, compressor\+\_\+, fail(), proxygen\+::\+G\+Z\+IP, header\+\_\+, is\+Compressible\+Content\+Type(), is\+Minimum\+Compressible\+Size(), response\+Message\+\_\+, and proxygen\+::\+Filter\+::send\+Headers().


\begin{DoxyCode}
37                                                        \{
38     DCHECK(compressor_ == \textcolor{keyword}{nullptr});
39     DCHECK(header_ == \textcolor{keyword}{false});
40 
41     chunked_ = msg.getIsChunked();
42 
43     \textcolor{comment}{// Make final determination of whether to compress}
44     compress_ = isCompressibleContentType(msg) &&
45       (chunked_ || isMinimumCompressibleSize(msg));
46 
47     \textcolor{comment}{// Add the gzip header}
48     \textcolor{keywordflow}{if} (compress_) \{
49       \textcolor{keyword}{auto}& headers = msg.getHeaders();
50       headers.set(HTTP\_HEADER\_CONTENT\_ENCODING, \textcolor{stringliteral}{"gzip"});
51     \}
52 
53     \textcolor{comment}{// Initialize compressor}
54     compressor_ = std::make\_unique<ZlibStreamCompressor>(
55       proxygen::ZlibCompressionType::GZIP, compressionLevel_);
56     \textcolor{keywordflow}{if} (!compressor_ || compressor_->hasError()) \{
57       fail();
58       \textcolor{keywordflow}{return};
59     \}
60 
61     \textcolor{comment}{// If it's chunked or not being compressed then the headers can be sent}
62     \textcolor{comment}{// if it's compressed and one body, then need to calculate content length.}
63     \textcolor{keywordflow}{if} (chunked_ || !compress_) \{
64       Filter::sendHeaders(msg);
65       header_ = \textcolor{keyword}{true};
66     \} \textcolor{keywordflow}{else} \{
67       responseMessage_ = std::make\_unique<HTTPMessage>(msg);
68     \}
69   \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}!chunked\+\_\+@{chunked\+\_\+}}
\index{chunked\+\_\+@{chunked\+\_\+}!proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}}
\subsubsection[{chunked\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+Zlib\+Server\+Filter\+::chunked\+\_\+ \{false\}\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1ZlibServerFilter_af5771117efd728be9a837e8076b93634}


Definition at line 192 of file Zlib\+Server\+Filter.\+h.



Referenced by send\+Body(), send\+E\+O\+M(), and send\+Headers().

\index{proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}!compress\+\_\+@{compress\+\_\+}}
\index{compress\+\_\+@{compress\+\_\+}!proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}}
\subsubsection[{compress\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+Zlib\+Server\+Filter\+::compress\+\_\+ \{false\}\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1ZlibServerFilter_abf65b91701e938d86e00c26d8fed522a}


Definition at line 193 of file Zlib\+Server\+Filter.\+h.



Referenced by send\+Body(), send\+Chunk\+Header(), send\+E\+O\+M(), and send\+Headers().

\index{proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}!compressible\+Content\+Types\+\_\+@{compressible\+Content\+Types\+\_\+}}
\index{compressible\+Content\+Types\+\_\+@{compressible\+Content\+Types\+\_\+}!proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}}
\subsubsection[{compressible\+Content\+Types\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::shared\+\_\+ptr$<$std\+::set$<$std\+::string$>$ $>$ proxygen\+::\+Zlib\+Server\+Filter\+::compressible\+Content\+Types\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1ZlibServerFilter_ab937a9209f2b80506f88a4c634ec7c3c}


Definition at line 190 of file Zlib\+Server\+Filter.\+h.



Referenced by is\+Compressible\+Content\+Type(), and proxygen\+::\+Zlib\+Server\+Filter\+Factory\+::on\+Request().

\index{proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}!compression\+Level\+\_\+@{compression\+Level\+\_\+}}
\index{compression\+Level\+\_\+@{compression\+Level\+\_\+}!proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}}
\subsubsection[{compression\+Level\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}int32\+\_\+t proxygen\+::\+Zlib\+Server\+Filter\+::compression\+Level\+\_\+ \{4\}\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1ZlibServerFilter_ad5b7b381657de037a1fc0db48fd33fe5}


Definition at line 188 of file Zlib\+Server\+Filter.\+h.



Referenced by proxygen\+::\+Zlib\+Server\+Filter\+Factory\+::on\+Request(), and send\+Headers().

\index{proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}!compressor\+\_\+@{compressor\+\_\+}}
\index{compressor\+\_\+@{compressor\+\_\+}!proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}}
\subsubsection[{compressor\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<${\bf Zlib\+Stream\+Compressor}$>$ proxygen\+::\+Zlib\+Server\+Filter\+::compressor\+\_\+ \{{\bf nullptr}\}\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1ZlibServerFilter_a98fd9c3a35b6da0a78c79e7e93a8fe95}


Definition at line 187 of file Zlib\+Server\+Filter.\+h.



Referenced by send\+Body(), send\+E\+O\+M(), and send\+Headers().

\index{proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}!header\+\_\+@{header\+\_\+}}
\index{header\+\_\+@{header\+\_\+}!proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}}
\subsubsection[{header\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+Zlib\+Server\+Filter\+::header\+\_\+ \{false\}\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1ZlibServerFilter_aff174b8cec64f898a5dd5d2ef3a43282}


Definition at line 191 of file Zlib\+Server\+Filter.\+h.



Referenced by send\+Body(), send\+Chunk\+Header(), and send\+Headers().

\index{proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}!minimum\+Compression\+Size\+\_\+@{minimum\+Compression\+Size\+\_\+}}
\index{minimum\+Compression\+Size\+\_\+@{minimum\+Compression\+Size\+\_\+}!proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}}
\subsubsection[{minimum\+Compression\+Size\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+Zlib\+Server\+Filter\+::minimum\+Compression\+Size\+\_\+ \{1000\}\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1ZlibServerFilter_aa2e00b66cb175c3aa80bab524aaa4249}


Definition at line 189 of file Zlib\+Server\+Filter.\+h.



Referenced by is\+Minimum\+Compressible\+Size(), and proxygen\+::\+Zlib\+Server\+Filter\+Factory\+::on\+Request().

\index{proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}!response\+Message\+\_\+@{response\+Message\+\_\+}}
\index{response\+Message\+\_\+@{response\+Message\+\_\+}!proxygen\+::\+Zlib\+Server\+Filter@{proxygen\+::\+Zlib\+Server\+Filter}}
\subsubsection[{response\+Message\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<${\bf H\+T\+T\+P\+Message}$>$ proxygen\+::\+Zlib\+Server\+Filter\+::response\+Message\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1ZlibServerFilter_af0267b7cf407bc1b99089c435a352615}


Definition at line 186 of file Zlib\+Server\+Filter.\+h.



Referenced by send\+Body(), and send\+Headers().



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
proxygen/httpserver/filters/{\bf Zlib\+Server\+Filter.\+h}\end{DoxyCompactItemize}
