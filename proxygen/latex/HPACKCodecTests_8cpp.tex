\section{proxygen/lib/http/codec/compress/test/\+H\+P\+A\+C\+K\+Codec\+Tests.cpp File Reference}
\label{HPACKCodecTests_8cpp}\index{proxygen/lib/http/codec/compress/test/\+H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{proxygen/lib/http/codec/compress/test/\+H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}}
{\ttfamily \#include $<$folly/\+Range.\+h$>$}\\*
{\ttfamily \#include $<$folly/io/\+Cursor.\+h$>$}\\*
{\ttfamily \#include $<$folly/io/\+I\+O\+Buf.\+h$>$}\\*
{\ttfamily \#include $<$glog/logging.\+h$>$}\\*
{\ttfamily \#include $<$folly/portability/\+G\+Test.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/compress/\+H\+P\+A\+C\+K\+Codec.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/compress/\+H\+P\+A\+C\+K\+Queue.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/compress/\+Header.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/compress/\+Header\+Codec.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/compress/test/\+Test\+Streaming\+Callback.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/compress/test/\+Test\+Util.\+h$>$}\\*
{\ttfamily \#include $<$vector$>$}\\*
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class {\bf H\+P\+A\+C\+K\+Codec\+Tests}
\item 
class {\bf H\+P\+A\+C\+K\+Queue\+Tests}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
bool {\bf is\+Lowercase} (String\+Piece str)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Codec\+Tests}, Request)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Codec\+Tests}, Response)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Codec\+Tests}, Headroom)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Codec\+Tests}, Lowercasing\+Header\+Names)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Codec\+Tests}, Multivalue\+Headers)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Codec\+Tests}, {\bf Decode\+Error})
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Codec\+Tests}, Header\+Codec\+Stats)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Codec\+Tests}, Uncompressed\+Size\+Limit)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Codec\+Tests}, Size\+Limit\+Stats)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Codec\+Tests}, Default\+Header\+Indexing\+Strategy)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Queue\+Tests}, Queue\+Inline)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Queue\+Tests}, Queue\+Reorder)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Queue\+Tests}, Queue\+Reorder\+Ooo)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+P\+A\+C\+K\+Queue\+Tests}, Queue\+Error)
\item 
{\bf T\+E\+S\+T\+\_\+P} ({\bf H\+P\+A\+C\+K\+Queue\+Tests}, Queue\+Deleted)
\item 
{\bf I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P} (Queue, {\bf H\+P\+A\+C\+K\+Queue\+Tests},\+::testing\+::\+Values(0, 1, 2, 3))
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}!I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P@{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P}}
\index{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P@{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P}!H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}}
\subsubsection[{I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+P(\+Queue, H\+P\+A\+C\+K\+Queue\+Tests,\+::testing\+::\+Values(0, 1, 2, 3))}]{\setlength{\rightskip}{0pt plus 5cm}I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+P (
\begin{DoxyParamCaption}
\item[{Queue}]{, }
\item[{{\bf H\+P\+A\+C\+K\+Queue\+Tests}}]{, }
\item[{\+::testing\+::\+Values(0, 1, 2, 3)}]{}
\end{DoxyParamCaption}
)}\label{HPACKCodecTests_8cpp_ab25c8dbc2755d8ce984077efc001e024}


Referenced by T\+E\+S\+T\+\_\+\+P().

\index{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}!is\+Lowercase@{is\+Lowercase}}
\index{is\+Lowercase@{is\+Lowercase}!H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}}
\subsubsection[{is\+Lowercase(\+String\+Piece str)}]{\setlength{\rightskip}{0pt plus 5cm}bool is\+Lowercase (
\begin{DoxyParamCaption}
\item[{String\+Piece}]{str}
\end{DoxyParamCaption}
)}\label{HPACKCodecTests_8cpp_acdf7b2666a3b1aa2935b0a550c603769}


Definition at line 31 of file H\+P\+A\+C\+K\+Codec\+Tests.\+cpp.



References proxygen\+::hpack\+::decode(), proxygen\+::\+H\+P\+A\+C\+K\+Codec\+::decode\+Streaming(), proxygen\+::\+H\+P\+A\+C\+K\+Codec\+::encode(), encode\+Decode(), proxygen\+::\+E\+R\+R\+OR, proxygen\+::\+Test\+Streaming\+Callback\+::error, proxygen\+::\+Test\+Streaming\+Callback\+::get\+Result(), and proxygen\+::\+Test\+Streaming\+Callback\+::has\+Error().



Referenced by T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
31                                   \{
32   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} ch : str) \{
33     \textcolor{keywordflow}{if} (isalpha(ch) && !islower(ch)) \{
34       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
35     \}
36   \}
37   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
38 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Codec\+Tests, Request)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Codec\+Tests}}]{, }
\item[{Request}]{}
\end{DoxyParamCaption}
)}\label{HPACKCodecTests_8cpp_ab1fedaf03aee96861c77143a546e76a9}


Definition at line 83 of file H\+P\+A\+C\+K\+Codec\+Tests.\+cpp.



References proxygen\+::hpack\+::basic\+Headers(), and encode\+Decode().


\begin{DoxyCode}
83                                  \{
84   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 3; i++) \{
85     \textcolor{keyword}{auto} result = encodeDecode(client, server, basicHeaders());
86     EXPECT\_TRUE(!result.hasError());
87     EXPECT\_EQ(result->headers.size(), 12);
88   \}
89 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Codec\+Tests, Response)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Codec\+Tests}}]{, }
\item[{Response}]{}
\end{DoxyParamCaption}
)}\label{HPACKCodecTests_8cpp_a899b9229364542885e68e54aad296a46}


Definition at line 91 of file H\+P\+A\+C\+K\+Codec\+Tests.\+cpp.



References proxygen\+::hpack\+::basic\+Headers(), encode\+Decode(), and proxygen\+::hpack\+::headers\+From\+Array().


\begin{DoxyCode}
91                                   \{
92   vector<vector<string>> headers = \{
93     \{\textcolor{stringliteral}{"content-length"}, \textcolor{stringliteral}{"80"}\},
94     \{\textcolor{stringliteral}{"content-encoding"}, \textcolor{stringliteral}{"gzip"}\},
95     \{\textcolor{stringliteral}{"x-fb-debug"}, \textcolor{stringliteral}{"sdfgrwer"}\}
96   \};
97   vector<Header> req = headersFromArray(headers);
98 
99   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 3; i++) \{
100     \textcolor{keyword}{auto} result = encodeDecode(server, client, basicHeaders());
101     EXPECT\_TRUE(!result.hasError());
102     EXPECT\_EQ(result->headers.size(), 12);
103   \}
104 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Codec\+Tests, Headroom)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Codec\+Tests}}]{, }
\item[{Headroom}]{}
\end{DoxyParamCaption}
)}\label{HPACKCodecTests_8cpp_abedbea19c4c8069c9fcfb327a47b26df}


Definition at line 106 of file H\+P\+A\+C\+K\+Codec\+Tests.\+cpp.



References proxygen\+::hpack\+::basic\+Headers(), and proxygen\+::hpack\+::decode().


\begin{DoxyCode}
106                                   \{
107   vector<Header> req = basicHeaders();
108 
109   uint32\_t headroom = 20;
110   client.setEncodeHeadroom(headroom);
111   unique\_ptr<IOBuf> encodedReq = client.encode(req);
112   EXPECT\_EQ(encodedReq->headroom(), headroom);
113   Cursor cursor(encodedReq.get());
114   \textcolor{keyword}{auto} result = decode(server, cursor, cursor.totalLength());
115   EXPECT\_TRUE(!result.hasError());
116   EXPECT\_EQ(result->headers.size(), 12);
117 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Codec\+Tests, Lowercasing\+Header\+Names)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Codec\+Tests}}]{, }
\item[{Lowercasing\+Header\+Names}]{}
\end{DoxyParamCaption}
)}\label{HPACKCodecTests_8cpp_acbab0df9edd4a28365130649283b82be}
makes sure that the encoder will lowercase the header names 

Definition at line 122 of file H\+P\+A\+C\+K\+Codec\+Tests.\+cpp.



References encode\+Decode(), proxygen\+::hpack\+::headers\+From\+Array(), and is\+Lowercase().


\begin{DoxyCode}
122                                                 \{
123   vector<vector<string>> headers = \{
124     \{\textcolor{stringliteral}{"Content-Length"}, \textcolor{stringliteral}{"80"}\},
125     \{\textcolor{stringliteral}{"Content-Encoding"}, \textcolor{stringliteral}{"gzip"}\},
126     \{\textcolor{stringliteral}{"X-FB-Debug"}, \textcolor{stringliteral}{"bleah"}\}
127   \};
128   \textcolor{keyword}{auto} result = encodeDecode(server, client, headersFromArray(headers));
129   EXPECT\_TRUE(!result.hasError());
130   \textcolor{keyword}{auto}& decoded = result->headers;
131   CHECK\_EQ(decoded.size(), 6);
132   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 6; i += 2) \{
133     EXPECT\_TRUE(isLowercase(decoded[i].str));
134   \}
135 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Codec\+Tests, Multivalue\+Headers)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Codec\+Tests}}]{, }
\item[{Multivalue\+Headers}]{}
\end{DoxyParamCaption}
)}\label{HPACKCodecTests_8cpp_a8a3f6e954dc196c81c678d762af2b6cf}
make sure we mark multi-\/valued headers appropriately, as expected by the S\+P\+DY codec. 

Definition at line 141 of file H\+P\+A\+C\+K\+Codec\+Tests.\+cpp.



References encode\+Decode(), and proxygen\+::hpack\+::headers\+From\+Array().


\begin{DoxyCode}
141                                            \{
142   vector<vector<string>> headers = \{
143     \{\textcolor{stringliteral}{"Content-Length"}, \textcolor{stringliteral}{"80"}\},
144     \{\textcolor{stringliteral}{"Content-Encoding"}, \textcolor{stringliteral}{"gzip"}\},
145     \{\textcolor{stringliteral}{"X-FB-Dup"}, \textcolor{stringliteral}{"bleah"}\},
146     \{\textcolor{stringliteral}{"X-FB-Dup"}, \textcolor{stringliteral}{"hahaha"}\}
147   \};
148   \textcolor{keyword}{auto} result = encodeDecode(server, client, headersFromArray(headers));
149   EXPECT\_TRUE(!result.hasError());
150   \textcolor{keyword}{auto}& decoded = result->headers;
151   CHECK\_EQ(decoded.size(), 8);
152   uint32\_t count = 0;
153   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 8; i += 2) \{
154     \textcolor{keywordflow}{if} (decoded[i].str == \textcolor{stringliteral}{"x-fb-dup"}) \{
155       count++;
156     \}
157   \}
158   EXPECT\_EQ(count, 2);
159 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Codec\+Tests, Decode\+Error)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Codec\+Tests}}]{, }
\item[{{\bf Decode\+Error}}]{}
\end{DoxyParamCaption}
)}\label{HPACKCodecTests_8cpp_ae3ed237508f60b9a985677702ad5b4b0}
test that we\textquotesingle{}re propagating the error correctly in the decoder 

Definition at line 164 of file H\+P\+A\+C\+K\+Codec\+Tests.\+cpp.



References proxygen\+::hpack\+::decode(), and proxygen\+::hpack\+::headers\+From\+Array().


\begin{DoxyCode}
164                                      \{
165   vector<vector<string>> headers = \{
166     \{\textcolor{stringliteral}{"Content-Length"}, \textcolor{stringliteral}{"80"}\}
167   \};
168   vector<Header> req = headersFromArray(headers);
169 
170   unique\_ptr<IOBuf> encodedReq = server.encode(req);
171   encodedReq->writableData()[0] = 0xFF;
172   Cursor cursor(encodedReq.get());
173 
174   TestHeaderCodecStats stats(HeaderCodec::Type::HPACK);
175   client.setStats(&stats);
176   \textcolor{keyword}{auto} result = decode(client, cursor, cursor.totalLength());
177   \textcolor{comment}{// this means there was an error}
178   EXPECT\_TRUE(result.hasError());
179   EXPECT\_EQ(result.error(), HPACK::DecodeError::INVALID\_INDEX);
180   EXPECT\_EQ(stats.errors, 1);
181   client.setStats(\textcolor{keyword}{nullptr});
182 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Codec\+Tests, Header\+Codec\+Stats)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Codec\+Tests}}]{, }
\item[{Header\+Codec\+Stats}]{}
\end{DoxyParamCaption}
)}\label{HPACKCodecTests_8cpp_aa0d9eb182d138860a00ef60c257e8deb}
testing that we\textquotesingle{}re calling the stats callbacks appropriately 

Definition at line 187 of file H\+P\+A\+C\+K\+Codec\+Tests.\+cpp.



References proxygen\+::hpack\+::decode(), proxygen\+::hpack\+::\+Test\+Header\+Codec\+Stats\+::decoded\+Bytes\+Compr, proxygen\+::hpack\+::\+Test\+Header\+Codec\+Stats\+::decoded\+Bytes\+Uncompr, proxygen\+::hpack\+::\+Test\+Header\+Codec\+Stats\+::decodes, proxygen\+::hpack\+::\+Test\+Header\+Codec\+Stats\+::encoded\+Bytes\+Compr, proxygen\+::hpack\+::\+Test\+Header\+Codec\+Stats\+::encoded\+Bytes\+Uncompr, proxygen\+::hpack\+::\+Test\+Header\+Codec\+Stats\+::encodes, proxygen\+::hpack\+::\+Test\+Header\+Codec\+Stats\+::errors, proxygen\+::hpack\+::headers\+From\+Array(), and proxygen\+::hpack\+::\+Test\+Header\+Codec\+Stats\+::reset().


\begin{DoxyCode}
187                                           \{
188   vector<vector<string>> headers = \{
189     \{\textcolor{stringliteral}{"Content-Length"}, \textcolor{stringliteral}{"80"}\},
190     \{\textcolor{stringliteral}{"Content-Encoding"}, \textcolor{stringliteral}{"gzip"}\},
191     \{\textcolor{stringliteral}{"X-FB-Debug"}, \textcolor{stringliteral}{"eirtijvdgtccffkutnbttcgbfieghgev"}\}
192   \};
193   vector<Header> resp = headersFromArray(headers);
194 
195   TestHeaderCodecStats stats(HeaderCodec::Type::HPACK);
196   \textcolor{comment}{// encode}
197   server.setStats(&stats);
198   unique\_ptr<IOBuf> encodedResp = server.encode(resp);
199   EXPECT\_EQ(stats.encodes, 1);
200   EXPECT\_EQ(stats.decodes, 0);
201   EXPECT\_EQ(stats.errors, 0);
202   EXPECT\_TRUE(stats.encodedBytesCompr > 0);
203   EXPECT\_TRUE(stats.encodedBytesUncompr > 0);
204   EXPECT\_EQ(stats.decodedBytesCompr, 0);
205   EXPECT\_EQ(stats.decodedBytesUncompr, 0);
206   server.setStats(\textcolor{keyword}{nullptr});
207 
208   \textcolor{comment}{// decode}
209   Cursor cursor(encodedResp.get());
210   stats.reset();
211   client.setStats(&stats);
212   \textcolor{keyword}{auto} result = decode(client, cursor, cursor.totalLength());
213   EXPECT\_TRUE(!result.hasError());
214   \textcolor{keyword}{auto}& decoded = result->headers;
215   CHECK\_EQ(decoded.size(), 3 * 2);
216   EXPECT\_EQ(stats.decodes, 1);
217   EXPECT\_EQ(stats.encodes, 0);
218   EXPECT\_GT(stats.decodedBytesCompr, 0);
219   EXPECT\_GT(stats.decodedBytesUncompr, 0);
220   EXPECT\_EQ(stats.encodedBytesCompr, 0);
221   EXPECT\_EQ(stats.encodedBytesUncompr, 0);
222   client.setStats(\textcolor{keyword}{nullptr});
223 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Codec\+Tests, Uncompressed\+Size\+Limit)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Codec\+Tests}}]{, }
\item[{Uncompressed\+Size\+Limit}]{}
\end{DoxyParamCaption}
)}\label{HPACKCodecTests_8cpp_ac43a6d3ee2302ca362dfcaa95db74e7a}
check that we\textquotesingle{}re enforcing the limit on total uncompressed size 

Definition at line 228 of file H\+P\+A\+C\+K\+Codec\+Tests.\+cpp.



References encode\+Decode(), and proxygen\+::hpack\+::headers\+From\+Array().


\begin{DoxyCode}
228                                                \{
229   vector<vector<string>> headers;
230   \textcolor{comment}{// generate lots of small headers}
231   \textcolor{keywordtype}{string} contentLength = \textcolor{stringliteral}{"Content-Length"};
232   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 10000; i++) \{
233     \textcolor{keywordtype}{string} value = folly::to<string>(i);
234     vector<string> header = \{contentLength, value\};
235     headers.push\_back(header);
236   \}
237   \textcolor{keyword}{auto} result = encodeDecode(server, client, headersFromArray(headers));
238   EXPECT\_TRUE(result.hasError());
239   EXPECT\_EQ(result.error(), HPACK::DecodeError::HEADERS\_TOO\_LARGE);
240 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Codec\+Tests, Size\+Limit\+Stats)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Codec\+Tests}}]{, }
\item[{Size\+Limit\+Stats}]{}
\end{DoxyParamCaption}
)}\label{HPACKCodecTests_8cpp_a23a83835015d9c7a86231823318fc97a}
Size limit stats 

Definition at line 246 of file H\+P\+A\+C\+K\+Codec\+Tests.\+cpp.



References proxygen\+::hpack\+::headers\+From\+Array(), and proxygen\+::hpack\+::\+Test\+Header\+Codec\+Stats\+::too\+Large.


\begin{DoxyCode}
246                                         \{
247   vector<vector<string>> headers;
248   \textcolor{comment}{// generate lots of small headers}
249   \textcolor{keywordtype}{string} contentLength = \textcolor{stringliteral}{"Content-Length"};
250   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 10000; i++) \{
251     \textcolor{keywordtype}{string} value = folly::to<string>(i);
252     vector<string> header = \{contentLength, value\};
253     headers.push\_back(header);
254   \}
255   \textcolor{keyword}{auto} encHeaders = headersFromArray(headers);
256   unique\_ptr<IOBuf> encoded = client.encode(encHeaders);
257   Cursor cursor(encoded.get());
258   TestStreamingCallback cb;
259   TestHeaderCodecStats stats(HeaderCodec::Type::HPACK);
260   server.setStats(&stats);
261   server.decodeStreaming(cursor, cursor.totalLength(), &cb);
262   \textcolor{keyword}{auto} result = cb.getResult();
263   EXPECT\_TRUE(result.hasError());
264   EXPECT\_EQ(result.error(), HPACK::DecodeError::HEADERS\_TOO\_LARGE);
265   EXPECT\_EQ(stats.tooLarge, 1);
266 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Codec\+Tests, Default\+Header\+Indexing\+Strategy)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Codec\+Tests}}]{, }
\item[{Default\+Header\+Indexing\+Strategy}]{}
\end{DoxyParamCaption}
)}\label{HPACKCodecTests_8cpp_a8997c80bd3a962d29b16d3f768a3ed06}


Definition at line 268 of file H\+P\+A\+C\+K\+Codec\+Tests.\+cpp.



References proxygen\+::hpack\+::basic\+Headers(), proxygen\+::\+H\+P\+A\+C\+K\+Codec\+::encode(), and proxygen\+::hpack\+::headers\+From\+Array().


\begin{DoxyCode}
268                                                        \{
269   vector<Header> headers = basicHeaders();
270   \textcolor{keywordtype}{size\_t} headersIndexableSize = 4;
271 
272   \textcolor{comment}{// Control equality check; all basic headers were indexed}
273   client.encode(headers);
274   EXPECT\_EQ(client.getCompressionInfo().egressHeadersStored\_,
275             headersIndexableSize);
276 
277   \textcolor{comment}{// Verify HPACKCodec by default utilizes the default header indexing strategy}
278   \textcolor{comment}{// by ensuring that it does not index any of the added headers below}
279   \textcolor{comment}{// The below is quite verbose but that is because Header constructors use}
280   \textcolor{comment}{// references and so we need the actual strings to not go out of scope}
281   vector<vector<string>> noIndexHeadersStrings = \{
282     \{\textcolor{stringliteral}{"content-length"}, \textcolor{stringliteral}{"80"}\},
283     \{\textcolor{stringliteral}{":path"}, \textcolor{stringliteral}{"/some/random/file.jpg"}\},
284     \{\textcolor{stringliteral}{":path"}, \textcolor{stringliteral}{"checks\_for\_="}\},
285     \{\textcolor{stringliteral}{"if-modified-since"}, \textcolor{stringliteral}{"some\_value"}\},
286     \{\textcolor{stringliteral}{"last-modified"}, \textcolor{stringliteral}{"some\_value"}\}
287   \};
288   vector<Header> noIndexHeaders = headersFromArray(noIndexHeadersStrings);
289   headers.insert(headers.end(), noIndexHeaders.begin(), noIndexHeaders.end());
290   HPACKCodec testCodec\{TransportDirection::UPSTREAM\};
291   testCodec.encode(headers);
292   EXPECT\_EQ(
293     testCodec.getCompressionInfo().egressHeadersStored\_, headersIndexableSize);
294 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Queue\+Tests, Queue\+Inline)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Queue\+Tests}}]{, }
\item[{Queue\+Inline}]{}
\end{DoxyParamCaption}
)}\label{HPACKCodecTests_8cpp_ac420394f68fa8c55738c2ddd83e46837}


Definition at line 309 of file H\+P\+A\+C\+K\+Codec\+Tests.\+cpp.



References proxygen\+::hpack\+::basic\+Headers(), proxygen\+::\+Test\+Streaming\+Callback\+::get\+Result(), and proxygen\+::\+Test\+Streaming\+Callback\+::reset().


\begin{DoxyCode}
309                                      \{
310   vector<Header> req = basicHeaders();
311   TestStreamingCallback cb;
312 
313   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 3; i++) \{
314     unique\_ptr<IOBuf> encodedReq = client.encode(req);
315     \textcolor{keyword}{auto} len = bufLen(encodedReq);
316     cb.reset();
317     queue->enqueueHeaderBlock(i, std::move(encodedReq), len, &cb, \textcolor{keyword}{false});
318     \textcolor{keyword}{auto} result = cb.getResult();
319     EXPECT\_TRUE(!result.hasError());
320     EXPECT\_EQ(result->headers.size(), 12);
321   \}
322 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Queue\+Tests, Queue\+Reorder)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Queue\+Tests}}]{, }
\item[{Queue\+Reorder}]{}
\end{DoxyParamCaption}
)}\label{HPACKCodecTests_8cpp_ae8437f4d158b709d1c6ea3acf403f0ea}


Definition at line 324 of file H\+P\+A\+C\+K\+Codec\+Tests.\+cpp.



References proxygen\+::hpack\+::basic\+Headers().


\begin{DoxyCode}
324                                       \{
325   vector<Header> req = basicHeaders();
326   vector<std::pair<unique\_ptr<IOBuf>, TestStreamingCallback>> data;
327 
328   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 4; i++) \{
329     data.emplace\_back(client.encode(req), TestStreamingCallback());
330   \}
331 
332   std::vector<int> insertOrder\{1, 3, 2, 0\};
333   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i: insertOrder) \{
334     \textcolor{keyword}{auto}& encodedReq = data[i].first;
335     \textcolor{keyword}{auto} len = bufLen(encodedReq);
336     queue->enqueueHeaderBlock(i, std::move(encodedReq), len, &data[i].second,
337                              \textcolor{keyword}{false});
338   \}
339   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}& d: data) \{
340     \textcolor{keyword}{auto} result = d.second.getResult();
341     EXPECT\_TRUE(!result.hasError());
342     EXPECT\_EQ(result->headers.size(), 12);
343   \}
344   EXPECT\_EQ(queue->getHolBlockCount(), 3);
345 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Queue\+Tests, Queue\+Reorder\+Ooo)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Queue\+Tests}}]{, }
\item[{Queue\+Reorder\+Ooo}]{}
\end{DoxyParamCaption}
)}\label{HPACKCodecTests_8cpp_af3edc4cfc6cd5a852da08ff118a85c57}


Definition at line 347 of file H\+P\+A\+C\+K\+Codec\+Tests.\+cpp.



References proxygen\+::hpack\+::basic\+Headers().


\begin{DoxyCode}
347                                          \{
348   vector<Header> req = basicHeaders();
349   vector<std::pair<unique\_ptr<IOBuf>, TestStreamingCallback>> data;
350 
351   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 4; i++) \{
352     data.emplace\_back(client.encode(req), TestStreamingCallback());
353   \}
354 
355   std::vector<int> insertOrder\{0, 3, 2, 1\};
356   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i: insertOrder) \{
357     \textcolor{keyword}{auto}& encodedReq = data[i].first;
358     \textcolor{keyword}{auto} len = bufLen(encodedReq);
359     \textcolor{comment}{// Allow idx 3 to be decoded out of order}
360     queue->enqueueHeaderBlock(i, std::move(encodedReq), len, &data[i].second,
361                               i == 3);
362   \}
363   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}& d: data) \{
364     \textcolor{keyword}{auto} result = d.second.getResult();
365     EXPECT\_TRUE(!result.hasError());
366     EXPECT\_EQ(result->headers.size(), 12);
367   \}
368   EXPECT\_EQ(queue->getHolBlockCount(), 1);
369 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+P\+A\+C\+K\+Queue\+Tests, Queue\+Error)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Queue\+Tests}}]{, }
\item[{Queue\+Error}]{}
\end{DoxyParamCaption}
)}\label{HPACKCodecTests_8cpp_af6f343474df5b663e70fd69e5d63b9d9}


Definition at line 371 of file H\+P\+A\+C\+K\+Codec\+Tests.\+cpp.



References proxygen\+::hpack\+::basic\+Headers(), proxygen\+::\+Test\+Streaming\+Callback\+::get\+Result(), and proxygen\+::\+Test\+Streaming\+Callback\+::reset().


\begin{DoxyCode}
371                                     \{
372   vector<Header> req = basicHeaders();
373   TestStreamingCallback cb;
374 
375   \textcolor{keywordtype}{bool} expectOk = \textcolor{keyword}{true};
376   \textcolor{comment}{// ok, dup, ok, lower}
377   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i: std::vector<int>(\{0, 0, 1, 0, 3, 3, 2\})) \{
378     unique\_ptr<IOBuf> encodedReq = client.encode(req);
379     \textcolor{keyword}{auto} len = bufLen(encodedReq);
380     cb.reset();
381     queue->enqueueHeaderBlock(i, std::move(encodedReq), len, &cb, \textcolor{keyword}{true});
382     \textcolor{keyword}{auto} result = cb.getResult();
383     \textcolor{keywordflow}{if} (expectOk) \{
384       EXPECT\_TRUE(!result.hasError());
385       EXPECT\_EQ(result->headers.size(), 12);
386     \} \textcolor{keywordflow}{else} \{
387       EXPECT\_TRUE(result.hasError());
388       EXPECT\_EQ(result.error(), HPACK::DecodeError::BAD\_SEQUENCE\_NUMBER);
389     \}
390     expectOk = !expectOk;
391   \}
392 \}
\end{DoxyCode}
\index{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}!T\+E\+S\+T\+\_\+P@{T\+E\+S\+T\+\_\+P}}
\index{T\+E\+S\+T\+\_\+P@{T\+E\+S\+T\+\_\+P}!H\+P\+A\+C\+K\+Codec\+Tests.\+cpp@{H\+P\+A\+C\+K\+Codec\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+P(\+H\+P\+A\+C\+K\+Queue\+Tests, Queue\+Deleted)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+P (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Queue\+Tests}}]{, }
\item[{Queue\+Deleted}]{}
\end{DoxyParamCaption}
)}\label{HPACKCodecTests_8cpp_a009e9ef87f3fb3ddb2a833ba9e6b39aa}


Definition at line 394 of file H\+P\+A\+C\+K\+Codec\+Tests.\+cpp.



References proxygen\+::hpack\+::basic\+Headers(), and I\+N\+S\+T\+A\+N\+T\+I\+A\+T\+E\+\_\+\+T\+E\+S\+T\+\_\+\+C\+A\+S\+E\+\_\+\+P().


\begin{DoxyCode}
394                                       \{
395   vector<Header> req = basicHeaders();
396   vector<std::pair<unique\_ptr<IOBuf>, TestStreamingCallback>> data;
397 
398   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{int} i = 0; i < 4; i++) \{
399     data.emplace\_back(client.encode(req), TestStreamingCallback());
400     \textcolor{keywordflow}{if} (i == GetParam()) \{
401       data.back().second.headersCompleteCb = [&] \{ queue.reset(); \};
402     \}
403   \}
404 
405   std::vector<int> insertOrder\{0, 3, 2, 1\};
406   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i: insertOrder) \{
407     \textcolor{keyword}{auto}& encodedReq = data[i].first;
408     \textcolor{keyword}{auto} len = bufLen(encodedReq);
409 
410     \textcolor{comment}{// Allow idx 3 to be decoded out of order}
411     queue->enqueueHeaderBlock(i, std::move(encodedReq), len, &data[i].second,
412                              i == 3);
413     \textcolor{keywordflow}{if} (!queue) \{
414       \textcolor{keywordflow}{break};
415     \}
416   \}
417 \}
\end{DoxyCode}
