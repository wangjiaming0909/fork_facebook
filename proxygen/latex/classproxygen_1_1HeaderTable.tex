\section{proxygen\+:\+:Header\+Table Class Reference}
\label{classproxygen_1_1HeaderTable}\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}


{\ttfamily \#include $<$Header\+Table.\+h$>$}

Inheritance diagram for proxygen\+:\+:Header\+Table\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classproxygen_1_1HeaderTable}
\end{center}
\end{figure}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using {\bf names\+\_\+map} = std\+::unordered\+\_\+map$<$ {\bf H\+P\+A\+C\+K\+Header\+Name}, std\+::list$<$ uint32\+\_\+t $>$$>$
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Header\+Table} (uint32\+\_\+t capacity\+Val)
\item 
virtual {\bf $\sim$\+Header\+Table} ()
\item 
{\bf Header\+Table} (const {\bf Header\+Table} \&)=delete
\item 
{\bf Header\+Table} \& {\bf operator=} (const {\bf Header\+Table} \&)=delete
\item 
virtual bool {\bf add} ({\bf H\+P\+A\+C\+K\+Header} header)
\item 
uint32\+\_\+t {\bf get\+Index} (const {\bf H\+P\+A\+C\+K\+Header} \&header) const 
\item 
const {\bf H\+P\+A\+C\+K\+Header} \& {\bf get\+Header} (uint32\+\_\+t index) const 
\item 
bool {\bf is\+Valid} (uint32\+\_\+t index) const 
\item 
bool {\bf has\+Name} (const {\bf H\+P\+A\+C\+K\+Header\+Name} \&header\+Name)
\item 
const {\bf names\+\_\+map} \& {\bf names} () const 
\item 
uint32\+\_\+t {\bf name\+Index} (const {\bf H\+P\+A\+C\+K\+Header\+Name} \&header\+Name) const 
\item 
uint32\+\_\+t {\bf capacity} () const 
\item 
uint32\+\_\+t {\bf get\+Max\+Table\+Length} (uint32\+\_\+t capacity\+Val) const 
\item 
virtual bool {\bf set\+Capacity} (uint32\+\_\+t {\bf capacity})
\item 
uint32\+\_\+t {\bf size} () const 
\item 
uint32\+\_\+t {\bf bytes} () const 
\item 
size\+\_\+t {\bf length} () const 
\item 
bool {\bf operator==} (const {\bf Header\+Table} \&other) const 
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static uint32\+\_\+t {\bf to\+External} (uint32\+\_\+t head, uint32\+\_\+t {\bf length}, uint32\+\_\+t internal\+Index)
\item 
static uint32\+\_\+t {\bf to\+Internal} (uint32\+\_\+t head, uint32\+\_\+t {\bf length}, uint32\+\_\+t external\+Index)
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
void {\bf init} (uint32\+\_\+t capacity\+Val)
\item 
virtual void {\bf increase\+Table\+Length\+To} (uint32\+\_\+t new\+Length)
\item 
virtual void {\bf resize\+Table} (uint32\+\_\+t new\+Length)
\item 
virtual void {\bf update\+Resized\+Table} (uint32\+\_\+t old\+Tail, uint32\+\_\+t old\+Length, uint32\+\_\+t new\+Length)
\item 
virtual uint32\+\_\+t {\bf remove\+Last} ()
\item 
void {\bf reset} ()
\item 
virtual uint32\+\_\+t {\bf evict} (uint32\+\_\+t needed, uint32\+\_\+t desired\+Capacity)
\item 
uint32\+\_\+t {\bf next} (uint32\+\_\+t i) const 
\item 
uint32\+\_\+t {\bf tail} () const 
\item 
uint32\+\_\+t {\bf to\+External} (uint32\+\_\+t internal\+Index) const 
\item 
uint32\+\_\+t {\bf to\+Internal} (uint32\+\_\+t external\+Index) const 
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
uint32\+\_\+t {\bf capacity\+\_\+} \{0\}
\item 
uint32\+\_\+t {\bf bytes\+\_\+} \{0\}
\item 
std\+::vector$<$ {\bf H\+P\+A\+C\+K\+Header} $>$ {\bf table\+\_\+}
\item 
uint32\+\_\+t {\bf size\+\_\+} \{0\}
\item 
uint32\+\_\+t {\bf head\+\_\+} \{0\}
\item 
{\bf names\+\_\+map} {\bf names\+\_\+}
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
uint32\+\_\+t {\bf get\+Index\+Impl} (const {\bf H\+P\+A\+C\+K\+Header\+Name} \&header, const folly\+::fbstring \&value, bool name\+Only) const 
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Data structure for maintaining indexed headers, based on a fixed-\/length ring with F\+I\+FO semantics. Externally it acts as an array. 

Definition at line 26 of file Header\+Table.\+h.



\subsection{Member Typedef Documentation}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!names\+\_\+map@{names\+\_\+map}}
\index{names\+\_\+map@{names\+\_\+map}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{names\+\_\+map}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::\+Header\+Table\+::names\+\_\+map} =  std\+::unordered\+\_\+map$<${\bf H\+P\+A\+C\+K\+Header\+Name}, std\+::list$<$uint32\+\_\+t$>$$>$}\label{classproxygen_1_1HeaderTable_ad8be16498debba4c9ed68abe694e1d07}


Definition at line 28 of file Header\+Table.\+h.



\subsection{Constructor \& Destructor Documentation}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!Header\+Table@{Header\+Table}}
\index{Header\+Table@{Header\+Table}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{Header\+Table(uint32\+\_\+t capacity\+Val)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+Header\+Table\+::\+Header\+Table (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{capacity\+Val}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}\label{classproxygen_1_1HeaderTable_a8bc6c6f742d93b32494e5bb362b8ee2b}


Definition at line 30 of file Header\+Table.\+h.



References init().



Referenced by $\sim$\+Header\+Table().


\begin{DoxyCode}
30                                              \{
31     init(capacityVal);
32   \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!````~Header\+Table@{$\sim$\+Header\+Table}}
\index{````~Header\+Table@{$\sim$\+Header\+Table}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{$\sim$\+Header\+Table()}]{\setlength{\rightskip}{0pt plus 5cm}virtual proxygen\+::\+Header\+Table\+::$\sim$\+Header\+Table (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HeaderTable_a9b6c9db2b59b6153a0d55f02a9307ba6}


Definition at line 34 of file Header\+Table.\+h.



References add(), get\+Header(), get\+Index(), has\+Name(), Header\+Table(), is\+Valid(), and operator=().


\begin{DoxyCode}
34 \{\}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!Header\+Table@{Header\+Table}}
\index{Header\+Table@{Header\+Table}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{Header\+Table(const Header\+Table \&)=delete}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+Header\+Table\+::\+Header\+Table (
\begin{DoxyParamCaption}
\item[{const {\bf Header\+Table} \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [delete]}}\label{classproxygen_1_1HeaderTable_a0bba6318f35864bf52e4a240c00b72b0}


\subsection{Member Function Documentation}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!add@{add}}
\index{add@{add}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{add(\+H\+P\+A\+C\+K\+Header header)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+Header\+Table\+::add (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Header}}]{header}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\label{classproxygen_1_1HeaderTable_a733f7bd056a003bbbf3e8f8d5ab9fa11}
Add the header entry at the beginning of the table (index=1)

\begin{DoxyReturn}{Returns}
true if it was able to add the entry 
\end{DoxyReturn}


Reimplemented in {\bf proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table} \doxyref{}{p.}{classproxygen_1_1QPACKHeaderTable_a92966263016752609108f97a231e18ca}.



Definition at line 33 of file Header\+Table.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Header\+::bytes(), bytes\+\_\+, capacity\+\_\+, evict(), get\+Max\+Table\+Length(), head\+\_\+, increase\+Table\+Length\+To(), length(), proxygen\+::\+H\+P\+A\+C\+K\+Header\+::name, names\+\_\+, next(), reset(), size\+\_\+, and table\+\_\+.



Referenced by proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::add(), proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+::decode\+Literal\+Header(), proxygen\+::\+H\+P\+A\+C\+K\+Encoder\+::encode\+As\+Literal(), proxygen\+::\+Header\+Table\+Tests\+::resize\+And\+Fill\+Table(), proxygen\+::\+H\+P\+A\+C\+K\+Context\+::seed\+Header\+Table(), proxygen\+::\+Static\+Header\+Table\+::\+Static\+Header\+Table(), proxygen\+::\+T\+E\+S\+T\+\_\+\+F(), and $\sim$\+Header\+Table().


\begin{DoxyCode}
33                                         \{
34   \textcolor{keywordflow}{if} (header.bytes() > capacity_) \{
35     \textcolor{comment}{// Per the RFC spec https://tools.ietf.org/html/rfc7541#page-11, we must}
36     \textcolor{comment}{// flush the underlying table if a request is made for a header that is}
37     \textcolor{comment}{// larger than the current table capacity}
38     reset();
39     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
40   \}
41 
42   \textcolor{comment}{// Make the necessary room in the table if appropriate per RFC spec}
43   \textcolor{keywordflow}{if} ((bytes_ + header.bytes()) > capacity_) \{
44     \textcolor{keywordflow}{if} (evict(header.bytes(), capacity_) == 0) \{
45       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
46     \}
47   \}
48 
49   \textcolor{keywordflow}{if} (size_ == length()) \{
50     increaseTableLengthTo(std::min((uint32\_t)ceil(size_ * 1.5),
51                                    getMaxTableLength(capacity_)));
52   \}
53   head_ = next(head_);
54   \textcolor{comment}{// index name}
55   names_[header.name].push\_back(head_);
56   bytes_ += header.bytes();
57   table_[head_] = std::move(header);
58 
59   ++size_;
60   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
61 \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!bytes@{bytes}}
\index{bytes@{bytes}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{bytes() const }]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+Header\+Table\+::bytes (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HeaderTable_a1f03bce888c80997e8b67ec378cdd723}
\begin{DoxyReturn}{Returns}
size in bytes, the sum of the size of all entries 
\end{DoxyReturn}


Definition at line 112 of file Header\+Table.\+h.



References bytes\+\_\+.



Referenced by proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::add(), proxygen\+::\+Q\+P\+A\+C\+K\+Context\+::get\+Bytes\+Stored(), proxygen\+::\+H\+P\+A\+C\+K\+Context\+::get\+Bytes\+Stored(), proxygen\+::operator$<$$<$(), operator==(), proxygen\+::\+Header\+Table\+Tests\+::resize\+And\+Fill\+Table(), proxygen\+::\+T\+E\+S\+T\+\_\+\+F(), and T\+E\+S\+T\+\_\+\+P().


\begin{DoxyCode}
112                          \{
113     \textcolor{keywordflow}{return} bytes_;
114   \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!capacity@{capacity}}
\index{capacity@{capacity}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{capacity() const }]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+Header\+Table\+::capacity (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HeaderTable_a2d96d2d1f1158954db3bae99a1854dc6}
Table capacity, or maximum number of bytes we can hold. 

Definition at line 86 of file Header\+Table.\+h.



References capacity\+\_\+, get\+Max\+Table\+Length(), and set\+Capacity().



Referenced by proxygen\+::\+H\+P\+A\+C\+K\+Encoder\+::encode(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode(), proxygen\+::\+H\+P\+A\+C\+K\+Encoder\+::encode\+As\+Literal(), proxygen\+::\+Q\+P\+A\+C\+K\+Context\+::get\+Table\+Size(), proxygen\+::\+H\+P\+A\+C\+K\+Context\+::get\+Table\+Size(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::is\+Draining(), proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+Base\+::set\+Header\+Table\+Max\+Size(), proxygen\+::\+H\+P\+A\+C\+K\+Encoder\+Base\+::set\+Header\+Table\+Size(), and proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::should\+Index().


\begin{DoxyCode}
86                             \{
87     \textcolor{keywordflow}{return} capacity_;
88   \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!evict@{evict}}
\index{evict@{evict}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{evict(uint32\+\_\+t needed, uint32\+\_\+t desired\+Capacity)}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+Header\+Table\+::evict (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{needed, }
\item[{uint32\+\_\+t}]{desired\+Capacity}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HeaderTable_a8503522cb62d6f94dc5aff4843e5c322}
Evict entries to make space for the needed amount of bytes. 

Reimplemented in {\bf proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table} \doxyref{}{p.}{classproxygen_1_1QPACKHeaderTable_a7acf709b3c58e89a33d70a409b81c237}.



Definition at line 196 of file Header\+Table.\+cpp.



References bytes\+\_\+, remove\+Last(), and size\+\_\+.



Referenced by add(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::evict(), length(), and set\+Capacity().


\begin{DoxyCode}
196                                                                      \{
197   uint32\_t previousSize = size_;
198   \textcolor{keywordflow}{while} (size_ > 0 && (bytes_ + needed > desiredCapacity)) \{
199     removeLast();
200   \}
201   \textcolor{keywordflow}{return} previousSize - size_;
202 \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!get\+Header@{get\+Header}}
\index{get\+Header@{get\+Header}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{get\+Header(uint32\+\_\+t index) const }]{\setlength{\rightskip}{0pt plus 5cm}const {\bf H\+P\+A\+C\+K\+Header} \& proxygen\+::\+Header\+Table\+::get\+Header (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{index}
\end{DoxyParamCaption}
) const}\label{classproxygen_1_1HeaderTable_a58ec9b8b28bf611947e7c586f9fad48a}
Get the table entry at the given external index.

\begin{DoxyReturn}{Returns}
the header entry 
\end{DoxyReturn}


Definition at line 93 of file Header\+Table.\+cpp.



References is\+Valid(), table\+\_\+, and to\+Internal().



Referenced by proxygen\+::\+Q\+P\+A\+C\+K\+Context\+::get\+Header(), proxygen\+::\+H\+P\+A\+C\+K\+Context\+::get\+Header(), proxygen\+::operator$<$$<$(), proxygen\+::\+T\+E\+S\+T\+\_\+\+F(), and $\sim$\+Header\+Table().


\begin{DoxyCode}
93                                                               \{
94   CHECK(isValid(index));
95   \textcolor{keywordflow}{return} table_[toInternal(index)];
96 \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!get\+Index@{get\+Index}}
\index{get\+Index@{get\+Index}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{get\+Index(const H\+P\+A\+C\+K\+Header \&header) const }]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+Header\+Table\+::get\+Index (
\begin{DoxyParamCaption}
\item[{const {\bf H\+P\+A\+C\+K\+Header} \&}]{header}
\end{DoxyParamCaption}
) const}\label{classproxygen_1_1HeaderTable_ade646871ccfed35b6abcc28c8c8998cc}
Get the index of the given header, if found.

\begin{DoxyReturn}{Returns}
0 in case the header is not found 
\end{DoxyReturn}


Definition at line 63 of file Header\+Table.\+cpp.



References get\+Index\+Impl(), proxygen\+::\+H\+P\+A\+C\+K\+Header\+::name, and proxygen\+::\+H\+P\+A\+C\+K\+Header\+::value.



Referenced by proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode\+Header\+Q(), proxygen\+::\+H\+P\+A\+C\+K\+Context\+::get\+Index(), proxygen\+::\+T\+E\+S\+T\+\_\+\+F(), and $\sim$\+Header\+Table().


\begin{DoxyCode}
63                                                               \{
64   \textcolor{keywordflow}{return} getIndexImpl(header.name, header.value, \textcolor{keyword}{false});
65 \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!get\+Index\+Impl@{get\+Index\+Impl}}
\index{get\+Index\+Impl@{get\+Index\+Impl}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{get\+Index\+Impl(const H\+P\+A\+C\+K\+Header\+Name \&header, const folly\+::fbstring \&value, bool name\+Only) const }]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+Header\+Table\+::get\+Index\+Impl (
\begin{DoxyParamCaption}
\item[{const {\bf H\+P\+A\+C\+K\+Header\+Name} \&}]{header, }
\item[{const folly\+::fbstring \&}]{value, }
\item[{bool}]{name\+Only}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HeaderTable_ab007cf535c28221527d4e446ac8c4e3c}


Definition at line 67 of file Header\+Table.\+cpp.



References names\+\_\+, table\+\_\+, and to\+External().



Referenced by get\+Index(), and name\+Index().


\begin{DoxyCode}
69                                                         \{
70   \textcolor{keyword}{auto} it = names_.find(headerName);
71   \textcolor{keywordflow}{if} (it == names_.end()) \{
72     \textcolor{keywordflow}{return} 0;
73   \}
74   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} indexIt = it->second.rbegin(); indexIt != it->second.rend();
75        ++indexIt) \{
76     \textcolor{keyword}{auto} i = *indexIt;
77     \textcolor{keywordflow}{if} (nameOnly || table_[i].value == value) \{
78       \textcolor{keywordflow}{return} toExternal(i);
79     \}
80   \}
81   \textcolor{keywordflow}{return} 0;
82 \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!get\+Max\+Table\+Length@{get\+Max\+Table\+Length}}
\index{get\+Max\+Table\+Length@{get\+Max\+Table\+Length}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{get\+Max\+Table\+Length(uint32\+\_\+t capacity\+Val) const }]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+Header\+Table\+::get\+Max\+Table\+Length (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{capacity\+Val}
\end{DoxyParamCaption}
) const}\label{classproxygen_1_1HeaderTable_af598a5ba14964459ae073173c5dfcd63}
Returns the maximum table length required to support \doxyref{H\+P\+A\+CK}{p.}{namespaceproxygen_1_1HPACK} headers given the specified capacity bytes 

Definition at line 98 of file Header\+Table.\+cpp.



Referenced by add(), capacity(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::get\+Max\+Entries(), init(), set\+Capacity(), and proxygen\+::\+T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
98                                                                   \{
99   \textcolor{comment}{// At a minimum an entry will take 32 bytes}
100   \textcolor{comment}{// No need to add an extra slot; i.e. a capacity of 32 to 63 bytes can hold}
101   \textcolor{comment}{// at most one entry.}
102   \textcolor{keywordflow}{return} (capacityVal >> 5);
103 \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!has\+Name@{has\+Name}}
\index{has\+Name@{has\+Name}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{has\+Name(const H\+P\+A\+C\+K\+Header\+Name \&header\+Name)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+Header\+Table\+::has\+Name (
\begin{DoxyParamCaption}
\item[{const {\bf H\+P\+A\+C\+K\+Header\+Name} \&}]{header\+Name}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HeaderTable_a280245c11a6653333d5f984159029942}
\begin{DoxyReturn}{Returns}
true if there is at least one header with the given name 
\end{DoxyReturn}


Definition at line 84 of file Header\+Table.\+cpp.



References names\+\_\+.



Referenced by proxygen\+::\+T\+E\+S\+T\+\_\+\+F(), and $\sim$\+Header\+Table().


\begin{DoxyCode}
84                                                            \{
85   \textcolor{keywordflow}{return} names_.find(headerName) != names_.end();
86 \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!increase\+Table\+Length\+To@{increase\+Table\+Length\+To}}
\index{increase\+Table\+Length\+To@{increase\+Table\+Length\+To}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{increase\+Table\+Length\+To(uint32\+\_\+t new\+Length)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Header\+Table\+::increase\+Table\+Length\+To (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{new\+Length}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HeaderTable_af24d57b442441844ac18fbd870eadb8c}


Reimplemented in {\bf proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table} \doxyref{}{p.}{classproxygen_1_1QPACKHeaderTable_a4a34bdab42cd92d5f865fc439243c383}.



Definition at line 159 of file Header\+Table.\+cpp.



References head\+\_\+, length(), names\+\_\+, resize\+Table(), size\+\_\+, tail(), and update\+Resized\+Table().



Referenced by add(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::increase\+Table\+Length\+To(), length(), and set\+Capacity().


\begin{DoxyCode}
159                                                           \{
160   DCHECK\_GE(newLength, length());
161   uint32\_t oldTail = (size_ > 0) ? tail() : 0;
162   \textcolor{keyword}{auto} oldLength = length();
163   resizeTable(newLength);
164 
165   \textcolor{comment}{// TODO: referenence to head here is incompatible with baseIndex}
166   \textcolor{keywordflow}{if} (size_ > 0 && oldTail > head_) \{
167     \textcolor{comment}{// the list wrapped around, need to move oldTail..oldLength to the end}
168     \textcolor{comment}{// of the now-larger table\_}
169     updateResizedTable(oldTail, oldLength, newLength);
170     \textcolor{comment}{// Update the names indecies that pointed to the old range}
171     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}& names\_it: names_) \{
172       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}& idx: names\_it.second) \{
173         \textcolor{keywordflow}{if} (idx >= oldTail) \{
174           DCHECK\_LT(idx + (length() - oldLength), length());
175           idx += (length() - oldLength);
176         \} \textcolor{keywordflow}{else} \{
177           \textcolor{comment}{// remaining indecies in the list were smaller than oldTail, so}
178           \textcolor{comment}{// should be indexed from 0}
179           \textcolor{keywordflow}{break};
180         \}
181       \}
182     \}
183   \}
184 \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!init@{init}}
\index{init@{init}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{init(uint32\+\_\+t capacity\+Val)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Header\+Table\+::init (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{capacity\+Val}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HeaderTable_a1188949acc16a0036530342e1fc4b0e6}
Initialize with a given capacity. 

Definition at line 20 of file Header\+Table.\+cpp.



References bytes\+\_\+, capacity\+\_\+, get\+Max\+Table\+Length(), head\+\_\+, names\+\_\+, size\+\_\+, and table\+\_\+.



Referenced by Header\+Table(), length(), and proxygen\+::\+Static\+Header\+Table\+::\+Static\+Header\+Table().


\begin{DoxyCode}
20                                            \{
21   bytes_ = 0;
22   size_ = 0;
23   head_ = 0;
24   capacity_ = capacityVal;
25   uint32\_t initLength = getMaxTableLength(capacity_) / 2;
26   table_.reserve(initLength);
27   \textcolor{keywordflow}{for} (uint32\_t i = 0; i < initLength; i++) \{
28     table_.emplace\_back();
29   \}
30   names_.clear();
31 \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!is\+Valid@{is\+Valid}}
\index{is\+Valid@{is\+Valid}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{is\+Valid(uint32\+\_\+t index) const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+Header\+Table\+::is\+Valid (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{index}
\end{DoxyParamCaption}
) const}\label{classproxygen_1_1HeaderTable_a11c66735867cf9b3c55d463a36c1c096}
Checks if an external index is valid. 

Definition at line 204 of file Header\+Table.\+cpp.



References proxygen\+::\+E\+R\+R\+OR, and size\+\_\+.



Referenced by get\+Header(), proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+::is\+Valid(), proxygen\+::\+Q\+P\+A\+C\+K\+Decoder\+::is\+Valid(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::is\+Valid(), and $\sim$\+Header\+Table().


\begin{DoxyCode}
204                                               \{
205   \textcolor{keywordtype}{bool} result = \textcolor{keyword}{false};
206   result = 0 < index && index <= size_;
207   \textcolor{keywordflow}{if} (!result) \{
208     LOG(ERROR) << \textcolor{stringliteral}{"Invalid index="} << index << \textcolor{stringliteral}{" size\_="} << size_;
209   \}
210   \textcolor{keywordflow}{return} result;
211 \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!length@{length}}
\index{length@{length}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{length() const }]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+Header\+Table\+::length (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HeaderTable_a2b0bb1caabcc9215221fe6ca265dc021}
\begin{DoxyReturn}{Returns}
how many slots we have in the table 
\end{DoxyReturn}


Definition at line 119 of file Header\+Table.\+h.



References evict(), increase\+Table\+Length\+To(), init(), next(), operator==(), remove\+Last(), reset(), resize\+Table(), table\+\_\+, tail(), to\+External(), to\+Internal(), and update\+Resized\+Table().



Referenced by add(), increase\+Table\+Length\+To(), next(), set\+Capacity(), tail(), proxygen\+::\+T\+E\+S\+T\+\_\+\+F(), to\+External(), and to\+Internal().


\begin{DoxyCode}
119                         \{
120     \textcolor{keywordflow}{return} table_.size();
121   \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!name\+Index@{name\+Index}}
\index{name\+Index@{name\+Index}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{name\+Index(const H\+P\+A\+C\+K\+Header\+Name \&header\+Name) const }]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+Header\+Table\+::name\+Index (
\begin{DoxyParamCaption}
\item[{const {\bf H\+P\+A\+C\+K\+Header\+Name} \&}]{header\+Name}
\end{DoxyParamCaption}
) const}\label{classproxygen_1_1HeaderTable_a3c25e611d22e7a940053acff9dc415f1}
Get any index of a header that has the given name. From all the headers with the given name we pick the last one added to the header table, but the way we pick the header can be arbitrary. 

Definition at line 88 of file Header\+Table.\+cpp.



References get\+Index\+Impl().



Referenced by proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::get\+Name\+Index\+Q(), proxygen\+::\+H\+P\+A\+C\+K\+Context\+::name\+Index(), names(), and proxygen\+::\+T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
88                                                                        \{
89   folly::fbstring value;
90   \textcolor{keywordflow}{return} getIndexImpl(headerName, value, \textcolor{keyword}{true} \textcolor{comment}{/* name only */});
91 \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!names@{names}}
\index{names@{names}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{names() const }]{\setlength{\rightskip}{0pt plus 5cm}const {\bf names\+\_\+map}\& proxygen\+::\+Header\+Table\+::names (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HeaderTable_a9417cd37167fcab5d56821377f677fdd}
\begin{DoxyReturn}{Returns}
the map holding the indexed names 
\end{DoxyReturn}


Definition at line 72 of file Header\+Table.\+h.



References name\+Index(), and names\+\_\+.



Referenced by proxygen\+::\+T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
72                                  \{
73     \textcolor{keywordflow}{return} names_;
74   \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!next@{next}}
\index{next@{next}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{next(uint32\+\_\+t i) const }]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+Header\+Table\+::next (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{i}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HeaderTable_ae3223bb00879ea1f18775f7b6e908f58}
Move the index to the right. 

Definition at line 213 of file Header\+Table.\+cpp.



References length().



Referenced by add(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::can\+Evict(), and length().


\begin{DoxyCode}
213                                            \{
214   \textcolor{keywordflow}{return} (i + 1) % length();
215 \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!operator=@{operator=}}
\index{operator=@{operator=}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{operator=(const Header\+Table \&)=delete}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Header\+Table}\& proxygen\+::\+Header\+Table\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf Header\+Table} \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [delete]}}\label{classproxygen_1_1HeaderTable_a6147e2a152ab1eb5184ef06dcb051ef8}


Referenced by $\sim$\+Header\+Table().

\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!operator==@{operator==}}
\index{operator==@{operator==}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{operator==(const Header\+Table \&other) const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+Header\+Table\+::operator== (
\begin{DoxyParamCaption}
\item[{const {\bf Header\+Table} \&}]{other}
\end{DoxyParamCaption}
) const}\label{classproxygen_1_1HeaderTable_a7509c2e759586894c2c7da83f6eee83d}


Definition at line 244 of file Header\+Table.\+cpp.



References bytes(), and size().



Referenced by length().


\begin{DoxyCode}
244                                                            \{
245   \textcolor{keywordflow}{if} (size() != other.size()) \{
246     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
247   \}
248   \textcolor{keywordflow}{if} (bytes() != other.bytes()) \{
249     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
250   \}
251   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
252 \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!remove\+Last@{remove\+Last}}
\index{remove\+Last@{remove\+Last}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{remove\+Last()}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+Header\+Table\+::remove\+Last (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HeaderTable_a04e79a9372362641082e61130c3e8dbb}
Removes one header entry from the beginning of the header table.

Returns the size of the removed header 

Reimplemented in {\bf proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table} \doxyref{}{p.}{classproxygen_1_1QPACKHeaderTable_aea7ebea22434b56fc18a77f972e4718a}.



Definition at line 105 of file Header\+Table.\+cpp.



References bytes\+\_\+, name, names\+\_\+, size\+\_\+, table\+\_\+, and tail().



Referenced by evict(), length(), and proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::remove\+Last().


\begin{DoxyCode}
105                                  \{
106   \textcolor{keyword}{auto} t = tail();
107   \textcolor{comment}{// remove the first element from the names index}
108   \textcolor{keyword}{auto} names\_it = names_.find(table_[t].name);
109   DCHECK(names\_it != names_.end());
110   \textcolor{keyword}{auto} &ilist = names\_it->second;
111   DCHECK\_EQ(ilist.front(), t);
112   ilist.pop\_front();
113 
114   \textcolor{comment}{// remove the name if there are no indices associated with it}
115   \textcolor{keywordflow}{if} (ilist.empty()) \{
116     names_.erase(names\_it);
117   \}
118   \textcolor{keyword}{const} \textcolor{keyword}{auto}& header = table_[t];
119   uint32\_t headerBytes = header.bytes();
120   bytes_ -= headerBytes;
121   VLOG(10) << \textcolor{stringliteral}{"Removing local idx="} << t << \textcolor{stringliteral}{" name="} << header.name
122            << \textcolor{stringliteral}{" value="} << header.value;
123   --size_;
124   \textcolor{keywordflow}{return} headerBytes;
125 \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!reset@{reset}}
\index{reset@{reset}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{reset()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Header\+Table\+::reset (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HeaderTable_acc85b5135059165f984a4c9eed8b810a}
Empties the underlying header table 

Definition at line 127 of file Header\+Table.\+cpp.



References bytes\+\_\+, names\+\_\+, and size\+\_\+.



Referenced by add(), and length().


\begin{DoxyCode}
127                         \{
128   names_.clear();
129 
130   bytes_ = 0;
131   size_ = 0;
132 
133   \textcolor{comment}{// Capacity remains unchanged and for now we leave head\_ index the same}
134 \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!resize\+Table@{resize\+Table}}
\index{resize\+Table@{resize\+Table}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{resize\+Table(uint32\+\_\+t new\+Length)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Header\+Table\+::resize\+Table (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{new\+Length}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HeaderTable_a5f6febb1d6eb8b091fa3e601a5a96f72}


Reimplemented in {\bf proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table} \doxyref{}{p.}{classproxygen_1_1QPACKHeaderTable_aa061b4f5265f968c081aca198615347e}.



Definition at line 186 of file Header\+Table.\+cpp.



References table\+\_\+.



Referenced by increase\+Table\+Length\+To(), length(), and proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::resize\+Table().


\begin{DoxyCode}
186                                                 \{
187   table_.resize(newLength);
188 \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!set\+Capacity@{set\+Capacity}}
\index{set\+Capacity@{set\+Capacity}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{set\+Capacity(uint32\+\_\+t capacity)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+Header\+Table\+::set\+Capacity (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{capacity}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\label{classproxygen_1_1HeaderTable_a20ce3242a2f6a5a77a100f6010db8a47}
Sets the current capacity of the header table, and evicts entries if needed. Returns false if eviction failed. 

Reimplemented in {\bf proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table} \doxyref{}{p.}{classproxygen_1_1QPACKHeaderTable_a8ee51228fbddd7ef548f1be1c2b8950b}.



Definition at line 136 of file Header\+Table.\+cpp.



References bytes\+\_\+, capacity\+\_\+, evict(), get\+Max\+Table\+Length(), increase\+Table\+Length\+To(), and length().



Referenced by capacity(), proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+Base\+::handle\+Table\+Size\+Update(), proxygen\+::\+Header\+Table\+Tests\+::resize\+Table(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::set\+Capacity(), proxygen\+::\+H\+P\+A\+C\+K\+Decoder\+Base\+::set\+Header\+Table\+Max\+Size(), proxygen\+::\+H\+P\+A\+C\+K\+Encoder\+Base\+::set\+Header\+Table\+Size(), and proxygen\+::\+T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
136                                                   \{
137   \textcolor{keywordflow}{if} (newCapacity == capacity_) \{
138     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
139   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (newCapacity < capacity_) \{
140     \textcolor{comment}{// NOTE: currently no actual resizing is performed...}
141     evict(0, newCapacity);
142     \textcolor{keywordflow}{if} (bytes_ > newCapacity) \{
143       \textcolor{comment}{// eviction failed!}
144       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
145     \}
146   \} \textcolor{keywordflow}{else} \{
147     \textcolor{comment}{// NOTE: due to the above lack of resizing, we must determine whether a}
148     \textcolor{comment}{// resize is actually appropriate (to handle cases where the underlying}
149     \textcolor{comment}{// vector is still >= to the size related to the new capacity requested)}
150     uint32\_t newLength = getMaxTableLength(newCapacity) / 2;
151     \textcolor{keywordflow}{if} (newLength > length()) \{
152       increaseTableLengthTo(newLength);
153     \}
154   \}
155   capacity_ = newCapacity;
156   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
157 \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!size@{size}}
\index{size@{size}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{size() const }]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+Header\+Table\+::size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HeaderTable_a8579a331163c2701e084d9506175ead9}
\begin{DoxyReturn}{Returns}
number of valid entries 
\end{DoxyReturn}


Definition at line 105 of file Header\+Table.\+h.



References size\+\_\+.



Referenced by proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::can\+Evict(), proxygen\+::\+H\+P\+A\+C\+K\+Context\+::dynamic\+To\+Global\+Index(), proxygen\+::\+Q\+P\+A\+C\+K\+Context\+::get\+Headers\+Stored(), proxygen\+::\+H\+P\+A\+C\+K\+Context\+::get\+Headers\+Stored(), proxygen\+::\+H\+P\+A\+C\+K\+Context\+::global\+To\+Dynamic\+Index(), proxygen\+::\+H\+P\+A\+C\+K\+Context\+::is\+Static(), proxygen\+::operator$<$$<$(), operator==(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::remove\+Last(), proxygen\+::\+Header\+Table\+Tests\+::resize\+And\+Fill\+Table(), proxygen\+::\+Header\+Table\+Tests\+::resize\+Table(), proxygen\+::\+Static\+Header\+Table\+::\+Static\+Header\+Table(), T\+E\+S\+T\+\_\+\+F(), proxygen\+::\+T\+E\+S\+T\+\_\+\+F(), and T\+E\+S\+T\+\_\+\+P().


\begin{DoxyCode}
105                         \{
106     \textcolor{keywordflow}{return} size_;
107   \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!tail@{tail}}
\index{tail@{tail}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{tail() const }]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+Header\+Table\+::tail (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HeaderTable_a356dde60cbd9b58f37320f968de97a86}
Get the index of the tail element of the table. 

Definition at line 217 of file Header\+Table.\+cpp.



References head\+\_\+, length(), and size\+\_\+.



Referenced by proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::can\+Evict(), increase\+Table\+Length\+To(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::increase\+Table\+Length\+To(), length(), remove\+Last(), and proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::remove\+Last().


\begin{DoxyCode}
217                                  \{
218   \textcolor{comment}{// tail is private, and only called in the encoder, where head\_ is always}
219   \textcolor{comment}{// valid}
220   DCHECK\_GT(size_, 0) << \textcolor{stringliteral}{"tail() undefined"};
221   \textcolor{keywordflow}{return} (head_ + length() - size_ + 1) % length();
222 \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!to\+External@{to\+External}}
\index{to\+External@{to\+External}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{to\+External(uint32\+\_\+t head, uint32\+\_\+t length, uint32\+\_\+t internal\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+Header\+Table\+::to\+External (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{head, }
\item[{uint32\+\_\+t}]{length, }
\item[{uint32\+\_\+t}]{internal\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classproxygen_1_1HeaderTable_ae79a881ef83bb8ddc7cc99e644f3288f}
Static versions of the methods that translate indices. 

Definition at line 228 of file Header\+Table.\+cpp.



Referenced by proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::get\+Index\+Impl(), get\+Index\+Impl(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::internal\+To\+Absolute(), length(), and to\+External().


\begin{DoxyCode}
229                                                          \{
230   \textcolor{keywordflow}{return} ((head + length - internalIndex) % length) + 1;
231 \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!to\+External@{to\+External}}
\index{to\+External@{to\+External}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{to\+External(uint32\+\_\+t internal\+Index) const }]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+Header\+Table\+::to\+External (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{internal\+Index}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HeaderTable_a8592bc2dde3c98b331a4a8826465b6ca}
Translate internal index to external one, including a static version. 

Definition at line 224 of file Header\+Table.\+cpp.



References head\+\_\+, length(), and to\+External().


\begin{DoxyCode}
224                                                              \{
225   \textcolor{keywordflow}{return} toExternal(head_, length(), internalIndex);
226 \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!to\+Internal@{to\+Internal}}
\index{to\+Internal@{to\+Internal}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{to\+Internal(uint32\+\_\+t head, uint32\+\_\+t length, uint32\+\_\+t external\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+Header\+Table\+::to\+Internal (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{head, }
\item[{uint32\+\_\+t}]{length, }
\item[{uint32\+\_\+t}]{external\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classproxygen_1_1HeaderTable_a5d0329b1762816819a8f8e59cf023b3c}


Definition at line 237 of file Header\+Table.\+cpp.



References length().



Referenced by get\+Header(), length(), to\+Internal(), and proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::to\+Internal().


\begin{DoxyCode}
238                                                          \{
239   \textcolor{comment}{// remove the offset}
240   --externalIndex;
241   \textcolor{keywordflow}{return} (head + length - externalIndex) % length;
242 \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!to\+Internal@{to\+Internal}}
\index{to\+Internal@{to\+Internal}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{to\+Internal(uint32\+\_\+t external\+Index) const }]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+Header\+Table\+::to\+Internal (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{external\+Index}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HeaderTable_a7ad33913fe72ed6ebba17df9635b4fb8}
Translate external index to internal one. 

Definition at line 233 of file Header\+Table.\+cpp.



References head\+\_\+, length(), and to\+Internal().


\begin{DoxyCode}
233                                                              \{
234   \textcolor{keywordflow}{return} toInternal(head_, length(), externalIndex);
235 \}
\end{DoxyCode}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!update\+Resized\+Table@{update\+Resized\+Table}}
\index{update\+Resized\+Table@{update\+Resized\+Table}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{update\+Resized\+Table(uint32\+\_\+t old\+Tail, uint32\+\_\+t old\+Length, uint32\+\_\+t new\+Length)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Header\+Table\+::update\+Resized\+Table (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{old\+Tail, }
\item[{uint32\+\_\+t}]{old\+Length, }
\item[{uint32\+\_\+t}]{new\+Length}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HeaderTable_a766176c1fe1a275f02170cd5847ea520}


Reimplemented in {\bf proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table} \doxyref{}{p.}{classproxygen_1_1QPACKHeaderTable_aadf63828e34b169116a27425f31ba61b}.



Definition at line 190 of file Header\+Table.\+cpp.



References table\+\_\+.



Referenced by increase\+Table\+Length\+To(), length(), and proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::update\+Resized\+Table().


\begin{DoxyCode}
191                                                          \{
192   std::move\_backward(table_.begin() + oldTail, table_.begin() + oldLength,
193                      table_.begin() + newLength);
194 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!bytes\+\_\+@{bytes\+\_\+}}
\index{bytes\+\_\+@{bytes\+\_\+}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{bytes\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+Header\+Table\+::bytes\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HeaderTable_a9b136aaf7d5a76973b2003e91deb4a62}


Definition at line 188 of file Header\+Table.\+h.



Referenced by add(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::add(), bytes(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::can\+Index(), evict(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::evict(), init(), remove\+Last(), reset(), and set\+Capacity().

\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!capacity\+\_\+@{capacity\+\_\+}}
\index{capacity\+\_\+@{capacity\+\_\+}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{capacity\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+Header\+Table\+::capacity\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HeaderTable_a51ae7385ef1baf101c860e8ca607973d}


Definition at line 187 of file Header\+Table.\+h.



Referenced by add(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::add(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::can\+Evict(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::can\+Index(), capacity(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::get\+Max\+Entries(), init(), and set\+Capacity().

\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!head\+\_\+@{head\+\_\+}}
\index{head\+\_\+@{head\+\_\+}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{head\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+Header\+Table\+::head\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HeaderTable_a28433c7d006a61458e4c8a4f780c9a21}


Definition at line 192 of file Header\+Table.\+h.



Referenced by add(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::add(), increase\+Table\+Length\+To(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::increase\+Table\+Length\+To(), init(), tail(), to\+External(), and to\+Internal().

\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!names\+\_\+@{names\+\_\+}}
\index{names\+\_\+@{names\+\_\+}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{names\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf names\+\_\+map} proxygen\+::\+Header\+Table\+::names\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HeaderTable_ab0cf4f76095d8fe357c7df3629353bfc}


Definition at line 194 of file Header\+Table.\+h.



Referenced by add(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::get\+Index\+Impl(), get\+Index\+Impl(), has\+Name(), increase\+Table\+Length\+To(), init(), names(), remove\+Last(), and reset().

\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!size\+\_\+@{size\+\_\+}}
\index{size\+\_\+@{size\+\_\+}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{size\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+Header\+Table\+::size\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HeaderTable_a9de8856182c6ac8c3560cec2cf490794}


Definition at line 191 of file Header\+Table.\+h.



Referenced by add(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::can\+Evict(), evict(), increase\+Table\+Length\+To(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::increase\+Table\+Length\+To(), init(), is\+Valid(), remove\+Last(), reset(), size(), and tail().

\index{proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}!table\+\_\+@{table\+\_\+}}
\index{table\+\_\+@{table\+\_\+}!proxygen\+::\+Header\+Table@{proxygen\+::\+Header\+Table}}
\subsubsection[{table\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<${\bf H\+P\+A\+C\+K\+Header}$>$ proxygen\+::\+Header\+Table\+::table\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HeaderTable_a114c19408859e2aafb37755401709f34}


Definition at line 189 of file Header\+Table.\+h.



Referenced by add(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::add(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::can\+Evict(), get\+Header(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::get\+Header(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::get\+Index\+Impl(), get\+Index\+Impl(), init(), length(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::\+Q\+P\+A\+C\+K\+Header\+Table(), remove\+Last(), resize\+Table(), and update\+Resized\+Table().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
proxygen/lib/http/codec/compress/{\bf Header\+Table.\+h}\item 
proxygen/lib/http/codec/compress/{\bf Header\+Table.\+cpp}\end{DoxyCompactItemize}
