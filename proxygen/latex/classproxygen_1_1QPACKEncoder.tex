\section{proxygen\+:\+:Q\+P\+A\+C\+K\+Encoder Class Reference}
\label{classproxygen_1_1QPACKEncoder}\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}


{\ttfamily \#include $<$Q\+P\+A\+C\+K\+Encoder.\+h$>$}

Inheritance diagram for proxygen\+:\+:Q\+P\+A\+C\+K\+Encoder\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classproxygen_1_1QPACKEncoder}
\end{center}
\end{figure}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct {\bf Encode\+Result}
\item 
struct {\bf Outstanding\+Block}
\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using {\bf Buf} = std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Q\+P\+A\+C\+K\+Encoder} (bool huffman, uint32\+\_\+t table\+Size={\bf H\+P\+A\+C\+K\+::k\+Table\+Size})
\item 
{\bf Encode\+Result} {\bf encode} (const std\+::vector$<$ {\bf H\+P\+A\+C\+K\+Header} $>$ \&headers, uint32\+\_\+t headroom, uint64\+\_\+t stream\+Id, uint32\+\_\+t max\+Encoder\+Stream\+Bytes=std\+::numeric\+\_\+limits$<$ uint32\+\_\+t $>$\+::max())
\item 
{\bf H\+P\+A\+C\+K\+::\+Decode\+Error} {\bf decode\+Decoder\+Stream} (std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ buf)
\item 
{\bf H\+P\+A\+C\+K\+::\+Decode\+Error} {\bf on\+Table\+State\+Sync} (uint32\+\_\+t inserts)
\item 
{\bf H\+P\+A\+C\+K\+::\+Decode\+Error} {\bf on\+Header\+Ack} (uint64\+\_\+t stream\+Id, bool all)
\item 
void {\bf set\+Header\+Table\+Size} (uint32\+\_\+t size)
\item 
void {\bf set\+Max\+Vulnerable} (uint32\+\_\+t max\+Vulnerable)
\item 
void {\bf set\+Min\+Free\+For\+Testing} (uint32\+\_\+t min\+Free)
\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
using {\bf Block\+References} = std\+::set$<$ uint32\+\_\+t $>$
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
bool {\bf allow\+Vulnerable} () const 
\item 
bool {\bf should\+Index} (const {\bf H\+P\+A\+C\+K\+Header} \&header) const 
\item 
void {\bf encode\+Control} (const {\bf H\+P\+A\+C\+K\+Header} \&header)
\item 
std\+::pair$<$ bool, uint32\+\_\+t $>$ {\bf maybe\+Duplicate} (uint32\+\_\+t relative\+Index)
\item 
{\bf Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result} {\bf encodeQ} (const std\+::vector$<$ {\bf H\+P\+A\+C\+K\+Header} $>$ \&headers, uint64\+\_\+t stream\+Id)
\item 
std\+::tuple$<$ bool, uint32\+\_\+t, uint32\+\_\+t $>$ {\bf get\+Name\+IndexQ} (const {\bf H\+P\+A\+C\+K\+Header\+Name} \&header\+Name)
\item 
void {\bf encode\+Stream\+LiteralQ} (const {\bf H\+P\+A\+C\+K\+Header} \&header, bool is\+Static\+Name, uint32\+\_\+t name\+Index, uint32\+\_\+t absolute\+Name\+Index, uint32\+\_\+t base\+Index, uint32\+\_\+t $\ast$largest\+Reference)
\item 
void {\bf encode\+HeaderQ} (const {\bf H\+P\+A\+C\+K\+Header} \&header, uint32\+\_\+t base\+Index, uint32\+\_\+t $\ast$largest\+Reference)
\item 
void {\bf encode\+InsertQ} (const {\bf H\+P\+A\+C\+K\+Header} \&header, bool is\+Static\+Name, uint32\+\_\+t name\+Index)
\item 
void {\bf encode\+LiteralQ} (const {\bf H\+P\+A\+C\+K\+Header} \&header, bool is\+Static\+Name, bool post\+Base, uint32\+\_\+t name\+Index, const {\bf H\+P\+A\+C\+K\+::\+Instruction} \&idx\+Instr)
\item 
uint32\+\_\+t {\bf encode\+Literal\+Q\+Helper} ({\bf H\+P\+A\+C\+K\+Encode\+Buffer} \&buffer, const {\bf H\+P\+A\+C\+K\+Header} \&header, bool is\+Static\+Name, uint32\+\_\+t name\+Index, uint8\+\_\+t static\+Flag, const {\bf H\+P\+A\+C\+K\+::\+Instruction} \&idx\+Instr, const {\bf H\+P\+A\+C\+K\+::\+Instruction} \&lit\+Instr)
\item 
void {\bf track\+Reference} (uint32\+\_\+t index, uint32\+\_\+t $\ast$largest\+Reference)
\item 
void {\bf encode\+Duplicate} (uint32\+\_\+t index)
\item 
{\bf H\+P\+A\+C\+K\+::\+Decode\+Error} {\bf decode\+Header\+Ack} ({\bf H\+P\+A\+C\+K\+Decode\+Buffer} \&dbuf, uint8\+\_\+t prefix\+Length, bool all)
\item 
bool {\bf last\+Entry\+Available} () const 
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
{\bf H\+P\+A\+C\+K\+Encode\+Buffer} {\bf control\+Buffer\+\_\+}
\item 
std\+::unordered\+\_\+map$<$ uint64\+\_\+t, std\+::list$<$ {\bf Outstanding\+Block} $>$ $>$ {\bf outstanding\+\_\+}
\item 
{\bf Outstanding\+Block} $\ast$ {\bf cur\+Outstanding\+\_\+} \{{\bf nullptr}\}
\item 
uint32\+\_\+t {\bf max\+Depends\+\_\+} \{0\}
\item 
uint32\+\_\+t {\bf max\+Vulnerable\+\_\+} \{{\bf H\+P\+A\+C\+K\+::k\+Default\+Blocking}\}
\item 
uint32\+\_\+t {\bf num\+Vulnerable\+\_\+} \{0\}
\item 
int64\+\_\+t {\bf max\+Encoder\+Stream\+Bytes\+\_\+} \{0\}
\item 
folly\+::\+I\+O\+Buf\+Queue {\bf decoder\+Ingress\+\_\+} \{folly\+::\+I\+O\+Buf\+Queue\+::cache\+Chain\+Length()\}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}


Definition at line 25 of file Q\+P\+A\+C\+K\+Encoder.\+h.



\subsection{Member Typedef Documentation}
\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!Block\+References@{Block\+References}}
\index{Block\+References@{Block\+References}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{Block\+References}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Block\+References} =  std\+::set$<$uint32\+\_\+t$>$\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1QPACKEncoder_a4df67ad35809ff47de76fe1ab6ec120b}


Definition at line 131 of file Q\+P\+A\+C\+K\+Encoder.\+h.

\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!Buf@{Buf}}
\index{Buf@{Buf}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{Buf}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Buf} =  std\+::unique\+\_\+ptr$<$folly\+::\+I\+O\+Buf$>$}\label{classproxygen_1_1QPACKEncoder_aee0e179bcc623c186f46fe3adeb2d5a9}
Encode the given headers. 

Definition at line 35 of file Q\+P\+A\+C\+K\+Encoder.\+h.



\subsection{Constructor \& Destructor Documentation}
\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!Q\+P\+A\+C\+K\+Encoder@{Q\+P\+A\+C\+K\+Encoder}}
\index{Q\+P\+A\+C\+K\+Encoder@{Q\+P\+A\+C\+K\+Encoder}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{Q\+P\+A\+C\+K\+Encoder(bool huffman, uint32\+\_\+t table\+Size=\+H\+P\+A\+C\+K\+::k\+Table\+Size)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Q\+P\+A\+C\+K\+Encoder (
\begin{DoxyParamCaption}
\item[{bool}]{huffman, }
\item[{uint32\+\_\+t}]{table\+Size = {\ttfamily {\bf H\+P\+A\+C\+K\+::k\+Table\+Size}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [explicit]}}\label{classproxygen_1_1QPACKEncoder_a65c39545ff1968342de160fb3b0a0253}


Definition at line 17 of file Q\+P\+A\+C\+K\+Encoder.\+cpp.



References proxygen\+::\+Header\+Indexing\+Strategy\+::get\+Default\+Instance(), and proxygen\+::\+H\+P\+A\+C\+K\+Encoder\+Base\+::set\+Header\+Indexing\+Strategy().


\begin{DoxyCode}
17                                                            :
18     \textcolor{comment}{// We only need the 'QPACK' table if we are using base index}
19     HPACKEncoderBase(huffman),
20     QPACKContext(tableSize, \textcolor{keyword}{true}),
21     controlBuffer_(kBufferGrowth, huffman) \{
22   \textcolor{comment}{// Default the encoder indexing strategy; it can be updated later as well}
23   setHeaderIndexingStrategy(HeaderIndexingStrategy::getDefaultInstance());
24 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!allow\+Vulnerable@{allow\+Vulnerable}}
\index{allow\+Vulnerable@{allow\+Vulnerable}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{allow\+Vulnerable() const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::allow\+Vulnerable (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}\label{classproxygen_1_1QPACKEncoder_a5c0136b79b0f104aae20640a3806fd33}


Definition at line 73 of file Q\+P\+A\+C\+K\+Encoder.\+h.



References decode\+Header\+Ack(), encode\+Control(), encode\+Duplicate(), encode\+Header\+Q(), encode\+Insert\+Q(), encode\+Literal\+Q(), encode\+Literal\+Q\+Helper(), encode\+Q(), encode\+Stream\+Literal\+Q(), get\+Name\+Index\+Q(), max\+Vulnerable\+\_\+, maybe\+Duplicate(), num\+Vulnerable\+\_\+, should\+Index(), and track\+Reference().



Referenced by encode\+Header\+Q(), encode\+Q(), encode\+Stream\+Literal\+Q(), get\+Name\+Index\+Q(), and maybe\+Duplicate().


\begin{DoxyCode}
73                                \{
74     \textcolor{keywordflow}{return} numVulnerable_ < maxVulnerable_;
75   \}
\end{DoxyCode}
\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!decode\+Decoder\+Stream@{decode\+Decoder\+Stream}}
\index{decode\+Decoder\+Stream@{decode\+Decoder\+Stream}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{decode\+Decoder\+Stream(std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ buf)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+P\+A\+C\+K\+::\+Decode\+Error} proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::decode\+Decoder\+Stream (
\begin{DoxyParamCaption}
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{buf}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1QPACKEncoder_a958853b86da90a5457fd6da07ba17546}


Definition at line 305 of file Q\+P\+A\+C\+K\+Encoder.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+::\+B\+U\+F\+F\+E\+R\+\_\+\+U\+N\+D\+E\+R\+F\+L\+OW, decode\+Header\+Ack(), decoder\+Ingress\+\_\+, proxygen\+::\+E\+R\+R\+OR, proxygen\+::\+H\+P\+A\+C\+K\+::\+N\+O\+NE, on\+Table\+State\+Sync(), proxygen\+::\+H\+P\+A\+C\+K\+::\+Q\+\_\+\+C\+A\+N\+C\+E\+L\+\_\+\+S\+T\+R\+E\+AM, proxygen\+::\+H\+P\+A\+C\+K\+::\+Q\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+A\+CK, and proxygen\+::\+H\+P\+A\+C\+K\+::\+Q\+\_\+\+T\+A\+B\+L\+E\+\_\+\+S\+T\+A\+T\+E\+\_\+\+S\+Y\+NC.



Referenced by proxygen\+::hpack\+::encode\+Decode(), and T\+E\+S\+T().


\begin{DoxyCode}
306                                    \{
307   decoderIngress_.append(std::move(buf));
308   folly::io::Cursor cursor(decoderIngress_.front());
309   HPACKDecodeBuffer dbuf(cursor, decoderIngress_.chainLength(), 0);
310   HPACK::DecodeError err = HPACK::DecodeError::NONE;
311   uint32\_t consumed = 0;
312   \textcolor{keywordflow}{while} (err == HPACK::DecodeError::NONE && !dbuf.empty()) \{
313     consumed = dbuf.consumedBytes();
314     \textcolor{keyword}{auto} byte = dbuf.peek();
315     \textcolor{keywordflow}{if} (byte & HPACK::Q_HEADER_ACK.code) \{
316       err = decodeHeaderAck(dbuf, HPACK::Q_HEADER_ACK.prefixLength, \textcolor{keyword}{false});
317     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (byte & HPACK::Q_CANCEL_STREAM.code) \{
318       err = decodeHeaderAck(dbuf, HPACK::Q_CANCEL_STREAM.prefixLength, \textcolor{keyword}{true});
319     \} \textcolor{keywordflow}{else} \{ \textcolor{comment}{// TABLE\_STATE\_SYNC}
320       uint64\_t inserts = 0;
321       err = dbuf.decodeInteger(HPACK::Q_TABLE_STATE_SYNC.prefixLength, inserts);
322       \textcolor{keywordflow}{if} (err == HPACK::DecodeError::NONE) \{
323         err = onTableStateSync(inserts);
324       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (err != HPACK::DecodeError::BUFFER_UNDERFLOW) \{
325         LOG(ERROR) << \textcolor{stringliteral}{"Failed to decode num inserts, err="} << err;
326       \}
327     \}
328   \} \textcolor{comment}{// while}
329   \textcolor{keywordflow}{if} (err == HPACK::DecodeError::BUFFER_UNDERFLOW) \{
330     err = HPACK::DecodeError::NONE;
331     decoderIngress_.trimStart(consumed);
332   \} \textcolor{keywordflow}{else} \{
333     decoderIngress_.trimStart(dbuf.consumedBytes());
334   \}
335   \textcolor{keywordflow}{return} err;
336 \}
\end{DoxyCode}
\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!decode\+Header\+Ack@{decode\+Header\+Ack}}
\index{decode\+Header\+Ack@{decode\+Header\+Ack}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{decode\+Header\+Ack(\+H\+P\+A\+C\+K\+Decode\+Buffer \&dbuf, uint8\+\_\+t prefix\+Length, bool all)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+P\+A\+C\+K\+::\+Decode\+Error} proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::decode\+Header\+Ack (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Decode\+Buffer} \&}]{dbuf, }
\item[{uint8\+\_\+t}]{prefix\+Length, }
\item[{bool}]{all}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1QPACKEncoder_a1bf17031c379a37462fbbd48c31267ef}


Definition at line 338 of file Q\+P\+A\+C\+K\+Encoder.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+::\+B\+U\+F\+F\+E\+R\+\_\+\+U\+N\+D\+E\+R\+F\+L\+OW, proxygen\+::\+H\+P\+A\+C\+K\+Decode\+Buffer\+::decode\+Integer(), proxygen\+::\+E\+R\+R\+OR, proxygen\+::\+H\+P\+A\+C\+K\+::\+N\+O\+NE, and on\+Header\+Ack().



Referenced by allow\+Vulnerable(), and decode\+Decoder\+Stream().


\begin{DoxyCode}
340                                                            \{
341   uint64\_t streamId = 0;
342   \textcolor{keyword}{auto} err = dbuf.decodeInteger(prefixLength, streamId);
343   \textcolor{keywordflow}{if} (err == HPACK::DecodeError::NONE) \{
344     err = onHeaderAck(streamId, all);
345   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (err != HPACK::DecodeError::BUFFER_UNDERFLOW) \{
346     LOG(ERROR) << \textcolor{stringliteral}{"Failed to decode streamId, err="} << err;
347   \}
348   \textcolor{keywordflow}{return} err;
349 \}
\end{DoxyCode}
\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!encode@{encode}}
\index{encode@{encode}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{encode(const std\+::vector$<$ H\+P\+A\+C\+K\+Header $>$ \&headers, uint32\+\_\+t headroom, uint64\+\_\+t stream\+Id, uint32\+\_\+t max\+Encoder\+Stream\+Bytes=std\+::numeric\+\_\+limits$<$ uint32\+\_\+t $>$\+::max())}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result} proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ {\bf H\+P\+A\+C\+K\+Header} $>$ \&}]{headers, }
\item[{uint32\+\_\+t}]{headroom, }
\item[{uint64\+\_\+t}]{stream\+Id, }
\item[{uint32\+\_\+t}]{max\+Encoder\+Stream\+Bytes = {\ttfamily std\+:\+:numeric\+\_\+limits$<$uint32\+\_\+t$>$\+:\+:max()}}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1QPACKEncoder_a6b6425a592f87ab9e5e59d7184bb714f}


Definition at line 27 of file Q\+P\+A\+C\+K\+Encoder.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Encode\+Buffer\+::add\+Headroom(), proxygen\+::\+Header\+Table\+::capacity(), control\+Buffer\+\_\+, encode\+Q(), proxygen\+::\+H\+P\+A\+C\+K\+Encoder\+Base\+::handle\+Pending\+Context\+Update(), max\+Encoder\+Stream\+Bytes\+\_\+, proxygen\+::\+H\+P\+A\+C\+K\+Encoder\+Base\+::stream\+Buffer\+\_\+, and proxygen\+::\+Q\+P\+A\+C\+K\+Context\+::table\+\_\+.



Referenced by proxygen\+::\+Q\+P\+A\+C\+K\+Codec\+::encode(), proxygen\+::hpack\+::encode\+Decode(), and T\+E\+S\+T().


\begin{DoxyCode}
30                                                      \{
31   \textcolor{keywordflow}{if} (headroom) \{
32     streamBuffer_.addHeadroom(headroom);
33   \}
34   maxEncoderStreamBytes_ = maxEncoderStreamBytes;
35   maxEncoderStreamBytes_ -=
36     handlePendingContextUpdate(controlBuffer_, table_.capacity());
37   \textcolor{keywordflow}{return} encodeQ(headers, streamId);
38 \}
\end{DoxyCode}
\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!encode\+Control@{encode\+Control}}
\index{encode\+Control@{encode\+Control}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{encode\+Control(const H\+P\+A\+C\+K\+Header \&header)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode\+Control (
\begin{DoxyParamCaption}
\item[{const {\bf H\+P\+A\+C\+K\+Header} \&}]{header}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1QPACKEncoder_af2c100529681d495c80dd55bfa791cc2}


Referenced by allow\+Vulnerable().

\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!encode\+Duplicate@{encode\+Duplicate}}
\index{encode\+Duplicate@{encode\+Duplicate}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{encode\+Duplicate(uint32\+\_\+t index)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode\+Duplicate (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1QPACKEncoder_a72da3077bc31c37fb056bbe1078be518}


Definition at line 249 of file Q\+P\+A\+C\+K\+Encoder.\+cpp.



References control\+Buffer\+\_\+, proxygen\+::\+H\+P\+A\+C\+K\+Encode\+Buffer\+::encode\+Integer(), max\+Encoder\+Stream\+Bytes\+\_\+, and proxygen\+::\+H\+P\+A\+C\+K\+::\+Q\+\_\+\+D\+U\+P\+L\+I\+C\+A\+TE.



Referenced by allow\+Vulnerable(), and maybe\+Duplicate().


\begin{DoxyCode}
249                                                  \{
250   DCHECK\_GT(index, 0);
251   maxEncoderStreamBytes_ -=
252     controlBuffer_.encodeInteger(index - 1, HPACK::Q_DUPLICATE);
253 \}
\end{DoxyCode}
\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!encode\+HeaderQ@{encode\+HeaderQ}}
\index{encode\+HeaderQ@{encode\+HeaderQ}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{encode\+Header\+Q(const H\+P\+A\+C\+K\+Header \&header, uint32\+\_\+t base\+Index, uint32\+\_\+t $\ast$largest\+Reference)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode\+HeaderQ (
\begin{DoxyParamCaption}
\item[{const {\bf H\+P\+A\+C\+K\+Header} \&}]{header, }
\item[{uint32\+\_\+t}]{base\+Index, }
\item[{uint32\+\_\+t $\ast$}]{largest\+Reference}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1QPACKEncoder_abbf47768a45d3f7d238a073253cba75c}


Definition at line 91 of file Q\+P\+A\+C\+K\+Encoder.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::absolute\+To\+Relative(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::add(), allow\+Vulnerable(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::can\+Index(), proxygen\+::\+H\+P\+A\+C\+K\+Header\+::copy(), encode\+Insert\+Q(), proxygen\+::\+H\+P\+A\+C\+K\+Encode\+Buffer\+::encode\+Integer(), encode\+Stream\+Literal\+Q(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::get\+Base\+Index(), proxygen\+::\+Header\+Table\+::get\+Index(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::get\+Index(), get\+Name\+Index\+Q(), proxygen\+::\+Q\+P\+A\+C\+K\+Context\+::get\+Static\+Table(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::is\+Valid(), last\+Entry\+Available(), max\+Encoder\+Stream\+Bytes\+\_\+, maybe\+Duplicate(), proxygen\+::\+H\+P\+A\+C\+K\+Header\+::name, proxygen\+::\+H\+P\+A\+C\+K\+::\+Q\+\_\+\+I\+N\+D\+E\+X\+ED, proxygen\+::\+H\+P\+A\+C\+K\+::\+Q\+\_\+\+I\+N\+D\+E\+X\+E\+D\+\_\+\+P\+O\+ST, proxygen\+::\+H\+P\+A\+C\+K\+::\+Q\+\_\+\+I\+N\+D\+E\+X\+E\+D\+\_\+\+S\+T\+A\+T\+IC, should\+Index(), proxygen\+::\+H\+P\+A\+C\+K\+Encoder\+Base\+::stream\+Buffer\+\_\+, proxygen\+::\+Q\+P\+A\+C\+K\+Context\+::table\+\_\+, track\+Reference(), and proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::\+U\+N\+A\+C\+K\+ED.



Referenced by allow\+Vulnerable(), and encode\+Q().


\begin{DoxyCode}
92                                                                              \{
93   uint32\_t index = getStaticTable().getIndex(header);
94   \textcolor{keywordflow}{if} (index > 0) \{
95     \textcolor{comment}{// static reference}
96     streamBuffer_.encodeInteger(index - 1,
97                                 HPACK::Q_INDEXED.code | HPACK::Q_INDEXED_STATIC,
98                                 HPACK::Q_INDEXED.prefixLength);
99     \textcolor{keywordflow}{return};
100   \}
101 
102   \textcolor{keywordtype}{bool} indexable = shouldIndex(header);
103   \textcolor{keywordflow}{if} (indexable) \{
104     index = table_.getIndex(header, allowVulnerable());
105     \textcolor{keywordflow}{if} (index == QPACKHeaderTable::UNACKED) \{
106       index = 0;
107       indexable = \textcolor{keyword}{false};
108     \}
109   \}
110   \textcolor{keywordflow}{if} (index != 0) \{
111     \textcolor{comment}{// dynamic reference}
112     \textcolor{keywordtype}{bool} duplicated = \textcolor{keyword}{false};
113     std::tie(duplicated, index) = maybeDuplicate(index);
114     \textcolor{comment}{// index is now 0 or absolute}
115     indexable &= (duplicated && index == 0);
116   \}
117   \textcolor{keywordflow}{if} (index == 0) \{
118     \textcolor{comment}{// No valid entry matching header, see if there's a matching name}
119     uint32\_t nameIndex = 0;
120     uint32\_t absoluteNameIndex = 0;
121     \textcolor{keywordtype}{bool} isStaticName = \textcolor{keyword}{false};
122     std::tie(isStaticName, nameIndex, absoluteNameIndex) =
123       getNameIndexQ(header.name);
124 
125     \textcolor{comment}{// Now check if we should emit an insertion on the control stream}
126     \textcolor{comment}{// Don't try to index if we're out of encoder flow control}
127     indexable &= maxEncoderStreamBytes_ > 0;
128     \textcolor{keywordflow}{if} (indexable && table_.canIndex(header)) \{
129       encodeInsertQ(header, isStaticName, nameIndex);
130       CHECK(table_.add(header.copy()));
131       \textcolor{keywordflow}{if} (allowVulnerable() && lastEntryAvailable()) \{
132         index = table_.getBaseIndex();
133       \} \textcolor{keywordflow}{else} \{
134         index = 0;
135         \textcolor{keywordflow}{if} (absoluteNameIndex > 0 &&
136             !table_.isValid(table_.absoluteToRelative(absoluteNameIndex))) \{
137           \textcolor{comment}{// The insert may have invalidated the name index.}
138           isStaticName = \textcolor{keyword}{true};
139           nameIndex = 0;
140           absoluteNameIndex = 0;
141         \}
142       \}
143     \}
144 
145     \textcolor{keywordflow}{if} (index == 0) \{
146       \textcolor{comment}{// Couldn't insert it: table full, not indexable, or table contains}
147       \textcolor{comment}{// vulnerable reference.  Encode a literal on the request stream.}
148       encodeStreamLiteralQ(header, isStaticName, nameIndex, absoluteNameIndex,
149                            baseIndex, largestReference);
150       \textcolor{keywordflow}{return};
151     \}
152   \}
153 
154   \textcolor{comment}{// Encoding a dynamic index reference}
155   DCHECK\_NE(index, 0);
156   trackReference(index, largestReference);
157   \textcolor{keywordflow}{if} (index > baseIndex) \{
158     streamBuffer_.encodeInteger(index - baseIndex - 1, HPACK::Q_INDEXED_POST);
159   \} \textcolor{keywordflow}{else} \{
160     streamBuffer_.encodeInteger(baseIndex - index, HPACK::Q_INDEXED);
161   \}
162 \}
\end{DoxyCode}
\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!encode\+InsertQ@{encode\+InsertQ}}
\index{encode\+InsertQ@{encode\+InsertQ}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{encode\+Insert\+Q(const H\+P\+A\+C\+K\+Header \&header, bool is\+Static\+Name, uint32\+\_\+t name\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode\+InsertQ (
\begin{DoxyParamCaption}
\item[{const {\bf H\+P\+A\+C\+K\+Header} \&}]{header, }
\item[{bool}]{is\+Static\+Name, }
\item[{uint32\+\_\+t}]{name\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1QPACKEncoder_a0465f6682bbcf44cd8774a68f2024108}


Definition at line 255 of file Q\+P\+A\+C\+K\+Encoder.\+cpp.



References control\+Buffer\+\_\+, encode\+Literal\+Q\+Helper(), max\+Encoder\+Stream\+Bytes\+\_\+, proxygen\+::\+H\+P\+A\+C\+K\+::\+Q\+\_\+\+I\+N\+S\+E\+R\+T\+\_\+\+N\+A\+M\+E\+\_\+\+R\+EF, proxygen\+::\+H\+P\+A\+C\+K\+::\+Q\+\_\+\+I\+N\+S\+E\+R\+T\+\_\+\+N\+A\+M\+E\+\_\+\+R\+E\+F\+\_\+\+S\+T\+A\+T\+IC, and proxygen\+::\+H\+P\+A\+C\+K\+::\+Q\+\_\+\+I\+N\+S\+E\+R\+T\+\_\+\+N\+O\+\_\+\+N\+A\+M\+E\+\_\+\+R\+EF.



Referenced by allow\+Vulnerable(), and encode\+Header\+Q().


\begin{DoxyCode}
257                                                      \{
258   \textcolor{keyword}{auto} encoded = encodeLiteralQHelper(
259       controlBuffer_, header, isStaticName, nameIndex,
260       HPACK::Q_INSERT_NAME_REF_STATIC, HPACK::Q_INSERT_NAME_REF,
261       HPACK::Q_INSERT_NO_NAME_REF);
262   maxEncoderStreamBytes_ -= encoded;
263 \}
\end{DoxyCode}
\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!encode\+LiteralQ@{encode\+LiteralQ}}
\index{encode\+LiteralQ@{encode\+LiteralQ}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{encode\+Literal\+Q(const H\+P\+A\+C\+K\+Header \&header, bool is\+Static\+Name, bool post\+Base, uint32\+\_\+t name\+Index, const H\+P\+A\+C\+K\+::\+Instruction \&idx\+Instr)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode\+LiteralQ (
\begin{DoxyParamCaption}
\item[{const {\bf H\+P\+A\+C\+K\+Header} \&}]{header, }
\item[{bool}]{is\+Static\+Name, }
\item[{bool}]{post\+Base, }
\item[{uint32\+\_\+t}]{name\+Index, }
\item[{const {\bf H\+P\+A\+C\+K\+::\+Instruction} \&}]{idx\+Instr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1QPACKEncoder_ace265a8f9b6237a973c620675f214458}


Definition at line 265 of file Q\+P\+A\+C\+K\+Encoder.\+cpp.



References encode\+Literal\+Q\+Helper(), proxygen\+::\+H\+P\+A\+C\+K\+::\+Q\+\_\+\+L\+I\+T\+E\+R\+AL, proxygen\+::\+H\+P\+A\+C\+K\+::\+Q\+\_\+\+L\+I\+T\+E\+R\+A\+L\+\_\+\+S\+T\+A\+T\+IC, and proxygen\+::\+H\+P\+A\+C\+K\+Encoder\+Base\+::stream\+Buffer\+\_\+.



Referenced by allow\+Vulnerable(), and encode\+Stream\+Literal\+Q().


\begin{DoxyCode}
269                                                                     \{
270   DCHECK(!isStaticName || !postBase);
271   encodeLiteralQHelper(
272       streamBuffer_, header, isStaticName, nameIndex,
273       HPACK::Q_LITERAL_STATIC, idxInstr,
274       HPACK::Q_LITERAL);
275 \}
\end{DoxyCode}
\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!encode\+Literal\+Q\+Helper@{encode\+Literal\+Q\+Helper}}
\index{encode\+Literal\+Q\+Helper@{encode\+Literal\+Q\+Helper}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{encode\+Literal\+Q\+Helper(\+H\+P\+A\+C\+K\+Encode\+Buffer \&buffer, const H\+P\+A\+C\+K\+Header \&header, bool is\+Static\+Name, uint32\+\_\+t name\+Index, uint8\+\_\+t static\+Flag, const H\+P\+A\+C\+K\+::\+Instruction \&idx\+Instr, const H\+P\+A\+C\+K\+::\+Instruction \&lit\+Instr)}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode\+Literal\+Q\+Helper (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+Encode\+Buffer} \&}]{buffer, }
\item[{const {\bf H\+P\+A\+C\+K\+Header} \&}]{header, }
\item[{bool}]{is\+Static\+Name, }
\item[{uint32\+\_\+t}]{name\+Index, }
\item[{uint8\+\_\+t}]{static\+Flag, }
\item[{const {\bf H\+P\+A\+C\+K\+::\+Instruction} \&}]{idx\+Instr, }
\item[{const {\bf H\+P\+A\+C\+K\+::\+Instruction} \&}]{lit\+Instr}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1QPACKEncoder_a5c3671c3c6ee5742e9f8f9082d753754}


Definition at line 277 of file Q\+P\+A\+C\+K\+Encoder.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+::\+Instruction\+::code, proxygen\+::\+H\+P\+A\+C\+K\+Encode\+Buffer\+::encode\+Integer(), proxygen\+::\+H\+P\+A\+C\+K\+Encode\+Buffer\+::encode\+Literal(), proxygen\+::\+H\+P\+A\+C\+K\+Header\+Name\+::get(), proxygen\+::\+H\+P\+A\+C\+K\+Header\+::name, proxygen\+::\+H\+P\+A\+C\+K\+::\+Instruction\+::prefix\+Length, proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::\+U\+N\+A\+C\+K\+ED, and proxygen\+::\+H\+P\+A\+C\+K\+Header\+::value.



Referenced by allow\+Vulnerable(), encode\+Insert\+Q(), and encode\+Literal\+Q().


\begin{DoxyCode}
284                                       \{
285   uint32\_t encoded = 0;
286   \textcolor{comment}{// name}
287   \textcolor{keywordflow}{if} (nameIndex) \{
288     VLOG(10) << \textcolor{stringliteral}{"encoding name index="} << nameIndex;
289     DCHECK\_NE(nameIndex, QPACKHeaderTable::UNACKED);
290     nameIndex -= 1; \textcolor{comment}{// we already know it's not 0}
291     uint8\_t byte = idxInstr.code;
292     \textcolor{keywordflow}{if} (isStaticName) \{
293       byte |= staticFlag;
294     \}
295     encoded += buffer.encodeInteger(nameIndex, byte, idxInstr.prefixLength);
296   \} \textcolor{keywordflow}{else} \{
297     encoded += buffer.encodeLiteral(litInstr.code, litInstr.prefixLength,
298                                     header.name.get());
299   \}
300   \textcolor{comment}{// value}
301   encoded += buffer.encodeLiteral(header.value);
302   \textcolor{keywordflow}{return} encoded;
303 \}
\end{DoxyCode}
\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!encodeQ@{encodeQ}}
\index{encodeQ@{encodeQ}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{encode\+Q(const std\+::vector$<$ H\+P\+A\+C\+K\+Header $>$ \&headers, uint64\+\_\+t stream\+Id)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Q\+P\+A\+C\+K\+Encoder\+::\+Encode\+Result} proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encodeQ (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ {\bf H\+P\+A\+C\+K\+Header} $>$ \&}]{headers, }
\item[{uint64\+\_\+t}]{stream\+Id}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1QPACKEncoder_a115c9467afdf19f3ce43f6389473e086}


Definition at line 41 of file Q\+P\+A\+C\+K\+Encoder.\+cpp.



References allow\+Vulnerable(), control\+Buffer\+\_\+, cur\+Outstanding\+\_\+, encode\+Header\+Q(), proxygen\+::\+H\+P\+A\+C\+K\+Encode\+Buffer\+::encode\+Integer(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::get\+Base\+Index(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::get\+Max\+Entries(), num\+Vulnerable\+\_\+, outstanding\+\_\+, proxygen\+::\+H\+P\+A\+C\+K\+::\+Q\+\_\+\+D\+E\+L\+T\+A\+\_\+\+B\+A\+SE, proxygen\+::\+H\+P\+A\+C\+K\+::\+Q\+\_\+\+D\+E\+L\+T\+A\+\_\+\+B\+A\+S\+E\+\_\+\+N\+EG, proxygen\+::\+H\+P\+A\+C\+K\+::\+Q\+\_\+\+D\+E\+L\+T\+A\+\_\+\+B\+A\+S\+E\+\_\+\+P\+OS, proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Outstanding\+Block\+::references, proxygen\+::\+H\+P\+A\+C\+K\+Encode\+Buffer\+::release(), proxygen\+::\+H\+P\+A\+C\+K\+Encoder\+Base\+::stream\+Buffer\+\_\+, proxygen\+::\+Q\+P\+A\+C\+K\+Context\+::table\+\_\+, and proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Outstanding\+Block\+::vulnerable.



Referenced by allow\+Vulnerable(), and encode().


\begin{DoxyCode}
41                                                                            \{
42   OutstandingBlock outstandingBlock;
43   \textcolor{comment}{// curOutstanding\_ points to a local stack variable, it's mostly for}
44   \textcolor{comment}{// convenience so other methods invoked from here can access it.}
45   curOutstanding_ = &outstandingBlock;
46   \textcolor{keyword}{auto} baseIndex = table_.getBaseIndex();
47 
48   uint32\_t largestReference = 0;
49   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& header: headers) \{
50     encodeHeaderQ(header, baseIndex, &largestReference);
51   \}
52 
53   \textcolor{keyword}{auto} streamBlock = streamBuffer_.release();
54 
55   \textcolor{comment}{// encode the prefix}
56   \textcolor{keywordflow}{if} (largestReference == 0) \{
57     streamBuffer_.encodeInteger(0); \textcolor{comment}{// LR}
58     streamBuffer_.encodeInteger(0); \textcolor{comment}{// baseIndex}
59   \} \textcolor{keywordflow}{else} \{
60     \textcolor{keyword}{auto} wireLR = (largestReference % (2 * table_.getMaxEntries())) + 1;
61     streamBuffer_.encodeInteger(wireLR);
62     \textcolor{keywordflow}{if} (largestReference > baseIndex) \{
63       streamBuffer_.encodeInteger(largestReference - baseIndex,
64                                   HPACK::Q_DELTA_BASE_NEG,
65                                   HPACK::Q_DELTA_BASE.prefixLength);
66     \} \textcolor{keywordflow}{else} \{
67       streamBuffer_.encodeInteger(baseIndex - largestReference,
68                                   HPACK::Q_DELTA_BASE_POS,
69                                   HPACK::Q_DELTA_BASE.prefixLength);
70     \}
71   \}
72   \textcolor{keyword}{auto} streamBuffer = streamBuffer_.release();
73   streamBuffer->prependChain(std::move(streamBlock));
74 
75   \textcolor{keyword}{auto} controlBuf = controlBuffer_.release();
76   \textcolor{comment}{// curOutstanding\_.references could be empty, if the block encodes only static}
77   \textcolor{comment}{// headers and/or literals.  If so we don't track anything.}
78   \textcolor{keywordflow}{if} (!curOutstanding_->references.empty()) \{
79     \textcolor{keywordflow}{if} (curOutstanding_->vulnerable) \{
80       DCHECK(allowVulnerable());
81       numVulnerable_++;
82     \}
83     outstanding_[streamId].emplace\_back(std::move(outstandingBlock));
84   \}
85   \textcolor{comment}{// Clear the pointer to our stack}
86   curOutstanding_ = \textcolor{keyword}{nullptr};
87 
88   \textcolor{keywordflow}{return} \{ std::move(controlBuf), std::move(streamBuffer) \};
89 \}
\end{DoxyCode}
\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!encode\+Stream\+LiteralQ@{encode\+Stream\+LiteralQ}}
\index{encode\+Stream\+LiteralQ@{encode\+Stream\+LiteralQ}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{encode\+Stream\+Literal\+Q(const H\+P\+A\+C\+K\+Header \&header, bool is\+Static\+Name, uint32\+\_\+t name\+Index, uint32\+\_\+t absolute\+Name\+Index, uint32\+\_\+t base\+Index, uint32\+\_\+t $\ast$largest\+Reference)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::encode\+Stream\+LiteralQ (
\begin{DoxyParamCaption}
\item[{const {\bf H\+P\+A\+C\+K\+Header} \&}]{header, }
\item[{bool}]{is\+Static\+Name, }
\item[{uint32\+\_\+t}]{name\+Index, }
\item[{uint32\+\_\+t}]{absolute\+Name\+Index, }
\item[{uint32\+\_\+t}]{base\+Index, }
\item[{uint32\+\_\+t $\ast$}]{largest\+Reference}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1QPACKEncoder_a640b785577850477f100136595f2aee5}


Definition at line 209 of file Q\+P\+A\+C\+K\+Encoder.\+cpp.



References allow\+Vulnerable(), encode\+Literal\+Q(), proxygen\+::\+H\+P\+A\+C\+K\+::\+Q\+\_\+\+L\+I\+T\+E\+R\+A\+L\+\_\+\+N\+A\+M\+E\+\_\+\+R\+EF, proxygen\+::\+H\+P\+A\+C\+K\+::\+Q\+\_\+\+L\+I\+T\+E\+R\+A\+L\+\_\+\+N\+A\+M\+E\+\_\+\+R\+E\+F\+\_\+\+P\+O\+ST, and track\+Reference().



Referenced by allow\+Vulnerable(), and encode\+Header\+Q().


\begin{DoxyCode}
211                                                                               \{
212   \textcolor{keywordflow}{if} (absoluteNameIndex > 0) \{
213     \textcolor{comment}{// Dynamic name reference, vulnerability checks already done}
214     CHECK(absoluteNameIndex <= baseIndex || allowVulnerable());
215     trackReference(absoluteNameIndex, largestReference);
216   \}
217   \textcolor{keywordflow}{if} (absoluteNameIndex > baseIndex) \{
218     encodeLiteralQ(header,
219                    \textcolor{keyword}{false}, \textcolor{comment}{/* not static */}
220                    \textcolor{keyword}{true}, \textcolor{comment}{/* post base */}
221                    absoluteNameIndex - baseIndex,
222                    HPACK::Q_LITERAL_NAME_REF_POST);
223   \} \textcolor{keywordflow}{else} \{
224     encodeLiteralQ(header,
225                    isStaticName,
226                    \textcolor{keyword}{false}, \textcolor{comment}{/* not post base */}
227                    isStaticName ? nameIndex : baseIndex - absoluteNameIndex + 1,
228                    HPACK::Q_LITERAL_NAME_REF);
229   \}
230 \}
\end{DoxyCode}
\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!get\+Name\+IndexQ@{get\+Name\+IndexQ}}
\index{get\+Name\+IndexQ@{get\+Name\+IndexQ}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{get\+Name\+Index\+Q(const H\+P\+A\+C\+K\+Header\+Name \&header\+Name)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::tuple$<$ bool, uint32\+\_\+t, uint32\+\_\+t $>$ proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::get\+Name\+IndexQ (
\begin{DoxyParamCaption}
\item[{const {\bf H\+P\+A\+C\+K\+Header\+Name} \&}]{header\+Name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1QPACKEncoder_a2a425f36602356c05ca3543a48c02d24}


Definition at line 186 of file Q\+P\+A\+C\+K\+Encoder.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::absolute\+To\+Relative(), allow\+Vulnerable(), proxygen\+::\+Q\+P\+A\+C\+K\+Context\+::get\+Static\+Table(), maybe\+Duplicate(), proxygen\+::\+Header\+Table\+::name\+Index(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::name\+Index(), and proxygen\+::\+Q\+P\+A\+C\+K\+Context\+::table\+\_\+.



Referenced by allow\+Vulnerable(), and encode\+Header\+Q().


\begin{DoxyCode}
187                                      \{
188   uint32\_t absoluteNameIndex = 0;
189   uint32\_t nameIndex = getStaticTable().nameIndex(headerName);
190   \textcolor{keywordtype}{bool} isStatic = \textcolor{keyword}{true};
191   \textcolor{keywordflow}{if} (nameIndex == 0) \{
192     \textcolor{comment}{// check dynamic table}
193     nameIndex = table_.nameIndex(headerName, allowVulnerable());
194     \textcolor{keywordflow}{if} (nameIndex != 0) \{
195       absoluteNameIndex = maybeDuplicate(nameIndex).second;
196       \textcolor{keywordflow}{if} (absoluteNameIndex) \{
197         isStatic = \textcolor{keyword}{false};
198         nameIndex = table_.absoluteToRelative(absoluteNameIndex);
199       \} \textcolor{keywordflow}{else} \{
200         nameIndex = 0;
201         absoluteNameIndex = 0;
202       \}
203     \}
204   \}
205   \textcolor{keywordflow}{return} std::tuple<bool, uint32\_t, uint32\_t>(
206     isStatic, nameIndex, absoluteNameIndex);
207 \}
\end{DoxyCode}
\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!last\+Entry\+Available@{last\+Entry\+Available}}
\index{last\+Entry\+Available@{last\+Entry\+Available}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{last\+Entry\+Available() const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::last\+Entry\+Available (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}\label{classproxygen_1_1QPACKEncoder_aad615aa83007ebf288b96953091620ff}


Definition at line 126 of file Q\+P\+A\+C\+K\+Encoder.\+h.



References max\+Encoder\+Stream\+Bytes\+\_\+.



Referenced by encode\+Header\+Q(), and maybe\+Duplicate().


\begin{DoxyCode}
126                                   \{
127     \textcolor{keywordflow}{return} maxEncoderStreamBytes_ >= 0;
128   \}
\end{DoxyCode}
\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!maybe\+Duplicate@{maybe\+Duplicate}}
\index{maybe\+Duplicate@{maybe\+Duplicate}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{maybe\+Duplicate(uint32\+\_\+t relative\+Index)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::pair$<$ bool, uint32\+\_\+t $>$ proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::maybe\+Duplicate (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{relative\+Index}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1QPACKEncoder_a1d8413ad66375106292cf42e34888497}


Definition at line 169 of file Q\+P\+A\+C\+K\+Encoder.\+cpp.



References allow\+Vulnerable(), encode\+Duplicate(), last\+Entry\+Available(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::maybe\+Duplicate(), and proxygen\+::\+Q\+P\+A\+C\+K\+Context\+::table\+\_\+.



Referenced by allow\+Vulnerable(), encode\+Header\+Q(), and get\+Name\+Index\+Q().


\begin{DoxyCode}
170                               \{
171   \textcolor{keyword}{auto} res = table_.maybeDuplicate(relativeIndex, allowVulnerable());
172   \textcolor{keywordflow}{if} (res.first) \{
173     VLOG(4) << \textcolor{stringliteral}{"Encoded duplicate index="} << relativeIndex;
174     encodeDuplicate(relativeIndex);
175     \textcolor{comment}{// Note we will emit duplications even when we are out of flow control,}
176     \textcolor{comment}{// but we won't reference them (eg: like we were at vulnerable max).}
177     \textcolor{keywordflow}{if} (!lastEntryAvailable()) \{
178       VLOG(4) << \textcolor{stringliteral}{"Duplicate is not usable because it overran encoder flow "}
179         \textcolor{stringliteral}{"control"};
180       \textcolor{keywordflow}{return} \{\textcolor{keyword}{true}, 0\};
181     \}
182   \}
183   \textcolor{keywordflow}{return} res;
184 \}
\end{DoxyCode}
\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!on\+Header\+Ack@{on\+Header\+Ack}}
\index{on\+Header\+Ack@{on\+Header\+Ack}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{on\+Header\+Ack(uint64\+\_\+t stream\+Id, bool all)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+P\+A\+C\+K\+::\+Decode\+Error} proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::on\+Header\+Ack (
\begin{DoxyParamCaption}
\item[{uint64\+\_\+t}]{stream\+Id, }
\item[{bool}]{all}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1QPACKEncoder_ae3fad66c9104dd44764247fa2cfead2c}


Definition at line 358 of file Q\+P\+A\+C\+K\+Encoder.\+cpp.



References proxygen\+::\+E\+R\+R\+OR, proxygen\+::\+H\+P\+A\+C\+K\+::\+I\+N\+V\+A\+L\+I\+D\+\_\+\+A\+CK, proxygen\+::\+H\+P\+A\+C\+K\+::\+N\+O\+NE, num\+Vulnerable\+\_\+, outstanding\+\_\+, proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::set\+Max\+Acked(), proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::sub\+Ref(), and proxygen\+::\+Q\+P\+A\+C\+K\+Context\+::table\+\_\+.



Referenced by decode\+Header\+Ack(), and T\+E\+S\+T().


\begin{DoxyCode}
358                                                                       \{
359   \textcolor{keyword}{auto} it = outstanding_.find(streamId);
360   \textcolor{keywordflow}{if} (it == outstanding_.end()) \{
361     \textcolor{keywordflow}{if} (!all) \{
362       LOG(ERROR) << \textcolor{stringliteral}{"Received an ack with no outstanding header blocks stream="}
363                  << streamId;
364       \textcolor{keywordflow}{return} HPACK::DecodeError::INVALID_ACK;
365     \} \textcolor{keywordflow}{else} \{
366       \textcolor{comment}{// all implies a reset, meaning it's not an error if there are no}
367       \textcolor{comment}{// outstanding blocks}
368       \textcolor{keywordflow}{return} HPACK::DecodeError::NONE;
369     \}
370   \}
371   DCHECK(!it->second.empty()) << \textcolor{stringliteral}{"Invariant violation: no blocks in stream "}
372      \textcolor{stringliteral}{"record"};
373   VLOG(5) << ((all) ? \textcolor{stringliteral}{"onCancelStream"} : \textcolor{stringliteral}{"onHeaderAck"}) << \textcolor{stringliteral}{" streamId="}
374           << streamId;
375   \textcolor{keywordflow}{if} (all) \{
376     \textcolor{comment}{// Happens when a stream is reset}
377     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}& block: it->second) \{
378       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i: block.references) \{
379         VLOG(5) << \textcolor{stringliteral}{"Decrementing refcount for absoluteIndex="} << i;
380         table_.subRef(i);
381       \}
382       \textcolor{keywordflow}{if} (block.vulnerable) \{
383         numVulnerable_--;
384       \}
385     \}
386     it->second.clear();
387   \} \textcolor{keywordflow}{else} \{
388     \textcolor{keyword}{auto} block = std::move(it->second.front());
389     it->second.pop\_front();
390     \textcolor{comment}{// a different stream, sub all the references}
391     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} i: block.references) \{
392       VLOG(5) << \textcolor{stringliteral}{"Decrementing refcount for absoluteIndex="} << i;
393       table_.subRef(i);
394     \}
395     \textcolor{keywordflow}{if} (block.vulnerable) \{
396       numVulnerable_--;
397     \}
398     \textcolor{comment}{// largest reference is implicitly acknowledged}
399     \textcolor{keywordflow}{if} (!block.references.empty()) \{
400       \textcolor{keyword}{auto} largestReference = *block.references.rbegin();
401       VLOG(5) << \textcolor{stringliteral}{"Implicitly acknowledging absoluteIndex="} << largestReference;
402       table_.setMaxAcked(largestReference);
403     \}
404   \}
405   \textcolor{keywordflow}{if} (it->second.empty()) \{
406     outstanding_.erase(it);
407   \}
408   \textcolor{keywordflow}{return} HPACK::DecodeError::NONE;
409 \}
\end{DoxyCode}
\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!on\+Table\+State\+Sync@{on\+Table\+State\+Sync}}
\index{on\+Table\+State\+Sync@{on\+Table\+State\+Sync}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{on\+Table\+State\+Sync(uint32\+\_\+t inserts)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+P\+A\+C\+K\+::\+Decode\+Error} proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::on\+Table\+State\+Sync (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{inserts}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1QPACKEncoder_aa0d0ad07d830f5c1df6bfe79b5d6baaf}


Definition at line 351 of file Q\+P\+A\+C\+K\+Encoder.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+::\+I\+N\+V\+A\+L\+I\+D\+\_\+\+A\+CK, proxygen\+::\+H\+P\+A\+C\+K\+::\+N\+O\+NE, proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::on\+Table\+State\+Sync(), and proxygen\+::\+Q\+P\+A\+C\+K\+Context\+::table\+\_\+.



Referenced by decode\+Decoder\+Stream(), and T\+E\+S\+T().


\begin{DoxyCode}
351                                                                 \{
352   \textcolor{keywordflow}{if} (inserts == 0 || !table_.onTableStateSync(inserts)) \{
353     \textcolor{keywordflow}{return} HPACK::DecodeError::INVALID_ACK;
354   \}
355   \textcolor{keywordflow}{return} HPACK::DecodeError::NONE;
356 \}
\end{DoxyCode}
\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!set\+Header\+Table\+Size@{set\+Header\+Table\+Size}}
\index{set\+Header\+Table\+Size@{set\+Header\+Table\+Size}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{set\+Header\+Table\+Size(uint32\+\_\+t size)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::set\+Header\+Table\+Size (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1QPACKEncoder_a246575e6a52428c4438ba7d44b93eb04}


Definition at line 58 of file Q\+P\+A\+C\+K\+Encoder.\+h.



References proxygen\+::\+H\+P\+A\+C\+K\+Encoder\+Base\+::set\+Header\+Table\+Size(), and proxygen\+::\+Q\+P\+A\+C\+K\+Context\+::table\+\_\+.



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
58                                          \{
59     HPACKEncoderBase::setHeaderTableSize(table_, size);
60   \}
\end{DoxyCode}
\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!set\+Max\+Vulnerable@{set\+Max\+Vulnerable}}
\index{set\+Max\+Vulnerable@{set\+Max\+Vulnerable}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{set\+Max\+Vulnerable(uint32\+\_\+t max\+Vulnerable)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::set\+Max\+Vulnerable (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{max\+Vulnerable}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1QPACKEncoder_acfe8c6d0f950a16ca671b091aee697f3}


Definition at line 62 of file Q\+P\+A\+C\+K\+Encoder.\+h.



References max\+Vulnerable\+\_\+.



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
62                                                 \{
63     maxVulnerable_ = maxVulnerable;
64   \}
\end{DoxyCode}
\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!set\+Min\+Free\+For\+Testing@{set\+Min\+Free\+For\+Testing}}
\index{set\+Min\+Free\+For\+Testing@{set\+Min\+Free\+For\+Testing}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{set\+Min\+Free\+For\+Testing(uint32\+\_\+t min\+Free)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::set\+Min\+Free\+For\+Testing (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{min\+Free}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1QPACKEncoder_a21b801d21b0c6b5c7ed13af1890428ad}


Definition at line 68 of file Q\+P\+A\+C\+K\+Encoder.\+h.



References proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::set\+Min\+Free\+For\+Testing(), and proxygen\+::\+Q\+P\+A\+C\+K\+Context\+::table\+\_\+.



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
68                                               \{
69     table_.setMinFreeForTesting(minFree);
70   \}
\end{DoxyCode}
\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!should\+Index@{should\+Index}}
\index{should\+Index@{should\+Index}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{should\+Index(const H\+P\+A\+C\+K\+Header \&header) const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::should\+Index (
\begin{DoxyParamCaption}
\item[{const {\bf H\+P\+A\+C\+K\+Header} \&}]{header}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1QPACKEncoder_a775c886f2c31a0bea3d412ac2ce0ebbf}


Definition at line 164 of file Q\+P\+A\+C\+K\+Encoder.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Header\+::bytes(), proxygen\+::\+Header\+Table\+::capacity(), proxygen\+::\+Header\+Indexing\+Strategy\+::index\+Header(), proxygen\+::\+H\+P\+A\+C\+K\+Encoder\+Base\+::indexing\+Strat\+\_\+, and proxygen\+::\+Q\+P\+A\+C\+K\+Context\+::table\+\_\+.



Referenced by allow\+Vulnerable(), and encode\+Header\+Q().


\begin{DoxyCode}
164                                                               \{
165   \textcolor{keywordflow}{return} (header.bytes() <= table_.capacity()) &&
166     (!indexingStrat_ || indexingStrat_->indexHeader(header));
167 \}
\end{DoxyCode}
\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!track\+Reference@{track\+Reference}}
\index{track\+Reference@{track\+Reference}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{track\+Reference(uint32\+\_\+t index, uint32\+\_\+t $\ast$largest\+Reference)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::track\+Reference (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{index, }
\item[{uint32\+\_\+t $\ast$}]{largest\+Reference}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1QPACKEncoder_a3b98063456243bf41c113cf3376a83fa}


Definition at line 232 of file Q\+P\+A\+C\+K\+Encoder.\+cpp.



References proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::add\+Ref(), cur\+Outstanding\+\_\+, proxygen\+::\+Q\+P\+A\+C\+K\+Header\+Table\+::is\+Vulnerable(), proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Outstanding\+Block\+::references, proxygen\+::\+Q\+P\+A\+C\+K\+Context\+::table\+\_\+, and proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::\+Outstanding\+Block\+::vulnerable.



Referenced by allow\+Vulnerable(), encode\+Header\+Q(), and encode\+Stream\+Literal\+Q().


\begin{DoxyCode}
233                                                               \{
234   CHECK\_NE(absoluteIndex, 0);
235   CHECK(curOutstanding_);
236   \textcolor{keywordflow}{if} (absoluteIndex > *largestReference) \{
237     *largestReference = absoluteIndex;
238     \textcolor{keywordflow}{if} (table_.isVulnerable(absoluteIndex)) \{
239       curOutstanding_->vulnerable = \textcolor{keyword}{true};
240     \}
241   \}
242   \textcolor{keyword}{auto} res = curOutstanding_->references.insert(absoluteIndex);
243   \textcolor{keywordflow}{if} (res.second) \{
244     VLOG(5) << \textcolor{stringliteral}{"Bumping refcount for absoluteIndex="} << absoluteIndex;
245     table_.addRef(absoluteIndex);
246   \}
247 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!control\+Buffer\+\_\+@{control\+Buffer\+\_\+}}
\index{control\+Buffer\+\_\+@{control\+Buffer\+\_\+}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{control\+Buffer\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+P\+A\+C\+K\+Encode\+Buffer} proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::control\+Buffer\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1QPACKEncoder_a17bc89bbd4b75ecf2dcb2a308f6f8b41}


Definition at line 130 of file Q\+P\+A\+C\+K\+Encoder.\+h.



Referenced by encode(), encode\+Duplicate(), encode\+Insert\+Q(), and encode\+Q().

\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!cur\+Outstanding\+\_\+@{cur\+Outstanding\+\_\+}}
\index{cur\+Outstanding\+\_\+@{cur\+Outstanding\+\_\+}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{cur\+Outstanding\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Outstanding\+Block}$\ast$ proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::cur\+Outstanding\+\_\+ \{{\bf nullptr}\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1QPACKEncoder_ae28c16a6d2fa808b340dffcb3fcf3cf0}


Definition at line 138 of file Q\+P\+A\+C\+K\+Encoder.\+h.



Referenced by encode\+Q(), and track\+Reference().

\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!decoder\+Ingress\+\_\+@{decoder\+Ingress\+\_\+}}
\index{decoder\+Ingress\+\_\+@{decoder\+Ingress\+\_\+}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{decoder\+Ingress\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+I\+O\+Buf\+Queue proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::decoder\+Ingress\+\_\+ \{folly\+::\+I\+O\+Buf\+Queue\+::cache\+Chain\+Length()\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1QPACKEncoder_aed9bc5c3f5b14475147aa328847a37f0}


Definition at line 143 of file Q\+P\+A\+C\+K\+Encoder.\+h.



Referenced by decode\+Decoder\+Stream().

\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!max\+Depends\+\_\+@{max\+Depends\+\_\+}}
\index{max\+Depends\+\_\+@{max\+Depends\+\_\+}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{max\+Depends\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::max\+Depends\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1QPACKEncoder_a2e875a95da3d3e3d095f01a084f33626}


Definition at line 139 of file Q\+P\+A\+C\+K\+Encoder.\+h.

\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!max\+Encoder\+Stream\+Bytes\+\_\+@{max\+Encoder\+Stream\+Bytes\+\_\+}}
\index{max\+Encoder\+Stream\+Bytes\+\_\+@{max\+Encoder\+Stream\+Bytes\+\_\+}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{max\+Encoder\+Stream\+Bytes\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}int64\+\_\+t proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::max\+Encoder\+Stream\+Bytes\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1QPACKEncoder_a21be7b67db82397e88b2c05d3fc6225f}


Definition at line 142 of file Q\+P\+A\+C\+K\+Encoder.\+h.



Referenced by encode(), encode\+Duplicate(), encode\+Header\+Q(), encode\+Insert\+Q(), and last\+Entry\+Available().

\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!max\+Vulnerable\+\_\+@{max\+Vulnerable\+\_\+}}
\index{max\+Vulnerable\+\_\+@{max\+Vulnerable\+\_\+}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{max\+Vulnerable\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::max\+Vulnerable\+\_\+ \{{\bf H\+P\+A\+C\+K\+::k\+Default\+Blocking}\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1QPACKEncoder_ac1fce785d3959573ba2f14422e2983b8}


Definition at line 140 of file Q\+P\+A\+C\+K\+Encoder.\+h.



Referenced by allow\+Vulnerable(), and set\+Max\+Vulnerable().

\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!num\+Vulnerable\+\_\+@{num\+Vulnerable\+\_\+}}
\index{num\+Vulnerable\+\_\+@{num\+Vulnerable\+\_\+}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{num\+Vulnerable\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::num\+Vulnerable\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1QPACKEncoder_a58592e3939452d6fb53795b0757a71e4}


Definition at line 141 of file Q\+P\+A\+C\+K\+Encoder.\+h.



Referenced by allow\+Vulnerable(), encode\+Q(), and on\+Header\+Ack().

\index{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}!outstanding\+\_\+@{outstanding\+\_\+}}
\index{outstanding\+\_\+@{outstanding\+\_\+}!proxygen\+::\+Q\+P\+A\+C\+K\+Encoder@{proxygen\+::\+Q\+P\+A\+C\+K\+Encoder}}
\subsubsection[{outstanding\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unordered\+\_\+map$<$uint64\+\_\+t, std\+::list$<${\bf Outstanding\+Block}$>$ $>$ proxygen\+::\+Q\+P\+A\+C\+K\+Encoder\+::outstanding\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1QPACKEncoder_a2ca20f63886b97ac3aea18243a8457a3}


Definition at line 137 of file Q\+P\+A\+C\+K\+Encoder.\+h.



Referenced by encode\+Q(), and on\+Header\+Ack().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
proxygen/lib/http/codec/compress/{\bf Q\+P\+A\+C\+K\+Encoder.\+h}\item 
proxygen/lib/http/codec/compress/{\bf Q\+P\+A\+C\+K\+Encoder.\+cpp}\end{DoxyCompactItemize}
