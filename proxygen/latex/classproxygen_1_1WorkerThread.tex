\section{proxygen\+:\+:Worker\+Thread Class Reference}
\label{classproxygen_1_1WorkerThread}\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}


{\ttfamily \#include $<$Worker\+Thread.\+h$>$}

Inheritance diagram for proxygen\+:\+:Worker\+Thread\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classproxygen_1_1WorkerThread}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Worker\+Thread} (folly\+::\+Event\+Base\+Manager $\ast$ebm, const std\+::string \&evb\+Name=std\+::string())
\item 
virtual {\bf $\sim$\+Worker\+Thread} ()
\item 
void {\bf start} ()
\item 
void {\bf stop\+When\+Idle} ()
\item 
void {\bf force\+Stop} ()
\item 
void {\bf wait} ()
\item 
folly\+::\+Event\+Base $\ast$ {\bf get\+Event\+Base} ()
\item 
std\+::thread\+::native\+\_\+handle\+\_\+type {\bf get\+Thread\+Native\+Handle} () noexcept
\item 
std\+::thread\+::id {\bf get\+Thread\+Id} () const noexcept
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static {\bf Worker\+Thread} $\ast$ {\bf get\+Current\+Worker\+Thread} ()
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
virtual void {\bf setup} ()
\item 
virtual void {\bf cleanup} ()
\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
enum {\bf State} \+: uint8\+\_\+t \{ \\*
{\bf State\+::\+I\+D\+LE}, 
{\bf State\+::\+S\+T\+A\+R\+T\+I\+NG}, 
{\bf State\+::\+R\+U\+N\+N\+I\+NG}, 
{\bf State\+::\+S\+T\+O\+P\+\_\+\+W\+H\+E\+N\+\_\+\+I\+D\+LE}, 
\\*
{\bf State\+::\+F\+O\+R\+C\+E\+\_\+\+S\+T\+OP}
 \}
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Worker\+Thread} ({\bf Worker\+Thread} const \&)=delete
\item 
{\bf Worker\+Thread} \& {\bf operator=} ({\bf Worker\+Thread} const \&)=delete
\item 
void {\bf run\+Loop} ()
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
{\bf State} {\bf state\+\_\+} \{{\bf State\+::\+I\+D\+LE}\}
\item 
std\+::thread {\bf thread\+\_\+}
\item 
std\+::mutex {\bf join\+Lock\+\_\+}
\item 
folly\+::\+Event\+Base {\bf event\+Base\+\_\+}
\item 
folly\+::\+Event\+Base\+Manager $\ast$ {\bf event\+Base\+Manager\+\_\+} \{{\bf nullptr}\}
\end{DoxyCompactItemize}
\subsection*{Static Private Attributes}
\begin{DoxyCompactItemize}
\item 
static F\+O\+L\+L\+Y\+\_\+\+T\+LS {\bf Worker\+Thread} $\ast$ {\bf current\+Worker\+\_\+} = {\bf nullptr}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
A \doxyref{Worker\+Thread}{p.}{classproxygen_1_1WorkerThread} represents an independent event loop that runs in its own thread. 

Definition at line 29 of file Worker\+Thread.\+h.



\subsection{Member Enumeration Documentation}
\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!State@{State}}
\index{State@{State}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}
\subsubsection[{State}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+Worker\+Thread\+::\+State} \+: uint8\+\_\+t\hspace{0.3cm}{\ttfamily [strong]}, {\ttfamily [private]}}\label{classproxygen_1_1WorkerThread_a73b0c3c1b63e12484801f8f2bb8a67b6}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{I\+D\+LE@{I\+D\+LE}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!I\+D\+LE@{I\+D\+LE}}\item[{\em 
I\+D\+LE\label{classproxygen_1_1WorkerThread_a73b0c3c1b63e12484801f8f2bb8a67b6aa5daf7f2ebbba4975d61dab1c40188c7}
}]\index{S\+T\+A\+R\+T\+I\+NG@{S\+T\+A\+R\+T\+I\+NG}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!S\+T\+A\+R\+T\+I\+NG@{S\+T\+A\+R\+T\+I\+NG}}\item[{\em 
S\+T\+A\+R\+T\+I\+NG\label{classproxygen_1_1WorkerThread_a73b0c3c1b63e12484801f8f2bb8a67b6a034312d8adc8099c1c6f53aaff745e26}
}]\index{R\+U\+N\+N\+I\+NG@{R\+U\+N\+N\+I\+NG}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!R\+U\+N\+N\+I\+NG@{R\+U\+N\+N\+I\+NG}}\item[{\em 
R\+U\+N\+N\+I\+NG\label{classproxygen_1_1WorkerThread_a73b0c3c1b63e12484801f8f2bb8a67b6a43491564ebcfd38568918efbd6e840fd}
}]\index{S\+T\+O\+P\+\_\+\+W\+H\+E\+N\+\_\+\+I\+D\+LE@{S\+T\+O\+P\+\_\+\+W\+H\+E\+N\+\_\+\+I\+D\+LE}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!S\+T\+O\+P\+\_\+\+W\+H\+E\+N\+\_\+\+I\+D\+LE@{S\+T\+O\+P\+\_\+\+W\+H\+E\+N\+\_\+\+I\+D\+LE}}\item[{\em 
S\+T\+O\+P\+\_\+\+W\+H\+E\+N\+\_\+\+I\+D\+LE\label{classproxygen_1_1WorkerThread_a73b0c3c1b63e12484801f8f2bb8a67b6a044c93a8c75acd1352d451bd436c6bb9}
}]\index{F\+O\+R\+C\+E\+\_\+\+S\+T\+OP@{F\+O\+R\+C\+E\+\_\+\+S\+T\+OP}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!F\+O\+R\+C\+E\+\_\+\+S\+T\+OP@{F\+O\+R\+C\+E\+\_\+\+S\+T\+OP}}\item[{\em 
F\+O\+R\+C\+E\+\_\+\+S\+T\+OP\label{classproxygen_1_1WorkerThread_a73b0c3c1b63e12484801f8f2bb8a67b6a4828c4ddf6aafe8d2ed5dbc6747b4fc1}
}]\end{description}
\end{Desc}


Definition at line 120 of file Worker\+Thread.\+h.


\begin{DoxyCode}
120                    : uint8\_t \{
121     IDLE,           \textcolor{comment}{// Not yet started}
122     STARTING,       \textcolor{comment}{// start() called, thread not fully started yet}
123     RUNNING,        \textcolor{comment}{// Thread running normally}
124     STOP\_WHEN\_IDLE, \textcolor{comment}{// stopWhenIdle() called, not stopped yet}
125     FORCE\_STOP,     \textcolor{comment}{// forceStop() called, but the loop is still cleaning up}
126   \};
\end{DoxyCode}


\subsection{Constructor \& Destructor Documentation}
\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!Worker\+Thread@{Worker\+Thread}}
\index{Worker\+Thread@{Worker\+Thread}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}
\subsubsection[{Worker\+Thread(folly\+::\+Event\+Base\+Manager $\ast$ebm, const std\+::string \&evb\+Name=std\+::string())}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+Worker\+Thread\+::\+Worker\+Thread (
\begin{DoxyParamCaption}
\item[{folly\+::\+Event\+Base\+Manager $\ast$}]{ebm, }
\item[{const std\+::string \&}]{evb\+Name = {\ttfamily std\+:\+:string()}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [explicit]}}\label{classproxygen_1_1WorkerThread_a3dfbc12d0f2cd59bb536e09ef274f806}


Definition at line 22 of file Worker\+Thread.\+cpp.



References event\+Base\+\_\+.


\begin{DoxyCode}
24     : eventBaseManager_(eventBaseManager) \{
25   \textcolor{comment}{// Only set the event base name if not empty.}
26   \textcolor{comment}{// While not ideal, this preserves the previous program name inheritance}
27   \textcolor{comment}{// behavior.}
28   \textcolor{keywordflow}{if} (!evbName.empty()) \{
29     eventBase_.setName(evbName);
30   \}
31 \}
\end{DoxyCode}
\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!````~Worker\+Thread@{$\sim$\+Worker\+Thread}}
\index{````~Worker\+Thread@{$\sim$\+Worker\+Thread}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}
\subsubsection[{$\sim$\+Worker\+Thread()}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+Worker\+Thread\+::$\sim$\+Worker\+Thread (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [virtual]}}\label{classproxygen_1_1WorkerThread_a0e4bb3ed14019772ff92c1f463de5836}


Definition at line 33 of file Worker\+Thread.\+cpp.



References I\+D\+LE, and state\+\_\+.


\begin{DoxyCode}
33                             \{
34   CHECK(state_ == State::IDLE);
35 \}
\end{DoxyCode}
\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!Worker\+Thread@{Worker\+Thread}}
\index{Worker\+Thread@{Worker\+Thread}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}
\subsubsection[{Worker\+Thread(\+Worker\+Thread const \&)=delete}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+Worker\+Thread\+::\+Worker\+Thread (
\begin{DoxyParamCaption}
\item[{{\bf Worker\+Thread} const \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [delete]}}\label{classproxygen_1_1WorkerThread_a6936c5a9afd21a67cc6eae4e50a30c2b}


\subsection{Member Function Documentation}
\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!cleanup@{cleanup}}
\index{cleanup@{cleanup}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}
\subsubsection[{cleanup()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Worker\+Thread\+::cleanup (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1WorkerThread_a08a1ebe42a2cf0d9516ffe646efa06ed}


Reimplemented in {\bf proxygen\+::\+Request\+Worker} \doxyref{}{p.}{classproxygen_1_1RequestWorker_a12d78f930553110068bb14cac39c815a}.



Definition at line 127 of file Worker\+Thread.\+cpp.



References current\+Worker\+\_\+, and event\+Base\+Manager\+\_\+.



Referenced by proxygen\+::\+Request\+Worker\+::cleanup(), and start().


\begin{DoxyCode}
127                            \{
128   currentWorker_ = \textcolor{keyword}{nullptr};
129   \textcolor{keywordflow}{if} (eventBaseManager_) \{
130     eventBaseManager_->clearEventBase();
131   \}
132 \}
\end{DoxyCode}
\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!force\+Stop@{force\+Stop}}
\index{force\+Stop@{force\+Stop}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}
\subsubsection[{force\+Stop()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Worker\+Thread\+::force\+Stop (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1WorkerThread_a999748b079c9c6ecb8a4c2b601aa04a1}
Request that the worker stop executing as soon as possible.

This will terminate the worker thread\textquotesingle{}s event loop, and cause the thread to return. If there are any services still running in the worker thread, their events will no longer be processed.

This function is asynchronous\+: it signals the worker thread to stop, and returns without waiting for the thread to actually terminate. The \doxyref{wait()}{p.}{classproxygen_1_1WorkerThread_ae82b85226ebcd484a7771a48cc57083d} method must be called to wait for the thread to terminate. 

Definition at line 73 of file Worker\+Thread.\+cpp.



References event\+Base\+\_\+, F\+O\+R\+C\+E\+\_\+\+S\+T\+OP, I\+D\+LE, R\+U\+N\+N\+I\+NG, state\+\_\+, and S\+T\+O\+P\+\_\+\+W\+H\+E\+N\+\_\+\+I\+D\+LE.


\begin{DoxyCode}
73                              \{
74   \textcolor{comment}{// Call runInEventBaseThread() to perform all of the work in the actual}
75   \textcolor{comment}{// worker thread.}
76   \textcolor{comment}{//}
77   \textcolor{comment}{// This way we don't have to synchronize access to state\_.}
78   eventBase_.runInEventBaseThread([\textcolor{keyword}{this}] \{
79     \textcolor{keywordflow}{if} (state_ == State::RUNNING || state_ == State::STOP_WHEN_IDLE) \{
80       state_ = State::FORCE_STOP;
81       eventBase_.terminateLoopSoon();
82     \textcolor{comment}{// state\_ could be IDLE if we don't execute this callback until the}
83     \textcolor{comment}{// EventBase is destroyed in the WorkerThread destructor}
84     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (state_ != State::IDLE) \{
85       LOG(FATAL) << \textcolor{stringliteral}{"forceStop() called in unexpected state "} <<
86           \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(state_);
87     \}
88   \});
89 \}
\end{DoxyCode}
\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!get\+Current\+Worker\+Thread@{get\+Current\+Worker\+Thread}}
\index{get\+Current\+Worker\+Thread@{get\+Current\+Worker\+Thread}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}
\subsubsection[{get\+Current\+Worker\+Thread()}]{\setlength{\rightskip}{0pt plus 5cm}static {\bf Worker\+Thread}$\ast$ proxygen\+::\+Worker\+Thread\+::get\+Current\+Worker\+Thread (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classproxygen_1_1WorkerThread_a45d55c6119f9a6e3b6a6109bd3abd465}
Get the current \doxyref{Worker\+Thread}{p.}{classproxygen_1_1WorkerThread} running this thread.

Returns nullptr if called from a thread that is not running inside \doxyref{Worker\+Thread}{p.}{classproxygen_1_1WorkerThread}. 

Definition at line 111 of file Worker\+Thread.\+h.



Referenced by proxygen\+::\+Request\+Worker\+::get\+Request\+Worker().


\begin{DoxyCode}
111                                                 \{
112     \textcolor{keywordflow}{return} currentWorker_;
113   \}
\end{DoxyCode}
\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!get\+Event\+Base@{get\+Event\+Base}}
\index{get\+Event\+Base@{get\+Event\+Base}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}
\subsubsection[{get\+Event\+Base()}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+Event\+Base$\ast$ proxygen\+::\+Worker\+Thread\+::get\+Event\+Base (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1WorkerThread_ad1d646fda1beb1c052eb5bdb920d72ae}
Get the Event\+Base used to drive the events in this worker thread. 

Definition at line 85 of file Worker\+Thread.\+h.



Referenced by proxygen\+::\+Request\+Worker\+::flush\+Stats().


\begin{DoxyCode}
85                                  \{
86     \textcolor{keywordflow}{return} &eventBase_;
87   \}
\end{DoxyCode}
\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!get\+Thread\+Id@{get\+Thread\+Id}}
\index{get\+Thread\+Id@{get\+Thread\+Id}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}
\subsubsection[{get\+Thread\+Id() const noexcept}]{\setlength{\rightskip}{0pt plus 5cm}std\+::thread\+::id proxygen\+::\+Worker\+Thread\+::get\+Thread\+Id (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1WorkerThread_a74bd1f78d13b1f3f4ad696bf024d05c8}
Get ID of the underlying thread objects (valid only when the thread is running). 

Definition at line 101 of file Worker\+Thread.\+h.


\begin{DoxyCode}
101                                            \{
102     \textcolor{keywordflow}{return} thread_.get\_id();
103   \}
\end{DoxyCode}
\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!get\+Thread\+Native\+Handle@{get\+Thread\+Native\+Handle}}
\index{get\+Thread\+Native\+Handle@{get\+Thread\+Native\+Handle}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}
\subsubsection[{get\+Thread\+Native\+Handle() noexcept}]{\setlength{\rightskip}{0pt plus 5cm}std\+::thread\+::native\+\_\+handle\+\_\+type proxygen\+::\+Worker\+Thread\+::get\+Thread\+Native\+Handle (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1WorkerThread_a28a5d53fe1c378526c519d465f7b19b8}
Get native handle of the underlying thread object (valid only when the thread is running). 

Definition at line 93 of file Worker\+Thread.\+h.


\begin{DoxyCode}
93                                                                \{
94     \textcolor{keywordflow}{return} thread_.native\_handle();
95   \}
\end{DoxyCode}
\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!operator=@{operator=}}
\index{operator=@{operator=}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}
\subsubsection[{operator=(\+Worker\+Thread const \&)=delete}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Worker\+Thread}\& proxygen\+::\+Worker\+Thread\+::operator= (
\begin{DoxyParamCaption}
\item[{{\bf Worker\+Thread} const \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [delete]}}\label{classproxygen_1_1WorkerThread_aa40740c89f57dc5647cfbe60413d7529}
\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!run\+Loop@{run\+Loop}}
\index{run\+Loop@{run\+Loop}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}
\subsubsection[{run\+Loop()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Worker\+Thread\+::run\+Loop (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1WorkerThread_a5a00b7bb6a4ae07e4ca79401255ab972}


Definition at line 134 of file Worker\+Thread.\+cpp.



References event\+Base\+\_\+, F\+O\+R\+C\+E\+\_\+\+S\+T\+OP, I\+D\+LE, R\+U\+N\+N\+I\+NG, S\+T\+A\+R\+T\+I\+NG, state\+\_\+, and S\+T\+O\+P\+\_\+\+W\+H\+E\+N\+\_\+\+I\+D\+LE.



Referenced by start().


\begin{DoxyCode}
134                            \{
135   \textcolor{comment}{// Update state\_}
136   CHECK(state_ == State::STARTING);
137   state_ = State::RUNNING;
138 
139   VLOG(1) << \textcolor{stringliteral}{"WorkerThread "} << \textcolor{keyword}{this} << \textcolor{stringliteral}{" starting"};
140 
141   \textcolor{comment}{// Call loopForever().  This will only return after stopWhenIdle() or}
142   \textcolor{comment}{// forceStop() has been called.}
143   eventBase_.loopForever();
144 
145   \textcolor{keywordflow}{if} (state_ == State::STOP_WHEN_IDLE) \{
146     \textcolor{comment}{// We have been asked to stop when there are no more events left.}
147     \textcolor{comment}{// Call loop() to finish processing events.  This will return when there}
148     \textcolor{comment}{// are no more events to process, or after forceStop() has been called.}
149     VLOG(1) << \textcolor{stringliteral}{"WorkerThread "} << \textcolor{keyword}{this} << \textcolor{stringliteral}{" finishing non-internal events"};
150     eventBase_.loop();
151   \}
152 
153   CHECK(state_ == State::STOP_WHEN_IDLE || state_ == State::FORCE_STOP);
154   state_ = State::IDLE;
155 
156   VLOG(1) << \textcolor{stringliteral}{"WorkerThread "} << \textcolor{keyword}{this} << \textcolor{stringliteral}{" terminated"};
157 \}
\end{DoxyCode}
\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!setup@{setup}}
\index{setup@{setup}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}
\subsubsection[{setup()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Worker\+Thread\+::setup (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1WorkerThread_abfff0b79758075c7604736c77c0f1201}


Reimplemented in {\bf proxygen\+::\+Request\+Worker} \doxyref{}{p.}{classproxygen_1_1RequestWorker_a0b48beda6efa8b5b4bc44b6120661ea0}.



Definition at line 98 of file Worker\+Thread.\+cpp.



References current\+Worker\+\_\+, event\+Base\+\_\+, and event\+Base\+Manager\+\_\+.



Referenced by proxygen\+::\+Request\+Worker\+::setup(), and start().


\begin{DoxyCode}
98                          \{
99 \textcolor{preprocessor}{#ifndef \_MSC\_VER}
100   sigset\_t ss;
101 
102   \textcolor{comment}{// Ignore some signals}
103   sigemptyset(&ss);
104   sigaddset(&ss, SIGHUP);
105   sigaddset(&ss, SIGINT);
106   sigaddset(&ss, SIGQUIT);
107   sigaddset(&ss, SIGUSR1);
108   sigaddset(&ss, SIGUSR2);
109   sigaddset(&ss, SIGPIPE);
110   sigaddset(&ss, SIGALRM);
111   sigaddset(&ss, SIGTERM);
112   sigaddset(&ss, SIGCHLD);
113   sigaddset(&ss, SIGIO);
114   PCHECK(pthread\_sigmask(SIG\_BLOCK, &ss, \textcolor{keyword}{nullptr}) == 0);
115 \textcolor{preprocessor}{#endif}
116 
117   \textcolor{comment}{// Update the currentWorker\_ thread-local pointer}
118   CHECK(\textcolor{keyword}{nullptr} == currentWorker_);
119   currentWorker_ = \textcolor{keyword}{this};
120 
121   \textcolor{comment}{// Update the manager with the event base this worker runs on}
122   \textcolor{keywordflow}{if} (eventBaseManager_) \{
123     eventBaseManager_->setEventBase(&eventBase_, \textcolor{keyword}{false});
124   \}
125 \}
\end{DoxyCode}
\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!start@{start}}
\index{start@{start}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}
\subsubsection[{start()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Worker\+Thread\+::start (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1WorkerThread_acaa48a3b641fe43ef380e93f1f068465}
Begin execution of the worker.

This starts the worker thread, and returns immediately. 

Definition at line 37 of file Worker\+Thread.\+cpp.



References cleanup(), event\+Base\+\_\+, I\+D\+LE, join\+Lock\+\_\+, run\+Loop(), setup(), S\+T\+A\+R\+T\+I\+NG, state\+\_\+, and thread\+\_\+.


\begin{DoxyCode}
37                          \{
38   CHECK(state_ == State::IDLE);
39   state_ = State::STARTING;
40 
41   \{
42     \textcolor{comment}{// because you could theoretically call wait in parallel with start,}
43     \textcolor{comment}{// why are you in such a hurry anyways?}
44     std::lock\_guard<std::mutex> guard(joinLock_);
45     thread_ = std::thread([&]() \textcolor{keyword}{mutable} \{
46         this->setup();
47         this->runLoop();
48         this->cleanup();
49       \});
50   \}
51   eventBase_.waitUntilRunning();
52   \textcolor{comment}{// The server has been set up and is now in the loop implementation}
53 \}
\end{DoxyCode}
\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!stop\+When\+Idle@{stop\+When\+Idle}}
\index{stop\+When\+Idle@{stop\+When\+Idle}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}
\subsubsection[{stop\+When\+Idle()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Worker\+Thread\+::stop\+When\+Idle (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1WorkerThread_a279c01ba29e287b3c7921d9c7065568f}
Request that the worker thread stop when there are no more events to process.

Normally each worker thread runs forever, even if it is idle with no events to process. This function requests that the worker thread return when it becomes idle.

This is used for graceful shutdown\+: Once the services have been asked to shutdown, \doxyref{stop\+When\+Idle()}{p.}{classproxygen_1_1WorkerThread_a279c01ba29e287b3c7921d9c7065568f} can be called on the \doxyref{Worker\+Thread}{p.}{classproxygen_1_1WorkerThread} so that it will return as soon as the services in this thread no longer have any events to process.

Typically you will still want to call \doxyref{force\+Stop()}{p.}{classproxygen_1_1WorkerThread_a999748b079c9c6ecb8a4c2b601aa04a1} after a timeout, in case some of the services take too long to shut down gracefully. 

Definition at line 55 of file Worker\+Thread.\+cpp.



References event\+Base\+\_\+, I\+D\+LE, R\+U\+N\+N\+I\+NG, state\+\_\+, and S\+T\+O\+P\+\_\+\+W\+H\+E\+N\+\_\+\+I\+D\+LE.


\begin{DoxyCode}
55                                 \{
56   \textcolor{comment}{// Call runInEventBaseThread() to perform all of the work in the actual}
57   \textcolor{comment}{// worker thread.}
58   \textcolor{comment}{//}
59   \textcolor{comment}{// This way we don't have to synchronize access to state\_.}
60   eventBase_.runInEventBaseThread([\textcolor{keyword}{this}] \{
61     \textcolor{keywordflow}{if} (state_ == State::RUNNING) \{
62       state_ = State::STOP_WHEN_IDLE;
63       eventBase_.terminateLoopSoon();
64     \textcolor{comment}{// state\_ could be IDLE if we don't execute this callback until the}
65     \textcolor{comment}{// EventBase is destroyed in the WorkerThread destructor}
66     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (state_ != State::IDLE && state_ != State::STOP_WHEN_IDLE) \{
67       LOG(FATAL) << \textcolor{stringliteral}{"stopWhenIdle() called in unexpected state "} <<
68           \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(state_);
69     \}
70   \});
71 \}
\end{DoxyCode}
\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!wait@{wait}}
\index{wait@{wait}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}
\subsubsection[{wait()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+Worker\+Thread\+::wait (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1WorkerThread_ae82b85226ebcd484a7771a48cc57083d}
Synchronously wait for termination of the worker thread.

Note that the worker thread will only terminate after \doxyref{stop\+When\+Idle()}{p.}{classproxygen_1_1WorkerThread_a279c01ba29e287b3c7921d9c7065568f} or \doxyref{force\+Stop()}{p.}{classproxygen_1_1WorkerThread_a999748b079c9c6ecb8a4c2b601aa04a1} has been called, so you typically should only call \doxyref{wait()}{p.}{classproxygen_1_1WorkerThread_ae82b85226ebcd484a7771a48cc57083d} after first using one of these functions. 

Definition at line 91 of file Worker\+Thread.\+cpp.



References join\+Lock\+\_\+, and thread\+\_\+.


\begin{DoxyCode}
91                         \{
92   std::lock\_guard<std::mutex> guard(joinLock_);
93   \textcolor{keywordflow}{if} (thread_.joinable()) \{
94     thread_.join();
95   \}
96 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!current\+Worker\+\_\+@{current\+Worker\+\_\+}}
\index{current\+Worker\+\_\+@{current\+Worker\+\_\+}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}
\subsubsection[{current\+Worker\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}F\+O\+L\+L\+Y\+\_\+\+T\+LS {\bf Worker\+Thread} $\ast$ proxygen\+::\+Worker\+Thread\+::current\+Worker\+\_\+ = {\bf nullptr}\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\label{classproxygen_1_1WorkerThread_aaadf136abe6aac4c8f8c355871b4991b}


Definition at line 141 of file Worker\+Thread.\+h.



Referenced by cleanup(), and setup().

\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!event\+Base\+\_\+@{event\+Base\+\_\+}}
\index{event\+Base\+\_\+@{event\+Base\+\_\+}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}
\subsubsection[{event\+Base\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+Event\+Base proxygen\+::\+Worker\+Thread\+::event\+Base\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1WorkerThread_ad854e9d6cb6a389aa81a6ee561bb05f7}


Definition at line 137 of file Worker\+Thread.\+h.



Referenced by force\+Stop(), run\+Loop(), setup(), start(), stop\+When\+Idle(), and Worker\+Thread().

\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!event\+Base\+Manager\+\_\+@{event\+Base\+Manager\+\_\+}}
\index{event\+Base\+Manager\+\_\+@{event\+Base\+Manager\+\_\+}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}
\subsubsection[{event\+Base\+Manager\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+Event\+Base\+Manager$\ast$ proxygen\+::\+Worker\+Thread\+::event\+Base\+Manager\+\_\+ \{{\bf nullptr}\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1WorkerThread_a4ecae1d3eb740423d844605c73f9c934}


Definition at line 138 of file Worker\+Thread.\+h.



Referenced by cleanup(), and setup().

\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!join\+Lock\+\_\+@{join\+Lock\+\_\+}}
\index{join\+Lock\+\_\+@{join\+Lock\+\_\+}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}
\subsubsection[{join\+Lock\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::mutex proxygen\+::\+Worker\+Thread\+::join\+Lock\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1WorkerThread_a0ce0a171505ad0302f49fbac3fad7f90}


Definition at line 136 of file Worker\+Thread.\+h.



Referenced by start(), and wait().

\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!state\+\_\+@{state\+\_\+}}
\index{state\+\_\+@{state\+\_\+}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}
\subsubsection[{state\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf State} proxygen\+::\+Worker\+Thread\+::state\+\_\+ \{{\bf State\+::\+I\+D\+LE}\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1WorkerThread_a8e388d362a3677f311c51fd2a39c1713}


Definition at line 134 of file Worker\+Thread.\+h.



Referenced by force\+Stop(), run\+Loop(), start(), stop\+When\+Idle(), and $\sim$\+Worker\+Thread().

\index{proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}!thread\+\_\+@{thread\+\_\+}}
\index{thread\+\_\+@{thread\+\_\+}!proxygen\+::\+Worker\+Thread@{proxygen\+::\+Worker\+Thread}}
\subsubsection[{thread\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::thread proxygen\+::\+Worker\+Thread\+::thread\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1WorkerThread_aa37b77c3b0f6ca42fbbb167e8f5fe9f3}


Definition at line 135 of file Worker\+Thread.\+h.



Referenced by start(), and wait().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
proxygen/lib/services/{\bf Worker\+Thread.\+h}\item 
proxygen/lib/services/{\bf Worker\+Thread.\+cpp}\end{DoxyCompactItemize}
