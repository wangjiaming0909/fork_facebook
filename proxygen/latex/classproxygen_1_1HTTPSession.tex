\section{proxygen\+:\+:H\+T\+T\+P\+Session Class Reference}
\label{classproxygen_1_1HTTPSession}\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}


{\ttfamily \#include $<$H\+T\+T\+P\+Session.\+h$>$}

Inheritance diagram for proxygen\+:\+:H\+T\+T\+P\+Session\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=8.327138cm]{classproxygen_1_1HTTPSession}
\end{center}
\end{figure}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class {\bf Drain\+Timeout}
\item 
class {\bf Flow\+Control\+Timeout}
\item 
class {\bf Shutdown\+Transport\+Callback}
\item 
class {\bf Write\+Segment}
\item 
class {\bf Write\+Timeout}
\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using {\bf Unique\+Ptr} = std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Session}, Destructor $>$
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf H\+T\+T\+P\+Session\+Base\+::\+Session\+Type} {\bf get\+Type} () const noexceptoverride
\item 
folly\+::\+Async\+Transport\+Wrapper $\ast$ {\bf get\+Transport} () override
\item 
folly\+::\+Event\+Base $\ast$ {\bf get\+Event\+Base} () const override
\item 
const folly\+::\+Async\+Transport\+Wrapper $\ast$ {\bf get\+Transport} () const override
\item 
bool {\bf has\+Active\+Transactions} () const override
\item 
uint32\+\_\+t {\bf get\+Num\+Outgoing\+Streams} () const override
\item 
uint32\+\_\+t {\bf get\+Num\+Incoming\+Streams} () const override
\item 
{\bf Byte\+Event\+Tracker} $\ast$ {\bf get\+Byte\+Event\+Tracker} ()
\item 
void {\bf set\+Byte\+Event\+Tracker} (std\+::shared\+\_\+ptr$<$ {\bf Byte\+Event\+Tracker} $>$ byte\+Event\+Tracker)
\item 
void {\bf set\+Session\+Stats} ({\bf H\+T\+T\+P\+Session\+Stats} $\ast$stats) override
\item 
void {\bf set\+Flow\+Control} (size\+\_\+t initial\+Receive\+Window, size\+\_\+t receive\+Stream\+Window\+Size, size\+\_\+t receive\+Session\+Window\+Size) override
\item 
void {\bf set\+Egress\+Settings} (const {\bf Settings\+List} \&in\+Settings) override
\item 
bool {\bf get\+H\+T\+T\+P2\+Priorities\+Enabled} () const override
\item 
void {\bf set\+H\+T\+T\+P2\+Priorities\+Enabled} (bool enabled) override
\item 
const folly\+::\+Socket\+Address \& {\bf get\+Local\+Address} () const noexceptoverride
\item 
const folly\+::\+Socket\+Address \& {\bf get\+Peer\+Address} () const noexceptoverride
\item 
const wangle\+::\+Transport\+Info \& {\bf get\+Setup\+Transport\+Info} () const noexceptoverride
\item 
bool {\bf get\+Current\+Transport\+Info} (wangle\+::\+Transport\+Info $\ast$tinfo) override
\item 
void {\bf set\+Max\+Concurrent\+Incoming\+Streams} (uint32\+\_\+t num) override
\item 
void {\bf set\+Egress\+Bytes\+Limit} (uint64\+\_\+t bytes\+Limit)
\item 
void {\bf start\+Now} () override
\item 
size\+\_\+t {\bf send\+Settings} () override
\item 
size\+\_\+t {\bf send\+Ping} () override
\item 
{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} {\bf send\+Priority} ({\bf http2\+::\+Priority\+Update} pri) override
\item 
size\+\_\+t {\bf send\+Priority} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} id, {\bf http2\+::\+Priority\+Update} pri) override
\item 
size\+\_\+t {\bf send\+Certificate\+Request} (std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ certificate\+Request\+Context, std\+::vector$<$ fizz\+::\+Extension $>$ extensions) override
\item 
void {\bf timeout\+Expired} () noexceptoverride
\item 
void {\bf describe} (std\+::ostream \&os) const override
\item 
bool {\bf is\+Busy} () const override
\item 
void {\bf notify\+Pending\+Shutdown} () override
\item 
void {\bf close\+When\+Idle} () override
\item 
void {\bf drop\+Connection} () override
\item 
void {\bf dump\+Connection\+State} (uint8\+\_\+t loglevel) override
\item 
bool {\bf get\+Current\+Transport\+Info\+Without\+Update} (wangle\+::\+Transport\+Info $\ast$tinfo) const override
\item 
void {\bf set\+Header\+Codec\+Stats} ({\bf Header\+Codec\+::\+Stats} $\ast$stats) override
\item 
void {\bf enable\+Double\+Goaway\+Drain} () override
\item 
bool {\bf conn\+Close\+By\+Remote} () override
\item 
void {\bf set\+Second\+Auth\+Manager} (std\+::unique\+\_\+ptr$<$ {\bf Secondary\+Auth\+Manager} $>$ second\+Auth\+Manager)
\item 
{\bf Secondary\+Auth\+Manager} $\ast$ {\bf get\+Second\+Auth\+Manager} () const 
\item 
bool {\bf is\+Detachable} (bool check\+Socket=true) const override
\end{DoxyCompactItemize}
\subsection*{Protected Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf H\+T\+T\+P\+Session} (const {\bf Wheel\+Timer\+Instance} \&timeout, folly\+::\+Async\+Transport\+Wrapper\+::\+Unique\+Ptr sock, const folly\+::\+Socket\+Address \&{\bf local\+Addr}, const folly\+::\+Socket\+Address \&{\bf peer\+Addr}, {\bf H\+T\+T\+P\+Session\+Controller} $\ast$controller, std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Codec} $>$ codec, const wangle\+::\+Transport\+Info \&tinfo, {\bf Info\+Callback} $\ast$info\+Callback)
\item 
{\bf H\+T\+T\+P\+Session} (folly\+::\+H\+H\+Wheel\+Timer $\ast$transaction\+Timeouts, folly\+::\+Async\+Transport\+Wrapper\+::\+Unique\+Ptr sock, const folly\+::\+Socket\+Address \&{\bf local\+Addr}, const folly\+::\+Socket\+Address \&{\bf peer\+Addr}, {\bf H\+T\+T\+P\+Session\+Controller} $\ast$controller, std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Codec} $>$ codec, const wangle\+::\+Transport\+Info \&tinfo, {\bf Info\+Callback} $\ast$info\+Callback)
\item 
{\bf $\sim$\+H\+T\+T\+P\+Session} () override
\item 
virtual void {\bf setup\+On\+Headers\+Complete} ({\bf H\+T\+T\+P\+Transaction} $\ast$txn, {\bf H\+T\+T\+P\+Message} $\ast$msg)=0
\item 
virtual {\bf H\+T\+T\+P\+Transaction\+::\+Handler} $\ast$ {\bf get\+Transaction\+Timeout\+Handler} ({\bf H\+T\+T\+P\+Transaction} $\ast$txn)=0
\item 
virtual void {\bf on\+Headers\+Sent} (const {\bf H\+T\+T\+P\+Message} \&, bool)
\item 
virtual bool {\bf all\+Transactions\+Started} () const =0
\item 
void {\bf set\+New\+Transaction\+Pause\+State} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} {\bf stream\+ID})
\item 
void {\bf on\+Egress\+Message\+Finished} ({\bf H\+T\+T\+P\+Transaction} $\ast$txn, bool with\+R\+ST=false)
\item 
std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ {\bf get\+Next\+To\+Send} (bool $\ast$cork, bool $\ast$eom)
\item 
void {\bf decrement\+Transaction\+Count} ({\bf H\+T\+T\+P\+Transaction} $\ast$txn, bool ingress\+E\+OM, bool egress\+E\+OM)
\item 
size\+\_\+t {\bf get\+Codec\+Send\+Window\+Size} () const 
\item 
size\+\_\+t {\bf send\+Priority\+Impl} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} {\bf stream\+ID}, {\bf http2\+::\+Priority\+Update} pri)
\item 
bool {\bf on\+Native\+Protocol\+Upgrade\+Impl} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} txn, std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Codec} $>$ codec, const std\+::string \&protocol\+String)
\item 
virtual folly\+::\+Optional$<$ const {\bf H\+T\+T\+P\+Message\+::\+H\+T\+T\+P\+Priority} $>$ {\bf get\+H\+T\+T\+P\+Priority} (uint8\+\_\+t) override
\item 
void {\bf read\+Timeout\+Expired} () noexcept
\item 
void {\bf write\+Timeout\+Expired} () noexcept
\item 
void {\bf flow\+Control\+Timeout\+Expired} () noexcept
\item 
void {\bf get\+Read\+Buffer} (void $\ast$$\ast$buf, size\+\_\+t $\ast$buf\+Size) override
\item 
void {\bf read\+Data\+Available} (size\+\_\+t read\+Size) noexceptoverride
\item 
bool {\bf is\+Buffer\+Movable} () noexceptoverride
\item 
void {\bf read\+Buffer\+Available} (std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$) noexceptoverride
\item 
void {\bf process\+Read\+Data} ()
\item 
void {\bf read\+E\+OF} () noexceptoverride
\item 
void {\bf read\+Err} (const folly\+::\+Async\+Socket\+Exception \&) noexceptoverride
\item 
std\+::string {\bf get\+Security\+Protocol} () const override
\item 
void {\bf on\+Message\+Begin} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} {\bf stream\+ID}, {\bf H\+T\+T\+P\+Message} $\ast$msg) override
\item 
void {\bf on\+Push\+Message\+Begin} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} {\bf stream\+ID}, {\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} assoc\+Stream\+ID, {\bf H\+T\+T\+P\+Message} $\ast$msg) override
\item 
void {\bf on\+Ex\+Message\+Begin} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} {\bf stream\+ID}, {\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} control\+Stream, bool unidirectional, {\bf H\+T\+T\+P\+Message} $\ast$msg) override
\item 
void {\bf on\+Headers\+Complete} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} {\bf stream\+ID}, std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Message} $>$ msg) override
\item 
void {\bf on\+Body} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} {\bf stream\+ID}, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ chain, uint16\+\_\+t padding) override
\item 
void {\bf on\+Chunk\+Header} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} {\bf stream}, size\+\_\+t length) override
\item 
void {\bf on\+Chunk\+Complete} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} {\bf stream}) override
\item 
void {\bf on\+Trailers\+Complete} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} {\bf stream\+ID}, std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Headers} $>$ trailers) override
\item 
void {\bf on\+Message\+Complete} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} {\bf stream\+ID}, bool upgrade) override
\item 
void {\bf on\+Error} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} {\bf stream\+ID}, const {\bf H\+T\+T\+P\+Exception} \&error, bool new\+Txn) override
\item 
void {\bf on\+Abort} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} {\bf stream\+ID}, {\bf Error\+Code} code) override
\item 
void {\bf on\+Goaway} (uint64\+\_\+t last\+Good\+Stream\+ID, {\bf Error\+Code} code, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ debug\+Data={\bf nullptr}) override
\item 
void {\bf on\+Ping\+Request} (uint64\+\_\+t unique\+ID) override
\item 
void {\bf on\+Ping\+Reply} (uint64\+\_\+t unique\+ID) override
\item 
void {\bf on\+Window\+Update} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} {\bf stream}, uint32\+\_\+t amount) override
\item 
void {\bf on\+Settings} (const {\bf Settings\+List} \&{\bf settings}) override
\item 
void {\bf on\+Settings\+Ack} () override
\item 
void {\bf on\+Priority} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} {\bf stream}, const {\bf H\+T\+T\+P\+Message\+::\+H\+T\+T\+P\+Priority} \&) override
\item 
void {\bf on\+Certificate\+Request} (uint16\+\_\+t request\+Id, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ auth\+Request) override
\item 
void {\bf on\+Certificate} (uint16\+\_\+t cert\+Id, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ authenticator) override
\item 
uint32\+\_\+t {\bf num\+Outgoing\+Streams} () const override
\item 
uint32\+\_\+t {\bf num\+Incoming\+Streams} () const override
\item 
void {\bf pause\+Ingress} ({\bf H\+T\+T\+P\+Transaction} $\ast$txn) noexceptoverride
\item 
void {\bf resume\+Ingress} ({\bf H\+T\+T\+P\+Transaction} $\ast$txn) noexceptoverride
\item 
void {\bf transaction\+Timeout} ({\bf H\+T\+T\+P\+Transaction} $\ast$txn) noexceptoverride
\item 
void {\bf send\+Headers} ({\bf H\+T\+T\+P\+Transaction} $\ast$txn, const {\bf H\+T\+T\+P\+Message} \&headers, {\bf H\+T\+T\+P\+Header\+Size} $\ast$size, bool include\+E\+OM) noexceptoverride
\item 
size\+\_\+t {\bf send\+Body} ({\bf H\+T\+T\+P\+Transaction} $\ast$txn, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$, bool include\+E\+OM, bool track\+Last\+Byte\+Flushed) noexceptoverride
\item 
size\+\_\+t {\bf send\+Chunk\+Header} ({\bf H\+T\+T\+P\+Transaction} $\ast$txn, size\+\_\+t length) noexceptoverride
\item 
size\+\_\+t {\bf send\+Chunk\+Terminator} ({\bf H\+T\+T\+P\+Transaction} $\ast$txn) noexceptoverride
\item 
size\+\_\+t {\bf send\+E\+OM} ({\bf H\+T\+T\+P\+Transaction} $\ast$txn, const {\bf H\+T\+T\+P\+Headers} $\ast$trailers) noexceptoverride
\item 
size\+\_\+t {\bf send\+Abort} ({\bf H\+T\+T\+P\+Transaction} $\ast$txn, {\bf Error\+Code} {\bf status\+Code}) noexceptoverride
\item 
size\+\_\+t {\bf send\+Priority} ({\bf H\+T\+T\+P\+Transaction} $\ast$txn, const {\bf http2\+::\+Priority\+Update} \&pri) noexceptoverride
\item 
void {\bf detach} ({\bf H\+T\+T\+P\+Transaction} $\ast$txn) noexceptoverride
\item 
size\+\_\+t {\bf send\+Window\+Update} ({\bf H\+T\+T\+P\+Transaction} $\ast$txn, uint32\+\_\+t bytes) noexceptoverride
\item 
void {\bf notify\+Pending\+Egress} () noexceptoverride
\item 
void {\bf notify\+Ingress\+Body\+Processed} (uint32\+\_\+t bytes) noexceptoverride
\item 
void {\bf notify\+Egress\+Body\+Buffered} (int64\+\_\+t bytes) noexceptoverride
\item 
{\bf H\+T\+T\+P\+Transaction} $\ast$ {\bf new\+Pushed\+Transaction} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} assoc\+Stream\+Id, {\bf H\+T\+T\+P\+Transaction\+::\+Push\+Handler} $\ast$handler) noexceptoverride
\item 
{\bf H\+T\+T\+P\+Transaction} $\ast$ {\bf new\+Ex\+Transaction} ({\bf H\+T\+T\+P\+Transaction\+::\+Handler} $\ast$handler, {\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} control\+Stream, bool unidirectional=false) noexceptoverride
\item 
const {\bf H\+T\+T\+P\+Codec} \& {\bf get\+Codec} () const noexceptoverride
\item 
const folly\+::\+Async\+Transport\+Wrapper $\ast$ {\bf get\+Underlying\+Transport} () const noexceptoverride
\item 
bool {\bf is\+Draining} () const override
\item 
void {\bf drain} () override
\item 
void {\bf shutdown\+Transport} (bool shutdown\+Reads=true, bool shutdown\+Writes=true, const std\+::string \&error\+Msg=\char`\"{}\char`\"{})
\item 
void {\bf shutdown\+Transport\+With\+Reset} ({\bf Proxygen\+Error} error\+Code, const std\+::string \&error\+Msg=\char`\"{}\char`\"{})
\item 
void {\bf run\+Loop\+Callback} () noexceptoverride
\item 
void {\bf schedule\+Write} ()
\item 
void {\bf update\+Write\+Count} ()
\item 
void {\bf update\+Write\+Buf\+Size} (int64\+\_\+t delta)
\item 
uint64\+\_\+t {\bf session\+Byte\+Offset} ()
\item 
void {\bf immediate\+Shutdown} ()
\item 
void {\bf check\+For\+Shutdown} ()
\item 
{\bf H\+T\+T\+P\+Transaction} $\ast$ {\bf find\+Transaction} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} {\bf stream\+ID})
\item 
{\bf H\+T\+T\+P\+Transaction} $\ast$ {\bf create\+Transaction} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} {\bf stream\+ID}, const folly\+::\+Optional$<$ {\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} $>$ \&assoc\+Stream\+ID, const folly\+::\+Optional$<$ {\bf H\+T\+T\+P\+Codec\+::\+Ex\+Attributes} $>$ \&ex\+Attributes, const {\bf http2\+::\+Priority\+Update} \&priority={\bf http2\+::\+Default\+Priority})
\item 
void {\bf on\+Write\+Success} (uint64\+\_\+t bytes\+Written)
\item 
void {\bf on\+Write\+Error} (size\+\_\+t bytes\+Written, const folly\+::\+Async\+Socket\+Exception \&ex)
\item 
void {\bf on\+Write\+Completed} ()
\item 
void {\bf pause\+Reads} ()
\item 
void {\bf on\+Session\+Parse\+Error} (const {\bf H\+T\+T\+P\+Exception} \&error)
\item 
void {\bf on\+New\+Transaction\+Parse\+Error} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} {\bf stream\+ID}, const {\bf H\+T\+T\+P\+Exception} \&error)
\item 
void {\bf resume\+Reads} ()
\item 
bool {\bf has\+More\+Writes} () const 
\item 
{\footnotesize template$<$typename... Args1, typename... Args2$>$ }\\void {\bf invoke\+On\+All\+Transactions} (void(H\+T\+T\+P\+Transaction\+::$\ast$fn)(Args1...), Args2 \&\&...args)
\item 
void {\bf resume\+Transactions} ()
\item 
void {\bf error\+On\+All\+Transactions} ({\bf Proxygen\+Error} err, const std\+::string \&error\+Msg)
\item 
void {\bf error\+On\+Transaction\+Ids} (const std\+::vector$<$ {\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} $>$ \&ids, {\bf Proxygen\+Error} err, const std\+::string \&extra\+Error\+Msg=\char`\"{}\char`\"{})
\item 
void {\bf error\+On\+Transaction\+Id} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} id, {\bf H\+T\+T\+P\+Exception} ex)
\item 
bool {\bf should\+Shutdown} () const 
\item 
void {\bf drain\+Impl} ()
\item 
void {\bf pause\+Reads\+Impl} ()
\item 
void {\bf resume\+Reads\+Impl} ()
\item 
bool {\bf reads\+Unpaused} () const 
\item 
bool {\bf reads\+Paused} () const 
\item 
bool {\bf reads\+Shutdown} () const 
\item 
bool {\bf writes\+Unpaused} () const 
\item 
bool {\bf writes\+Paused} () const 
\item 
bool {\bf writes\+Shutdown} () const 
\item 
void {\bf reschedule\+Loop\+Callbacks} ()
\item 
void {\bf cancel\+Loop\+Callbacks} ()
\end{DoxyCompactItemize}
\subsection*{Protected Attributes}
\begin{DoxyCompactItemize}
\item 
{\bf Write\+Timeout} {\bf write\+Timeout\+\_\+}
\item 
folly\+::\+I\+O\+Buf\+Queue {\bf write\+Buf\+\_\+} \{folly\+::\+I\+O\+Buf\+Queue\+::cache\+Chain\+Length()\}
\item 
folly\+::\+I\+O\+Buf\+Queue {\bf read\+Buf\+\_\+} \{folly\+::\+I\+O\+Buf\+Queue\+::cache\+Chain\+Length()\}
\item 
{\bf H\+T\+T\+P2\+Priority\+Queue} {\bf txn\+Egress\+Queue\+\_\+}
\item 
std\+::map$<$ {\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}, {\bf H\+T\+T\+P\+Transaction} $>$ {\bf transactions\+\_\+}
\item 
uint32\+\_\+t {\bf live\+Transactions\+\_\+} \{0\}
\item 
folly\+::\+Async\+Transport\+Wrapper\+::\+Unique\+Ptr {\bf sock\+\_\+}
\item 
{\bf Wheel\+Timer\+Instance} {\bf timeout\+\_\+}
\item 
unsigned {\bf num\+Active\+Writes\+\_\+} \{0\}
\item 
bool {\bf draining\+\_\+}\+:1
\item 
bool {\bf started\+\_\+}\+:1
\item 
bool {\bf writes\+Draining\+\_\+}\+:1
\item 
bool {\bf reset\+After\+Draining\+Writes\+\_\+}\+:1
\item 
bool {\bf ingress\+Error\+\_\+}\+:1
\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
enum {\bf Socket\+State} \{ {\bf U\+N\+P\+A\+U\+S\+ED} = 0, 
{\bf P\+A\+U\+S\+ED} = 1, 
{\bf S\+H\+U\+T\+D\+O\+WN} = 2
 \}
\item 
using {\bf Write\+Segment\+List} = folly\+::\+Intrusive\+List$<$ {\bf Write\+Segment},\&{\bf Write\+Segment\+::list\+Hook} $>$
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
uint32\+\_\+t {\bf get\+Max\+Concurrent\+Outgoing\+Streams\+Remote} () const override
\item 
bool {\bf is\+Upstream} () const 
\item 
bool {\bf is\+Downstream} () const 
\item 
void {\bf on\+Egress\+Buffered} () override
\item 
void {\bf on\+Egress\+Buffer\+Cleared} () override
\item 
void {\bf setup\+Codec} ()
\item 
void {\bf on\+Set\+Send\+Window} (uint32\+\_\+t window\+Size)
\item 
void {\bf on\+Set\+Max\+Initiated\+Streams} (uint32\+\_\+t max\+Txns)
\item 
uint32\+\_\+t {\bf get\+Cert\+Auth\+Setting\+Val} ()
\item 
bool {\bf verify\+Cert\+Auth\+Setting} (uint32\+\_\+t value)
\item 
void {\bf add\+Last\+Byte\+Event} ({\bf H\+T\+T\+P\+Transaction} $\ast$txn, uint64\+\_\+t byte\+No) noexcept
\item 
void {\bf add\+Ack\+To\+Last\+Byte\+Event} ({\bf H\+T\+T\+P\+Transaction} $\ast$txn, const {\bf Byte\+Event} \&last\+Byte\+Event)
\item 
void {\bf on\+Connection\+Send\+Window\+Open} () override
\item 
void {\bf on\+Connection\+Send\+Window\+Closed} () override
\item 
{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} {\bf get\+Graceful\+Goaway\+Ack} () const 
\item 
void {\bf invalid\+Stream} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} {\bf stream}, {\bf Error\+Code} code={\bf Error\+Code\+::\+\_\+\+S\+P\+D\+Y\+\_\+\+I\+N\+V\+A\+L\+I\+D\+\_\+\+S\+T\+R\+E\+AM})
\item 
{\bf http2\+::\+Priority\+Update} {\bf get\+Message\+Priority} (const {\bf H\+T\+T\+P\+Message} $\ast$msg)
\item 
bool {\bf is\+Conn\+Window\+Full} () const 
\item 
void {\bf on\+Ping\+Reply\+Latency} (int64\+\_\+t latency) noexceptoverride
\item 
void {\bf on\+Last\+Byte\+Event} ({\bf H\+T\+T\+P\+Transaction} $\ast$txn, uint64\+\_\+t offset, bool eom\+Tracked) noexceptoverride
\item 
void {\bf on\+Delete\+Ack\+Event} () noexceptoverride
\item 
void {\bf common\+Eom} ({\bf H\+T\+T\+P\+Transaction} $\ast$txn, size\+\_\+t encoded\+Size, bool piggybacked) noexcept
\item 
void {\bf add\+Waiting\+For\+Replay\+Safety} (Replay\+Safety\+Callback $\ast$callback) noexceptoverride
\item 
void {\bf remove\+Waiting\+For\+Replay\+Safety} (Replay\+Safety\+Callback $\ast$callback) noexceptoverride
\item 
bool {\bf need\+To\+Block\+For\+Replay\+Safety} () const override
\item 
void {\bf on\+Replay\+Safe} () noexceptoverride
\item 
size\+\_\+t {\bf get\+Pipeline\+Stream\+Count} () const 
\item 
bool {\bf maybe\+Resume\+Paused\+Pipelined\+Transaction} (size\+\_\+t old\+Stream\+Count, uint32\+\_\+t txn\+Seqn)
\item 
void {\bf increment\+Outgoing\+Streams} ()
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::list$<$ Replay\+Safety\+Callback $\ast$ $>$ {\bf waiting\+For\+Replay\+Safety\+\_\+}
\item 
{\bf Write\+Segment\+List} {\bf pending\+Writes\+\_\+}
\item 
{\bf Flow\+Control\+Filter} $\ast$ {\bf conn\+Flow\+Control\+\_\+} \{{\bf nullptr}\}
\item 
uint32\+\_\+t {\bf max\+Concurrent\+Outgoing\+Streams\+Remote\+\_\+} \{100000\}
\item 
uint32\+\_\+t {\bf max\+Concurrent\+Incoming\+Streams\+\_\+} \{100\}
\item 
uint32\+\_\+t {\bf outgoing\+Streams\+\_\+} \{0\}
\item 
uint32\+\_\+t {\bf incoming\+Streams\+\_\+} \{0\}
\item 
uint64\+\_\+t {\bf bytes\+Written\+\_\+} \{0\}
\item 
uint64\+\_\+t {\bf bytes\+Scheduled\+\_\+} \{0\}
\item 
int64\+\_\+t {\bf pending\+Write\+Size\+Delta\+\_\+} \{0\}
\item 
uint64\+\_\+t {\bf body\+Bytes\+Per\+Write\+Buf\+\_\+} \{0\}
\item 
{\bf H\+T\+T\+P2\+Priority\+Queue\+::\+Next\+Egress\+Result} {\bf next\+Egress\+Results\+\_\+}
\item 
std\+::shared\+\_\+ptr$<$ {\bf Byte\+Event\+Tracker} $>$ {\bf byte\+Event\+Tracker\+\_\+} \{{\bf nullptr}\}
\item 
uint64\+\_\+t {\bf egress\+Bytes\+Limit\+\_\+} \{0\}
\item 
size\+\_\+t {\bf initial\+Receive\+Window\+\_\+} \{0\}
\item 
size\+\_\+t {\bf receive\+Stream\+Window\+Size\+\_\+} \{0\}
\item 
size\+\_\+t {\bf receive\+Session\+Window\+Size\+\_\+} \{0\}
\item 
std\+::unique\+\_\+ptr$<$ {\bf Shutdown\+Transport\+Callback} $>$ {\bf shutdown\+Transport\+Cb\+\_\+}
\item 
{\bf Flow\+Control\+Timeout} {\bf flow\+Control\+Timeout\+\_\+}
\item 
{\bf Drain\+Timeout} {\bf drain\+Timeout\+\_\+}
\item 
{\bf Socket\+State} {\bf reads\+\_\+}\+:2
\item 
{\bf Socket\+State} {\bf writes\+\_\+}\+:2
\item 
bool {\bf ingress\+Upgraded\+\_\+}\+:1
\item 
bool {\bf reset\+Socket\+On\+Shutdown\+\_\+}\+:1
\item 
bool {\bf in\+Loop\+Callback\+\_\+}\+:1
\item 
bool {\bf in\+Resume\+\_\+}\+:1
\item 
bool {\bf pending\+Pause\+\_\+}\+:1
\item 
std\+::unique\+\_\+ptr$<$ {\bf Secondary\+Auth\+Manager} $>$ {\bf second\+Auth\+Manager\+\_\+}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}


Definition at line 43 of file H\+T\+T\+P\+Session.\+h.



\subsection{Member Typedef Documentation}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!Unique\+Ptr@{Unique\+Ptr}}
\index{Unique\+Ptr@{Unique\+Ptr}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{Unique\+Ptr}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::\+H\+T\+T\+P\+Session\+::\+Unique\+Ptr} =  std\+::unique\+\_\+ptr$<${\bf H\+T\+T\+P\+Session}, Destructor$>$}\label{classproxygen_1_1HTTPSession_ad099bb84051caa91e5ed30e309a8e524}


Definition at line 55 of file H\+T\+T\+P\+Session.\+h.

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!Write\+Segment\+List@{Write\+Segment\+List}}
\index{Write\+Segment\+List@{Write\+Segment\+List}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{Write\+Segment\+List}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+List} =  folly\+::\+Intrusive\+List$<${\bf Write\+Segment}, \&{\bf Write\+Segment\+::list\+Hook}$>$\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_ad873fa3dc448235a6d181726acb09083}


Definition at line 909 of file H\+T\+T\+P\+Session.\+h.



\subsection{Member Enumeration Documentation}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!Socket\+State@{Socket\+State}}
\index{Socket\+State@{Socket\+State}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{Socket\+State}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+H\+T\+T\+P\+Session\+::\+Socket\+State}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_ad288f49c7e19dd6f77c495534207b088}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{U\+N\+P\+A\+U\+S\+ED@{U\+N\+P\+A\+U\+S\+ED}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!U\+N\+P\+A\+U\+S\+ED@{U\+N\+P\+A\+U\+S\+ED}}\item[{\em 
U\+N\+P\+A\+U\+S\+ED\label{classproxygen_1_1HTTPSession_ad288f49c7e19dd6f77c495534207b088a04c6aa065c3d808e1a312a5603991056}
}]\index{P\+A\+U\+S\+ED@{P\+A\+U\+S\+ED}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!P\+A\+U\+S\+ED@{P\+A\+U\+S\+ED}}\item[{\em 
P\+A\+U\+S\+ED\label{classproxygen_1_1HTTPSession_ad288f49c7e19dd6f77c495534207b088ae2204ef6c34fe2fb6089476f72c33599}
}]\index{S\+H\+U\+T\+D\+O\+WN@{S\+H\+U\+T\+D\+O\+WN}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!S\+H\+U\+T\+D\+O\+WN@{S\+H\+U\+T\+D\+O\+WN}}\item[{\em 
S\+H\+U\+T\+D\+O\+WN\label{classproxygen_1_1HTTPSession_ad288f49c7e19dd6f77c495534207b088a0950955a2c19cce39c01d459e1a82989}
}]\end{description}
\end{Desc}


Definition at line 1037 of file H\+T\+T\+P\+Session.\+h.


\begin{DoxyCode}
1037                    \{
1038     UNPAUSED = 0,
1039     PAUSED = 1,
1040     SHUTDOWN = 2,
1041   \};
\end{DoxyCode}


\subsection{Constructor \& Destructor Documentation}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!H\+T\+T\+P\+Session@{H\+T\+T\+P\+Session}}
\index{H\+T\+T\+P\+Session@{H\+T\+T\+P\+Session}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{H\+T\+T\+P\+Session(const Wheel\+Timer\+Instance \&timeout, folly\+::\+Async\+Transport\+Wrapper\+::\+Unique\+Ptr sock, const folly\+::\+Socket\+Address \&local\+Addr, const folly\+::\+Socket\+Address \&peer\+Addr, H\+T\+T\+P\+Session\+Controller $\ast$controller, std\+::unique\+\_\+ptr$<$ H\+T\+T\+P\+Codec $>$ codec, const wangle\+::\+Transport\+Info \&tinfo, Info\+Callback $\ast$info\+Callback)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+H\+T\+T\+P\+Session\+::\+H\+T\+T\+P\+Session (
\begin{DoxyParamCaption}
\item[{const {\bf Wheel\+Timer\+Instance} \&}]{timeout, }
\item[{folly\+::\+Async\+Transport\+Wrapper\+::\+Unique\+Ptr}]{sock, }
\item[{const folly\+::\+Socket\+Address \&}]{local\+Addr, }
\item[{const folly\+::\+Socket\+Address \&}]{peer\+Addr, }
\item[{{\bf H\+T\+T\+P\+Session\+Controller} $\ast$}]{controller, }
\item[{std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Codec} $>$}]{codec, }
\item[{const wangle\+::\+Transport\+Info \&}]{tinfo, }
\item[{{\bf Info\+Callback} $\ast$}]{info\+Callback}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a2a638217ec14e4c3a554e5f7a3705e73}
\doxyref{H\+T\+T\+P\+Session}{p.}{classproxygen_1_1HTTPSession} is an abstract base class and cannot be instantiated directly. If you want to handle requests and send responses (act as a server), construct a \doxyref{H\+T\+T\+P\+Downstream\+Session}{p.}{classproxygen_1_1HTTPDownstreamSession}. If you want to make requests and handle responses (act as a client), construct a \doxyref{H\+T\+T\+P\+Upstream\+Session}{p.}{classproxygen_1_1HTTPUpstreamSession}.


\begin{DoxyParams}{Parameters}
{\em transaction\+Timeouts} & Timeout for each transaction in the session. \\
\hline
{\em sock} & An open socket on which any applicable T\+LS handshaking has been completed already. \\
\hline
{\em local\+Addr} & Address and port of the local end of the socket. \\
\hline
{\em peer\+Addr} & Address and port of the remote end of the socket. \\
\hline
{\em controller} & Controller which can create the handler for a new transaction. \\
\hline
{\em codec} & A codec with which to parse/generate messages in whatever H\+T\+T\+P-\/like wire format this session needs. \\
\hline
{\em tinfo} & Struct containing the transport\textquotesingle{}s T\+C\+P/\+S\+SL level info. \\
\hline
{\em Info\+Callback} & Optional callback to be informed of session lifecycle events. \\
\hline
\end{DoxyParams}


Referenced by conn\+Close\+By\+Remote(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!H\+T\+T\+P\+Session@{H\+T\+T\+P\+Session}}
\index{H\+T\+T\+P\+Session@{H\+T\+T\+P\+Session}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{H\+T\+T\+P\+Session(folly\+::\+H\+H\+Wheel\+Timer $\ast$transaction\+Timeouts, folly\+::\+Async\+Transport\+Wrapper\+::\+Unique\+Ptr sock, const folly\+::\+Socket\+Address \&local\+Addr, const folly\+::\+Socket\+Address \&peer\+Addr, H\+T\+T\+P\+Session\+Controller $\ast$controller, std\+::unique\+\_\+ptr$<$ H\+T\+T\+P\+Codec $>$ codec, const wangle\+::\+Transport\+Info \&tinfo, Info\+Callback $\ast$info\+Callback)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+H\+T\+T\+P\+Session\+::\+H\+T\+T\+P\+Session (
\begin{DoxyParamCaption}
\item[{folly\+::\+H\+H\+Wheel\+Timer $\ast$}]{transaction\+Timeouts, }
\item[{folly\+::\+Async\+Transport\+Wrapper\+::\+Unique\+Ptr}]{sock, }
\item[{const folly\+::\+Socket\+Address \&}]{local\+Addr, }
\item[{const folly\+::\+Socket\+Address \&}]{peer\+Addr, }
\item[{{\bf H\+T\+T\+P\+Session\+Controller} $\ast$}]{controller, }
\item[{std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Codec} $>$}]{codec, }
\item[{const wangle\+::\+Transport\+Info \&}]{tinfo, }
\item[{{\bf Info\+Callback} $\ast$}]{info\+Callback}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a57528c5706f43b154e07ec638150379a}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!````~H\+T\+T\+P\+Session@{$\sim$\+H\+T\+T\+P\+Session}}
\index{````~H\+T\+T\+P\+Session@{$\sim$\+H\+T\+T\+P\+Session}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{$\sim$\+H\+T\+T\+P\+Session() override}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+H\+T\+T\+P\+Session\+::$\sim$\+H\+T\+T\+P\+Session (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a187a60444f84cc7e6354844e3c5f2e01}


Definition at line 278 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P2\+Priority\+Queue\+::drop\+Priority\+Nodes(), proxygen\+::\+H\+T\+T\+P2\+Priority\+Queue\+::empty(), flow\+Control\+Timeout\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::run\+Destroy\+Callbacks(), sock\+\_\+, transactions\+\_\+, txn\+Egress\+Queue\+\_\+, and write\+Timeout\+\_\+.



Referenced by conn\+Close\+By\+Remote().


\begin{DoxyCode}
278                           \{
279   VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" closing"};
280 
281   CHECK(transactions_.empty());
282   txnEgressQueue_.dropPriorityNodes();
283   CHECK(txnEgressQueue_.empty());
284   DCHECK(!sock_->getReadCallback());
285 
286   \textcolor{keywordflow}{if} (writeTimeout_.isScheduled()) \{
287     writeTimeout_.cancelTimeout();
288   \}
289 
290   \textcolor{keywordflow}{if} (flowControlTimeout_.isScheduled()) \{
291     flowControlTimeout_.cancelTimeout();
292   \}
293 
294   runDestroyCallbacks();
295 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!add\+Ack\+To\+Last\+Byte\+Event@{add\+Ack\+To\+Last\+Byte\+Event}}
\index{add\+Ack\+To\+Last\+Byte\+Event@{add\+Ack\+To\+Last\+Byte\+Event}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{add\+Ack\+To\+Last\+Byte\+Event(\+H\+T\+T\+P\+Transaction $\ast$txn, const Byte\+Event \&last\+Byte\+Event)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::add\+Ack\+To\+Last\+Byte\+Event (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Transaction} $\ast$}]{txn, }
\item[{const {\bf Byte\+Event} \&}]{last\+Byte\+Event}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_aa1c17d464b437d42106683ea38fcb3e9}


Referenced by get\+Max\+Concurrent\+Outgoing\+Streams\+Remote().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!add\+Last\+Byte\+Event@{add\+Last\+Byte\+Event}}
\index{add\+Last\+Byte\+Event@{add\+Last\+Byte\+Event}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{add\+Last\+Byte\+Event(\+H\+T\+T\+P\+Transaction $\ast$txn, uint64\+\_\+t byte\+No) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::add\+Last\+Byte\+Event (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Transaction} $\ast$}]{txn, }
\item[{uint64\+\_\+t}]{byte\+No}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_ac39676e76e0a700cce8f22c5d9f96f0d}


Referenced by get\+Max\+Concurrent\+Outgoing\+Streams\+Remote().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!add\+Waiting\+For\+Replay\+Safety@{add\+Waiting\+For\+Replay\+Safety}}
\index{add\+Waiting\+For\+Replay\+Safety@{add\+Waiting\+For\+Replay\+Safety}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{add\+Waiting\+For\+Replay\+Safety(\+Replay\+Safety\+Callback $\ast$callback) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::add\+Waiting\+For\+Replay\+Safety (
\begin{DoxyParamCaption}
\item[{Replay\+Safety\+Callback $\ast$}]{callback}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_a5063383ff090008d3620aa7cfc7947c1}
Add a Replay\+Safety\+Callback requesting notification when the transport has replay protection.

Most transport-\/layer security protocols (like T\+LS) provide protection against an eavesdropper capturing data, and later replaying it to the server. However, 0-\/\+R\+TT security protocols allow initial data to be sent without replay protection before the security handshake completes. This function can be used when a H\+T\+TP session is in that initial non-\/replay safe stage, but a request requires a replay safe transport. Will trigger callback synchronously if the transport is already replay safe. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_ad59fc55072f8c6dfc312abf9f39328ce}.



Definition at line 802 of file H\+T\+T\+P\+Session.\+h.



References waiting\+For\+Replay\+Safety\+\_\+.


\begin{DoxyCode}
803                                                         \{
804     \textcolor{keywordflow}{if} (sock_->isReplaySafe()) \{
805       callback->onReplaySafe();
806     \} \textcolor{keywordflow}{else} \{
807       waitingForReplaySafety_.push\_back(callback);
808     \}
809   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!all\+Transactions\+Started@{all\+Transactions\+Started}}
\index{all\+Transactions\+Started@{all\+Transactions\+Started}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{all\+Transactions\+Started() const =0}]{\setlength{\rightskip}{0pt plus 5cm}virtual bool proxygen\+::\+H\+T\+T\+P\+Session\+::all\+Transactions\+Started (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [pure virtual]}}\label{classproxygen_1_1HTTPSession_a5353997f3caf71049568ad2c460424c5}


Implemented in {\bf proxygen\+::\+H\+T\+T\+P\+Upstream\+Session} \doxyref{}{p.}{classproxygen_1_1HTTPUpstreamSession_a9dcfcdc8c22e0916ee317fbcd55ec49c}, and {\bf proxygen\+::\+H\+T\+T\+P\+Downstream\+Session} \doxyref{}{p.}{classproxygen_1_1HTTPDownstreamSession_ac4df02bf0fd27a6526aee299cee857e5}.



Referenced by drain(), on\+Headers\+Sent(), and should\+Shutdown().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!cancel\+Loop\+Callbacks@{cancel\+Loop\+Callbacks}}
\index{cancel\+Loop\+Callbacks@{cancel\+Loop\+Callbacks}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{cancel\+Loop\+Callbacks()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::cancel\+Loop\+Callbacks (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a3882f861cd96eaee8d7e853fc3639270}


Definition at line 663 of file H\+T\+T\+P\+Session.\+h.



References shutdown\+Transport\+Cb\+\_\+.



Referenced by proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::detach\+Thread\+Locals().


\begin{DoxyCode}
663                              \{
664     \textcolor{keywordflow}{if} (isLoopCallbackScheduled()) \{
665       cancelLoopCallback();
666     \}
667     \textcolor{keywordflow}{if} (shutdownTransportCb_) \{
668       shutdownTransportCb_->cancelLoopCallback();
669     \}
670   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!check\+For\+Shutdown@{check\+For\+Shutdown}}
\index{check\+For\+Shutdown@{check\+For\+Shutdown}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{check\+For\+Shutdown()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::check\+For\+Shutdown (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a51a5012bdb77ee9d24b45a075a351cdc}
Check whether the socket is shut down in both directions; if it is, initiate the destruction of this \doxyref{H\+T\+T\+P\+Session}{p.}{classproxygen_1_1HTTPSession}. 

Definition at line 2447 of file H\+T\+T\+P\+Session.\+cpp.



References reads\+\_\+, reads\+Shutdown(), reset\+Socket\+On\+Shutdown\+\_\+, proxygen\+::\+S\+H\+U\+T\+D\+O\+WN, sock\+\_\+, transactions\+\_\+, and writes\+Shutdown().



Referenced by detach(), immediate\+Shutdown(), run\+Loop\+Callback(), session\+Byte\+Offset(), shutdown\+Transport(), and shutdown\+Transport\+With\+Reset().


\begin{DoxyCode}
2447                               \{
2448   VLOG(10) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" checking for shutdown, readShutdown="}
2449            << readsShutdown() << \textcolor{stringliteral}{", writesShutdown="} << writesShutdown()
2450            << \textcolor{stringliteral}{", transaction set empty="} << transactions_.empty();
2451 
2452   \textcolor{comment}{// Two conditions are required to destroy the HTTPSession:}
2453   \textcolor{comment}{//   * All writes have been finished.}
2454   \textcolor{comment}{//   * There are no transactions remaining on the session.}
2455   \textcolor{keywordflow}{if} (writesShutdown() && transactions_.empty() &&
2456       !isLoopCallbackScheduled()) \{
2457     VLOG(4) << \textcolor{stringliteral}{"destroying "} << *\textcolor{keyword}{this};
2458     sock_->setReadCB(\textcolor{keyword}{nullptr});
2459     \textcolor{keyword}{auto} asyncSocket = sock_->getUnderlyingTransport<folly::AsyncSocket>();
2460     \textcolor{keywordflow}{if} (asyncSocket) \{
2461       asyncSocket->setBufferCallback(\textcolor{keyword}{nullptr});
2462     \}
2463     reads_ = SocketState::SHUTDOWN;
2464     \textcolor{keywordflow}{if} (resetSocketOnShutdown_) \{
2465       sock_->closeWithReset();
2466     \} \textcolor{keywordflow}{else} \{
2467       sock_->closeNow();
2468     \}
2469     destroy();
2470   \}
2471 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!close\+When\+Idle@{close\+When\+Idle}}
\index{close\+When\+Idle@{close\+When\+Idle}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{close\+When\+Idle() override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::close\+When\+Idle (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}}\label{classproxygen_1_1HTTPSession_a17a9bd92ab6c58976923ca38235d14e3}


Definition at line 464 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, drain(), drop\+Connection(), proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+Goaway(), proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Last\+Incoming\+Stream\+I\+D(), has\+More\+Writes(), is\+Busy(), proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, schedule\+Write(), and write\+Buf\+\_\+.



Referenced by Curl\+Service\+::\+Curl\+Client\+::connect\+Success(), timeout\+Expired(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Drain\+Timeout\+::timeout\+Expired().


\begin{DoxyCode}
464                            \{
465   \textcolor{comment}{// If drain() already called, this is a noop}
466   drain();
467   \textcolor{comment}{// Generate the second GOAWAY now. No-op if second GOAWAY already sent.}
468   \textcolor{keywordflow}{if} (codec_->generateGoaway(writeBuf_,
469                              codec_->getLastIncomingStreamID(),
470                              ErrorCode::NO_ERROR)) \{
471     scheduleWrite();
472   \}
473   \textcolor{keywordflow}{if} (!isBusy() && !hasMoreWrites()) \{
474     \textcolor{comment}{// if we're already idle, close now}
475     dropConnection();
476   \}
477 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!common\+Eom@{common\+Eom}}
\index{common\+Eom@{common\+Eom}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{common\+Eom(\+H\+T\+T\+P\+Transaction $\ast$txn, size\+\_\+t encoded\+Size, bool piggybacked) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::common\+Eom (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Transaction} $\ast$}]{txn, }
\item[{size\+\_\+t}]{encoded\+Size, }
\item[{bool}]{piggybacked}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_ab3772d377d80a1455b5e63a582cc04f3}
Common E\+OM process shared by send\+Headers, send\+Body and send\+E\+OM


\begin{DoxyParams}{Parameters}
{\em txn} & the transaction that\textquotesingle{}s sending request \\
\hline
{\em encoded\+Size} & size of data frame generated by codec \\
\hline
{\em piggybacked} & whether this eom is a separate send\+E\+OM or piggybacked in send\+Headers and send\+Body \\
\hline
\end{DoxyParams}


Definition at line 1664 of file H\+T\+T\+P\+Session.\+cpp.



References byte\+Event\+Tracker\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::handle\+Last\+Byte\+Events(), on\+Egress\+Message\+Finished(), and session\+Byte\+Offset().



Referenced by is\+Conn\+Window\+Full(), send\+Body(), send\+E\+O\+M(), and send\+Headers().


\begin{DoxyCode}
1667                                \{
1668   HTTPSessionBase::handleLastByteEvents(
1669     byteEventTracker_.get(), txn, encodedSize, sessionByteOffset(),
1670     piggybacked);
1671   onEgressMessageFinished(txn);
1672 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!conn\+Close\+By\+Remote@{conn\+Close\+By\+Remote}}
\index{conn\+Close\+By\+Remote@{conn\+Close\+By\+Remote}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{conn\+Close\+By\+Remote() override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::conn\+Close\+By\+Remote (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a0f17d905706699ce11d91ff621057575}
If the connection is closed by remote end 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_a271ccbb8e9438dc47040d4d78995b72c}.



Definition at line 215 of file H\+T\+T\+P\+Session.\+h.



References get\+Second\+Auth\+Manager(), get\+Transaction\+Timeout\+Handler(), get\+Transport(), H\+T\+T\+P\+Session(), is\+Detachable(), proxygen\+::local\+Addr, proxygen\+::peer\+Addr, set\+Second\+Auth\+Manager(), setup\+On\+Headers\+Complete(), and $\sim$\+H\+T\+T\+P\+Session().


\begin{DoxyCode}
215                                     \{
216     \textcolor{keyword}{auto} sock = getTransport()->getUnderlyingTransport<folly::AsyncSocket>();
217     \textcolor{keywordflow}{if} (sock) \{
218       \textcolor{keywordflow}{return} sock->isClosedByPeer();
219     \}
220     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
221   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!create\+Transaction@{create\+Transaction}}
\index{create\+Transaction@{create\+Transaction}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{create\+Transaction(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D stream\+I\+D, const folly\+::\+Optional$<$ H\+T\+T\+P\+Codec\+::\+Stream\+I\+D $>$ \&assoc\+Stream\+I\+D, const folly\+::\+Optional$<$ H\+T\+T\+P\+Codec\+::\+Ex\+Attributes $>$ \&ex\+Attributes, const http2\+::\+Priority\+Update \&priority=http2\+::\+Default\+Priority)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Transaction} $\ast$ proxygen\+::\+H\+T\+T\+P\+Session\+::create\+Transaction (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{stream\+ID, }
\item[{const folly\+::\+Optional$<$ {\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} $>$ \&}]{assoc\+Stream\+ID, }
\item[{const folly\+::\+Optional$<$ {\bf H\+T\+T\+P\+Codec\+::\+Ex\+Attributes} $>$ \&}]{ex\+Attributes, }
\item[{const {\bf http2\+::\+Priority\+Update} \&}]{priority = {\ttfamily {\bf http2\+::\+Default\+Priority}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a7dfa230066871e4512642fcc63534cd6}
Create a new transaction. \begin{DoxyReturn}{Returns}
pointer to the transaction on success, or else nullptr if it already exists 
\end{DoxyReturn}


Definition at line 2567 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, get\+Codec\+Send\+Window\+Size(), proxygen\+::\+Wheel\+Timer\+Instance\+::get\+Default\+Timeout(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+I\+D(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::get\+Num\+Txn\+Served(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+Session\+Stats(), proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Transport\+Direction(), proxygen\+::\+Wheel\+Timer\+Instance\+::get\+Wheel\+Timer(), incoming\+Streams\+\_\+, increment\+Outgoing\+Streams(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::increment\+Seq\+No(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, initial\+Receive\+Window\+\_\+, is\+Downstream(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::is\+Priority\+Sampled(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::is\+Pushed(), is\+Upstream(), live\+Transactions\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Activate\+Connection(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::on\+Create\+Transaction(), receive\+Stream\+Window\+Size\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Stats\+::record\+Session\+Reused(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::session\+Stats\+\_\+, proxygen\+::\+H\+T\+T\+P\+Transaction\+::set\+Priority\+Sampled(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::set\+Receive\+Window(), sock\+\_\+, stream\+ID, proxygen\+::\+H\+T\+T\+P\+Codec\+::supports\+Stream\+Flow\+Control(), timeout\+\_\+, transactions\+\_\+, and txn\+Egress\+Queue\+\_\+.



Referenced by new\+Ex\+Transaction(), new\+Pushed\+Transaction(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::new\+Transaction(), on\+Error(), on\+Ex\+Message\+Begin(), on\+Message\+Begin(), on\+Push\+Message\+Begin(), and session\+Byte\+Offset().


\begin{DoxyCode}
2571                                          \{
2572   \textcolor{keywordflow}{if} (!sock_->good() || transactions_.count(streamID)) \{
2573     \textcolor{comment}{// Refuse to add a transaction on a closing session or if a}
2574     \textcolor{comment}{// transaction of that ID already exists.}
2575     \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};
2576   \}
2577 
2578   \textcolor{keywordflow}{if} (transactions_.empty()) \{
2579     \textcolor{keywordflow}{if} (infoCallback_) \{
2580       infoCallback_->onActivateConnection(*\textcolor{keyword}{this});
2581     \}
2582     \textcolor{keywordflow}{if} (getConnectionManager()) \{
2583       getConnectionManager()->onActivated(*\textcolor{keyword}{this});
2584     \}
2585     HTTPSessionBase::onCreateTransaction();
2586   \}
2587 
2588   \textcolor{keyword}{auto} matchPair = transactions_.emplace(
2589     std::piecewise\_construct,
2590     std::forward\_as\_tuple(streamID),
2591     std::forward\_as\_tuple(
2592       codec_->getTransportDirection(), streamID, getNumTxnServed(), *\textcolor{keyword}{this},
2593       txnEgressQueue_, timeout_.getWheelTimer(), timeout_.getDefaultTimeout(),
2594       sessionStats_,
2595       codec_->supportsStreamFlowControl(),
2596       initialReceiveWindow_,
2597       getCodecSendWindowSize(),
2598       priority,
2599       assocStreamID,
2600       exAttributes
2601     ));
2602 
2603   CHECK(matchPair.second) << \textcolor{stringliteral}{"Emplacement failed, despite earlier "}
2604     \textcolor{stringliteral}{"existence check."};
2605 
2606   HTTPTransaction* txn = &matchPair.first->second;
2607 
2608   \textcolor{keywordflow}{if} (isPrioritySampled()) \{
2609     txn->setPrioritySampled(\textcolor{keyword}{true} \textcolor{comment}{/* sampled */});
2610   \}
2611 
2612   \textcolor{keywordflow}{if} (getNumTxnServed() > 0) \{
2613     \textcolor{keyword}{auto} stats = txn->getSessionStats();
2614     \textcolor{keywordflow}{if} (stats != \textcolor{keyword}{nullptr}) \{
2615       stats->recordSessionReused();
2616     \}
2617   \}
2618 
2619   VLOG(5) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" adding streamID="} << txn->getID()
2620           << \textcolor{stringliteral}{", liveTransactions\_ was "} << liveTransactions_;
2621 
2622   ++liveTransactions_;
2623   incrementSeqNo();
2624   txn->setReceiveWindow(receiveStreamWindowSize_);
2625 
2626   \textcolor{keywordflow}{if} (isUpstream() && !txn->isPushed()) \{
2627     incrementOutgoingStreams();
2628   \textcolor{comment}{// do not count towards MAX\_CONCURRENT\_STREAMS for PUSH\_PROMISE}
2629   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!(isDownstream() && txn->isPushed())) \{
2630     incomingStreams_++;
2631   \}
2632 
2633   \textcolor{keywordflow}{return} txn;
2634 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!decrement\+Transaction\+Count@{decrement\+Transaction\+Count}}
\index{decrement\+Transaction\+Count@{decrement\+Transaction\+Count}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{decrement\+Transaction\+Count(\+H\+T\+T\+P\+Transaction $\ast$txn, bool ingress\+E\+O\+M, bool egress\+E\+O\+M)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::decrement\+Transaction\+Count (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Transaction} $\ast$}]{txn, }
\item[{bool}]{ingress\+E\+OM, }
\item[{bool}]{egress\+E\+OM}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a2e8db93bfcc5b41ec095428c62f23c95}


Definition at line 1866 of file H\+T\+T\+P\+Session.\+cpp.



References incoming\+Streams\+\_\+, is\+Downstream(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::is\+Pushed(), is\+Upstream(), outgoing\+Streams\+\_\+, and proxygen\+::\+H\+T\+T\+P\+Transaction\+::test\+And\+Clear\+Active().



Referenced by detach(), on\+Egress\+Message\+Finished(), on\+Headers\+Sent(), and on\+Message\+Complete().


\begin{DoxyCode}
1868                                                             \{
1869   \textcolor{keywordflow}{if} ((isUpstream() && !txn->isPushed()) ||
1870       (isDownstream() && txn->isPushed())) \{
1871     \textcolor{keywordflow}{if} (ingressEOM && txn->testAndClearActive()) \{
1872       outgoingStreams_--;
1873     \}
1874   \} \textcolor{keywordflow}{else} \{
1875     \textcolor{keywordflow}{if} (egressEOM && txn->testAndClearActive()) \{
1876       incomingStreams_--;
1877     \}
1878   \}
1879 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!describe@{describe}}
\index{describe@{describe}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{describe(std\+::ostream \&os) const override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::describe (
\begin{DoxyParamCaption}
\item[{std\+::ostream \&}]{os}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_aa266c1a755e4fac09edf6f1e0deba8c1}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_ab1907c602f4948511e3c2f4268446364}.



Definition at line 435 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::get\+Codec\+Protocol\+String(), get\+Local\+Address(), get\+Peer\+Address(), proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Protocol(), proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+User\+Agent(), and is\+Downstream().



Referenced by timeout\+Expired().


\begin{DoxyCode}
435                                           \{
436   os << \textcolor{stringliteral}{"proto="} << getCodecProtocolString(codec_->getProtocol());
437   \textcolor{keywordflow}{if} (isDownstream()) \{
438     os << \textcolor{stringliteral}{", UA="} << codec_->getUserAgent()
439        << \textcolor{stringliteral}{", downstream="} << getPeerAddress() << \textcolor{stringliteral}{", "} << getLocalAddress()
440        << \textcolor{stringliteral}{"=local"};
441   \} \textcolor{keywordflow}{else} \{
442     os << \textcolor{stringliteral}{", local="} << getLocalAddress() << \textcolor{stringliteral}{", "} << getPeerAddress()
443        << \textcolor{stringliteral}{"=upstream"};
444   \}
445 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!detach@{detach}}
\index{detach@{detach}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{detach(\+H\+T\+T\+P\+Transaction $\ast$txn) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::detach (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Transaction} $\ast$}]{txn}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_a0cc489b64c47726cfb97f2b2d750b590}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_ad3a4d2e4b5ea45e424ce6eae07ba4c3f}.



Definition at line 1904 of file H\+T\+T\+P\+Session.\+cpp.



References check\+For\+Shutdown(), decrement\+Transaction\+Count(), find\+Transaction(), get\+Pipeline\+Stream\+Count(), has\+More\+Writes(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, live\+Transactions\+\_\+, maybe\+Resume\+Paused\+Pipelined\+Transaction(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Deactivate\+Connection(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Transaction\+Detached(), reads\+Shutdown(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::remove\+Ex\+Transaction(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::remove\+Pushed\+Transaction(), resume\+Ingress(), resume\+Reads(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::set\+Latest\+Active(), should\+Shutdown(), shutdown\+Transport(), stream\+ID, transactions\+\_\+, writes\+Draining\+\_\+, and writes\+Shutdown().



Referenced by proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::detach\+Transactions(), num\+Incoming\+Streams(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::set\+E\+O\+R().


\begin{DoxyCode}
1904                                                  \{
1905   DestructorGuard guard(\textcolor{keyword}{this});
1906   HTTPCodec::StreamID streamID = txn->getID();
1907   \textcolor{keyword}{auto} txnSeqn = txn->getSequenceNumber();
1908   \textcolor{keyword}{auto} it = transactions_.find(txn->getID());
1909   DCHECK(it != transactions_.end());
1910 
1911   \textcolor{keywordflow}{if} (txn->isIngressPaused()) \{
1912     \textcolor{comment}{// Someone detached a transaction that was paused.  Make the resumeIngress}
1913     \textcolor{comment}{// call to keep liveTransactions\_ in order}
1914     VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" detached paused transaction="} << streamID;
1915     resumeIngress(txn);
1916   \}
1917 
1918   VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" removing streamID="} << streamID <<
1919     \textcolor{stringliteral}{", liveTransactions was "} << liveTransactions_;
1920   CHECK\_GT(liveTransactions\_, 0);
1921   liveTransactions\_--;
1922 
1923   \textcolor{keywordflow}{if} (txn->isPushed()) \{
1924     \textcolor{keyword}{auto} assocTxn = findTransaction(*txn->getAssocTxnId());
1925     \textcolor{keywordflow}{if} (assocTxn) \{
1926       assocTxn->removePushedTransaction(streamID);
1927     \}
1928   \}
1929   \textcolor{keywordflow}{if} (txn->getControlStream()) \{
1930     \textcolor{keyword}{auto} controlTxn = findTransaction(*txn->getControlStream());
1931     \textcolor{keywordflow}{if} (controlTxn) \{
1932       controlTxn->removeExTransaction(streamID);
1933     \}
1934   \}
1935 
1936   \textcolor{keyword}{auto} oldStreamCount = getPipelineStreamCount();
1937   decrementTransactionCount(txn, \textcolor{keyword}{true}, \textcolor{keyword}{true});
1938   transactions_.erase(it);
1939 
1940   \textcolor{keywordflow}{if} (transactions_.empty()) \{
1941     HTTPSessionBase::setLatestActive();
1942     \textcolor{keywordflow}{if} (infoCallback_) \{
1943       infoCallback_->onDeactivateConnection(*\textcolor{keyword}{this});
1944     \}
1945     \textcolor{keywordflow}{if} (getConnectionManager()) \{
1946       getConnectionManager()->onDeactivated(*\textcolor{keyword}{this});
1947     \}
1948   \} \textcolor{keywordflow}{else} \{
1949     \textcolor{keywordflow}{if} (infoCallback_) \{
1950       infoCallback_->onTransactionDetached(*\textcolor{keyword}{this});
1951     \}
1952   \}
1953 
1954   \textcolor{keywordflow}{if} (!readsShutdown()) \{
1955     \textcolor{keywordflow}{if} (maybeResumePausedPipelinedTransaction(oldStreamCount, txnSeqn)) \{
1956       \textcolor{keywordflow}{return};
1957     \} \textcolor{keywordflow}{else} \{
1958       \textcolor{comment}{// this will resume reads if they were paused (eg: 0 HTTP transactions)}
1959       resumeReads();
1960     \}
1961   \}
1962 
1963   \textcolor{keywordflow}{if} (liveTransactions\_ == 0 && transactions_.empty() && !isScheduled()) \{
1964     resetTimeout();
1965   \}
1966 
1967   \textcolor{comment}{// It's possible that this is the last transaction in the session,}
1968   \textcolor{comment}{// so check whether the conditions for shutdown are satisfied.}
1969   \textcolor{keywordflow}{if} (transactions_.empty()) \{
1970     \textcolor{keywordflow}{if} (shouldShutdown()) \{
1971       writesDraining_ = \textcolor{keyword}{true};
1972     \}
1973     \textcolor{comment}{// Handle the case where we are draining writes but all remaining}
1974     \textcolor{comment}{// transactions terminated with no egress.}
1975     \textcolor{keywordflow}{if} (writesDraining_ && !writesShutdown() && !hasMoreWrites()) \{
1976       shutdownTransport(\textcolor{keyword}{false}, \textcolor{keyword}{true});
1977       \textcolor{keywordflow}{return};
1978     \}
1979   \}
1980   checkForShutdown();
1981 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!drain@{drain}}
\index{drain@{drain}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{drain() override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::drain (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a7cf098767599f9b93dced643dd996efb}
Drains the current transactions and prevents new transactions from being created on this session. If this is an upstream session and the number of transactions reaches zero, this session will shutdown the transport and delete itself. For downstream sessions, an explicit call to \doxyref{drop\+Connection()}{p.}{classproxygen_1_1HTTPSession_a60c801ba3d005b715d85661d0ab5e50f} or \doxyref{shutdown\+Transport()}{p.}{classproxygen_1_1HTTPSession_a7773c16e03030dca8e168a2e41564335} is required. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_a840a10b132ba952fedbd8af8aac1692d}.



Reimplemented in {\bf proxygen\+::\+H\+T\+T\+P\+Upstream\+Session} \doxyref{}{p.}{classproxygen_1_1HTTPUpstreamSession_a3fb9c14db09f1ddae0e6b30ad783516b}.



Definition at line 2474 of file H\+T\+T\+P\+Session.\+cpp.



References all\+Transactions\+Started(), drain\+Impl(), draining\+\_\+, is\+Upstream(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::set\+Close\+Reason(), proxygen\+::\+S\+H\+U\+T\+D\+O\+WN, shutdown\+Transport(), and transactions\+\_\+.



Referenced by close\+When\+Idle(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::drain(), is\+Draining(), notify\+Pending\+Shutdown(), and on\+Goaway().


\begin{DoxyCode}
2474                    \{
2475   \textcolor{keywordflow}{if} (!draining_) \{
2476     VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" draining"};
2477     draining_ = \textcolor{keyword}{true};
2478     setCloseReason(ConnectionCloseReason::SHUTDOWN);
2479 
2480     \textcolor{keywordflow}{if} (allTransactionsStarted()) \{
2481       drainImpl();
2482     \}
2483     \textcolor{keywordflow}{if} (transactions_.empty() && isUpstream()) \{
2484       \textcolor{comment}{// We don't do this for downstream since we need to wait for}
2485       \textcolor{comment}{// inflight requests to arrive}
2486       VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" shutdown from drain"};
2487       shutdownTransport(\textcolor{keyword}{true}, \textcolor{keyword}{true});
2488     \}
2489   \} \textcolor{keywordflow}{else} \{
2490     VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" already draining"};
2491   \}
2492 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!drain\+Impl@{drain\+Impl}}
\index{drain\+Impl@{drain\+Impl}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{drain\+Impl()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::drain\+Impl (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a6047ce6e7eea6982b1e2652eaf8ad95c}


Definition at line 2494 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+Goaway(), get\+Graceful\+Goaway\+Ack(), proxygen\+::\+H\+T\+T\+P\+Codec\+::is\+Reusable(), proxygen\+::\+H\+T\+T\+P\+Codec\+::is\+Waiting\+To\+Drain(), proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, schedule\+Write(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::set\+Close\+Reason(), proxygen\+::\+S\+H\+U\+T\+D\+O\+WN, started\+\_\+, and write\+Buf\+\_\+.



Referenced by drain(), invoke\+On\+All\+Transactions(), and send\+Headers().


\begin{DoxyCode}
2494                             \{
2495   \textcolor{keywordflow}{if} (codec_->isReusable() || codec_->isWaitingToDrain()) \{
2496     setCloseReason(ConnectionCloseReason::SHUTDOWN);
2497     \textcolor{comment}{// For HTTP/2, if we haven't started yet then we cannot send a GOAWAY frame}
2498     \textcolor{comment}{// since we haven't sent the initial SETTINGS frame. Defer sending that}
2499     \textcolor{comment}{// GOAWAY until the initial SETTINGS is sent.}
2500     \textcolor{keywordflow}{if} (started_) \{
2501       codec_->generateGoaway(writeBuf_,
2502                              getGracefulGoawayAck(),
2503                              ErrorCode::NO_ERROR);
2504       scheduleWrite();
2505     \}
2506   \}
2507 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!drop\+Connection@{drop\+Connection}}
\index{drop\+Connection@{drop\+Connection}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{drop\+Connection() override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::drop\+Connection (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}}\label{classproxygen_1_1HTTPSession_a60c801ba3d005b715d85661d0ab5e50f}


Definition at line 493 of file H\+T\+T\+P\+Session.\+cpp.



References has\+More\+Writes(), immediate\+Shutdown(), proxygen\+::k\+Error\+Dropped, reads\+Shutdown(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::set\+Close\+Reason(), proxygen\+::\+S\+H\+U\+T\+D\+O\+WN, shutdown\+Transport(), shutdown\+Transport\+With\+Reset(), sock\+\_\+, transactions\+\_\+, and writes\+Shutdown().



Referenced by close\+When\+Idle(), and timeout\+Expired().


\begin{DoxyCode}
493                             \{
494   VLOG(4) << \textcolor{stringliteral}{"dropping "} << *\textcolor{keyword}{this};
495   \textcolor{keywordflow}{if} (!sock_ || (readsShutdown() && writesShutdown())) \{
496     VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" already shutdown"};
497     \textcolor{keywordflow}{return};
498   \}
499 
500   setCloseReason(ConnectionCloseReason::SHUTDOWN);
501   \textcolor{keywordflow}{if} (transactions_.empty() && !hasMoreWrites()) \{
502     DestructorGuard dg(\textcolor{keyword}{this});
503     shutdownTransport(\textcolor{keyword}{true}, \textcolor{keyword}{true});
504     \textcolor{comment}{// shutdownTransport might have generated a write (goaway)}
505     \textcolor{comment}{// If so, writes will not be shutdown, so fall through to}
506     \textcolor{comment}{// shutdownTransportWithReset.}
507     \textcolor{keywordflow}{if} (readsShutdown() && writesShutdown()) \{
508       immediateShutdown();
509       \textcolor{keywordflow}{return};
510     \}
511   \}
512   shutdownTransportWithReset(kErrorDropped);
513 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!dump\+Connection\+State@{dump\+Connection\+State}}
\index{dump\+Connection\+State@{dump\+Connection\+State}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{dump\+Connection\+State(uint8\+\_\+t loglevel) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::dump\+Connection\+State (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{loglevel}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}}\label{classproxygen_1_1HTTPSession_abe73197503c2bc4aa024555be2fa0338}


Definition at line 515 of file H\+T\+T\+P\+Session.\+cpp.



Referenced by timeout\+Expired().


\begin{DoxyCode}
515 \{\}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!enable\+Double\+Goaway\+Drain@{enable\+Double\+Goaway\+Drain}}
\index{enable\+Double\+Goaway\+Drain@{enable\+Double\+Goaway\+Drain}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{enable\+Double\+Goaway\+Drain() override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::enable\+Double\+Goaway\+Drain (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_ab2b5edde97da1c7321b3c1beb2e42ebd}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_af39df2dc9f0103a2673b71038837ec60}.



Definition at line 208 of file H\+T\+T\+P\+Session.\+h.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, and proxygen\+::\+H\+T\+T\+P\+Codec\+::enable\+Double\+Goaway\+Drain().


\begin{DoxyCode}
208                                           \{
209     codec_->enableDoubleGoawayDrain();
210   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!error\+On\+All\+Transactions@{error\+On\+All\+Transactions}}
\index{error\+On\+All\+Transactions@{error\+On\+All\+Transactions}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{error\+On\+All\+Transactions(\+Proxygen\+Error err, const std\+::string \&error\+Msg)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::error\+On\+All\+Transactions (
\begin{DoxyParamCaption}
\item[{{\bf Proxygen\+Error}}]{err, }
\item[{const std\+::string \&}]{error\+Msg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a76a5df5785a313ba1c7d92dcc6799648}
This function invokes a callback on all transactions. It is safe, but runs in O(n$\ast$log n) and if the callback {\itshape adds} transactions, they will not get the callback. 

Definition at line 2824 of file H\+T\+T\+P\+Session.\+cpp.



References error\+On\+Transaction\+Ids(), and transactions\+\_\+.



Referenced by invoke\+On\+All\+Transactions(), and shutdown\+Transport\+With\+Reset().


\begin{DoxyCode}
2826                                \{
2827   std::vector<HTTPCodec::StreamID> ids;
2828   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& txn: transactions_) \{
2829     ids.push\_back(txn.first);
2830   \}
2831   errorOnTransactionIds(ids, err, errorMsg);
2832 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!error\+On\+Transaction\+Id@{error\+On\+Transaction\+Id}}
\index{error\+On\+Transaction\+Id@{error\+On\+Transaction\+Id}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{error\+On\+Transaction\+Id(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D id, H\+T\+T\+P\+Exception ex)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::error\+On\+Transaction\+Id (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{id, }
\item[{{\bf H\+T\+T\+P\+Exception}}]{ex}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a36534e5e65f672c5757334d53ec2087f}


Definition at line 2853 of file H\+T\+T\+P\+Session.\+cpp.



References find\+Transaction().



Referenced by error\+On\+Transaction\+Ids(), invoke\+On\+All\+Transactions(), and on\+Goaway().


\begin{DoxyCode}
2855                       \{
2856   \textcolor{keyword}{auto} txn = findTransaction(\textcolor{keywordtype}{id});
2857   \textcolor{keywordflow}{if} (txn != \textcolor{keyword}{nullptr}) \{
2858     txn->onError(std::move(ex));
2859   \}
2860 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!error\+On\+Transaction\+Ids@{error\+On\+Transaction\+Ids}}
\index{error\+On\+Transaction\+Ids@{error\+On\+Transaction\+Ids}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{error\+On\+Transaction\+Ids(const std\+::vector$<$ H\+T\+T\+P\+Codec\+::\+Stream\+I\+D $>$ \&ids, Proxygen\+Error err, const std\+::string \&extra\+Error\+Msg="""")}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::error\+On\+Transaction\+Ids (
\begin{DoxyParamCaption}
\item[{const std\+::vector$<$ {\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} $>$ \&}]{ids, }
\item[{{\bf Proxygen\+Error}}]{err, }
\item[{const std\+::string \&}]{extra\+Error\+Msg = {\ttfamily \char`\"{}\char`\"{}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a0c80a7af521add6b6710e4462856b700}


Definition at line 2834 of file H\+T\+T\+P\+Session.\+cpp.



References error\+On\+Transaction\+Id(), proxygen\+::get\+Error\+String(), proxygen\+::\+H\+T\+T\+P\+Exception\+::\+I\+N\+G\+R\+E\+S\+S\+\_\+\+A\+N\+D\+\_\+\+E\+G\+R\+E\+SS, and proxygen\+::\+Exception\+::set\+Proxygen\+Error().



Referenced by error\+On\+All\+Transactions(), invoke\+On\+All\+Transactions(), and on\+Goaway().


\begin{DoxyCode}
2837                              \{
2838   std::string extraErrorMsg;
2839   \textcolor{keywordflow}{if} (!errorMsg.empty()) \{
2840     extraErrorMsg = folly::to<std::string>(\textcolor{stringliteral}{". "}, errorMsg);
2841   \}
2842 
2843   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} \textcolor{keywordtype}{id}: ids) \{
2844     HTTPException ex(HTTPException::Direction::INGRESS_AND_EGRESS,
2845       folly::to<std::string>(getErrorString(err),
2846         \textcolor{stringliteral}{" on transaction id: "}, \textcolor{keywordtype}{id},
2847         extraErrorMsg));
2848     ex.setProxygenError(err);
2849     errorOnTransactionId(\textcolor{keywordtype}{id}, std::move(ex));
2850   \}
2851 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!find\+Transaction@{find\+Transaction}}
\index{find\+Transaction@{find\+Transaction}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{find\+Transaction(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D stream\+I\+D)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Transaction} $\ast$ proxygen\+::\+H\+T\+T\+P\+Session\+::find\+Transaction (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{stream\+ID}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_aee368bf4f4005d808257939ad72234ed}
Get the \doxyref{H\+T\+T\+P\+Transaction}{p.}{classproxygen_1_1HTTPTransaction} for the given transaction ID, or nullptr if that transaction ID does not exist within this \doxyref{H\+T\+T\+P\+Session}{p.}{classproxygen_1_1HTTPSession}. 

Definition at line 2557 of file H\+T\+T\+P\+Session.\+cpp.



References transactions\+\_\+.



Referenced by detach(), error\+On\+Transaction\+Id(), invoke\+On\+All\+Transactions(), on\+Abort(), on\+Body(), on\+Chunk\+Complete(), on\+Chunk\+Header(), on\+Error(), on\+Ex\+Message\+Begin(), on\+Headers\+Complete(), on\+Message\+Begin(), on\+Message\+Complete(), proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::on\+Native\+Protocol\+Upgrade(), on\+Native\+Protocol\+Upgrade\+Impl(), on\+Priority(), on\+Push\+Message\+Begin(), on\+Trailers\+Complete(), on\+Window\+Update(), pause\+Ingress(), resume\+Ingress(), session\+Byte\+Offset(), and set\+New\+Transaction\+Pause\+State().


\begin{DoxyCode}
2557                                                        \{
2558   \textcolor{keyword}{auto} it = transactions_.find(streamID);
2559   \textcolor{keywordflow}{if} (it == transactions_.end()) \{
2560     \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};
2561   \} \textcolor{keywordflow}{else} \{
2562     \textcolor{keywordflow}{return} &it->second;
2563   \}
2564 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!flow\+Control\+Timeout\+Expired@{flow\+Control\+Timeout\+Expired}}
\index{flow\+Control\+Timeout\+Expired@{flow\+Control\+Timeout\+Expired}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{flow\+Control\+Timeout\+Expired() noexcept}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::flow\+Control\+Timeout\+Expired (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_ad0f4e15083621ec88c260ae1494e1c51}


Definition at line 425 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::set\+Close\+Reason(), shutdown\+Transport(), and proxygen\+::\+T\+I\+M\+E\+O\+UT.



Referenced by get\+H\+T\+T\+P\+Priority(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Flow\+Control\+Timeout\+::timeout\+Expired().


\begin{DoxyCode}
425                                                 \{
426   VLOG(4) << \textcolor{stringliteral}{"Flow control timeout for "} << *\textcolor{keyword}{this};
427 
428   DestructorGuard g(\textcolor{keyword}{this});
429 
430   setCloseReason(ConnectionCloseReason::TIMEOUT);
431   shutdownTransport(\textcolor{keyword}{true}, \textcolor{keyword}{true});
432 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Byte\+Event\+Tracker@{get\+Byte\+Event\+Tracker}}
\index{get\+Byte\+Event\+Tracker@{get\+Byte\+Event\+Tracker}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Byte\+Event\+Tracker()}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Byte\+Event\+Tracker}$\ast$ proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Byte\+Event\+Tracker (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HTTPSession_a99a081c8679ece357e810e5615178a2b}


Definition at line 88 of file H\+T\+T\+P\+Session.\+h.



References byte\+Event\+Tracker\+\_\+, set\+Byte\+Event\+Tracker(), set\+Egress\+Settings(), set\+Flow\+Control(), and set\+Session\+Stats().


\begin{DoxyCode}
88 \{ \textcolor{keywordflow}{return} byteEventTracker_.get(); \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Cert\+Auth\+Setting\+Val@{get\+Cert\+Auth\+Setting\+Val}}
\index{get\+Cert\+Auth\+Setting\+Val@{get\+Cert\+Auth\+Setting\+Val}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Cert\+Auth\+Setting\+Val()}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Cert\+Auth\+Setting\+Val (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a8bce2a0083afab9016f69310dd035351}


Definition at line 185 of file H\+T\+T\+P\+Session.\+cpp.



References get\+Transport(), and is\+Upstream().



Referenced by get\+Max\+Concurrent\+Outgoing\+Streams\+Remote(), and setup\+Codec().


\begin{DoxyCode}
185                                             \{
186   uint32\_t certAuthSettingVal = 0;
187   constexpr uint16\_t settingLen = 4;
188   std::unique\_ptr<folly::IOBuf> ekm;
189   folly::StringPiece label;
190   \textcolor{keywordflow}{if} (isUpstream()) \{
191     label = kClientLabel;
192   \} \textcolor{keywordflow}{else} \{
193     label = kServerLabel;
194   \}
195   \textcolor{keyword}{auto} fizzBase = getTransport()->getUnderlyingTransport<AsyncFizzBase>();
196   \textcolor{keywordflow}{if} (fizzBase) \{
197     ekm = fizzBase->getEkm(label, \textcolor{keyword}{nullptr}, settingLen);
198   \} \textcolor{keywordflow}{else} \{
199     VLOG(4) << \textcolor{stringliteral}{"Underlying transport does not support secondary "}
200                \textcolor{stringliteral}{"authentication."};
201     \textcolor{keywordflow}{return} certAuthSettingVal;
202   \}
203   \textcolor{keywordflow}{if} (ekm && ekm->computeChainDataLength() == settingLen) \{
204     folly::io::Cursor cursor(ekm.get());
205     uint32\_t ekmVal = cursor.readBE<uint32\_t>();
206     certAuthSettingVal = (ekmVal & 0x3fffffff) | 0x80000000;
207   \}
208   \textcolor{keywordflow}{return} certAuthSettingVal;
209 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Codec@{get\+Codec}}
\index{get\+Codec@{get\+Codec}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Codec() const noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf H\+T\+T\+P\+Codec}\& proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Codec (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_a6eaf7bac72499cd50c8e77e7b1b72a4d}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_a50773010568880d549b9de1cc710f51c}.



Definition at line 440 of file H\+T\+T\+P\+Session.\+h.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, and proxygen\+::\+Filter\+Chain$<$ T1, T2, Filter\+Type, set\+\_\+callback, Take\+Ownership $>$\+::get\+Chain\+End().


\begin{DoxyCode}
440                                                       \{
441     \textcolor{keywordflow}{return} codec_.getChainEnd();
442   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Codec\+Send\+Window\+Size@{get\+Codec\+Send\+Window\+Size}}
\index{get\+Codec\+Send\+Window\+Size@{get\+Codec\+Send\+Window\+Size}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Codec\+Send\+Window\+Size() const }]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Codec\+Send\+Window\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a812803459bbdfc56b7f75cf6a5cf9916}


Definition at line 712 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Default\+Window\+Size(), proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Ingress\+Settings(), proxygen\+::\+H\+T\+T\+P\+Settings\+::get\+Setting(), proxygen\+::\+I\+N\+I\+T\+I\+A\+L\+\_\+\+W\+I\+N\+D\+O\+W\+\_\+\+S\+I\+ZE, and settings.



Referenced by create\+Transaction(), on\+Headers\+Sent(), and on\+Native\+Protocol\+Upgrade\+Impl().


\begin{DoxyCode}
712                                                  \{
713   \textcolor{keyword}{const} HTTPSettings* settings = codec_->getIngressSettings();
714   \textcolor{keywordflow}{if} (settings) \{
715     \textcolor{keywordflow}{return} settings->getSetting(SettingsId::INITIAL_WINDOW_SIZE,
716                                 codec_->getDefaultWindowSize());
717   \}
718   \textcolor{keywordflow}{return} codec_->getDefaultWindowSize();
719 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Current\+Transport\+Info@{get\+Current\+Transport\+Info}}
\index{get\+Current\+Transport\+Info@{get\+Current\+Transport\+Info}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Current\+Transport\+Info(wangle\+::\+Transport\+Info $\ast$tinfo) override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Current\+Transport\+Info (
\begin{DoxyParamCaption}
\item[{wangle\+::\+Transport\+Info $\ast$}]{tinfo}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_aa82b0bd3fa4af3999b03cbccbfe136c8}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_a8164721d4bf7c3f1b9006d0bcdcfdda9}.



Definition at line 2031 of file H\+T\+T\+P\+Session.\+cpp.



References get\+Current\+Transport\+Info\+Without\+Update(), and proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::transport\+Info\+\_\+.



Referenced by get\+Setup\+Transport\+Info().


\begin{DoxyCode}
2031                                                               \{
2032   \textcolor{keywordflow}{if} (getCurrentTransportInfoWithoutUpdate(tinfo)) \{
2033     \textcolor{comment}{// some fields are the same with the setup transport info}
2034     tinfo->setupTime = transportInfo_.setupTime;
2035     tinfo->secure = transportInfo_.secure;
2036     tinfo->sslSetupTime = transportInfo_.sslSetupTime;
2037     tinfo->sslVersion = transportInfo_.sslVersion;
2038     tinfo->sslCipher = transportInfo_.sslCipher;
2039     tinfo->sslResume = transportInfo_.sslResume;
2040     tinfo->appProtocol = transportInfo_.appProtocol;
2041     tinfo->sslError = transportInfo_.sslError;
2042 \textcolor{preprocessor}{#if defined(\_\_linux\_\_) || defined(\_\_FreeBSD\_\_)}
2043     \textcolor{comment}{// update connection transport info with the latest RTT}
2044     \textcolor{keywordflow}{if} (tinfo->tcpinfo.tcpi\_rtt > 0) \{
2045       transportInfo_.tcpinfo.tcpi\_rtt = tinfo->tcpinfo.tcpi\_rtt;
2046       transportInfo_.rtt = std::chrono::microseconds(tinfo->tcpinfo.tcpi\_rtt);
2047     \}
2048     transportInfo_.rtx = tinfo->rtx;
2049 \textcolor{preprocessor}{#endif}
2050     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
2051   \}
2052   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
2053 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Current\+Transport\+Info\+Without\+Update@{get\+Current\+Transport\+Info\+Without\+Update}}
\index{get\+Current\+Transport\+Info\+Without\+Update@{get\+Current\+Transport\+Info\+Without\+Update}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Current\+Transport\+Info\+Without\+Update(wangle\+::\+Transport\+Info $\ast$tinfo) const override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Current\+Transport\+Info\+Without\+Update (
\begin{DoxyParamCaption}
\item[{wangle\+::\+Transport\+Info $\ast$}]{tinfo}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a835f8ccd23c3890580f3ba11a7a9b51c}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_a68a5d49e2a7d811eb423565f62877b8e}.



Definition at line 2017 of file H\+T\+T\+P\+Session.\+cpp.



References sock\+\_\+.



Referenced by get\+Current\+Transport\+Info(), and timeout\+Expired().


\begin{DoxyCode}
2018                                 \{
2019   \textcolor{keyword}{auto} sock = sock_->getUnderlyingTransport<AsyncSocket>();
2020   \textcolor{keywordflow}{if} (sock) \{
2021     tinfo->initWithSocket(sock);
2022 \textcolor{preprocessor}{#if defined(\_\_linux\_\_) || defined(\_\_FreeBSD\_\_)}
2023     tinfo->readTcpCongestionControl(sock);
2024     tinfo->readMaxPacingRate(sock);
2025 \textcolor{preprocessor}{#endif // defined(\_\_linux\_\_) || defined(\_\_FreeBSD\_\_)}
2026     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
2027   \}
2028   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
2029 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Event\+Base@{get\+Event\+Base}}
\index{get\+Event\+Base@{get\+Event\+Base}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Event\+Base() const override}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+Event\+Base$\ast$ proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Event\+Base (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_af6225e79bfb92a2b8b5445d02f385eb5}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_a60d26c60a2326428d9f4bc0e56b0f24d}.



Definition at line 65 of file H\+T\+T\+P\+Session.\+h.



References sock\+\_\+.


\begin{DoxyCode}
65                                                 \{
66     \textcolor{keywordflow}{if} (sock_) \{
67       \textcolor{keywordflow}{return} sock_->getEventBase();
68     \}
69     \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};
70   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Graceful\+Goaway\+Ack@{get\+Graceful\+Goaway\+Ack}}
\index{get\+Graceful\+Goaway\+Ack@{get\+Graceful\+Goaway\+Ack}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Graceful\+Goaway\+Ack() const }]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Graceful\+Goaway\+Ack (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a0f8fa22651a3a9a92ba6778bd377bfb3}
Get the id of the stream we should ack in a graceful G\+O\+A\+W\+AY 

Definition at line 2911 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Last\+Incoming\+Stream\+I\+D(), proxygen\+::\+H\+T\+T\+P\+Codec\+::is\+Reusable(), and proxygen\+::\+H\+T\+T\+P\+Codec\+::is\+Waiting\+To\+Drain().



Referenced by drain\+Impl(), get\+Max\+Concurrent\+Outgoing\+Streams\+Remote(), and start\+Now().


\begin{DoxyCode}
2911                                                           \{
2912   \textcolor{keywordflow}{if} (!codec_->isReusable() || codec_->isWaitingToDrain()) \{
2913     \textcolor{comment}{// TODO: just track last stream ID inside HTTPSession since this logic}
2914     \textcolor{comment}{// is shared between HTTP/2 and SPDY}
2915     \textcolor{keywordflow}{return} codec_->getLastIncomingStreamID();
2916   \}
2917   VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" getGracefulGoawayAck is reusable and not draining"};
2918   \textcolor{comment}{// return the maximum possible stream id}
2919   \textcolor{keywordflow}{return} std::numeric\_limits<int32\_t>::max();
2920 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+H\+T\+T\+P2\+Priorities\+Enabled@{get\+H\+T\+T\+P2\+Priorities\+Enabled}}
\index{get\+H\+T\+T\+P2\+Priorities\+Enabled@{get\+H\+T\+T\+P2\+Priorities\+Enabled}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+H\+T\+T\+P2\+Priorities\+Enabled() const override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::get\+H\+T\+T\+P2\+Priorities\+Enabled (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a177d9f43b8dcd75a09ccbe02a2f00498}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_a6f0916403f1d1a63bc1236d2fb8b9d4d}.



Definition at line 114 of file H\+T\+T\+P\+Session.\+h.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::get\+H\+T\+T\+P2\+Priorities\+Enabled().



Referenced by get\+Message\+Priority(), on\+Priority(), and send\+Headers().


\begin{DoxyCode}
114                                                   \{
115     \textcolor{keywordflow}{return} HTTPSessionBase::getHTTP2PrioritiesEnabled();
116   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+H\+T\+T\+P\+Priority@{get\+H\+T\+T\+P\+Priority}}
\index{get\+H\+T\+T\+P\+Priority@{get\+H\+T\+T\+P\+Priority}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+H\+T\+T\+P\+Priority(uint8\+\_\+t) override}]{\setlength{\rightskip}{0pt plus 5cm}virtual folly\+::\+Optional$<$const {\bf H\+T\+T\+P\+Message\+::\+H\+T\+T\+P\+Priority}$>$ proxygen\+::\+H\+T\+T\+P\+Session\+::get\+H\+T\+T\+P\+Priority (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a53c7e76d73a80296ffab4461dd0dbb0b}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_a98b3e5d3b9c5daef7699fa0fe5d3faeb}.



Reimplemented in {\bf proxygen\+::\+H\+T\+T\+P\+Upstream\+Session} \doxyref{}{p.}{classproxygen_1_1HTTPUpstreamSession_af70db0ee27cd989936d7421e6f667b65}.



Definition at line 341 of file H\+T\+T\+P\+Session.\+h.



References flow\+Control\+Timeout\+Expired(), get\+Read\+Buffer(), is\+Buffer\+Movable(), process\+Read\+Data(), read\+Buffer\+Available(), read\+Data\+Available(), read\+E\+O\+F(), read\+Err(), read\+Timeout\+Expired(), and write\+Timeout\+Expired().



Referenced by proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::get\+H\+T\+T\+P\+Priority().


\begin{DoxyCode}
342                       \{
343     \textcolor{keywordflow}{return} folly::none;
344   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Local\+Address@{get\+Local\+Address}}
\index{get\+Local\+Address@{get\+Local\+Address}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Local\+Address() const noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}const folly\+::\+Socket\+Address\& proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Local\+Address (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_a4d802545b2cf56aeb3b8308c7d3a9371}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_ac7cb79f04ed2136bd09ef7e282f7b505}.



Definition at line 122 of file H\+T\+T\+P\+Session.\+h.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::get\+Local\+Address().



Referenced by describe(), and proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::get\+Transaction\+Timeout\+Handler().


\begin{DoxyCode}
122                                                                       \{
123     \textcolor{keywordflow}{return} HTTPSessionBase::getLocalAddress();
124   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Max\+Concurrent\+Outgoing\+Streams\+Remote@{get\+Max\+Concurrent\+Outgoing\+Streams\+Remote}}
\index{get\+Max\+Concurrent\+Outgoing\+Streams\+Remote@{get\+Max\+Concurrent\+Outgoing\+Streams\+Remote}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Max\+Concurrent\+Outgoing\+Streams\+Remote() const override}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Max\+Concurrent\+Outgoing\+Streams\+Remote (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_ae793a714b3812adadb6c1610002cd7e0}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_af9860328645020065957a76fa95685c7}.



Definition at line 722 of file H\+T\+T\+P\+Session.\+h.



References proxygen\+::\+\_\+\+S\+P\+D\+Y\+\_\+\+I\+N\+V\+A\+L\+I\+D\+\_\+\+S\+T\+R\+E\+AM, add\+Ack\+To\+Last\+Byte\+Event(), add\+Last\+Byte\+Event(), get\+Cert\+Auth\+Setting\+Val(), get\+Graceful\+Goaway\+Ack(), get\+Message\+Priority(), invalid\+Stream(), is\+Downstream(), is\+Upstream(), max\+Concurrent\+Outgoing\+Streams\+Remote\+\_\+, on\+Connection\+Send\+Window\+Closed(), on\+Connection\+Send\+Window\+Open(), on\+Egress\+Buffer\+Cleared(), on\+Egress\+Buffered(), on\+Set\+Max\+Initiated\+Streams(), on\+Set\+Send\+Window(), setup\+Codec(), and verify\+Cert\+Auth\+Setting().


\begin{DoxyCode}
722                                                                   \{
723     \textcolor{keywordflow}{return} maxConcurrentOutgoingStreamsRemote_;
724   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Message\+Priority@{get\+Message\+Priority}}
\index{get\+Message\+Priority@{get\+Message\+Priority}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Message\+Priority(const H\+T\+T\+P\+Message $\ast$msg)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf http2\+::\+Priority\+Update} proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Message\+Priority (
\begin{DoxyParamCaption}
\item[{const {\bf H\+T\+T\+P\+Message} $\ast$}]{msg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a58e8277f3fdd50bc8496c79018b21987}


Definition at line 737 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::http2\+::\+Default\+Priority, proxygen\+::http2\+::\+Priority\+Update\+::exclusive, get\+H\+T\+T\+P2\+Priorities\+Enabled(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+H\+T\+T\+P2\+Priority(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Priority(), proxygen\+::\+H\+T\+T\+P\+Codec\+::map\+Priority\+To\+Dependency(), proxygen\+::http2\+::\+Priority\+Update\+::stream\+Dependency, and proxygen\+::http2\+::\+Priority\+Update\+::weight.



Referenced by get\+Max\+Concurrent\+Outgoing\+Streams\+Remote(), on\+Ex\+Message\+Begin(), on\+Message\+Begin(), on\+Push\+Message\+Begin(), and send\+Headers().


\begin{DoxyCode}
737                                                       \{
738   http2::PriorityUpdate h2Pri = http2::DefaultPriority;
739 
740   \textcolor{comment}{// if HTTP2 priorities are enabled, get them from the message}
741   \textcolor{comment}{// and ignore otherwise}
742   \textcolor{keywordflow}{if} (getHTTP2PrioritiesEnabled() && msg) \{
743     \textcolor{keyword}{auto} res = msg->getHTTP2Priority();
744     \textcolor{keywordflow}{if} (res) \{
745       h2Pri.streamDependency = std::get<0>(*res);
746       h2Pri.exclusive = std::get<1>(*res);
747       h2Pri.weight = std::get<2>(*res);
748     \} \textcolor{keywordflow}{else} \{
749       \textcolor{comment}{// HTTPMessage with setPriority called explicitly}
750       h2Pri.streamDependency =
751         codec_->mapPriorityToDependency(msg->getPriority());
752     \}
753   \}
754   \textcolor{keywordflow}{return} h2Pri;
755 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Next\+To\+Send@{get\+Next\+To\+Send}}
\index{get\+Next\+To\+Send@{get\+Next\+To\+Send}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Next\+To\+Send(bool $\ast$cork, bool $\ast$eom)}]{\setlength{\rightskip}{0pt plus 5cm}unique\+\_\+ptr$<$ I\+O\+Buf $>$ proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Next\+To\+Send (
\begin{DoxyParamCaption}
\item[{bool $\ast$}]{cork, }
\item[{bool $\ast$}]{eom}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a0a609ab80e8953402ea2b13ab64f5717}
Gets the next I\+O\+Buf to send (either write\+Buf\+\_\+ or new egress from the priority queue), and sets cork appropriately 

Definition at line 2055 of file H\+T\+T\+P\+Session.\+cpp.



References byte\+Event\+Tracker\+\_\+, bytes\+Written\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, conn\+Flow\+Control\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::egress\+Body\+Size\+Limit\+\_\+, proxygen\+::\+H\+T\+T\+P2\+Priority\+Queue\+::empty(), proxygen\+::\+Flow\+Control\+Filter\+::get\+Available\+Send(), proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Protocol(), is\+Conn\+Window\+Full(), proxygen\+::is\+Spdy\+Codec\+Protocol(), proxygen\+::\+H\+T\+T\+P2\+Priority\+Queue\+::next\+Egress(), next\+Egress\+Results\+\_\+, num\+Active\+Writes\+\_\+, proxygen\+::\+T\+T\+L\+B\+A\+Stats\+::record\+T\+T\+L\+B\+A\+I\+O\+B\+Split\+By\+Eom(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::session\+Stats\+\_\+, txn\+Egress\+Queue\+\_\+, write\+Buf\+\_\+, and writes\+Shutdown().



Referenced by on\+Headers\+Sent(), and run\+Loop\+Callback().


\begin{DoxyCode}
2055                                                                   \{
2056   \textcolor{comment}{// limit ourselves to one outstanding write at a time (onWriteSuccess calls}
2057   \textcolor{comment}{// scheduleWrite)}
2058   \textcolor{keywordflow}{if} (numActiveWrites_ > 0 || writesShutdown()) \{
2059     VLOG(4) << \textcolor{stringliteral}{"skipping write during this loop, numActiveWrites\_="} <<
2060       numActiveWrites_ << \textcolor{stringliteral}{" writesShutdown()="} << writesShutdown();
2061     \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};
2062   \}
2063 
2064   \textcolor{comment}{// We always tack on at least one body packet to the current write buf}
2065   \textcolor{comment}{// This ensures that a short HTTPS response will go out in a single SSL record}
2066   \textcolor{keywordflow}{while} (!txnEgressQueue_.empty()) \{
2067     uint32\_t toSend = kWriteReadyMax;
2068     \textcolor{keywordflow}{if} (connFlowControl_) \{
2069       \textcolor{keywordflow}{if} (connFlowControl_->getAvailableSend() == 0) \{
2070         VLOG(4) << \textcolor{stringliteral}{"Session-level send window is full, skipping remaining "}
2071                 << \textcolor{stringliteral}{"body writes this loop"};
2072         \textcolor{keywordflow}{break};
2073       \}
2074       toSend = std::min(toSend, connFlowControl_->getAvailableSend());
2075     \}
2076     txnEgressQueue_.nextEgress(nextEgressResults_,
2077                                isSpdyCodecProtocol(codec_->getProtocol()));
2078     CHECK(!nextEgressResults_.empty()); \textcolor{comment}{// Queue was non empty, so this must be}
2079     \textcolor{comment}{// The maximum we will send for any transaction in this loop}
2080     uint32\_t txnMaxToSend = toSend * nextEgressResults_.front().second;
2081     \textcolor{keywordflow}{if} (txnMaxToSend == 0) \{
2082       \textcolor{comment}{// toSend is smaller than the number of transactions.  Give all egress}
2083       \textcolor{comment}{// to the first transaction}
2084       nextEgressResults_.erase(++nextEgressResults_.begin(),
2085                                nextEgressResults_.end());
2086       txnMaxToSend = std::min(toSend, egressBodySizeLimit_);
2087       nextEgressResults_.front().second = 1;
2088     \}
2089     \textcolor{keywordflow}{if} (nextEgressResults_.size() > 1 && txnMaxToSend > egressBodySizeLimit_) \{
2090       \textcolor{comment}{// Cap the max to egressBodySizeLimit\_, and recompute toSend accordingly}
2091       txnMaxToSend = egressBodySizeLimit_;
2092       toSend = txnMaxToSend / nextEgressResults_.front().second;
2093     \}
2094     \textcolor{comment}{// split allowed by relative weight, with some minimum}
2095     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} txnPair: nextEgressResults_) \{
2096       uint32\_t txnAllowed = txnPair.second * toSend;
2097       \textcolor{keywordflow}{if} (nextEgressResults\_.size() > 1) \{
2098         CHECK\_LE(txnAllowed, egressBodySizeLimit_);
2099       \}
2100       \textcolor{keywordflow}{if} (connFlowControl_) \{
2101         CHECK\_LE(txnAllowed, connFlowControl_->getAvailableSend());
2102       \}
2103       \textcolor{keywordflow}{if} (txnAllowed == 0) \{
2104         \textcolor{comment}{// The ratio * toSend was so small this txn gets nothing.}
2105         VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" breaking egress loop on 0 txnAllowed"};
2106         \textcolor{keywordflow}{break};
2107       \}
2108 
2109       VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" egressing txnID="} << txnPair.first->getID() <<
2110         \textcolor{stringliteral}{" allowed="} << txnAllowed;
2111       txnPair.first->onWriteReady(txnAllowed, txnPair.second);
2112     \}
2113     nextEgressResults\_.clear();
2114     \textcolor{comment}{// it can be empty because of HTTPTransaction rate limiting.  We should}
2115     \textcolor{comment}{// change rate limiting to clearPendingEgress while waiting.}
2116     \textcolor{keywordflow}{if} (!writeBuf_.empty()) \{
2117       \textcolor{keywordflow}{break};
2118     \}
2119   \}
2120   *eom = \textcolor{keyword}{false};
2121   \textcolor{keywordflow}{if} (byteEventTracker_) \{
2122     uint64\_t needed = byteEventTracker_->preSend(cork, eom, bytesWritten_);
2123     \textcolor{keywordflow}{if} (needed > 0) \{
2124       VLOG(5) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" writeBuf\_.chainLength(): "}
2125               << writeBuf_.chainLength() << \textcolor{stringliteral}{" txnEgressQueue\_.empty(): "}
2126               << txnEgressQueue_.empty();
2127 
2128       \textcolor{keywordflow}{if} (needed < writeBuf_.chainLength()) \{
2129         \textcolor{comment}{// split the next EOM chunk}
2130         VLOG(5) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" splitting "} << needed << \textcolor{stringliteral}{" bytes out of a "}
2131                 << writeBuf_.chainLength() << \textcolor{stringliteral}{" bytes IOBuf"};
2132         *cork = \textcolor{keyword}{true};
2133         \textcolor{keywordflow}{if} (sessionStats_) \{
2134           sessionStats_->recordTTLBAIOBSplitByEom();
2135         \}
2136         \textcolor{keywordflow}{return} writeBuf_.split(needed);
2137       \} \textcolor{keywordflow}{else} \{
2138         CHECK\_EQ(needed, writeBuf_.chainLength());
2139       \}
2140     \}
2141   \}
2142 
2143   \textcolor{comment}{// cork if there are txns with pending egress and room to send them}
2144   *cork = !txnEgressQueue_.empty() && !isConnWindowFull();
2145   \textcolor{keywordflow}{return} writeBuf_.move();
2146 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Num\+Incoming\+Streams@{get\+Num\+Incoming\+Streams}}
\index{get\+Num\+Incoming\+Streams@{get\+Num\+Incoming\+Streams}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Num\+Incoming\+Streams() const override}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Num\+Incoming\+Streams (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a9e47485f76defbdb18a2ee8046d3c8ca}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_a7a4c7680d780f387820250e4cabe0be3}.



Definition at line 84 of file H\+T\+T\+P\+Session.\+h.



References incoming\+Streams\+\_\+.



Referenced by is\+Detachable().


\begin{DoxyCode}
84                                                   \{
85     \textcolor{keywordflow}{return} incomingStreams_;
86   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Num\+Outgoing\+Streams@{get\+Num\+Outgoing\+Streams}}
\index{get\+Num\+Outgoing\+Streams@{get\+Num\+Outgoing\+Streams}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Num\+Outgoing\+Streams() const override}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Num\+Outgoing\+Streams (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a01e761397c1bf1a22dd1591566329d10}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_a11605f93fcb9a5831d55a58c96d43766}.



Definition at line 80 of file H\+T\+T\+P\+Session.\+h.



References outgoing\+Streams\+\_\+.


\begin{DoxyCode}
80                                                   \{
81     \textcolor{keywordflow}{return} outgoingStreams_;
82   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Peer\+Address@{get\+Peer\+Address}}
\index{get\+Peer\+Address@{get\+Peer\+Address}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Peer\+Address() const noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}const folly\+::\+Socket\+Address\& proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Peer\+Address (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_a06f714cc6f6448b73257796d7abc551a}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_a95a44632907c6e22cd970a359c361269}.



Definition at line 126 of file H\+T\+T\+P\+Session.\+h.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::get\+Peer\+Address().



Referenced by describe(), and shutdown\+Transport().


\begin{DoxyCode}
126                                                                      \{
127     \textcolor{keywordflow}{return} HTTPSessionBase::getPeerAddress();
128   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Pipeline\+Stream\+Count@{get\+Pipeline\+Stream\+Count}}
\index{get\+Pipeline\+Stream\+Count@{get\+Pipeline\+Stream\+Count}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Pipeline\+Stream\+Count() const }]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Pipeline\+Stream\+Count (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a7f79405657f8c7970a7c2aefebbfc512}


Definition at line 837 of file H\+T\+T\+P\+Session.\+h.



References incoming\+Streams\+\_\+, increment\+Outgoing\+Streams(), is\+Downstream(), and maybe\+Resume\+Paused\+Pipelined\+Transaction().



Referenced by detach(), maybe\+Resume\+Paused\+Pipelined\+Transaction(), on\+Egress\+Message\+Finished(), and on\+Message\+Begin().


\begin{DoxyCode}
837                                         \{
838     \textcolor{keywordflow}{return} isDownstream() ? incomingStreams_ : transactions_.size();
839   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Read\+Buffer@{get\+Read\+Buffer}}
\index{get\+Read\+Buffer@{get\+Read\+Buffer}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Read\+Buffer(void $\ast$$\ast$buf, size\+\_\+t $\ast$buf\+Size) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Read\+Buffer (
\begin{DoxyParamCaption}
\item[{void $\ast$$\ast$}]{buf, }
\item[{size\+\_\+t $\ast$}]{buf\+Size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a44d7eea9bf8759a4cbcf2fb1d82255bb}


Definition at line 526 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::max\+Read\+Buffer\+Size\+\_\+, and read\+Buf\+\_\+.



Referenced by get\+H\+T\+T\+P\+Priority().


\begin{DoxyCode}
526                                                       \{
527   FOLLY\_SCOPED\_TRACE\_SECTION(\textcolor{stringliteral}{"HTTPSession - getReadBuffer"});
528   pair<void*,uint32\_t> readSpace =
529     readBuf_.preallocate(kMinReadSize, HTTPSessionBase::maxReadBufferSize_);
530   *buf = readSpace.first;
531   *bufSize = readSpace.second;
532 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Second\+Auth\+Manager@{get\+Second\+Auth\+Manager}}
\index{get\+Second\+Auth\+Manager@{get\+Second\+Auth\+Manager}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Second\+Auth\+Manager() const }]{\setlength{\rightskip}{0pt plus 5cm}{\bf Secondary\+Auth\+Manager} $\ast$ proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Second\+Auth\+Manager (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classproxygen_1_1HTTPSession_a6626c7d6b00d8c2a181f108aeca9dd6b}
Get the \doxyref{Secondary\+Auth\+Manager}{p.}{classproxygen_1_1SecondaryAuthManager} attached to this session. 

Definition at line 1829 of file H\+T\+T\+P\+Session.\+cpp.



References second\+Auth\+Manager\+\_\+.



Referenced by conn\+Close\+By\+Remote().


\begin{DoxyCode}
1829                                                               \{
1830   \textcolor{keywordflow}{return} secondAuthManager_.get();
1831 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Security\+Protocol@{get\+Security\+Protocol}}
\index{get\+Security\+Protocol@{get\+Security\+Protocol}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Security\+Protocol() const override}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Security\+Protocol (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_ab4971509542ec5d3a4812666f01752f8}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_a1cf1fd957cfdaba77f24fad464ad9ff1}.



Definition at line 360 of file H\+T\+T\+P\+Session.\+h.



References on\+Abort(), on\+Body(), on\+Certificate(), on\+Certificate\+Request(), on\+Chunk\+Complete(), on\+Chunk\+Header(), on\+Error(), on\+Ex\+Message\+Begin(), on\+Goaway(), on\+Headers\+Complete(), on\+Message\+Begin(), on\+Message\+Complete(), on\+Ping\+Reply(), on\+Ping\+Request(), on\+Priority(), on\+Push\+Message\+Begin(), on\+Settings(), on\+Settings\+Ack(), on\+Trailers\+Complete(), on\+Window\+Update(), settings, and sock\+\_\+.


\begin{DoxyCode}
360                                                  \{
361     \textcolor{keywordflow}{return} sock_->getSecurityProtocol();
362   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Setup\+Transport\+Info@{get\+Setup\+Transport\+Info}}
\index{get\+Setup\+Transport\+Info@{get\+Setup\+Transport\+Info}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Setup\+Transport\+Info() const noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}const wangle\+::\+Transport\+Info\& proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Setup\+Transport\+Info (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_a64beb207eb35324706b875207915087e}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_ab93736e566ed2d2cdc9f58739c043a80}.



Definition at line 130 of file H\+T\+T\+P\+Session.\+h.



References get\+Current\+Transport\+Info(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::get\+Setup\+Transport\+Info(), send\+Certificate\+Request(), send\+Ping(), send\+Priority(), send\+Settings(), set\+Egress\+Bytes\+Limit(), set\+Max\+Concurrent\+Incoming\+Streams(), and start\+Now().


\begin{DoxyCode}
131              \{
132     \textcolor{keywordflow}{return} HTTPSessionBase::getSetupTransportInfo();
133   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Transaction\+Timeout\+Handler@{get\+Transaction\+Timeout\+Handler}}
\index{get\+Transaction\+Timeout\+Handler@{get\+Transaction\+Timeout\+Handler}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Transaction\+Timeout\+Handler(\+H\+T\+T\+P\+Transaction $\ast$txn)=0}]{\setlength{\rightskip}{0pt plus 5cm}virtual {\bf H\+T\+T\+P\+Transaction\+::\+Handler}$\ast$ proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Transaction\+Timeout\+Handler (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Transaction} $\ast$}]{txn}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [pure virtual]}}\label{classproxygen_1_1HTTPSession_af9a8e7884bf77f9c5831f652ff803616}
Called by transaction\+Timeout if the transaction has no handler. 

Implemented in {\bf proxygen\+::\+H\+T\+T\+P\+Upstream\+Session} \doxyref{}{p.}{classproxygen_1_1HTTPUpstreamSession_a04d4ebfc2ba33f1c0dcc52221b68ea03}, and {\bf proxygen\+::\+H\+T\+T\+P\+Downstream\+Session} \doxyref{}{p.}{classproxygen_1_1HTTPDownstreamSession_a771c925d1b689f25408bb90a1f2144d4}.



Referenced by conn\+Close\+By\+Remote(), and transaction\+Timeout().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Transport@{get\+Transport}}
\index{get\+Transport@{get\+Transport}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Transport() override}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+Async\+Transport\+Wrapper$\ast$ proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Transport (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a9a3bd3fa8d867fec154e90a8d830af35}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_a53dc4760bd667494edb310e1fde77e2b}.



Definition at line 61 of file H\+T\+T\+P\+Session.\+h.



References sock\+\_\+.



Referenced by conn\+Close\+By\+Remote(), get\+Cert\+Auth\+Setting\+Val(), on\+Certificate(), on\+Certificate\+Request(), and verify\+Cert\+Auth\+Setting().


\begin{DoxyCode}
61                                                       \{
62     \textcolor{keywordflow}{return} sock_.get();
63   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Transport@{get\+Transport}}
\index{get\+Transport@{get\+Transport}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Transport() const override}]{\setlength{\rightskip}{0pt plus 5cm}const folly\+::\+Async\+Transport\+Wrapper$\ast$ proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Transport (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_ab64b62af1ed594428a7aa50be35449c6}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_a2cd16f658a7a997660ed21b3ce079a39}.



Definition at line 72 of file H\+T\+T\+P\+Session.\+h.



References sock\+\_\+.


\begin{DoxyCode}
72                                                                   \{
73     \textcolor{keywordflow}{return} sock_.get();
74   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Type@{get\+Type}}
\index{get\+Type@{get\+Type}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Type() const noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Session\+Base\+::\+Session\+Type} proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Type (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_a5e40fcbfdc692240baee16cdf2f7f297}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_ada7ab028d3156a4e7b47512334b46606}.



Definition at line 57 of file H\+T\+T\+P\+Session.\+h.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+H\+T\+TP.


\begin{DoxyCode}
57                                                                \{
58     \textcolor{keywordflow}{return} HTTPSessionBase::SessionType::HTTP;
59   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!get\+Underlying\+Transport@{get\+Underlying\+Transport}}
\index{get\+Underlying\+Transport@{get\+Underlying\+Transport}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{get\+Underlying\+Transport() const noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}const folly\+::\+Async\+Transport\+Wrapper$\ast$ proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Underlying\+Transport (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_ac71867cf47b46d4da272325fcbbfe456}
Returns the underlying Async\+Transport\+Wrapper. Overrides \doxyref{H\+T\+T\+P\+Transaction\+::\+Transport\+::get\+Underlying\+Transport()}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_ab344a20364f4a9687d7197b32251a8f9}. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_ab344a20364f4a9687d7197b32251a8f9}.



Definition at line 448 of file H\+T\+T\+P\+Session.\+h.



References sock\+\_\+.


\begin{DoxyCode}
449                               \{
450     \textcolor{keywordflow}{return} sock_.get();
451   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!has\+Active\+Transactions@{has\+Active\+Transactions}}
\index{has\+Active\+Transactions@{has\+Active\+Transactions}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{has\+Active\+Transactions() const override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::has\+Active\+Transactions (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a82ff05f591f90fc68145ee47cce9d7da}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_ac16349a13d736e043dd0f9120e542709}.



Definition at line 76 of file H\+T\+T\+P\+Session.\+h.



References transactions\+\_\+.


\begin{DoxyCode}
76                                               \{
77     \textcolor{keywordflow}{return} !transactions_.empty();
78   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!has\+More\+Writes@{has\+More\+Writes}}
\index{has\+More\+Writes@{has\+More\+Writes}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{has\+More\+Writes() const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::has\+More\+Writes (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_adc047d8e5824d2368060aec1e30fb3b6}
Check whether the session has any writes in progress or upcoming 

Definition at line 2812 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P2\+Priority\+Queue\+::empty(), num\+Active\+Writes\+\_\+, pending\+Writes\+\_\+, txn\+Egress\+Queue\+\_\+, and write\+Buf\+\_\+.



Referenced by close\+When\+Idle(), detach(), drop\+Connection(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::is\+Reusable(), on\+Write\+Success(), run\+Loop\+Callback(), session\+Byte\+Offset(), and shutdown\+Transport().


\begin{DoxyCode}
2812                                  \{
2813   VLOG(10) << \_\_PRETTY\_FUNCTION\_\_
2814     << \textcolor{stringliteral}{" numActiveWrites\_: "} << numActiveWrites_
2815     << \textcolor{stringliteral}{" pendingWrites\_.empty(): "} << pendingWrites_.empty()
2816     << \textcolor{stringliteral}{" pendingWrites\_.size(): "} << pendingWrites_.size()
2817     << \textcolor{stringliteral}{" txnEgressQueue\_.empty(): "} << txnEgressQueue_.empty();
2818 
2819   \textcolor{keywordflow}{return} (numActiveWrites_ != 0) ||
2820     !pendingWrites_.empty() || writeBuf_.front() ||
2821     !txnEgressQueue_.empty();
2822 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!immediate\+Shutdown@{immediate\+Shutdown}}
\index{immediate\+Shutdown@{immediate\+Shutdown}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{immediate\+Shutdown()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::immediate\+Shutdown (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a15caf918295099c6396ea3266a810342}
Immediately shut down the session, by deleting the loop callbacks first 

Definition at line 479 of file H\+T\+T\+P\+Session.\+cpp.



References check\+For\+Shutdown(), shutdown\+Transport\+Cb\+\_\+, transactions\+\_\+, and writes\+Shutdown().



Referenced by drop\+Connection(), and session\+Byte\+Offset().


\begin{DoxyCode}
479                                     \{
480   \textcolor{keywordflow}{if} (isLoopCallbackScheduled()) \{
481     cancelLoopCallback();
482   \}
483   \textcolor{keywordflow}{if} (shutdownTransportCb_) \{
484     shutdownTransportCb_.reset();
485   \}
486   \textcolor{comment}{// checkForShutdown only closes the connection if these conditions are true}
487   DCHECK(writesShutdown());
488   DCHECK(transactions_.empty());
489   checkForShutdown();
490 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!increment\+Outgoing\+Streams@{increment\+Outgoing\+Streams}}
\index{increment\+Outgoing\+Streams@{increment\+Outgoing\+Streams}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{increment\+Outgoing\+Streams()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::increment\+Outgoing\+Streams (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_aa3591cfa6ee461e5a20ca0ffe4943157}


Definition at line 2637 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::on\+New\+Outgoing\+Stream(), and outgoing\+Streams\+\_\+.



Referenced by create\+Transaction(), get\+Pipeline\+Stream\+Count(), and send\+Headers().


\begin{DoxyCode}
2637                                       \{
2638   outgoingStreams_++;
2639   HTTPSessionBase::onNewOutgoingStream(outgoingStreams_);
2640 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!invalid\+Stream@{invalid\+Stream}}
\index{invalid\+Stream@{invalid\+Stream}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{invalid\+Stream(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D stream, Error\+Code code=\+Error\+Code\+::\+\_\+\+S\+P\+D\+Y\+\_\+\+I\+N\+V\+A\+L\+I\+D\+\_\+\+S\+T\+R\+E\+A\+M)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::invalid\+Stream (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{stream, }
\item[{{\bf Error\+Code}}]{code = {\ttfamily {\bf Error\+Code\+::\+\_\+\+S\+P\+D\+Y\+\_\+\+I\+N\+V\+A\+L\+I\+D\+\_\+\+S\+T\+R\+E\+AM}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a76d95e77fe08def351d56bc501a8a014}
Invoked when the codec processes callbacks for a stream we are no longer tracking. 

Definition at line 2922 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Exception\+::\+I\+N\+G\+R\+E\+S\+S\+\_\+\+A\+N\+D\+\_\+\+E\+G\+R\+E\+SS, on\+Error(), proxygen\+::\+H\+T\+T\+P\+Exception\+::set\+Codec\+Status\+Code(), and proxygen\+::\+H\+T\+T\+P\+Codec\+::supports\+Parallel\+Requests().



Referenced by get\+Max\+Concurrent\+Outgoing\+Streams\+Remote(), on\+Body(), on\+Chunk\+Complete(), on\+Chunk\+Header(), on\+Error(), on\+Ex\+Message\+Begin(), on\+Headers\+Complete(), on\+Message\+Complete(), on\+Push\+Message\+Begin(), and on\+Trailers\+Complete().


\begin{DoxyCode}
2922                                                                         \{
2923   \textcolor{keywordflow}{if} (!codec_->supportsParallelRequests()) \{
2924     LOG(ERROR) << \textcolor{stringliteral}{"Invalid stream on non-parallel codec."};
2925     \textcolor{keywordflow}{return};
2926   \}
2927 
2928   HTTPException err(HTTPException::Direction::INGRESS_AND_EGRESS,
2929                     folly::to<std::string>(\textcolor{stringliteral}{"invalid stream="}, stream));
2930   \textcolor{comment}{// TODO: Below line will change for HTTP/2 -- just call a const getter}
2931   \textcolor{comment}{// function for the status code.}
2932   err.setCodecStatusCode(code);
2933   onError(stream, err, \textcolor{keyword}{true});
2934 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!invoke\+On\+All\+Transactions@{invoke\+On\+All\+Transactions}}
\index{invoke\+On\+All\+Transactions@{invoke\+On\+All\+Transactions}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{invoke\+On\+All\+Transactions(void(\+H\+T\+T\+P\+Transaction\+::$\ast$fn)(\+Args1...), Args2 \&\&...\+args)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename... Args1, typename... Args2$>$ void proxygen\+::\+H\+T\+T\+P\+Session\+::invoke\+On\+All\+Transactions (
\begin{DoxyParamCaption}
\item[{void(H\+T\+T\+P\+Transaction\+::$\ast$)(Args1...)}]{fn, }
\item[{Args2 \&\&...}]{args}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a313e95bd7ff25e8565b8f915bf9333ce}
This function invokes a callback on all transactions. It is safe, but runs in O(n$\ast$log n) and if the callback {\itshape adds} transactions, they will not get the callback. 

Definition at line 586 of file H\+T\+T\+P\+Session.\+h.



References drain\+Impl(), error\+On\+All\+Transactions(), error\+On\+Transaction\+Id(), error\+On\+Transaction\+Ids(), find\+Transaction(), pause\+Reads\+Impl(), resume\+Reads\+Impl(), resume\+Transactions(), should\+Shutdown(), and transactions\+\_\+.



Referenced by on\+Goaway(), on\+Set\+Send\+Window(), resume\+Transactions(), run\+Loop\+Callback(), shutdown\+Transport(), and update\+Write\+Buf\+Size().


\begin{DoxyCode}
587                                                 \{
588     DestructorGuard g(\textcolor{keyword}{this});
589     std::vector<HTTPCodec::StreamID> ids;
590     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& txn: transactions_) \{
591       ids.push\_back(txn.first);
592     \}
593     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} idit = ids.begin(); idit != ids.end() && !transactions\_.empty();
594          ++idit) \{
595       \textcolor{keyword}{auto} txn = findTransaction(*idit);
596       \textcolor{keywordflow}{if} (txn != \textcolor{keyword}{nullptr}) \{
597         (txn->*fn)(std::forward<Args2>(args)...);
598       \}
599     \}
600   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!is\+Buffer\+Movable@{is\+Buffer\+Movable}}
\index{is\+Buffer\+Movable@{is\+Buffer\+Movable}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{is\+Buffer\+Movable() noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::is\+Buffer\+Movable (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_a0f7082999e3f66a8a049dac93cc89120}


Definition at line 552 of file H\+T\+T\+P\+Session.\+cpp.



Referenced by get\+H\+T\+T\+P\+Priority().


\begin{DoxyCode}
552                                       \{
553   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
554 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!is\+Busy@{is\+Busy}}
\index{is\+Busy@{is\+Busy}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{is\+Busy() const override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::is\+Busy (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [override]}}\label{classproxygen_1_1HTTPSession_ab67702bcd40390a2b42e8404bbbdc8c0}


Definition at line 448 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::is\+Busy(), and transactions\+\_\+.



Referenced by close\+When\+Idle(), and timeout\+Expired().


\begin{DoxyCode}
448                           \{
449   \textcolor{keywordflow}{return} !transactions_.empty() || codec_->isBusy();
450 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!is\+Conn\+Window\+Full@{is\+Conn\+Window\+Full}}
\index{is\+Conn\+Window\+Full@{is\+Conn\+Window\+Full}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{is\+Conn\+Window\+Full() const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::is\+Conn\+Window\+Full (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_ac542a7e7e5672a1eebac1c3864c562b3}


Definition at line 767 of file H\+T\+T\+P\+Session.\+h.



References common\+Eom(), conn\+Flow\+Control\+\_\+, proxygen\+::\+Flow\+Control\+Filter\+::get\+Available\+Send(), on\+Delete\+Ack\+Event(), on\+Last\+Byte\+Event(), and on\+Ping\+Reply\+Latency().



Referenced by get\+Next\+To\+Send().


\begin{DoxyCode}
767                                 \{
768     \textcolor{keywordflow}{return} connFlowControl_ && connFlowControl_->getAvailableSend() == 0;
769   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!is\+Detachable@{is\+Detachable}}
\index{is\+Detachable@{is\+Detachable}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{is\+Detachable(bool check\+Socket=true) const override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::is\+Detachable (
\begin{DoxyParamCaption}
\item[{bool}]{check\+Socket = {\ttfamily true}}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a7b58add6b1ec1961896913447c51d232}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_ac388822ab6bddae72234d11aaf661796}.



Definition at line 2993 of file H\+T\+T\+P\+Session.\+cpp.



References drain\+Timeout\+\_\+, flow\+Control\+Timeout\+\_\+, get\+Num\+Incoming\+Streams(), sock\+\_\+, transactions\+\_\+, writes\+Paused(), and write\+Timeout\+\_\+.



Referenced by conn\+Close\+By\+Remote().


\begin{DoxyCode}
2993                                                      \{
2994   \textcolor{keywordflow}{if} (checkSocket && sock_ && !sock_->isDetachable()) \{
2995     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
2996   \}
2997   \textcolor{keywordflow}{return} transactions_.size() == 0 && getNumIncomingStreams() == 0 &&
2998     !writesPaused() && !flowControlTimeout_.isScheduled() &&
2999     !writeTimeout_.isScheduled() && !drainTimeout_.isScheduled();
3000 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!is\+Downstream@{is\+Downstream}}
\index{is\+Downstream@{is\+Downstream}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{is\+Downstream() const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::is\+Downstream (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_ac638a06769e43a6846f6e3fdcd222a2f}


Definition at line 521 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, and proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Transport\+Direction().



Referenced by create\+Transaction(), decrement\+Transaction\+Count(), describe(), get\+Max\+Concurrent\+Outgoing\+Streams\+Remote(), get\+Pipeline\+Stream\+Count(), new\+Pushed\+Transaction(), on\+Abort(), on\+Message\+Begin(), on\+Push\+Message\+Begin(), proxygen\+::\+H\+T\+T\+P\+Session\+::\+Shutdown\+Transport\+Callback\+::run\+Loop\+Callback(), send\+Headers(), and setup\+Codec().


\begin{DoxyCode}
521                                      \{
522   \textcolor{keywordflow}{return} codec_->getTransportDirection() == TransportDirection::DOWNSTREAM;
523 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!is\+Draining@{is\+Draining}}
\index{is\+Draining@{is\+Draining}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{is\+Draining() const override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::is\+Draining (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a9a22889a5b99545ce0ca0f73bf3b622f}
Returns true if this session is draining. This can happen if \doxyref{drain()}{p.}{classproxygen_1_1HTTPSession_a7cf098767599f9b93dced643dd996efb} is called explicitly, if a G\+O\+A\+W\+AY frame is received, or during shutdown. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_a8c6aa03b14a2f69b5672f8b8b9e61b04}.



Definition at line 457 of file H\+T\+T\+P\+Session.\+h.



References drain(), draining\+\_\+, run\+Loop\+Callback(), schedule\+Write(), shutdown\+Transport(), shutdown\+Transport\+With\+Reset(), update\+Write\+Buf\+Size(), and update\+Write\+Count().


\begin{DoxyCode}
457 \{ \textcolor{keywordflow}{return} draining_; \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!is\+Upstream@{is\+Upstream}}
\index{is\+Upstream@{is\+Upstream}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{is\+Upstream() const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::is\+Upstream (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a148f158cafab7dcf1d42f3281d48acb0}


Definition at line 517 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Transport\+Direction(), and proxygen\+::\+U\+P\+S\+T\+R\+E\+AM.



Referenced by create\+Transaction(), decrement\+Transaction\+Count(), drain(), get\+Cert\+Auth\+Setting\+Val(), get\+Max\+Concurrent\+Outgoing\+Streams\+Remote(), on\+Certificate(), on\+Certificate\+Request(), on\+Goaway(), send\+Headers(), should\+Shutdown(), and verify\+Cert\+Auth\+Setting().


\begin{DoxyCode}
517                                    \{
518   \textcolor{keywordflow}{return} codec_->getTransportDirection() == TransportDirection::UPSTREAM;
519 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!maybe\+Resume\+Paused\+Pipelined\+Transaction@{maybe\+Resume\+Paused\+Pipelined\+Transaction}}
\index{maybe\+Resume\+Paused\+Pipelined\+Transaction@{maybe\+Resume\+Paused\+Pipelined\+Transaction}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{maybe\+Resume\+Paused\+Pipelined\+Transaction(size\+\_\+t old\+Stream\+Count, uint32\+\_\+t txn\+Seqn)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::maybe\+Resume\+Paused\+Pipelined\+Transaction (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{old\+Stream\+Count, }
\item[{uint32\+\_\+t}]{txn\+Seqn}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a071fbeb84224d7e88ddc7a4d4c96f429}


Definition at line 1887 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, get\+Pipeline\+Stream\+Count(), proxygen\+::\+H\+T\+T\+P\+Codec\+::supports\+Parallel\+Requests(), and transactions\+\_\+.



Referenced by detach(), get\+Pipeline\+Stream\+Count(), and on\+Egress\+Message\+Finished().


\begin{DoxyCode}
1888                                            \{
1889   \textcolor{keywordflow}{if} (!codec_->supportsParallelRequests() && !transactions_.empty() &&
1890       getPipelineStreamCount() < oldStreamCount &&
1891       getPipelineStreamCount() == 1) \{
1892     \textcolor{keyword}{auto}& nextTxn = transactions_.rbegin()->second;
1893     DCHECK\_EQ(nextTxn.getSequenceNumber(), txnSeqn + 1);
1894     DCHECK(!nextTxn.isIngressComplete());
1895     DCHECK(nextTxn.isIngressPaused());
1896     VLOG(4) << \textcolor{stringliteral}{"Resuming paused pipelined txn "} << nextTxn;
1897     nextTxn.resumeIngress();
1898     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1899   \}
1900   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1901 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!need\+To\+Block\+For\+Replay\+Safety@{need\+To\+Block\+For\+Replay\+Safety}}
\index{need\+To\+Block\+For\+Replay\+Safety@{need\+To\+Block\+For\+Replay\+Safety}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{need\+To\+Block\+For\+Replay\+Safety() const override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::need\+To\+Block\+For\+Replay\+Safety (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a1137af56342cbee20ecfc301d751249c}
This is a temporary workaround until we have a better way to allocate stream I\+Ds to waiting transactions. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_ab1aee32c238a162b654a72d7418184e4}.



Definition at line 824 of file H\+T\+T\+P\+Session.\+h.



References on\+Replay\+Safe(), and waiting\+For\+Replay\+Safety\+\_\+.


\begin{DoxyCode}
824                                                    \{
825     \textcolor{keywordflow}{return} !waitingForReplaySafety_.empty();
826   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!new\+Ex\+Transaction@{new\+Ex\+Transaction}}
\index{new\+Ex\+Transaction@{new\+Ex\+Transaction}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{new\+Ex\+Transaction(\+H\+T\+T\+P\+Transaction\+::\+Handler $\ast$handler, H\+T\+T\+P\+Codec\+::\+Stream\+I\+D control\+Stream, bool unidirectional=false) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Transaction} $\ast$F\+O\+L\+L\+Y\+\_\+\+N\+U\+L\+L\+A\+B\+LE proxygen\+::\+H\+T\+T\+P\+Session\+::new\+Ex\+Transaction (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Transaction\+::\+Handler} $\ast$}]{handler, }
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{control\+Stream, }
\item[{bool}]{unidirectional = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_a91041fbc94aedb5e52a7d90584df32f0}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_a20b32d68bfd4c591fde51b997bf8a250}.



Definition at line 681 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::create\+Stream(), create\+Transaction(), draining\+\_\+, proxygen\+::\+E\+N\+A\+B\+L\+E\+\_\+\+E\+X\+\_\+\+H\+E\+A\+D\+E\+RS, proxygen\+::\+E\+R\+R\+OR, proxygen\+::get\+Codec\+Protocol\+String(), proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Egress\+Settings(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+I\+D(), proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Protocol(), max\+Concurrent\+Outgoing\+Streams\+Remote\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+No\+Stream, outgoing\+Streams\+\_\+, proxygen\+::\+H\+T\+T\+P\+Transaction\+::set\+Handler(), set\+New\+Transaction\+Pause\+State(), and started\+\_\+.



Referenced by num\+Incoming\+Streams().


\begin{DoxyCode}
684                                   \{
685   CHECK(handler && controlStream > 0);
686   \textcolor{keyword}{auto} eSettings = codec_->getEgressSettings();
687   \textcolor{keywordflow}{if} (!eSettings || !eSettings->getSetting(SettingsId::ENABLE_EX_HEADERS, 0)) \{
688     LOG(ERROR) << getCodecProtocolString(codec_->getProtocol())
689                << \textcolor{stringliteral}{" does not support ExTransaction"};
690     \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};
691   \}
692   \textcolor{keywordflow}{if} (draining_ || (outgoingStreams_ >= maxConcurrentOutgoingStreamsRemote_)) \{
693     LOG(ERROR) << \textcolor{stringliteral}{"cannot support any more transactions in "} << *\textcolor{keyword}{this};
694     \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};
695   \}
696 
697   DCHECK(started_);
698   HTTPTransaction* txn =
699     createTransaction(codec_->createStream(),
700                       HTTPCodec::NoStream,
701                       HTTPCodec::ExAttributes(controlStream, unidirectional));
702   \textcolor{keywordflow}{if} (!txn) \{
703     \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};
704   \}
705 
706   DestructorGuard dg(\textcolor{keyword}{this});
707   txn->setHandler(handler);
708   setNewTransactionPauseState(txn->getID());
709   \textcolor{keywordflow}{return} txn;
710 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!new\+Pushed\+Transaction@{new\+Pushed\+Transaction}}
\index{new\+Pushed\+Transaction@{new\+Pushed\+Transaction}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{new\+Pushed\+Transaction(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D assoc\+Stream\+Id, H\+T\+T\+P\+Transaction\+::\+Push\+Handler $\ast$handler) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Transaction} $\ast$ proxygen\+::\+H\+T\+T\+P\+Session\+::new\+Pushed\+Transaction (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{assoc\+Stream\+Id, }
\item[{{\bf H\+T\+T\+P\+Transaction\+::\+Push\+Handler} $\ast$}]{handler}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_a6fc526a94762ffba441171c5df5e5c8a}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_aab6408cb6f66484b35618207fc5cc47d}.



Definition at line 649 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::create\+Stream(), create\+Transaction(), draining\+\_\+, proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+I\+D(), is\+Downstream(), max\+Concurrent\+Outgoing\+Streams\+Remote\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+No\+Ex\+Attributes, outgoing\+Streams\+\_\+, proxygen\+::\+H\+T\+T\+P\+Transaction\+::set\+Handler(), set\+New\+Transaction\+Pause\+State(), and proxygen\+::\+H\+T\+T\+P\+Codec\+::supports\+Push\+Transactions().



Referenced by num\+Incoming\+Streams().


\begin{DoxyCode}
651                                                 \{
652   \textcolor{keywordflow}{if} (!codec_->supportsPushTransactions()) \{
653     \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};
654   \}
655   CHECK(isDownstream());
656   CHECK\_NOTNULL(handler);
657   \textcolor{keywordflow}{if} (draining_ || (outgoingStreams_ >= maxConcurrentOutgoingStreamsRemote_)) \{
658     \textcolor{comment}{// This session doesn't support any more push transactions}
659     \textcolor{comment}{// This could be an actual problem - since a single downstream SPDY session}
660     \textcolor{comment}{// might be connected to N upstream hosts, each of which send M pushes,}
661     \textcolor{comment}{// which exceeds the limit.}
662     \textcolor{comment}{// should we queue?}
663     \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};
664   \}
665 
666   HTTPTransaction* txn = createTransaction(codec_->createStream(),
667                                            assocStreamId,
668                                            HTTPCodec::NoExAttributes);
669   \textcolor{keywordflow}{if} (!txn) \{
670     \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};
671   \}
672 
673   DestructorGuard dg(\textcolor{keyword}{this});
674   \textcolor{keyword}{auto} txnID = txn->getID();
675   txn->setHandler(handler);
676   setNewTransactionPauseState(txnID);
677   \textcolor{keywordflow}{return} txn;
678 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!notify\+Egress\+Body\+Buffered@{notify\+Egress\+Body\+Buffered}}
\index{notify\+Egress\+Body\+Buffered@{notify\+Egress\+Body\+Buffered}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{notify\+Egress\+Body\+Buffered(int64\+\_\+t bytes) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::notify\+Egress\+Body\+Buffered (
\begin{DoxyParamCaption}
\item[{int64\+\_\+t}]{bytes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_abafa372cce7d6f75d99a64a9dd8d41bb}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_a9ac88e461ed34742fde46678d52392fc}.



Definition at line 2005 of file H\+T\+T\+P\+Session.\+cpp.



References pending\+Write\+Size\+Delta\+\_\+, sock\+\_\+, and update\+Write\+Buf\+Size().



Referenced by num\+Incoming\+Streams().


\begin{DoxyCode}
2005                                                             \{
2006   pendingWriteSizeDelta_ += bytes;
2007   \textcolor{comment}{// any net change requires us to update pause/resume state in the}
2008   \textcolor{comment}{// loop callback}
2009   \textcolor{keywordflow}{if} (pendingWriteSizeDelta_ > 0) \{
2010     \textcolor{comment}{// pause inline, resume in loop}
2011     updateWriteBufSize(0);
2012   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!isLoopCallbackScheduled()) \{
2013     sock_->getEventBase()->runInLoop(\textcolor{keyword}{this});
2014   \}
2015 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!notify\+Ingress\+Body\+Processed@{notify\+Ingress\+Body\+Processed}}
\index{notify\+Ingress\+Body\+Processed@{notify\+Ingress\+Body\+Processed}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{notify\+Ingress\+Body\+Processed(uint32\+\_\+t bytes) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::notify\+Ingress\+Body\+Processed (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{bytes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_a086a9f6a363899f7d83dff3e822f8bad}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_a81b96f75e461f7e176e3178040486b56}.



Definition at line 1994 of file H\+T\+T\+P\+Session.\+cpp.



References conn\+Flow\+Control\+\_\+, proxygen\+::\+Flow\+Control\+Filter\+::ingress\+Bytes\+Processed(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::notify\+Body\+Processed(), resume\+Reads(), schedule\+Write(), and write\+Buf\+\_\+.



Referenced by num\+Incoming\+Streams().


\begin{DoxyCode}
1994                                                                \{
1995   \textcolor{keywordflow}{if} (HTTPSessionBase::notifyBodyProcessed(bytes)) \{
1996     resumeReads();
1997   \}
1998   \textcolor{keywordflow}{if} (connFlowControl_ &&
1999       connFlowControl_->ingressBytesProcessed(writeBuf_, bytes)) \{
2000     scheduleWrite();
2001   \}
2002 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!notify\+Pending\+Egress@{notify\+Pending\+Egress}}
\index{notify\+Pending\+Egress@{notify\+Pending\+Egress}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{notify\+Pending\+Egress() noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::notify\+Pending\+Egress (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_ab181c938399f0bfff3edcb36981c1565}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_a6f89b92fa724cb3a2591ab01332c18b8}.



Definition at line 453 of file H\+T\+T\+P\+Session.\+cpp.



References schedule\+Write().



Referenced by num\+Incoming\+Streams().


\begin{DoxyCode}
453                                           \{
454   scheduleWrite();
455 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!notify\+Pending\+Shutdown@{notify\+Pending\+Shutdown}}
\index{notify\+Pending\+Shutdown@{notify\+Pending\+Shutdown}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{notify\+Pending\+Shutdown() override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::notify\+Pending\+Shutdown (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}}\label{classproxygen_1_1HTTPSession_a9ae035349c89f5ea79a0bc052926a837}


Definition at line 458 of file H\+T\+T\+P\+Session.\+cpp.



References drain().



Referenced by read\+Timeout\+Expired(), and timeout\+Expired().


\begin{DoxyCode}
458                                    \{
459   VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" notified pending shutdown"};
460   drain();
461 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!num\+Incoming\+Streams@{num\+Incoming\+Streams}}
\index{num\+Incoming\+Streams@{num\+Incoming\+Streams}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{num\+Incoming\+Streams() const override}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::num\+Incoming\+Streams (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a32ded5f1b237ce4aac4dacb8d8844b6f}
Return the number of open streams started by the remote side. Parallel codecs with a maximum number of streams will invoke this to determine if a new stream exceeds the limit. 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_aad2decb51a53dc21448547ba34b0409a}.



Definition at line 403 of file H\+T\+T\+P\+Session.\+h.



References detach(), incoming\+Streams\+\_\+, new\+Ex\+Transaction(), new\+Pushed\+Transaction(), notify\+Egress\+Body\+Buffered(), notify\+Ingress\+Body\+Processed(), notify\+Pending\+Egress(), pause\+Ingress(), resume\+Ingress(), send\+Abort(), send\+Body(), send\+Chunk\+Header(), send\+Chunk\+Terminator(), send\+E\+O\+M(), send\+Headers(), send\+Priority(), send\+Window\+Update(), status\+Code, and transaction\+Timeout().


\begin{DoxyCode}
403                                                \{
404     \textcolor{keywordflow}{return} incomingStreams_;
405   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!num\+Outgoing\+Streams@{num\+Outgoing\+Streams}}
\index{num\+Outgoing\+Streams@{num\+Outgoing\+Streams}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{num\+Outgoing\+Streams() const override}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::num\+Outgoing\+Streams (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_ac9f475ec074ab357ffeeb614cfe3f83d}
Return the number of open streams started by this codec callback. Parallel codecs with a maximum number of streams will invoke this to determine if a new stream exceeds the limit. 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_a65779e4b1763aa1daa424f02a5ca3f05}.



Definition at line 400 of file H\+T\+T\+P\+Session.\+h.



References outgoing\+Streams\+\_\+.


\begin{DoxyCode}
400                                                \{
401     \textcolor{keywordflow}{return} outgoingStreams_;
402   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Abort@{on\+Abort}}
\index{on\+Abort@{on\+Abort}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Abort(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D stream\+I\+D, Error\+Code code) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Abort (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{, }
\item[{{\bf Error\+Code}}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_ac3183c78b441791ee835660ffb91ed9f}
Called when the peer has asked to shut down a stream immediately. 
\begin{DoxyParams}{Parameters}
{\em stream} & The stream ID \\
\hline
{\em code} & The code the stream was aborted with \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
Not applicable to all protocols. 
\end{DoxyNote}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_a110afc4d5324a47b9b2f6356afc70bbf}.



Definition at line 1163 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+C\+A\+N\+C\+EL, find\+Transaction(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+Assoc\+Txn\+Id(), proxygen\+::get\+Error\+Code\+String(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+Ex\+Transactions(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+Pushed\+Transactions(), proxygen\+::\+H\+T\+T\+P\+Exception\+::\+I\+N\+G\+R\+E\+S\+S\+\_\+\+A\+N\+D\+\_\+\+E\+G\+R\+E\+SS, is\+Downstream(), proxygen\+::k\+Error\+Stream\+Abort, proxygen\+::\+H\+T\+T\+P\+Transaction\+::on\+Error(), proxygen\+::\+H\+T\+T\+P\+Exception\+::set\+Codec\+Status\+Code(), proxygen\+::\+Exception\+::set\+Proxygen\+Error(), and stream\+ID.



Referenced by get\+Security\+Protocol().


\begin{DoxyCode}
1164                                           \{
1165   VLOG(4) << \textcolor{stringliteral}{"stream abort on "} << *\textcolor{keyword}{this} << \textcolor{stringliteral}{", streamID="} << streamID
1166           << \textcolor{stringliteral}{", code="} << getErrorCodeString(code);
1167   HTTPTransaction* txn = findTransaction(streamID);
1168   \textcolor{keywordflow}{if} (!txn) \{
1169     VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" abort for unrecognized transaction, streamID= "}
1170       << streamID;
1171     \textcolor{keywordflow}{return};
1172   \}
1173   HTTPException ex(HTTPException::Direction::INGRESS_AND_EGRESS,
1174     folly::to<std::string>(\textcolor{stringliteral}{"Stream aborted, streamID="},
1175       streamID, \textcolor{stringliteral}{", code="}, getErrorCodeString(code)));
1176   ex.setProxygenError(kErrorStreamAbort);
1177   ex.setCodecStatusCode(code);
1178   DestructorGuard dg(\textcolor{keyword}{this});
1179   \textcolor{keywordflow}{if} (isDownstream() && !txn->getAssocTxnId() && code == ErrorCode::CANCEL) \{
1180     \textcolor{comment}{// Cancelling the assoc txn cancels all push txns}
1181     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = txn->getPushedTransactions().begin();
1182          it != txn->getPushedTransactions().end(); ) \{
1183       \textcolor{keyword}{auto} pushTxn = findTransaction(*it);
1184       ++it;
1185       DCHECK(pushTxn != \textcolor{keyword}{nullptr});
1186       pushTxn->onError(ex);
1187     \}
1188   \}
1189   \textcolor{keyword}{auto} exTxns = txn->getExTransactions();
1190   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = exTxns.begin(); it != exTxns.end(); ++it) \{
1191     \textcolor{keyword}{auto} exTxn = findTransaction(*it);
1192     \textcolor{keywordflow}{if} (exTxn) \{
1193       exTxn->onError(ex);
1194     \}
1195   \}
1196   txn->onError(ex);
1197 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Body@{on\+Body}}
\index{on\+Body@{on\+Body}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Body(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D stream\+I\+D, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ chain, uint16\+\_\+t padding) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Body (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{stream, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{chain, }
\item[{uint16\+\_\+t}]{padding}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a4ef5f45a171469eadd34144f3a00802c}
Called for each block of message body data 
\begin{DoxyParams}{Parameters}
{\em stream} & The stream ID \\
\hline
{\em chain} & One or more buffers of body data. The codec will remove any protocol framing, such as H\+T\+T\+P/1.\+1 chunk headers, from the buffers before calling this function. \\
\hline
{\em padding} & Number of pad bytes that came with the data segment \\
\hline
\end{DoxyParams}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_af6661786cb419aa6b0138ed1d8085d52}.



Definition at line 970 of file H\+T\+T\+P\+Session.\+cpp.



References conn\+Flow\+Control\+\_\+, find\+Transaction(), proxygen\+::\+Flow\+Control\+Filter\+::ingress\+Bytes\+Processed(), invalid\+Stream(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::on\+Body\+Impl(), pause\+Reads(), schedule\+Write(), and write\+Buf\+\_\+.



Referenced by get\+Security\+Protocol().


\begin{DoxyCode}
971                                                                \{
972   FOLLY\_SCOPED\_TRACE\_SECTION(\textcolor{stringliteral}{"HTTPSession - onBody"});
973   DestructorGuard dg(\textcolor{keyword}{this});
974   \textcolor{comment}{// The codec's parser detected part of the ingress message's}
975   \textcolor{comment}{// entity-body.}
976   uint64\_t length = chain->computeChainDataLength();
977   HTTPTransaction* txn = findTransaction(streamID);
978   \textcolor{keywordflow}{if} (!txn) \{
979     \textcolor{keywordflow}{if} (connFlowControl_ &&
980         connFlowControl_->ingressBytesProcessed(writeBuf_, length)) \{
981       scheduleWrite();
982     \}
983     invalidStream(streamID);
984     \textcolor{keywordflow}{return};
985   \}
986 
987   \textcolor{keywordflow}{if} (HTTPSessionBase::onBodyImpl(std::move(chain), length, padding, txn)) \{
988     VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" pausing due to read limit exceeded."};
989     pauseReads();
990   \}
991 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Certificate@{on\+Certificate}}
\index{on\+Certificate@{on\+Certificate}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Certificate(uint16\+\_\+t cert\+Id, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ authenticator) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Certificate (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a4bdeeff83639f5b0afdec5b2d92ea48d}
Called upon receipt of an authenticator, for protocols that support secondary certificate authentication. 
\begin{DoxyParams}{Parameters}
{\em cert\+Id} & The Cert-\/\+ID identifying this authenticator \\
\hline
{\em authenticator} & The authenticator request \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
Not all protocols support secondary certificate authentication. H\+T\+T\+P/2 does, but H\+T\+T\+P/1.\+1 doesn\textquotesingle{}t. 
\end{DoxyNote}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_a39962dfe4038936e8042e725e50c2d45}.



Definition at line 1384 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, get\+Transport(), is\+Upstream(), second\+Auth\+Manager\+\_\+, and proxygen\+::\+U\+P\+S\+T\+R\+E\+AM.



Referenced by get\+Security\+Protocol().


\begin{DoxyCode}
1385                                                                     \{
1386   DestructorGuard dg(\textcolor{keyword}{this});
1387   VLOG(4) << \textcolor{stringliteral}{"CERTIFICATE on"} << *\textcolor{keyword}{this} << \textcolor{stringliteral}{", certId="} << certId;
1388 
1389   \textcolor{keywordflow}{if} (!secondAuthManager_) \{
1390     \textcolor{keywordflow}{return};
1391   \}
1392 
1393   \textcolor{keywordtype}{bool} isValid = \textcolor{keyword}{false};
1394   \textcolor{keyword}{auto} fizzBase = getTransport()->getUnderlyingTransport<AsyncFizzBase>();
1395   \textcolor{keywordflow}{if} (fizzBase) \{
1396     \textcolor{keywordflow}{if} (isUpstream()) \{
1397       isValid = secondAuthManager_->validateAuthenticator(
1398           *fizzBase,
1399           TransportDirection::UPSTREAM,
1400           certId,
1401           std::move(authenticator));
1402     \} \textcolor{keywordflow}{else} \{
1403       isValid = secondAuthManager_->validateAuthenticator(
1404           *fizzBase,
1405           TransportDirection::DOWNSTREAM,
1406           certId,
1407           std::move(authenticator));
1408     \}
1409   \} \textcolor{keywordflow}{else} \{
1410     VLOG(4) << \textcolor{stringliteral}{"Underlying transport does not support secondary "}
1411                \textcolor{stringliteral}{"authentication."};
1412     \textcolor{keywordflow}{return};
1413   \}
1414   \textcolor{keywordflow}{if} (isValid) \{
1415     VLOG(4) << \textcolor{stringliteral}{"Successfully validated the authenticator provided by the peer."};
1416   \} \textcolor{keywordflow}{else} \{
1417     VLOG(4) << \textcolor{stringliteral}{"Failed to validate the authenticator provided by the peer"};
1418   \}
1419 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Certificate\+Request@{on\+Certificate\+Request}}
\index{on\+Certificate\+Request@{on\+Certificate\+Request}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Certificate\+Request(uint16\+\_\+t request\+Id, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ auth\+Request) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Certificate\+Request (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_ae98209dbf84dc096fb2ace705407fd47}
Called upon receipt of a certificate request frame, for protocols that support secondary certificate authentication. 
\begin{DoxyParams}{Parameters}
{\em request\+Id} & The Request-\/\+ID identifying the certificate request \\
\hline
{\em auth\+Request} & The authenticator request \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
Not all protocols support secondary certificate authentication. H\+T\+T\+P/2 does, but H\+T\+T\+P/1.\+1 doesn\textquotesingle{}t. 
\end{DoxyNote}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_a982896bcd896ea45a10b03a294ded590}.



Definition at line 1347 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+Certificate(), get\+Transport(), is\+Upstream(), schedule\+Write(), second\+Auth\+Manager\+\_\+, proxygen\+::\+U\+P\+S\+T\+R\+E\+AM, and write\+Buf\+\_\+.



Referenced by get\+Security\+Protocol().


\begin{DoxyCode}
1348                                                                          \{
1349   DestructorGuard dg(\textcolor{keyword}{this});
1350   VLOG(4) << \textcolor{stringliteral}{"CERTIFICATE\_REQUEST on"} << *\textcolor{keyword}{this} << \textcolor{stringliteral}{", requestId="} << requestId;
1351 
1352   \textcolor{keywordflow}{if} (!secondAuthManager_) \{
1353     \textcolor{keywordflow}{return};
1354   \}
1355 
1356   std::pair<uint16\_t, std::unique\_ptr<folly::IOBuf>> authenticator;
1357   \textcolor{keyword}{auto} fizzBase = getTransport()->getUnderlyingTransport<AsyncFizzBase>();
1358   \textcolor{keywordflow}{if} (fizzBase) \{
1359     \textcolor{keywordflow}{if} (isUpstream()) \{
1360       authenticator =
1361           secondAuthManager_->getAuthenticator(*fizzBase,
1362                                                TransportDirection::UPSTREAM,
1363                                                requestId,
1364                                                std::move(authRequest));
1365     \} \textcolor{keywordflow}{else} \{
1366       authenticator =
1367           secondAuthManager_->getAuthenticator(*fizzBase,
1368                                                TransportDirection::DOWNSTREAM,
1369                                                requestId,
1370                                                std::move(authRequest));
1371     \}
1372   \} \textcolor{keywordflow}{else} \{
1373     VLOG(4) << \textcolor{stringliteral}{"Underlying transport does not support secondary "}
1374                \textcolor{stringliteral}{"authentication."};
1375     \textcolor{keywordflow}{return};
1376   \}
1377   \textcolor{keywordflow}{if} (codec_->generateCertificate(writeBuf_,
1378                                   authenticator.first,
1379                                   std::move(authenticator.second)) > 0) \{
1380     scheduleWrite();
1381   \}
1382 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Chunk\+Complete@{on\+Chunk\+Complete}}
\index{on\+Chunk\+Complete@{on\+Chunk\+Complete}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Chunk\+Complete(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D stream) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Chunk\+Complete (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a201f8d42c3a6754e2743b5e5661b901e}
Called when the terminating C\+R\+LF is received to end a chunk of H\+T\+TP body data.


\begin{DoxyParams}{Parameters}
{\em stream} & The stream ID \\
\hline
\end{DoxyParams}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_aad1fa297ee8929ea5032b7037956198b}.



Definition at line 1018 of file H\+T\+T\+P\+Session.\+cpp.



References find\+Transaction(), invalid\+Stream(), and proxygen\+::\+H\+T\+T\+P\+Transaction\+::on\+Ingress\+Chunk\+Complete().



Referenced by get\+Security\+Protocol().


\begin{DoxyCode}
1018                                                             \{
1019   \textcolor{comment}{// The codec's parser detected the end of the message body chunk}
1020   \textcolor{comment}{// associated with the most recent call to onChunkHeader().}
1021   HTTPTransaction* txn = findTransaction(streamID);
1022   \textcolor{keywordflow}{if} (!txn) \{
1023     invalidStream(streamID);
1024     \textcolor{keywordflow}{return};
1025   \}
1026   txn->onIngressChunkComplete();
1027 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Chunk\+Header@{on\+Chunk\+Header}}
\index{on\+Chunk\+Header@{on\+Chunk\+Header}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Chunk\+Header(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D stream, size\+\_\+t length) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Chunk\+Header (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{, }
\item[{size\+\_\+t}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a3137afb711666467861a8d61d9f15824}
Called for each H\+T\+TP chunk header.

\doxyref{on\+Chunk\+Header()}{p.}{classproxygen_1_1HTTPSession_a3137afb711666467861a8d61d9f15824} will be called when the chunk header is received. As the chunk data arrives, it will be passed to the callback normally with \doxyref{on\+Body()}{p.}{classproxygen_1_1HTTPSession_a4ef5f45a171469eadd34144f3a00802c} calls. Note that the chunk data may arrive in multiple \doxyref{on\+Body()}{p.}{classproxygen_1_1HTTPSession_a4ef5f45a171469eadd34144f3a00802c} calls\+: it is not guaranteed to arrive in a single \doxyref{on\+Body()}{p.}{classproxygen_1_1HTTPSession_a4ef5f45a171469eadd34144f3a00802c} call.

After the chunk data has been received and the terminating C\+R\+LF has been received, \doxyref{on\+Chunk\+Complete()}{p.}{classproxygen_1_1HTTPSession_a201f8d42c3a6754e2743b5e5661b901e} will be called.


\begin{DoxyParams}{Parameters}
{\em stream} & The stream ID \\
\hline
{\em length} & The chunk length. \\
\hline
\end{DoxyParams}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_ae106b662c7e855b4677ec55d4235e66d}.



Definition at line 993 of file H\+T\+T\+P\+Session.\+cpp.



References find\+Transaction(), invalid\+Stream(), and proxygen\+::\+H\+T\+T\+P\+Transaction\+::on\+Ingress\+Chunk\+Header().



Referenced by get\+Security\+Protocol().


\begin{DoxyCode}
994                                                \{
995   \textcolor{comment}{// The codec's parser detected a chunk header (meaning that this}
996   \textcolor{comment}{// connection probably is HTTP/1.1).}
997   \textcolor{comment}{//}
998   \textcolor{comment}{// After calling onChunkHeader(), the codec will call onBody() zero}
999   \textcolor{comment}{// or more times and then call onChunkComplete().}
1000   \textcolor{comment}{//}
1001   \textcolor{comment}{// The reason for this callback on the chunk header is to support}
1002   \textcolor{comment}{// an optimization.  In general, the job of the codec is to present}
1003   \textcolor{comment}{// the HTTPSession with an abstract view of a message,}
1004   \textcolor{comment}{// with all the details of wire formatting hidden.  However, there's}
1005   \textcolor{comment}{// one important case where we want to know about chunking: reverse}
1006   \textcolor{comment}{// proxying where both the client and server streams are HTTP/1.1.}
1007   \textcolor{comment}{// In that scenario, we preserve the server's chunk boundaries when}
1008   \textcolor{comment}{// sending the response to the client, in order to avoid possibly}
1009   \textcolor{comment}{// making the egress packetization worse by rechunking.}
1010   HTTPTransaction* txn = findTransaction(streamID);
1011   \textcolor{keywordflow}{if} (!txn) \{
1012     invalidStream(streamID);
1013     \textcolor{keywordflow}{return};
1014   \}
1015   txn->onIngressChunkHeader(length);
1016 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Connection\+Send\+Window\+Closed@{on\+Connection\+Send\+Window\+Closed}}
\index{on\+Connection\+Send\+Window\+Closed@{on\+Connection\+Send\+Window\+Closed}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Connection\+Send\+Window\+Closed() override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Connection\+Send\+Window\+Closed (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a8073b08df1319efb31f35fc64268d60a}


Implements {\bf proxygen\+::\+Flow\+Control\+Filter\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1FlowControlFilter_1_1Callback_ab226241c68d175d41d4465af4c2cf757}.



Definition at line 2892 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P2\+Priority\+Queue\+::empty(), flow\+Control\+Timeout\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+::\+Flow\+Control\+Timeout\+::get\+Timeout\+Duration(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Flow\+Control\+Window\+Closed(), proxygen\+::\+H\+T\+T\+P\+Session\+Stats\+::record\+Session\+Stalled(), proxygen\+::\+Wheel\+Timer\+Instance\+::schedule\+Timeout(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::session\+Stats\+\_\+, timeout\+\_\+, and txn\+Egress\+Queue\+\_\+.



Referenced by get\+Max\+Concurrent\+Outgoing\+Streams\+Remote().


\begin{DoxyCode}
2892                                                \{
2893   \textcolor{keywordflow}{if}(!txnEgressQueue_.empty()) \{
2894     VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" session stalled by flow control"};
2895     \textcolor{keywordflow}{if} (sessionStats_) \{
2896       sessionStats_->recordSessionStalled();
2897     \}
2898   \}
2899   DCHECK(!flowControlTimeout_.isScheduled());
2900   \textcolor{keywordflow}{if} (infoCallback_) \{
2901     infoCallback_->onFlowControlWindowClosed(*\textcolor{keyword}{this});
2902   \}
2903   \textcolor{keyword}{auto} timeout = flowControlTimeout_.getTimeoutDuration();
2904   \textcolor{keywordflow}{if} (timeout != std::chrono::milliseconds(0)) \{
2905     timeout_.scheduleTimeout(&flowControlTimeout_, timeout);
2906   \} \textcolor{keywordflow}{else} \{
2907     timeout_.scheduleTimeout(&flowControlTimeout_);
2908   \}
2909 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Connection\+Send\+Window\+Open@{on\+Connection\+Send\+Window\+Open}}
\index{on\+Connection\+Send\+Window\+Open@{on\+Connection\+Send\+Window\+Open}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Connection\+Send\+Window\+Open() override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Connection\+Send\+Window\+Open (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_abf2d1ccc7eab9fe9a157bbf0999d73a4}
Callback function from the flow control filter if the full window becomes not full. 

Implements {\bf proxygen\+::\+Flow\+Control\+Filter\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1FlowControlFilter_1_1Callback_a177ffe967dcc7969454c1a42ebc6f0d0}.



Definition at line 2886 of file H\+T\+T\+P\+Session.\+cpp.



References flow\+Control\+Timeout\+\_\+, and schedule\+Write().



Referenced by get\+Max\+Concurrent\+Outgoing\+Streams\+Remote().


\begin{DoxyCode}
2886                                              \{
2887   flowControlTimeout_.cancelTimeout();
2888   \textcolor{comment}{// We can write more now. Schedule a write.}
2889   scheduleWrite();
2890 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Delete\+Ack\+Event@{on\+Delete\+Ack\+Event}}
\index{on\+Delete\+Ack\+Event@{on\+Delete\+Ack\+Event}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Delete\+Ack\+Event() noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Delete\+Ack\+Event (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_a3d2b7bdd5d59059cee9b566553db91f1}


Implements {\bf proxygen\+::\+Byte\+Event\+Tracker\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1ByteEventTracker_1_1Callback_a66e469488f7fc0ea0ccd333a7b90ecbe}.



Definition at line 2942 of file H\+T\+T\+P\+Session.\+cpp.



References reads\+Shutdown(), shutdown\+Transport(), and transactions\+\_\+.



Referenced by is\+Conn\+Window\+Full().


\begin{DoxyCode}
2942                                             \{
2943   \textcolor{keywordflow}{if} (readsShutdown()) \{
2944     shutdownTransport(\textcolor{keyword}{true}, transactions_.empty());
2945   \}
2946 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Egress\+Buffer\+Cleared@{on\+Egress\+Buffer\+Cleared}}
\index{on\+Egress\+Buffer\+Cleared@{on\+Egress\+Buffer\+Cleared}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Egress\+Buffer\+Cleared() override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Egress\+Buffer\+Cleared (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_ab0bf53cea09153535c0f04b3cbaf6d21}


Definition at line 2954 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, and proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Egress\+Buffer\+Cleared().



Referenced by get\+Max\+Concurrent\+Outgoing\+Streams\+Remote().


\begin{DoxyCode}
2954                                         \{
2955   \textcolor{keywordflow}{if} (infoCallback_) \{
2956     infoCallback_->onEgressBufferCleared(*\textcolor{keyword}{this});
2957   \}
2958 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Egress\+Buffered@{on\+Egress\+Buffered}}
\index{on\+Egress\+Buffered@{on\+Egress\+Buffered}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Egress\+Buffered() override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Egress\+Buffered (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_ab2f721e17c15de3c3b8f0e6332c71933}


Definition at line 2948 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, and proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Egress\+Buffered().



Referenced by get\+Max\+Concurrent\+Outgoing\+Streams\+Remote().


\begin{DoxyCode}
2948                                    \{
2949   \textcolor{keywordflow}{if} (infoCallback_) \{
2950     infoCallback_->onEgressBuffered(*\textcolor{keyword}{this});
2951   \}
2952 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Egress\+Message\+Finished@{on\+Egress\+Message\+Finished}}
\index{on\+Egress\+Message\+Finished@{on\+Egress\+Message\+Finished}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Egress\+Message\+Finished(\+H\+T\+T\+P\+Transaction $\ast$txn, bool with\+R\+S\+T=false)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Egress\+Message\+Finished (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Transaction} $\ast$}]{txn, }
\item[{bool}]{with\+R\+ST = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_ae5aa7681b3dffcccf4cae4d2dbf36cfa}
Invoked when the transaction finishes sending a message and appropriately shuts down reads and/or writes with respect to downstream or upstream semantics. 

Definition at line 1722 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, decrement\+Transaction\+Count(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+Max\+Deferred\+Size(), get\+Pipeline\+Stream\+Count(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+Sequence\+Number(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::is\+Reusable(), maybe\+Resume\+Paused\+Pipelined\+Transaction(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Request\+End(), reads\+Shutdown(), reset\+After\+Draining\+Writes\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::set\+Close\+Reason(), shutdown\+Transport(), shutdown\+Transport\+Cb\+\_\+, sock\+\_\+, proxygen\+::\+T\+R\+A\+N\+S\+A\+C\+T\+I\+O\+N\+\_\+\+A\+B\+O\+RT, and transactions\+\_\+.



Referenced by common\+Eom(), on\+Headers\+Sent(), and send\+Abort().


\begin{DoxyCode}
1722                                                                        \{
1723   \textcolor{comment}{// If the semantics of the protocol don't permit more messages}
1724   \textcolor{comment}{// to be read or sent on this connection, close the socket in one or}
1725   \textcolor{comment}{// more directions.}
1726   CHECK(!transactions_.empty());
1727 
1728   \textcolor{keywordflow}{if} (infoCallback_) \{
1729     infoCallback_->onRequestEnd(*\textcolor{keyword}{this}, txn->getMaxDeferredSize());
1730   \}
1731   \textcolor{keyword}{auto} oldStreamCount = getPipelineStreamCount();
1732   decrementTransactionCount(txn, \textcolor{keyword}{false}, \textcolor{keyword}{true});
1733   \textcolor{keywordflow}{if} (withRST || ((!codec_->isReusable() || readsShutdown()) &&
1734                   transactions_.size() == 1)) \{
1735     \textcolor{comment}{// We should shutdown reads if we are closing with RST or we aren't}
1736     \textcolor{comment}{// interested in any further messages (ie if we are a downstream session).}
1737     \textcolor{comment}{// Upgraded sessions have independent ingress and egress, and the reads}
1738     \textcolor{comment}{// need not be shutdown on egress finish.}
1739     \textcolor{keywordflow}{if} (withRST) \{
1740       \textcolor{comment}{// Let any queued writes complete, but send a RST when done.}
1741       VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" resetting egress after this message"};
1742       resetAfterDrainingWrites_ = \textcolor{keyword}{true};
1743       setCloseReason(ConnectionCloseReason::TRANSACTION_ABORT);
1744       shutdownTransport(\textcolor{keyword}{true}, \textcolor{keyword}{true});
1745     \} \textcolor{keywordflow}{else} \{
1746       \textcolor{comment}{// the reason is already set (either not reusable or readshutdown).}
1747 
1748       \textcolor{comment}{// Defer normal shutdowns until the end of the loop.  This}
1749       \textcolor{comment}{// handles an edge case with direct responses with Connection:}
1750       \textcolor{comment}{// close served before ingress EOM.  The remainder of the ingress}
1751       \textcolor{comment}{// message may be in the parse loop, so give it a chance to}
1752       \textcolor{comment}{// finish out and avoid a kErrorEOF}
1753 
1754       \textcolor{comment}{// we can get here during shutdown, in that case do not schedule a}
1755       \textcolor{comment}{// shutdown callback again}
1756       \textcolor{keywordflow}{if} (!shutdownTransportCb_) \{
1757         \textcolor{comment}{// Just for safety, the following bumps the refcount on this session}
1758         \textcolor{comment}{// to keep it live until the loopCb runs}
1759         shutdownTransportCb_.reset(\textcolor{keyword}{new} ShutdownTransportCallback(\textcolor{keyword}{this}));
1760         sock_->getEventBase()->runInLoop(shutdownTransportCb_.get(), \textcolor{keyword}{true});
1761       \}
1762     \}
1763   \} \textcolor{keywordflow}{else} \{
1764     maybeResumePausedPipelinedTransaction(oldStreamCount,
1765                                           txn->getSequenceNumber());
1766   \}
1767 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Error@{on\+Error}}
\index{on\+Error@{on\+Error}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Error(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D stream\+I\+D, const H\+T\+T\+P\+Exception \&error, bool new\+Txn) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Error (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{stream, }
\item[{const {\bf H\+T\+T\+P\+Exception} \&}]{error, }
\item[{bool}]{new\+Txn}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_ab44f22d1c1900f583f4e8584fb2f0105}
Called when a parsing or protocol error has occurred 
\begin{DoxyParams}{Parameters}
{\em stream} & The stream ID \\
\hline
{\em error} & Description of the error \\
\hline
{\em new\+Txn} & true if on\+Message\+Begin has not been called for txn \\
\hline
\end{DoxyParams}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_a39e04260da7dd1a074393fe473d6ac34}.



Definition at line 1099 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, create\+Transaction(), find\+Transaction(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+Egress\+State(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+Handler(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::handle\+Error\+Directly(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, ingress\+Error\+\_\+, invalid\+Stream(), proxygen\+::\+H\+T\+T\+P\+Codec\+::is\+Reusable(), proxygen\+::k\+Error\+Message, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+No\+Ex\+Attributes, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+No\+Stream, proxygen\+::\+H\+T\+T\+P\+Transaction\+::on\+Error(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Ingress\+Error(), on\+New\+Transaction\+Parse\+Error(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Request\+Begin(), on\+Session\+Parse\+Error(), proxygen\+::\+S\+E\+S\+S\+I\+O\+N\+\_\+\+P\+A\+R\+S\+E\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::set\+Close\+Reason(), shutdown\+Transport(), proxygen\+::\+H\+T\+T\+P\+Codec\+::supports\+Parallel\+Requests(), and transactions\+\_\+.



Referenced by get\+Security\+Protocol(), invalid\+Stream(), on\+Headers\+Complete(), and on\+Push\+Message\+Begin().


\begin{DoxyCode}
1100                                                                    \{
1101   DestructorGuard dg(\textcolor{keyword}{this});
1102   \textcolor{comment}{// The codec detected an error in the ingress stream, possibly bad}
1103   \textcolor{comment}{// syntax, a truncated message, or bad semantics in the frame.  If reads}
1104   \textcolor{comment}{// are paused, queue up the event; otherwise, process it now.}
1105   VLOG(4) << \textcolor{stringliteral}{"Error on "} << *\textcolor{keyword}{this} << \textcolor{stringliteral}{", streamID="} << streamID
1106           << \textcolor{stringliteral}{", "} << error;
1107 
1108   \textcolor{keywordflow}{if} (ingressError_) \{
1109     \textcolor{keywordflow}{return};
1110   \}
1111   \textcolor{keywordflow}{if} (!codec_->supportsParallelRequests()) \{
1112     \textcolor{comment}{// this error should only prevent us from reading/handling more errors}
1113     \textcolor{comment}{// on serial streams}
1114     ingressError_ = \textcolor{keyword}{true};
1115     setCloseReason(ConnectionCloseReason::SESSION_PARSE_ERROR);
1116   \}
1117   \textcolor{keywordflow}{if} ((streamID == 0) && infoCallback_) \{
1118     infoCallback_->onIngressError(*\textcolor{keyword}{this}, kErrorMessage);
1119   \}
1120 
1121   \textcolor{keywordflow}{if} (!streamID) \{
1122     ingressError_ = \textcolor{keyword}{true};
1123     onSessionParseError(error);
1124     \textcolor{keywordflow}{return};
1125   \}
1126 
1127   HTTPTransaction* txn = findTransaction(streamID);
1128   \textcolor{keywordflow}{if} (!txn) \{
1129     \textcolor{keywordflow}{if} (error.hasHttpStatusCode() && streamID != 0) \{
1130       \textcolor{comment}{// If the error has an HTTP code, then parsing was fine, it just was}
1131       \textcolor{comment}{// illegal in a higher level way}
1132       txn = createTransaction(streamID, HTTPCodec::NoStream,
1133                               HTTPCodec::NoExAttributes);
1134       \textcolor{keywordflow}{if} (infoCallback_) \{
1135         infoCallback_->onRequestBegin(*\textcolor{keyword}{this});
1136       \}
1137       \textcolor{keywordflow}{if} (txn) \{
1138         handleErrorDirectly(txn, error);
1139       \}
1140     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (newTxn) \{
1141       onNewTransactionParseError(streamID, error);
1142     \} \textcolor{keywordflow}{else} \{
1143       VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" parse error with invalid transaction"};
1144       invalidStream(streamID);
1145     \}
1146     \textcolor{keywordflow}{return};
1147   \}
1148 
1149   \textcolor{keywordflow}{if} (!txn->getHandler() &&
1150       txn->getEgressState() == HTTPTransactionEgressSM::State::Start) \{
1151     handleErrorDirectly(txn, error);
1152     \textcolor{keywordflow}{return};
1153   \}
1154 
1155   txn->onError(error);
1156   \textcolor{keywordflow}{if} (!codec_->isReusable() && transactions_.empty()) \{
1157     VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{"shutdown from onError"};
1158     setCloseReason(ConnectionCloseReason::SESSION_PARSE_ERROR);
1159     shutdownTransport(\textcolor{keyword}{true}, \textcolor{keyword}{true});
1160   \}
1161 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Ex\+Message\+Begin@{on\+Ex\+Message\+Begin}}
\index{on\+Ex\+Message\+Begin@{on\+Ex\+Message\+Begin}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Ex\+Message\+Begin(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D stream\+I\+D, H\+T\+T\+P\+Codec\+::\+Stream\+I\+D control\+Stream, bool unidirectional, H\+T\+T\+P\+Message $\ast$msg) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Ex\+Message\+Begin (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{, }
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{, }
\item[{bool}]{, }
\item[{{\bf H\+T\+T\+P\+Message} $\ast$}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a597d69aedaebffdb4c442ca9d1d6408b}
Called when a new extended message is seen while parsing the ingress.


\begin{DoxyParams}{Parameters}
{\em stream} & The stream ID \\
\hline
{\em control\+Stream} & The stream ID of the associated stream, which can never be 0 \\
\hline
{\em msg} & A newly allocated \doxyref{H\+T\+T\+P\+Message}{p.}{classproxygen_1_1HTTPMessage} \\
\hline
\end{DoxyParams}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_abe873557040a9184715f7f5a47c863a1}.



Definition at line 860 of file H\+T\+T\+P\+Session.\+cpp.



References create\+Transaction(), proxygen\+::\+E\+R\+R\+OR, find\+Transaction(), get\+Message\+Priority(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, invalid\+Stream(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::is\+Ingress\+Paused(), proxygen\+::\+H\+T\+T\+P\+Codec\+::\+No\+Stream, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Request\+Begin(), and proxygen\+::\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR.



Referenced by get\+Security\+Protocol().


\begin{DoxyCode}
863                                                 \{
864   VLOG(4) << \textcolor{stringliteral}{"processing new ExMessage="} << streamID
865           << \textcolor{stringliteral}{" on controlStream="} << controlStream << \textcolor{stringliteral}{", "} << *\textcolor{keyword}{this};
866   \textcolor{keywordflow}{if} (infoCallback_) \{
867     infoCallback_->onRequestBegin(*\textcolor{keyword}{this});
868   \}
869   \textcolor{keywordflow}{if} (controlStream == 0) \{
870     LOG(ERROR) << \textcolor{stringliteral}{"ExMessage="} << streamID << \textcolor{stringliteral}{" should have an active control "}
871                << \textcolor{stringliteral}{"stream="} << controlStream << \textcolor{stringliteral}{", "} << *\textcolor{keyword}{this};
872     invalidStream(streamID, ErrorCode::PROTOCOL_ERROR);
873     \textcolor{keywordflow}{return};
874   \}
875 
876   HTTPTransaction* controlTxn = findTransaction(controlStream);
877   \textcolor{keywordflow}{if} (!controlTxn) \{
878     \textcolor{comment}{// control stream is broken, or remote sends a bogus stream id}
879     LOG(ERROR) << \textcolor{stringliteral}{"no control stream="} << controlStream << \textcolor{stringliteral}{", "} << *\textcolor{keyword}{this};
880     \textcolor{keywordflow}{return};
881   \}
882 
883   http2::PriorityUpdate messagePriority = getMessagePriority(msg);
884   \textcolor{keyword}{auto} txn = createTransaction(streamID,
885                                HTTPCodec::NoStream,
886                                HTTPCodec::ExAttributes(controlStream,
887                                                        unidirectional),
888                                messagePriority);
889   \textcolor{keywordflow}{if} (!txn) \{
890     \textcolor{keywordflow}{return};  \textcolor{comment}{// This could happen if the socket is bad.}
891   \}
892   \textcolor{comment}{// control stream may be paused if the upstream is not ready yet}
893   \textcolor{keywordflow}{if} (controlTxn->isIngressPaused()) \{
894     txn->pauseIngress();
895   \}
896 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Goaway@{on\+Goaway}}
\index{on\+Goaway@{on\+Goaway}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Goaway(uint64\+\_\+t last\+Good\+Stream\+I\+D, Error\+Code code, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ debug\+Data=nullptr) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Goaway (
\begin{DoxyParamCaption}
\item[{uint64\+\_\+t}]{, }
\item[{{\bf Error\+Code}}]{, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{ = {\ttfamily {\bf nullptr}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a22d185dd9d6777d445ae30269345c942}
Called upon receipt of a goaway. 
\begin{DoxyParams}{Parameters}
{\em last\+Good\+Stream\+ID} & Last successful stream created by the receiver \\
\hline
{\em code} & The code the connection was aborted with \\
\hline
{\em debug\+Data} & The additional debug data for diagnostic purpose \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
Not all protocols have goaways. S\+P\+DY does, but H\+T\+T\+P/1.\+1 doesn\textquotesingle{}t. 
\end{DoxyNote}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_a782493dc0d063e7f5c626db2617d042b}.



Definition at line 1199 of file H\+T\+T\+P\+Session.\+cpp.



References drain(), error\+On\+Transaction\+Id(), error\+On\+Transaction\+Ids(), proxygen\+::get\+Error\+Code\+String(), proxygen\+::get\+Error\+String(), proxygen\+::\+G\+O\+A\+W\+AY, proxygen\+::\+H\+T\+T\+P\+Exception\+::\+I\+N\+G\+R\+E\+S\+S\+\_\+\+A\+N\+D\+\_\+\+E\+G\+R\+E\+SS, invoke\+On\+All\+Transactions(), is\+Upstream(), proxygen\+::k\+Error\+Stream\+Unacknowledged, proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+No\+Stream, proxygen\+::\+H\+T\+T\+P\+Transaction\+::on\+Goaway(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::set\+Close\+Reason(), proxygen\+::\+Exception\+::set\+Proxygen\+Error(), stream\+ID, and transactions\+\_\+.



Referenced by get\+Security\+Protocol().


\begin{DoxyCode}
1201                                                                 \{
1202   DestructorGuard g(\textcolor{keyword}{this});
1203   VLOG(4) << \textcolor{stringliteral}{"GOAWAY on "} << *\textcolor{keyword}{this} << \textcolor{stringliteral}{", code="} << getErrorCodeString(code);
1204 
1205   setCloseReason(ConnectionCloseReason::GOAWAY);
1206 
1207   \textcolor{comment}{// Drain active transactions and prevent new transactions}
1208   drain();
1209 
1210   \textcolor{comment}{// We give the less-forceful onGoaway() first so that transactions have}
1211   \textcolor{comment}{// a chance to do stat tracking before potentially getting a forceful}
1212   \textcolor{comment}{// onError().}
1213   invokeOnAllTransactions(&HTTPTransaction::onGoaway, code);
1214 
1215   \textcolor{comment}{// Abort transactions which have been initiated but not created}
1216   \textcolor{comment}{// successfully at the remote end. Upstream transactions are created}
1217   \textcolor{comment}{// with odd transaction IDs and downstream transactions with even IDs.}
1218   vector<HTTPCodec::StreamID> ids;
1219   \textcolor{keyword}{auto} firstStream = HTTPCodec::NoStream;
1220 
1221   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& txn: transactions_) \{
1222     \textcolor{keyword}{auto} streamID = txn.first;
1223     \textcolor{keywordflow}{if} (((\textcolor{keywordtype}{bool})(streamID & 0x01) == isUpstream()) &&
1224         (streamID > lastGoodStreamID)) \{
1225       \textcolor{keywordflow}{if} (firstStream == HTTPCodec::NoStream) \{
1226         \textcolor{comment}{// transactions\_ is a set so it should be sorted by stream id.}
1227         \textcolor{comment}{// We will defer adding the firstStream to the id list until}
1228         \textcolor{comment}{// we can determine whether we have a codec error code.}
1229         firstStream = streamID;
1230         \textcolor{keywordflow}{continue};
1231       \}
1232 
1233       ids.push\_back(streamID);
1234     \}
1235   \}
1236 
1237 
1238   \textcolor{keywordflow}{if} (firstStream != HTTPCodec::NoStream && code != ErrorCode::NO_ERROR) \{
1239     \textcolor{comment}{// If we get a codec error, we will attempt to blame the first stream}
1240     \textcolor{comment}{// by delivering a specific error to it and let the rest of the streams}
1241     \textcolor{comment}{// get a normal unacknowledged stream error.}
1242     ProxygenError err = kErrorStreamUnacknowledged;
1243     \textcolor{keywordtype}{string} debugInfo = (debugData) ?
1244       folly::to<string>(\textcolor{stringliteral}{" with debug info: "}, (\textcolor{keywordtype}{char}*)debugData->data()) : \textcolor{stringliteral}{""};
1245     HTTPException ex(HTTPException::Direction::INGRESS_AND_EGRESS,
1246       folly::to<std::string>(getErrorString(err),
1247         \textcolor{stringliteral}{" on transaction id: "}, *firstStream,
1248         \textcolor{stringliteral}{" with codec error: "}, getErrorCodeString(code),
1249         debugInfo));
1250     ex.setProxygenError(err);
1251     errorOnTransactionId(*firstStream, std::move(ex));
1252   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (firstStream != HTTPCodec::NoStream) \{
1253     ids.push\_back(*firstStream);
1254   \}
1255 
1256   errorOnTransactionIds(ids, kErrorStreamUnacknowledged);
1257 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Headers\+Complete@{on\+Headers\+Complete}}
\index{on\+Headers\+Complete@{on\+Headers\+Complete}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Headers\+Complete(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D stream\+I\+D, std\+::unique\+\_\+ptr$<$ H\+T\+T\+P\+Message $>$ msg) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Headers\+Complete (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{stream, }
\item[{std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Message} $>$}]{msg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a01cf2e4876e0d44c1b7974833bef3272}
Called when all the headers of an ingress message have been parsed 
\begin{DoxyParams}{Parameters}
{\em stream} & The stream ID \\
\hline
{\em msg} & The message \\
\hline
{\em size} & Size of the ingress header \\
\hline
\end{DoxyParams}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_a7c462d2b3485d0d1077a9ba775f90ebc}.



Definition at line 899 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, find\+Transaction(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::get\+Control\+Stream(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, proxygen\+::\+H\+T\+T\+P\+Exception\+::\+I\+N\+G\+R\+E\+S\+S\+\_\+\+A\+N\+D\+\_\+\+E\+G\+R\+E\+SS, invalid\+Stream(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::is\+Remote\+Initiated(), proxygen\+::\+H\+T\+T\+P\+Codec\+::is\+Reusable(), on\+Error(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Ingress\+Message(), proxygen\+::\+R\+E\+F\+U\+S\+E\+D\+\_\+\+S\+T\+R\+E\+AM, proxygen\+::\+R\+E\+Q\+\_\+\+N\+O\+T\+R\+E\+U\+S\+A\+B\+LE, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::set\+Close\+Reason(), proxygen\+::\+H\+T\+T\+P\+Exception\+::set\+Codec\+Status\+Code(), setup\+On\+Headers\+Complete(), stream\+ID, and proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::transport\+Info\+\_\+.



Referenced by get\+Security\+Protocol().


\begin{DoxyCode}
900                                                             \{
901   \textcolor{comment}{// The codec's parser detected the end of an ingress message's}
902   \textcolor{comment}{// headers.}
903   VLOG(4) << \textcolor{stringliteral}{"processing ingress headers complete for "} << *\textcolor{keyword}{this} <<
904       \textcolor{stringliteral}{", streamID="} << streamID;
905 
906   \textcolor{keywordflow}{if} (!codec_->isReusable()) \{
907     setCloseReason(ConnectionCloseReason::REQ_NOTREUSABLE);
908   \}
909 
910   \textcolor{keywordflow}{if} (infoCallback_) \{
911     infoCallback_->onIngressMessage(*\textcolor{keyword}{this}, *msg.get());
912   \}
913   HTTPTransaction* txn = findTransaction(streamID);
914   \textcolor{keywordflow}{if} (!txn) \{
915     invalidStream(streamID);
916     \textcolor{keywordflow}{return};
917   \}
918 
919   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* sslCipher =
920       transportInfo_.sslCipher ? transportInfo_.sslCipher->c\_str() : \textcolor{keyword}{nullptr};
921   msg->setSecureInfo(transportInfo_.sslVersion, sslCipher);
922   msg->setSecure(transportInfo_.secure);
923 
924   \textcolor{keyword}{auto} controlStreamID = txn->getControlStream();
925   \textcolor{keywordflow}{if} (controlStreamID) \{
926     \textcolor{keyword}{auto} controlTxn = findTransaction(*controlStreamID);
927     \textcolor{keywordflow}{if} (!controlTxn) \{
928       VLOG(2) << \textcolor{stringliteral}{"txn="} << streamID << \textcolor{stringliteral}{" with a broken controlTxn="}
929               << *controlStreamID << \textcolor{stringliteral}{" "} << *\textcolor{keyword}{this};
930       HTTPException ex(
931           HTTPException::Direction::INGRESS_AND_EGRESS,
932           folly::to<std::string>(\textcolor{stringliteral}{"broken controlTxn "}, *controlStreamID));
933       onError(streamID, ex, \textcolor{keyword}{true});
934       \textcolor{keywordflow}{return};
935     \}
936 
937     \textcolor{comment}{// Call onExTransaction() only for requests.}
938     \textcolor{keywordflow}{if} (txn->isRemoteInitiated() && !controlTxn->onExTransaction(txn)) \{
939       VLOG(2) << \textcolor{stringliteral}{"Failed to add exTxn="} << streamID
940               << \textcolor{stringliteral}{" to controlTxn="} << *controlStreamID << \textcolor{stringliteral}{", "} << *\textcolor{keyword}{this};
941       HTTPException ex(
942           HTTPException::Direction::INGRESS_AND_EGRESS,
943           folly::to<std::string>(\textcolor{stringliteral}{"Fail to add exTxn "}, streamID));
944       ex.setCodecStatusCode(ErrorCode::REFUSED_STREAM);
945       onError(streamID, ex, \textcolor{keyword}{true});
946       \textcolor{keywordflow}{return};
947     \}
948   \} \textcolor{keywordflow}{else} \{
949     setupOnHeadersComplete(txn, msg.get());
950   \}
951 
952   \textcolor{comment}{// The txn may have already been aborted by the handler.}
953   \textcolor{comment}{// Verify that the txn still exists before ingress callbacks.}
954   txn = findTransaction(streamID);
955   \textcolor{keywordflow}{if} (!txn) \{
956     \textcolor{keywordflow}{return};
957   \}
958 
959   \textcolor{keywordflow}{if} (!txn->getHandler()) \{
960     txn->sendAbort();
961     \textcolor{keywordflow}{return};
962   \}
963 
964   \textcolor{comment}{// Tell the Transaction to start processing the message now}
965   \textcolor{comment}{// that the full ingress headers have arrived.}
966   txn->onIngressHeadersComplete(std::move(msg));
967 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Headers\+Sent@{on\+Headers\+Sent}}
\index{on\+Headers\+Sent@{on\+Headers\+Sent}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Headers\+Sent(const H\+T\+T\+P\+Message \&, bool)}]{\setlength{\rightskip}{0pt plus 5cm}virtual void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Headers\+Sent (
\begin{DoxyParamCaption}
\item[{const {\bf H\+T\+T\+P\+Message} \&}]{, }
\item[{bool}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_af9ed177276be468c39890fd444d3b38c}
Invoked when headers have been sent. 

Reimplemented in {\bf proxygen\+::\+H\+T\+T\+P\+Downstream\+Session} \doxyref{}{p.}{classproxygen_1_1HTTPDownstreamSession_a31074b29a9d0287158c721de87b5ba58}.



Definition at line 302 of file H\+T\+T\+P\+Session.\+h.



References all\+Transactions\+Started(), decrement\+Transaction\+Count(), get\+Codec\+Send\+Window\+Size(), get\+Next\+To\+Send(), on\+Egress\+Message\+Finished(), on\+Native\+Protocol\+Upgrade\+Impl(), send\+Priority\+Impl(), set\+New\+Transaction\+Pause\+State(), and stream\+ID.



Referenced by send\+Headers().


\begin{DoxyCode}
304               \{\}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Last\+Byte\+Event@{on\+Last\+Byte\+Event}}
\index{on\+Last\+Byte\+Event@{on\+Last\+Byte\+Event}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Last\+Byte\+Event(\+H\+T\+T\+P\+Transaction $\ast$txn, uint64\+\_\+t offset, bool eom\+Tracked) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Last\+Byte\+Event (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Transaction} $\ast$}]{txn, }
\item[{uint64\+\_\+t}]{offset, }
\item[{bool}]{eom\+Tracked}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_a262d04adeb8feb2c1bf6ebb5159b67d6}


Implements {\bf proxygen\+::\+Byte\+Event\+Tracker\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1ByteEventTracker_1_1Callback_a2089b3b9335dbc03598f35a007821883}.



Definition at line 2974 of file H\+T\+T\+P\+Session.\+cpp.



References byte\+Event\+Tracker\+\_\+, and sock\+\_\+.



Referenced by is\+Conn\+Window\+Full().


\begin{DoxyCode}
2975                                                                         \{
2976   \textcolor{keywordflow}{if} (!sock_->isEorTrackingEnabled() || !eomTracked) \{
2977     \textcolor{keywordflow}{return};
2978   \}
2979 
2980   \textcolor{keywordflow}{if} (eomOffset != sock_->getAppBytesWritten()) \{
2981     VLOG(2) << \textcolor{stringliteral}{"tracking ack to last app byte "} << eomOffset
2982         << \textcolor{stringliteral}{" while "} << sock_->getAppBytesWritten()
2983         << \textcolor{stringliteral}{" app bytes have already been written"};
2984     \textcolor{keywordflow}{return};
2985   \}
2986 
2987   VLOG(5) << \textcolor{stringliteral}{"tracking raw last byte "} << sock_->getRawBytesWritten()
2988           << \textcolor{stringliteral}{" while the app last byte is "} << eomOffset;
2989 
2990   byteEventTracker_->addAckByteEvent(sock_->getRawBytesWritten(), txn);
2991 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Message\+Begin@{on\+Message\+Begin}}
\index{on\+Message\+Begin@{on\+Message\+Begin}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Message\+Begin(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D stream\+I\+D, H\+T\+T\+P\+Message $\ast$msg) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Message\+Begin (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{stream, }
\item[{{\bf H\+T\+T\+P\+Message} $\ast$}]{msg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a0a4087a0c6fbfbb6a419dff46c0d3517}
Called when a new message is seen while parsing the ingress 
\begin{DoxyParams}{Parameters}
{\em stream} & The stream ID \\
\hline
{\em msg} & A newly allocated \doxyref{H\+T\+T\+P\+Message}{p.}{classproxygen_1_1HTTPMessage} \\
\hline
\end{DoxyParams}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_a7bcd0c639fd05f92b31806cee4f4b1aa}.



Definition at line 758 of file H\+T\+T\+P\+Session.\+cpp.



References byte\+Event\+Tracker\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, create\+Transaction(), find\+Transaction(), get\+Message\+Priority(), get\+Pipeline\+Stream\+Count(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, proxygen\+::\+H\+T\+T\+P\+Exception\+::\+I\+N\+G\+R\+E\+S\+S\+\_\+\+A\+N\+D\+\_\+\+E\+G\+R\+E\+SS, is\+Downstream(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::is\+Pushed(), live\+Transactions\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+No\+Ex\+Attributes, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+No\+Stream, proxygen\+::\+H\+T\+T\+P\+Transaction\+::on\+Error(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Request\+Begin(), reads\+Paused(), reads\+Unpaused(), proxygen\+::\+H\+T\+T\+P\+Exception\+::set\+Codec\+Status\+Code(), proxygen\+::\+S\+T\+R\+E\+A\+M\+\_\+\+C\+L\+O\+S\+ED, proxygen\+::\+H\+T\+T\+P\+Codec\+::supports\+Parallel\+Requests(), and transactions\+\_\+.



Referenced by get\+Security\+Protocol().


\begin{DoxyCode}
758                                                                         \{
759   VLOG(4) << \textcolor{stringliteral}{"processing new msg streamID="} << streamID << \textcolor{stringliteral}{" "} << *\textcolor{keyword}{this};
760   \textcolor{keywordflow}{if} (infoCallback_) \{
761     infoCallback_->onRequestBegin(*\textcolor{keyword}{this});
762   \}
763 
764   HTTPTransaction* txn = findTransaction(streamID);
765   \textcolor{keywordflow}{if} (txn) \{
766     \textcolor{keywordflow}{if} (isDownstream() && txn->isPushed()) \{
767       \textcolor{comment}{// Push streams are unidirectional (half-closed). If the downstream}
768       \textcolor{comment}{// attempts to send ingress, abort with STREAM\_CLOSED error.}
769       HTTPException ex(HTTPException::Direction::INGRESS_AND_EGRESS,
770                        \textcolor{stringliteral}{"Downstream attempts to send ingress, abort."});
771       ex.setCodecStatusCode(ErrorCode::STREAM_CLOSED);
772       txn->onError(ex);
773     \}
774     \textcolor{keywordflow}{return};  \textcolor{comment}{// If this transaction is already registered, no need to add it now}
775   \}
776 
777   http2::PriorityUpdate messagePriority = getMessagePriority(msg);
778   txn = createTransaction(streamID, HTTPCodec::NoStream,
779                           HTTPCodec::NoExAttributes, messagePriority);
780   \textcolor{keywordflow}{if} (!txn) \{
781     \textcolor{keywordflow}{return};  \textcolor{comment}{// This could happen if the socket is bad.}
782   \}
783 
784   \textcolor{keywordflow}{if} (!codec_->supportsParallelRequests() && getPipelineStreamCount() > 1) \{
785     \textcolor{comment}{// The previous transaction hasn't completed yet. Pause reads until}
786     \textcolor{comment}{// it completes; this requires pausing both transactions.}
787 
788     \textcolor{comment}{// HTTP/1.1 pipeline is detected, and which is incompactible with}
789     \textcolor{comment}{// ByteEventTracker. Drain all the ByteEvents}
790     CHECK(byteEventTracker_);
791     byteEventTracker_->drainByteEvents();
792 
793     \textcolor{comment}{// drainByteEvents() may detach txn(s). Don't pause read if one txn left}
794     \textcolor{keywordflow}{if} (getPipelineStreamCount() < 2) \{
795       DCHECK(readsUnpaused());
796       \textcolor{keywordflow}{return};
797     \}
798 
799     \textcolor{comment}{// There must be at least two transactions (we just checked). The previous}
800     \textcolor{comment}{// txns haven't completed yet. Pause reads until they complete}
801     DCHECK\_GE(transactions_.size(), 2);
802     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = ++transactions_.rbegin(); it != transactions_.rend(); ++it) \{
803       DCHECK(it->second.isIngressEOMSeen());
804       it->second.pauseIngress();
805     \}
806     transactions_.rbegin()->second.pauseIngress();
807     DCHECK\_EQ(liveTransactions_, 0);
808     DCHECK(readsPaused());
809   \}
810 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Message\+Complete@{on\+Message\+Complete}}
\index{on\+Message\+Complete@{on\+Message\+Complete}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Message\+Complete(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D stream\+I\+D, bool upgrade) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Message\+Complete (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{stream, }
\item[{bool}]{upgrade}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a564c10e0a4a6fbf287eed792501337f8}
Called at end of a message (including body and trailers, if applicable) 
\begin{DoxyParams}{Parameters}
{\em stream} & The stream ID \\
\hline
{\em upgrade} & Whether the connection has been upgraded to another protocol. \\
\hline
\end{DoxyParams}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_a8b42c169cc7f48b42be7f97b463db08e}.



Definition at line 1041 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, decrement\+Transaction\+Count(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::extra\+Response\+Expected(), find\+Transaction(), ingress\+Upgraded\+\_\+, invalid\+Stream(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::is\+Downstream(), proxygen\+::\+H\+T\+T\+P\+Codec\+::is\+Reusable(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::on\+Ingress\+E\+O\+M(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::on\+Ingress\+Upgrade(), shutdown\+Transport(), stream\+ID, proxygen\+::\+H\+T\+T\+P\+Codec\+::supports\+Parallel\+Requests(), and proxygen\+::\+T\+CP.



Referenced by get\+Security\+Protocol().


\begin{DoxyCode}
1042                                              \{
1043   DestructorGuard dg(\textcolor{keyword}{this});
1044   \textcolor{comment}{// The codec's parser detected the end of the ingress message for}
1045   \textcolor{comment}{// this transaction.}
1046   VLOG(4) << \textcolor{stringliteral}{"processing ingress message complete for "} << *\textcolor{keyword}{this} <<
1047     \textcolor{stringliteral}{", streamID="} << streamID;
1048   HTTPTransaction* txn = findTransaction(streamID);
1049   \textcolor{keywordflow}{if} (!txn) \{
1050     invalidStream(streamID);
1051     \textcolor{keywordflow}{return};
1052   \}
1053 
1054   \textcolor{keywordflow}{if} (upgrade) \{
1055     \textcolor{comment}{/* Send the upgrade callback to the transaction and the handler.}
1056 \textcolor{comment}{     * Currently we support upgrades for only HTTP sessions and not SPDY}
1057 \textcolor{comment}{     * sessions.}
1058 \textcolor{comment}{     */}
1059     ingressUpgraded_ = \textcolor{keyword}{true};
1060     txn->onIngressUpgrade(UpgradeProtocol::TCP);
1061     \textcolor{keywordflow}{return};
1062   \}
1063 
1064   \textcolor{comment}{// txnIngressFinished = !1xx response}
1065   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} txnIngressFinished =
1066     txn->isDownstream() || !txn->extraResponseExpected();
1067   \textcolor{keywordflow}{if} (txnIngressFinished) \{
1068     decrementTransactionCount(txn, \textcolor{keyword}{true}, \textcolor{keyword}{false});
1069   \}
1070   txn->onIngressEOM();
1071 
1072   \textcolor{comment}{// The codec knows, based on the semantics of whatever protocol it}
1073   \textcolor{comment}{// supports, whether it's valid for any more ingress messages to arrive}
1074   \textcolor{comment}{// after this one.  For example, an HTTP/1.1 request containing}
1075   \textcolor{comment}{// "Connection: close" indicates the end of the ingress, whereas a}
1076   \textcolor{comment}{// SPDY session generally can handle more messages at any time.}
1077   \textcolor{comment}{//}
1078   \textcolor{comment}{// If the connection is not reusable, we close the read side of it}
1079   \textcolor{comment}{// but not the write side.  There are two reasons why more writes}
1080   \textcolor{comment}{// may occur after this point:}
1081   \textcolor{comment}{//   * If there are previous writes buffered up in the pendingWrites\_}
1082   \textcolor{comment}{//     queue, we need to attempt to complete them.}
1083   \textcolor{comment}{//   * The Handler associated with the transaction may want to}
1084   \textcolor{comment}{//     produce more egress data when the ingress message is fully}
1085   \textcolor{comment}{//     complete.  (As a common example, an application that handles}
1086   \textcolor{comment}{//     form POSTs may not be able to even start generating a response}
1087   \textcolor{comment}{//     until it has received the full request body.)}
1088   \textcolor{comment}{//}
1089   \textcolor{comment}{// There may be additional checks that need to be performed that are}
1090   \textcolor{comment}{// specific to requests or responses, so we call the subclass too.}
1091   \textcolor{keywordflow}{if} (!codec_->isReusable() &&
1092       txnIngressFinished &&
1093       !codec_->supportsParallelRequests()) \{
1094     VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" cannot reuse ingress"};
1095     shutdownTransport(\textcolor{keyword}{true}, \textcolor{keyword}{false});
1096   \}
1097 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Native\+Protocol\+Upgrade\+Impl@{on\+Native\+Protocol\+Upgrade\+Impl}}
\index{on\+Native\+Protocol\+Upgrade\+Impl@{on\+Native\+Protocol\+Upgrade\+Impl}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Native\+Protocol\+Upgrade\+Impl(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D txn, std\+::unique\+\_\+ptr$<$ H\+T\+T\+P\+Codec $>$ codec, const std\+::string \&protocol\+String)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Native\+Protocol\+Upgrade\+Impl (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{txn, }
\item[{std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Codec} $>$}]{codec, }
\item[{const std\+::string \&}]{protocol\+String}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a21c24124cbf0b80891dadba2192c5443}


Definition at line 1421 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, conn\+Flow\+Control\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::create\+Stream(), find\+Transaction(), get\+Codec\+Send\+Window\+Size(), proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Default\+Window\+Size(), proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Egress\+Settings(), proxygen\+::\+I\+N\+I\+T\+I\+A\+L\+\_\+\+W\+I\+N\+D\+O\+W\+\_\+\+S\+I\+ZE, initial\+Receive\+Window\+\_\+, max\+Concurrent\+Incoming\+Streams\+\_\+, max\+Concurrent\+Outgoing\+Streams\+Remote\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::on\+Codec\+Changed(), receive\+Session\+Window\+Size\+\_\+, receive\+Stream\+Window\+Size\+\_\+, proxygen\+::\+H\+T\+T\+P\+Transaction\+::reset(), schedule\+Write(), send\+Settings(), proxygen\+::\+Filter\+Chain$<$ T1, T2, Filter\+Type, set\+\_\+callback, Take\+Ownership $>$\+::set\+Destination(), proxygen\+::\+Flow\+Control\+Filter\+::set\+Receive\+Window\+Size(), proxygen\+::\+H\+T\+T\+P\+Settings\+::set\+Setting(), settings, setup\+Codec(), sock\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::supports\+Parallel\+Requests(), proxygen\+::\+H\+T\+T\+P\+Codec\+::supports\+Stream\+Flow\+Control(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::transport\+Info\+\_\+, and write\+Buf\+\_\+.



Referenced by on\+Headers\+Sent(), proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::on\+Native\+Protocol\+Upgrade(), and proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::on\+Native\+Protocol\+Upgrade().


\begin{DoxyCode}
1423                                    \{
1424   CHECK\_EQ(streamID, 1);
1425   HTTPTransaction* txn = findTransaction(streamID);
1426   CHECK(txn);
1427   \textcolor{comment}{// only HTTP1xCodec calls onNativeProtocolUpgrade}
1428   CHECK(!codec_->supportsParallelRequests());
1429 
1430   \textcolor{comment}{// Reset to  defaults}
1431   maxConcurrentIncomingStreams_ = 100;
1432   maxConcurrentOutgoingStreamsRemote_ = 10000;
1433 
1434   \textcolor{comment}{// overwrite destination, delay current codec deletion until the end}
1435   \textcolor{comment}{// of the event loop}
1436   \textcolor{keyword}{auto} oldCodec = codec_.setDestination(std::move(codec));
1437   sock_->getEventBase()->runInLoop([oldCodec = std::move(oldCodec)] () \{\});
1438 
1439   onCodecChanged();
1440 
1441   setupCodec();
1442 
1443   \textcolor{comment}{// txn will be streamID=1, have to make a placeholder}
1444   (void)codec_->createStream();
1445 
1446   \textcolor{comment}{// This can happen if flow control was not explicitly set, and it got the}
1447   \textcolor{comment}{// HTTP1xCodec defaults.  Reset to the new codec default}
1448   \textcolor{keywordflow}{if} (initialReceiveWindow_ == 0 || receiveStreamWindowSize_ == 0 ||
1449       receiveSessionWindowSize_ == 0) \{
1450     initialReceiveWindow_ = receiveStreamWindowSize_ =
1451       receiveSessionWindowSize_ = codec_->getDefaultWindowSize();
1452   \}
1453 
1454   \textcolor{comment}{// trigger settings frame that would have gone out in startNow()}
1455   HTTPSettings* settings = codec_->getEgressSettings();
1456   \textcolor{keywordflow}{if} (settings) \{
1457     settings->setSetting(SettingsId::INITIAL_WINDOW_SIZE,
1458                          initialReceiveWindow_);
1459   \}
1460   sendSettings();
1461   \textcolor{keywordflow}{if} (connFlowControl_) \{
1462     connFlowControl_->setReceiveWindowSize(writeBuf_,
1463                                            receiveSessionWindowSize_);
1464     scheduleWrite();
1465   \}
1466 
1467   \textcolor{comment}{// Convert the transaction that contained the Upgrade header}
1468   txn->reset(codec_->supportsStreamFlowControl(),
1469              initialReceiveWindow_,
1470              receiveStreamWindowSize_,
1471              getCodecSendWindowSize());
1472 
1473   \textcolor{keywordflow}{if} (!transportInfo_.secure &&
1474       (!transportInfo_.appProtocol ||
1475        transportInfo_.appProtocol->empty())) \{
1476     transportInfo_.appProtocol = std::make\_shared<string>(
1477       protocolString);
1478   \}
1479 
1480   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1481 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+New\+Transaction\+Parse\+Error@{on\+New\+Transaction\+Parse\+Error}}
\index{on\+New\+Transaction\+Parse\+Error@{on\+New\+Transaction\+Parse\+Error}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+New\+Transaction\+Parse\+Error(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D stream\+I\+D, const H\+T\+T\+P\+Exception \&error)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+New\+Transaction\+Parse\+Error (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{stream\+ID, }
\item[{const {\bf H\+T\+T\+P\+Exception} \&}]{error}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a8ae5da6c95ed842ddf2a0d8e83397478}
Send a transaction abort and leave the session and transport intact. 

Definition at line 2754 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+Rst\+Stream(), proxygen\+::\+H\+T\+T\+P\+Exception\+::get\+Codec\+Status\+Code(), proxygen\+::\+H\+T\+T\+P\+Exception\+::has\+Codec\+Status\+Code(), proxygen\+::\+H\+T\+T\+P\+Codec\+::is\+Reusable(), schedule\+Write(), proxygen\+::\+S\+E\+S\+S\+I\+O\+N\+\_\+\+P\+A\+R\+S\+E\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::set\+Close\+Reason(), and write\+Buf\+\_\+.



Referenced by on\+Error(), and session\+Byte\+Offset().


\begin{DoxyCode}
2755                                                                          \{
2756   VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" parse error with new transaction"};
2757   \textcolor{keywordflow}{if} (error.hasCodecStatusCode()) \{
2758     codec_->generateRstStream(writeBuf_, streamID, error.getCodecStatusCode());
2759     scheduleWrite();
2760   \}
2761   \textcolor{keywordflow}{if} (!codec_->isReusable()) \{
2762     \textcolor{comment}{// HTTP 1x codec does not support per stream abort so this will}
2763     \textcolor{comment}{// render the codec not reusable}
2764     setCloseReason(ConnectionCloseReason::SESSION_PARSE_ERROR);
2765   \}
2766 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Ping\+Reply@{on\+Ping\+Reply}}
\index{on\+Ping\+Reply@{on\+Ping\+Reply}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Ping\+Reply(uint64\+\_\+t unique\+I\+D) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Ping\+Reply (
\begin{DoxyParamCaption}
\item[{uint64\+\_\+t}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a1ce7c717bb5a5e5410a3f7f2506cd8a9}
Called upon receipt of a ping reply 
\begin{DoxyParams}{Parameters}
{\em unique\+ID} & Unique identifier for the ping \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
Not all protocols have pings. S\+P\+DY does, but H\+T\+T\+P/1.\+1 doesn\textquotesingle{}t. 
\end{DoxyNote}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_a6ebe6de42080d9b8834f48add6f63553}.



Definition at line 1278 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, and proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Ping\+Reply\+Received().



Referenced by get\+Security\+Protocol().


\begin{DoxyCode}
1278                                                \{
1279   VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" got ping reply with id="} << uniqueID;
1280   \textcolor{keywordflow}{if} (infoCallback_) \{
1281     infoCallback_->onPingReplyReceived();
1282   \}
1283 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Ping\+Reply\+Latency@{on\+Ping\+Reply\+Latency}}
\index{on\+Ping\+Reply\+Latency@{on\+Ping\+Reply\+Latency}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Ping\+Reply\+Latency(int64\+\_\+t latency) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Ping\+Reply\+Latency (
\begin{DoxyParamCaption}
\item[{int64\+\_\+t}]{latency}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_a63363dd6eb679673b1f548176994f4c9}


Implements {\bf proxygen\+::\+Byte\+Event\+Tracker\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1ByteEventTracker_1_1Callback_a2dbef0abec0b00ac3a2a53eafaf19bcd}.



Definition at line 2936 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, and proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Ping\+Reply\+Sent().



Referenced by is\+Conn\+Window\+Full().


\begin{DoxyCode}
2936                                                              \{
2937   \textcolor{keywordflow}{if} (infoCallback_ && latency >= 0) \{
2938     infoCallback_->onPingReplySent(latency);
2939   \}
2940 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Ping\+Request@{on\+Ping\+Request}}
\index{on\+Ping\+Request@{on\+Ping\+Request}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Ping\+Request(uint64\+\_\+t unique\+I\+D) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Ping\+Request (
\begin{DoxyParamCaption}
\item[{uint64\+\_\+t}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_ab5e3ba18cca07e6e6bfff73e1d549c21}
Called upon receipt of a ping request 
\begin{DoxyParams}{Parameters}
{\em unique\+ID} & Unique identifier for the ping \\
\hline
\end{DoxyParams}
\begin{DoxyNote}{Note}
Not all protocols have pings. S\+P\+DY does, but H\+T\+T\+P/1.\+1 doesn\textquotesingle{}t. 
\end{DoxyNote}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_a1740eddb4466d8d9a411f558d37c7d39}.



Definition at line 1259 of file H\+T\+T\+P\+Session.\+cpp.



References byte\+Event\+Tracker\+\_\+, bytes\+Scheduled\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+Ping\+Reply(), proxygen\+::get\+Current\+Time(), schedule\+Write(), and write\+Buf\+\_\+.



Referenced by get\+Security\+Protocol().


\begin{DoxyCode}
1259                                                  \{
1260   VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" got ping request with id="} << uniqueID;
1261 
1262   TimePoint timestamp = getCurrentTime();
1263 
1264   \textcolor{comment}{// Insert the ping reply to the head of writeBuf\_}
1265   folly::IOBufQueue pingBuf(folly::IOBufQueue::cacheChainLength());
1266   codec_->generatePingReply(pingBuf, uniqueID);
1267   \textcolor{keywordtype}{size\_t} pingSize = pingBuf.chainLength();
1268   pingBuf.append(writeBuf_.move());
1269   writeBuf_.append(pingBuf.move());
1270 
1271   \textcolor{keywordflow}{if} (byteEventTracker_) \{
1272     byteEventTracker_->addPingByteEvent(pingSize, timestamp, bytesScheduled_);
1273   \}
1274 
1275   scheduleWrite();
1276 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Priority@{on\+Priority}}
\index{on\+Priority@{on\+Priority}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Priority(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D stream, const H\+T\+T\+P\+Message\+::\+H\+T\+T\+P\+Priority \&) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Priority (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{, }
\item[{const {\bf H\+T\+T\+P\+Message\+::\+H\+T\+T\+P\+Priority} \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a1da743cba2417a010d2d1fa7a7333f79}
Called upon receipt of a priority frame, for protocols that support dynamic priority 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_aa3960bf891965283f9a99797af9e99b3}.



Definition at line 1330 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P2\+Priority\+Queue\+::add\+Or\+Update\+Priority\+Node(), find\+Transaction(), get\+H\+T\+T\+P2\+Priorities\+Enabled(), and txn\+Egress\+Queue\+\_\+.



Referenced by get\+Security\+Protocol().


\begin{DoxyCode}
1331                                                                  \{
1332   \textcolor{keywordflow}{if} (!getHTTP2PrioritiesEnabled()) \{
1333     \textcolor{keywordflow}{return};
1334   \}
1335   http2::PriorityUpdate h2Pri\{std::get<0>(pri), std::get<1>(pri),
1336       std::get<2>(pri)\};
1337   HTTPTransaction* txn = findTransaction(streamID);
1338   \textcolor{keywordflow}{if} (txn) \{
1339     \textcolor{comment}{// existing txn, change pri}
1340     txn->onPriorityUpdate(h2Pri);
1341   \} \textcolor{keywordflow}{else} \{
1342     \textcolor{comment}{// virtual node}
1343     txnEgressQueue_.addOrUpdatePriorityNode(streamID, h2Pri);
1344   \}
1345 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Push\+Message\+Begin@{on\+Push\+Message\+Begin}}
\index{on\+Push\+Message\+Begin@{on\+Push\+Message\+Begin}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Push\+Message\+Begin(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D stream\+I\+D, H\+T\+T\+P\+Codec\+::\+Stream\+I\+D assoc\+Stream\+I\+D, H\+T\+T\+P\+Message $\ast$msg) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Push\+Message\+Begin (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{, }
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{, }
\item[{{\bf H\+T\+T\+P\+Message} $\ast$}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_ac22c3f0f0f6c3162a805150faeae3577}
Called when a new push message is seen while parsing the ingress.


\begin{DoxyParams}{Parameters}
{\em stream} & The stream ID \\
\hline
{\em assoc\+Stream} & The stream ID of the associated stream, which can never be 0 \\
\hline
{\em msg} & A newly allocated \doxyref{H\+T\+T\+P\+Message}{p.}{classproxygen_1_1HTTPMessage} \\
\hline
\end{DoxyParams}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_a2a54bb421215a2929e2c8ee0d2112032}.



Definition at line 813 of file H\+T\+T\+P\+Session.\+cpp.



References create\+Transaction(), find\+Transaction(), get\+Message\+Priority(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, proxygen\+::\+H\+T\+T\+P\+Exception\+::\+I\+N\+G\+R\+E\+S\+S\+\_\+\+A\+N\+D\+\_\+\+E\+G\+R\+E\+SS, invalid\+Stream(), is\+Downstream(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::is\+Ingress\+E\+O\+M\+Seen(), proxygen\+::\+H\+T\+T\+P\+Codec\+::\+No\+Ex\+Attributes, on\+Error(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::on\+Pushed\+Transaction(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Request\+Begin(), proxygen\+::\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, proxygen\+::\+R\+E\+F\+U\+S\+E\+D\+\_\+\+S\+T\+R\+E\+AM, and proxygen\+::\+H\+T\+T\+P\+Exception\+::set\+Codec\+Status\+Code().



Referenced by get\+Security\+Protocol().


\begin{DoxyCode}
815                                                   \{
816   VLOG(4) << \textcolor{stringliteral}{"processing new push promise streamID="} << streamID
817           << \textcolor{stringliteral}{" on assocStreamID="} << assocStreamID << \textcolor{stringliteral}{" "} << *\textcolor{keyword}{this};
818   \textcolor{keywordflow}{if} (infoCallback_) \{
819     infoCallback_->onRequestBegin(*\textcolor{keyword}{this});
820   \}
821   \textcolor{keywordflow}{if} (assocStreamID == 0) \{
822     VLOG(2) << \textcolor{stringliteral}{"push promise "} << streamID << \textcolor{stringliteral}{" should be associated with "}
823             << \textcolor{stringliteral}{"an active stream="} << assocStreamID << \textcolor{stringliteral}{" "} << *\textcolor{keyword}{this};
824     invalidStream(streamID, ErrorCode::PROTOCOL_ERROR);
825     \textcolor{keywordflow}{return};
826   \}
827 
828   \textcolor{keywordflow}{if} (isDownstream()) \{
829     VLOG(2) << \textcolor{stringliteral}{"push promise cannot be sent to upstream "} << *\textcolor{keyword}{this};
830     invalidStream(streamID, ErrorCode::PROTOCOL_ERROR);
831     \textcolor{keywordflow}{return};
832   \}
833 
834   HTTPTransaction* assocTxn = findTransaction(assocStreamID);
835   \textcolor{keywordflow}{if} (!assocTxn || assocTxn->isIngressEOMSeen()) \{
836     VLOG(2) << \textcolor{stringliteral}{"cannot find the assocTxn="} << assocTxn
837             << \textcolor{stringliteral}{", or assoc stream is already closed by upstream"} << *\textcolor{keyword}{this};
838     invalidStream(streamID, ErrorCode::PROTOCOL_ERROR);
839     \textcolor{keywordflow}{return};
840   \}
841 
842   http2::PriorityUpdate messagePriority = getMessagePriority(msg);
843   \textcolor{keyword}{auto} txn = createTransaction(streamID, assocStreamID,
844                                HTTPCodec::NoExAttributes, messagePriority);
845   \textcolor{keywordflow}{if} (!txn) \{
846     \textcolor{keywordflow}{return};  \textcolor{comment}{// This could happen if the socket is bad.}
847   \}
848 
849   \textcolor{keywordflow}{if} (!assocTxn->onPushedTransaction(txn)) \{
850     VLOG(1) << \textcolor{stringliteral}{"Failed to add pushed txn "} << streamID
851             << \textcolor{stringliteral}{" to assoc txn "} << assocStreamID << \textcolor{stringliteral}{" on "} << *\textcolor{keyword}{this};
852     HTTPException ex(HTTPException::Direction::INGRESS_AND_EGRESS,
853       folly::to<std::string>(\textcolor{stringliteral}{"Failed to add pushed transaction "}, streamID));
854     ex.setCodecStatusCode(ErrorCode::REFUSED_STREAM);
855     onError(streamID, ex, \textcolor{keyword}{true});
856   \}
857 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Replay\+Safe@{on\+Replay\+Safe}}
\index{on\+Replay\+Safe@{on\+Replay\+Safe}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Replay\+Safe() noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Replay\+Safe (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_ae436dca1500823b949fb266db3c2ac29}
Callback from the transport to this \doxyref{H\+T\+T\+P\+Session}{p.}{classproxygen_1_1HTTPSession} to signal when the transport has become replay safe. 

Definition at line 2960 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Full\+Handshake\+Completion(), sock\+\_\+, and waiting\+For\+Replay\+Safety\+\_\+.



Referenced by need\+To\+Block\+For\+Replay\+Safety().


\begin{DoxyCode}
2960                                         \{
2961   CHECK(sock_);
2962   sock_->setReplaySafetyCallback(\textcolor{keyword}{nullptr});
2963 
2964   \textcolor{keywordflow}{if} (infoCallback_) \{
2965     infoCallback_->onFullHandshakeCompletion(*\textcolor{keyword}{this});
2966   \}
2967 
2968   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} callback : waitingForReplaySafety_) \{
2969     callback->onReplaySafe();
2970   \}
2971   waitingForReplaySafety\_.clear();
2972 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Session\+Parse\+Error@{on\+Session\+Parse\+Error}}
\index{on\+Session\+Parse\+Error@{on\+Session\+Parse\+Error}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Session\+Parse\+Error(const H\+T\+T\+P\+Exception \&error)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Session\+Parse\+Error (
\begin{DoxyParamCaption}
\item[{const {\bf H\+T\+T\+P\+Exception} \&}]{error}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a64dbb1a5aebced260bcd58985ed18de8}
Send a session layer abort and shutdown the transport for reads and writes. 

Definition at line 2738 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+Goaway(), proxygen\+::\+H\+T\+T\+P\+Exception\+::get\+Codec\+Status\+Code(), proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Last\+Incoming\+Stream\+I\+D(), proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Protocol(), proxygen\+::\+H\+T\+T\+P\+Exception\+::has\+Codec\+Status\+Code(), proxygen\+::is\+H\+T\+T\+P2\+Codec\+Protocol(), schedule\+Write(), proxygen\+::\+S\+E\+S\+S\+I\+O\+N\+\_\+\+P\+A\+R\+S\+E\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::set\+Close\+Reason(), shutdown\+Transport(), proxygen\+::\+Exception\+::what(), and write\+Buf\+\_\+.



Referenced by on\+Error(), and session\+Byte\+Offset().


\begin{DoxyCode}
2738                                                                 \{
2739   VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" session layer parse error. Terminate the session."};
2740   \textcolor{keywordflow}{if} (error.hasCodecStatusCode()) \{
2741     std::unique\_ptr<folly::IOBuf> errorMsg =
2742       folly::IOBuf::copyBuffer(error.what());
2743     codec_->generateGoaway(writeBuf_,
2744                            codec_->getLastIncomingStreamID(),
2745                            error.getCodecStatusCode(),
2746                            isHTTP2CodecProtocol(codec_->getProtocol()) ?
2747                            std::move(errorMsg) : nullptr);
2748     scheduleWrite();
2749   \}
2750   setCloseReason(ConnectionCloseReason::SESSION_PARSE_ERROR);
2751   shutdownTransport(\textcolor{keyword}{true}, \textcolor{keyword}{true});
2752 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Set\+Max\+Initiated\+Streams@{on\+Set\+Max\+Initiated\+Streams}}
\index{on\+Set\+Max\+Initiated\+Streams@{on\+Set\+Max\+Initiated\+Streams}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Set\+Max\+Initiated\+Streams(uint32\+\_\+t max\+Txns)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Set\+Max\+Initiated\+Streams (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{max\+Txns}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_aa55102f8247091f8991987c31cad731a}


Definition at line 1489 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, max\+Concurrent\+Outgoing\+Streams\+Remote\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Settings\+Outgoing\+Streams\+Full(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Settings\+Outgoing\+Streams\+Not\+Full(), and proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::supports\+More\+Transactions().



Referenced by get\+Max\+Concurrent\+Outgoing\+Streams\+Remote(), and on\+Settings().


\begin{DoxyCode}
1489                                                            \{
1490   VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" got new maximum number of concurrent txns "}
1491           << \textcolor{stringliteral}{"we can initiate: "} << maxTxns;
1492   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} didSupport = supportsMoreTransactions();
1493   maxConcurrentOutgoingStreamsRemote_ = maxTxns;
1494   \textcolor{keywordflow}{if} (infoCallback_ && didSupport != supportsMoreTransactions()) \{
1495     \textcolor{keywordflow}{if} (didSupport) \{
1496       infoCallback_->onSettingsOutgoingStreamsFull(*\textcolor{keyword}{this});
1497     \} \textcolor{keywordflow}{else} \{
1498       infoCallback_->onSettingsOutgoingStreamsNotFull(*\textcolor{keyword}{this});
1499     \}
1500   \}
1501 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Set\+Send\+Window@{on\+Set\+Send\+Window}}
\index{on\+Set\+Send\+Window@{on\+Set\+Send\+Window}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Set\+Send\+Window(uint32\+\_\+t window\+Size)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Set\+Send\+Window (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{window\+Size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_aa124be6ff34cd03af98ac3b283ba2af9}


Definition at line 1483 of file H\+T\+T\+P\+Session.\+cpp.



References invoke\+On\+All\+Transactions(), and proxygen\+::\+H\+T\+T\+P\+Transaction\+::on\+Ingress\+Set\+Send\+Window().



Referenced by get\+Max\+Concurrent\+Outgoing\+Streams\+Remote(), and on\+Settings().


\begin{DoxyCode}
1483                                                      \{
1484   VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" got send window size adjustment. new="} << windowSize;
1485   invokeOnAllTransactions(&HTTPTransaction::onIngressSetSendWindow,
1486                           windowSize);
1487 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Settings@{on\+Settings}}
\index{on\+Settings@{on\+Settings}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Settings(const Settings\+List \&settings) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Settings (
\begin{DoxyParamCaption}
\item[{const {\bf Settings\+List} \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a51b54c75597c9ead6142aa8c26689b09}
Called upon receipt of a settings frame, for protocols that support settings.


\begin{DoxyParams}{Parameters}
{\em settings} & a list of settings that were sent in the settings frame \\
\hline
\end{DoxyParams}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_a74342e68c4a6845289a3385f947d1b65}.



Definition at line 1302 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+Settings\+Ack(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, proxygen\+::\+I\+N\+I\+T\+I\+A\+L\+\_\+\+W\+I\+N\+D\+O\+W\+\_\+\+S\+I\+ZE, proxygen\+::\+M\+A\+X\+\_\+\+C\+O\+N\+C\+U\+R\+R\+E\+N\+T\+\_\+\+S\+T\+R\+E\+A\+MS, on\+Set\+Max\+Initiated\+Streams(), on\+Set\+Send\+Window(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Settings(), schedule\+Write(), proxygen\+::\+S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+H\+T\+T\+P\+\_\+\+C\+E\+R\+T\+\_\+\+A\+U\+TH, verify\+Cert\+Auth\+Setting(), and write\+Buf\+\_\+.



Referenced by get\+Security\+Protocol().


\begin{DoxyCode}
1302                                                          \{
1303   DestructorGuard g(\textcolor{keyword}{this});
1304   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}& setting : settings) \{
1305     \textcolor{keywordflow}{if} (setting.id == SettingsId::INITIAL_WINDOW_SIZE) \{
1306       onSetSendWindow(setting.value);
1307     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (setting.id == SettingsId::MAX_CONCURRENT_STREAMS) \{
1308       onSetMaxInitiatedStreams(setting.value);
1309     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (setting.id == SettingsId::SETTINGS_HTTP_CERT_AUTH) \{
1310       \textcolor{keywordflow}{if} (!(verifyCertAuthSetting(setting.value))) \{
1311         \textcolor{keywordflow}{return};
1312       \}
1313     \}
1314   \}
1315   \textcolor{keywordflow}{if} (codec_->generateSettingsAck(writeBuf_) > 0) \{
1316     scheduleWrite();
1317   \}
1318   \textcolor{keywordflow}{if} (infoCallback_) \{
1319     infoCallback_->onSettings(*\textcolor{keyword}{this}, settings);
1320   \}
1321 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Settings\+Ack@{on\+Settings\+Ack}}
\index{on\+Settings\+Ack@{on\+Settings\+Ack}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Settings\+Ack() override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Settings\+Ack (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a2761f5d6f21da00af36fe73385339e9a}
Called upon receipt of a settings frame with A\+CK set, for protocols that support settings ack. 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_a9ec9c7daad56b25852e4d7b31ffc1ae7}.



Definition at line 1323 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, and proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Settings\+Ack().



Referenced by get\+Security\+Protocol().


\begin{DoxyCode}
1323                                 \{
1324   VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" received settings ack"};
1325   \textcolor{keywordflow}{if} (infoCallback_) \{
1326     infoCallback_->onSettingsAck(*\textcolor{keyword}{this});
1327   \}
1328 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Trailers\+Complete@{on\+Trailers\+Complete}}
\index{on\+Trailers\+Complete@{on\+Trailers\+Complete}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Trailers\+Complete(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D stream\+I\+D, std\+::unique\+\_\+ptr$<$ H\+T\+T\+P\+Headers $>$ trailers) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Trailers\+Complete (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{stream, }
\item[{std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Headers} $>$}]{trailers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a78452f9b06f73e48e2397923fb71d0dd}
Called when all the trailers of an ingress message have been parsed, but only if the number of trailers is nonzero. 
\begin{DoxyParams}{Parameters}
{\em stream} & The stream ID \\
\hline
{\em trailers} & The message trailers \\
\hline
\end{DoxyParams}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_aa3ecee42ce8c09840aa67ee824c5cfe3}.



Definition at line 1030 of file H\+T\+T\+P\+Session.\+cpp.



References find\+Transaction(), invalid\+Stream(), and proxygen\+::\+H\+T\+T\+P\+Transaction\+::on\+Ingress\+Trailers().



Referenced by get\+Security\+Protocol().


\begin{DoxyCode}
1031                                                                   \{
1032   HTTPTransaction* txn = findTransaction(streamID);
1033   \textcolor{keywordflow}{if} (!txn) \{
1034     invalidStream(streamID);
1035     \textcolor{keywordflow}{return};
1036   \}
1037   txn->onIngressTrailers(std::move(trailers));
1038 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Window\+Update@{on\+Window\+Update}}
\index{on\+Window\+Update@{on\+Window\+Update}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Window\+Update(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D stream, uint32\+\_\+t amount) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Window\+Update (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{, }
\item[{uint32\+\_\+t}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_aa0fb58504e91e4f38601e2fdd0cebb42}
Called upon receipt of a window update, for protocols that support flow control. For instance spdy/3 and higher. 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_a2e07b2b70565c4f2782d8767abf0e780}.



Definition at line 1285 of file H\+T\+T\+P\+Session.\+cpp.



References find\+Transaction(), and proxygen\+::\+H\+T\+T\+P\+Transaction\+::on\+Ingress\+Window\+Update().



Referenced by get\+Security\+Protocol().


\begin{DoxyCode}
1286                                                   \{
1287   VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" got window update on streamID="} << streamID << \textcolor{stringliteral}{" for "}
1288           << amount << \textcolor{stringliteral}{" bytes."};
1289   HTTPTransaction* txn = findTransaction(streamID);
1290   \textcolor{keywordflow}{if} (!txn) \{
1291     \textcolor{comment}{// We MUST be using SPDY/3+ if we got WINDOW\_UPDATE. The spec says that -}
1292     \textcolor{comment}{//}
1293     \textcolor{comment}{// A sender should ignore all the WINDOW\_UPDATE frames associated with the}
1294     \textcolor{comment}{// stream after it send the last frame for the stream.}
1295     \textcolor{comment}{//}
1296     \textcolor{comment}{// TODO: Only ignore if this is from some past transaction}
1297     \textcolor{keywordflow}{return};
1298   \}
1299   txn->onIngressWindowUpdate(amount);
1300 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Write\+Completed@{on\+Write\+Completed}}
\index{on\+Write\+Completed@{on\+Write\+Completed}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Write\+Completed()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Write\+Completed (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_af385c143cc9ad6f4930b6b045c7a69b7}
Check whether to shut down the transport after a write completes. 

Definition at line 2720 of file H\+T\+T\+P\+Session.\+cpp.



References num\+Active\+Writes\+\_\+, pending\+Writes\+\_\+, shutdown\+Transport(), and writes\+Draining\+\_\+.



Referenced by on\+Write\+Success(), and session\+Byte\+Offset().


\begin{DoxyCode}
2720                               \{
2721   \textcolor{keywordflow}{if} (!writesDraining_) \{
2722     \textcolor{keywordflow}{return};
2723   \}
2724 
2725   \textcolor{keywordflow}{if} (numActiveWrites_) \{
2726     \textcolor{keywordflow}{return};
2727   \}
2728 
2729   \textcolor{comment}{// Don't shutdown if there might be more writes}
2730   \textcolor{keywordflow}{if} (!pendingWrites_.empty()) \{
2731     \textcolor{keywordflow}{return};
2732   \}
2733 
2734   \textcolor{comment}{// All finished draining writes, so shut down the egress}
2735   shutdownTransport(\textcolor{keyword}{false}, \textcolor{keyword}{true});
2736 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Write\+Error@{on\+Write\+Error}}
\index{on\+Write\+Error@{on\+Write\+Error}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Write\+Error(size\+\_\+t bytes\+Written, const folly\+::\+Async\+Socket\+Exception \&ex)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Write\+Error (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{bytes\+Written, }
\item[{const folly\+::\+Async\+Socket\+Exception \&}]{ex}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a688a4b503444c67e39e85db88fb58900}
Invoked by \doxyref{Write\+Segment}{p.}{classproxygen_1_1HTTPSession_1_1WriteSegment} on write failure. 

Definition at line 2702 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, proxygen\+::\+I\+O\+\_\+\+W\+R\+I\+T\+E\+\_\+\+E\+R\+R\+OR, proxygen\+::k\+Error\+Write, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Write(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::set\+Close\+Reason(), shutdown\+Transport\+With\+Reset(), and proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::transport\+Info\+\_\+.



Referenced by session\+Byte\+Offset(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().


\begin{DoxyCode}
2703                                                           \{
2704   VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" write error: "} << ex.what();
2705   \textcolor{keywordflow}{if} (infoCallback_) \{
2706     infoCallback_->onWrite(*\textcolor{keyword}{this}, bytesWritten);
2707   \}
2708 
2709   \textcolor{keyword}{auto} sslEx = \textcolor{keyword}{dynamic\_cast<}\textcolor{keyword}{const }folly::SSLException*\textcolor{keyword}{>}(&ex);
2710   \textcolor{comment}{// Save the SSL error, if there was one.  It will be recorded later}
2711   \textcolor{keywordflow}{if} (sslEx && sslEx->getSSLError() == folly::SSLError::SSL\_ERROR) \{
2712     transportInfo_.sslError = ex.what();
2713   \}
2714 
2715   setCloseReason(ConnectionCloseReason::IO_WRITE_ERROR);
2716   shutdownTransportWithReset(kErrorWrite, ex.what());
2717 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!on\+Write\+Success@{on\+Write\+Success}}
\index{on\+Write\+Success@{on\+Write\+Success}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{on\+Write\+Success(uint64\+\_\+t bytes\+Written)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::on\+Write\+Success (
\begin{DoxyParamCaption}
\item[{uint64\+\_\+t}]{bytes\+Written}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a48514244601d32eb56208361c6d6c62e}
Invoked by \doxyref{Write\+Segment}{p.}{classproxygen_1_1HTTPSession_1_1WriteSegment} on completion of a write. 

Definition at line 2643 of file H\+T\+T\+P\+Session.\+cpp.



References byte\+Event\+Tracker\+\_\+, bytes\+Written\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, egress\+Bytes\+Limit\+\_\+, has\+More\+Writes(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, in\+Loop\+Callback\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::is\+Reusable(), num\+Active\+Writes\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Write(), on\+Write\+Completed(), pending\+Writes\+\_\+, reads\+Shutdown(), run\+Loop\+Callback(), proxygen\+::\+Wheel\+Timer\+Instance\+::schedule\+Timeout(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::set\+Close\+Reason(), shutdown\+Transport(), timeout\+\_\+, transactions\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::transport\+Info\+\_\+, proxygen\+::\+U\+N\+K\+N\+O\+WN, update\+Write\+Buf\+Size(), update\+Write\+Count(), and write\+Timeout\+\_\+.



Referenced by session\+Byte\+Offset(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Success().


\begin{DoxyCode}
2643                                                  \{
2644   DestructorGuard dg(\textcolor{keyword}{this});
2645   bytesWritten_ += bytesWritten;
2646   transportInfo_.totalBytes += bytesWritten;
2647   CHECK(writeTimeout_.isScheduled());
2648   \textcolor{keywordflow}{if} (pendingWrites_.empty()) \{
2649     VLOG(10) << \textcolor{stringliteral}{"Cancel write timer on last successful write"};
2650     writeTimeout_.cancelTimeout();
2651   \} \textcolor{keywordflow}{else} \{
2652     VLOG(10) << \textcolor{stringliteral}{"Refresh write timer on writeSuccess"};
2653     timeout_.scheduleTimeout(&writeTimeout_);
2654   \}
2655 
2656   \textcolor{keywordflow}{if} (infoCallback_) \{
2657     infoCallback_->onWrite(*\textcolor{keyword}{this}, bytesWritten);
2658   \}
2659 
2660   VLOG(5) << \textcolor{stringliteral}{"total bytesWritten\_: "} << bytesWritten_;
2661 
2662   \textcolor{comment}{// processByteEvents will return true if it has been replaced with another}
2663   \textcolor{comment}{// tracker in the middle and needs to be re-run.  Should happen at most}
2664   \textcolor{comment}{// once.  while with no body is intentional}
2665   \textcolor{keywordflow}{while} (byteEventTracker_ &&
2666          byteEventTracker_->processByteEvents(
2667            byteEventTracker_, bytesWritten_)) \{\} \textcolor{comment}{// pass}
2668 
2669   \textcolor{keywordflow}{if} ((!codec_->isReusable() || readsShutdown()) && (transactions_.empty())) \{
2670     \textcolor{keywordflow}{if} (!codec_->isReusable()) \{
2671       \textcolor{comment}{// Shouldn't happen unless there is a bug. This can only happen when}
2672       \textcolor{comment}{// someone calls shutdownTransport, but did not specify a reason before.}
2673       setCloseReason(ConnectionCloseReason::UNKNOWN);
2674     \}
2675     VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" shutdown from onWriteSuccess"};
2676     shutdownTransport(\textcolor{keyword}{true}, \textcolor{keyword}{true});
2677   \}
2678   numActiveWrites_--;
2679   \textcolor{keywordflow}{if} (!inLoopCallback_) \{
2680     updateWriteCount();
2681     \textcolor{comment}{// safe to resume here:}
2682     updateWriteBufSize(-folly::to<int64\_t>(bytesWritten));
2683     \textcolor{comment}{// PRIO\_FIXME: this is done because of the corking business...}
2684     \textcolor{comment}{//             in the future we may want to have a pull model}
2685     \textcolor{comment}{//             whereby the socket asks us for a given amount of}
2686     \textcolor{comment}{//             data to send...}
2687     \textcolor{keywordflow}{if} (numActiveWrites_ == 0 && hasMoreWrites()) \{
2688       runLoopCallback();
2689     \}
2690   \}
2691   onWriteCompleted();
2692 
2693   \textcolor{keywordflow}{if} (egressBytesLimit_ > 0 && bytesWritten_ >= egressBytesLimit_) \{
2694     VLOG(4) << \textcolor{stringliteral}{"Egress limit reached, shutting down "}
2695       \textcolor{stringliteral}{"session (egressed "} << bytesWritten_ << \textcolor{stringliteral}{", limit set to "}
2696       << egressBytesLimit_ << \textcolor{stringliteral}{")"};
2697     shutdownTransport(\textcolor{keyword}{true}, \textcolor{keyword}{true});
2698   \}
2699 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!pause\+Ingress@{pause\+Ingress}}
\index{pause\+Ingress@{pause\+Ingress}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{pause\+Ingress(\+H\+T\+T\+P\+Transaction $\ast$txn) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::pause\+Ingress (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Transaction} $\ast$}]{txn}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_af42a143c0ea8e8e0635cbf9f0283f953}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_a854efe446d5edff65c09243eed1bfbb5}.



Definition at line 1509 of file H\+T\+T\+P\+Session.\+cpp.



References find\+Transaction(), live\+Transactions\+\_\+, and pause\+Reads().



Referenced by num\+Incoming\+Streams().


\begin{DoxyCode}
1509                                                             \{
1510   VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" pausing streamID="} << txn->getID() <<
1511     \textcolor{stringliteral}{", liveTransactions\_ was "} << liveTransactions_;
1512   CHECK\_GT(liveTransactions_, 0);
1513   --liveTransactions_;
1514   \textcolor{keyword}{auto} exTxns = txn->getExTransactions();
1515   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = exTxns.begin(); it != exTxns.end(); ++it) \{
1516     \textcolor{keyword}{auto} exTxn = findTransaction(*it);
1517     \textcolor{keywordflow}{if} (exTxn) \{
1518       exTxn->pauseIngress();
1519     \}
1520   \}
1521 
1522   \textcolor{keywordflow}{if} (liveTransactions_ == 0) \{
1523     pauseReads();
1524   \}
1525 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!pause\+Reads@{pause\+Reads}}
\index{pause\+Reads@{pause\+Reads}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{pause\+Reads()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::pause\+Reads (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_ae581da85b242f0cf6f4b657b8753894a}
Stop reading from the transport until \doxyref{resume\+Reads()}{p.}{classproxygen_1_1HTTPSession_a4fc8e06ea32500b275a03eb1b9829c39} is called 

Definition at line 2769 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::ingress\+Limit\+Exceeded(), pause\+Reads\+Impl(), reads\+Unpaused(), proxygen\+::\+H\+T\+T\+P\+Codec\+::set\+Parser\+Paused(), and proxygen\+::\+H\+T\+T\+P\+Codec\+::supports\+Parallel\+Requests().



Referenced by on\+Body(), pause\+Ingress(), and session\+Byte\+Offset().


\begin{DoxyCode}
2769                         \{
2770   \textcolor{comment}{// Make sure the parser is paused.  Note that if reads are shutdown}
2771   \textcolor{comment}{// before they are paused, we never make it past the if.}
2772   codec_->setParserPaused(\textcolor{keyword}{true});
2773   \textcolor{keywordflow}{if} (!readsUnpaused() ||
2774       (codec_->supportsParallelRequests() &&
2775        !ingressLimitExceeded())) \{
2776     \textcolor{keywordflow}{return};
2777   \}
2778   pauseReadsImpl();
2779 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!pause\+Reads\+Impl@{pause\+Reads\+Impl}}
\index{pause\+Reads\+Impl@{pause\+Reads\+Impl}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{pause\+Reads\+Impl()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::pause\+Reads\+Impl (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a7dca771911bbca787c0c7581afc3392a}


Definition at line 2781 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Ingress\+Paused(), reads\+\_\+, and sock\+\_\+.



Referenced by proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::detach\+Thread\+Locals(), invoke\+On\+All\+Transactions(), and pause\+Reads().


\begin{DoxyCode}
2781                                  \{
2782   VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{": pausing reads"};
2783   \textcolor{keywordflow}{if} (infoCallback_) \{
2784     infoCallback_->onIngressPaused(*\textcolor{keyword}{this});
2785   \}
2786   cancelTimeout();
2787   sock_->setReadCB(\textcolor{keyword}{nullptr});
2788   reads_ = SocketState::PAUSED;
2789 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!process\+Read\+Data@{process\+Read\+Data}}
\index{process\+Read\+Data@{process\+Read\+Data}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{process\+Read\+Data()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::process\+Read\+Data (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_af0320784362dcf40c2bce6e3f0d98301}


Definition at line 575 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, ingress\+Error\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::on\+Ingress(), read\+Buf\+\_\+, reads\+Unpaused(), and proxygen\+::\+H\+T\+T\+P\+Codec\+::set\+Parser\+Paused().



Referenced by get\+H\+T\+T\+P\+Priority(), read\+Buffer\+Available(), read\+Data\+Available(), and run\+Loop\+Callback().


\begin{DoxyCode}
575                              \{
576   FOLLY\_SCOPED\_TRACE\_SECTION(\textcolor{stringliteral}{"HTTPSession - processReadData"});
577   \textcolor{comment}{// skip any empty IOBufs before feeding CODEC.}
578   \textcolor{keywordflow}{while} (readBuf_.front() != \textcolor{keyword}{nullptr} && readBuf_.front()->length() == 0) \{
579     readBuf_.pop\_front();
580   \}
581 
582   \textcolor{comment}{// Pass the ingress data through the codec to parse it. The codec}
583   \textcolor{comment}{// will invoke various methods of the HTTPSession as callbacks.}
584   \textcolor{keyword}{const} IOBuf* currentReadBuf;
585   \textcolor{comment}{// It's possible for the last buffer in a chain to be empty here.}
586   \textcolor{comment}{// AsyncTransport saw fd activity so asked for a read buffer, but it was}
587   \textcolor{comment}{// SSL traffic and not enough to decrypt a whole record.  Later we invoke}
588   \textcolor{comment}{// this function from the loop callback.}
589   \textcolor{keywordflow}{while} (!ingressError_ &&
590          readsUnpaused() &&
591          ((currentReadBuf = readBuf_.front()) != \textcolor{keyword}{nullptr} &&
592           currentReadBuf->length() != 0)) \{
593     \textcolor{comment}{// We're about to parse, make sure the parser is not paused}
594     codec_->setParserPaused(\textcolor{keyword}{false});
595     \textcolor{keywordtype}{size\_t} bytesParsed = codec_->onIngress(*currentReadBuf);
596     \textcolor{keywordflow}{if} (bytesParsed == 0) \{
597       \textcolor{comment}{// If the codec didn't make any progress with current input, we}
598       \textcolor{comment}{// better get more.}
599       \textcolor{keywordflow}{break};
600     \}
601     readBuf_.trimStart(bytesParsed);
602   \}
603 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!read\+Buffer\+Available@{read\+Buffer\+Available}}
\index{read\+Buffer\+Available@{read\+Buffer\+Available}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{read\+Buffer\+Available(std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::read\+Buffer\+Available (
\begin{DoxyParamCaption}
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_a5e76f86ed8e366c32399e02feac3cfe6}


Definition at line 557 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Read(), process\+Read\+Data(), and read\+Buf\+\_\+.



Referenced by get\+H\+T\+T\+P\+Priority().


\begin{DoxyCode}
557                                                                       \{
558   \textcolor{keywordtype}{size\_t} readSize = readBuf->computeChainDataLength();
559   FOLLY\_SCOPED\_TRACE\_SECTION(
560       \textcolor{stringliteral}{"HTTPSession - readBufferAvailable"}, \textcolor{stringliteral}{"readSize"}, readSize);
561   VLOG(5) << \textcolor{stringliteral}{"read completed on "} << *\textcolor{keyword}{this} << \textcolor{stringliteral}{", bytes="} << readSize;
562 
563   DestructorGuard dg(\textcolor{keyword}{this});
564   resetTimeout();
565   readBuf_.append(std::move(readBuf));
566 
567   \textcolor{keywordflow}{if} (infoCallback_) \{
568     infoCallback_->onRead(*\textcolor{keyword}{this}, readSize);
569   \}
570 
571   processReadData();
572 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!read\+Data\+Available@{read\+Data\+Available}}
\index{read\+Data\+Available@{read\+Data\+Available}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{read\+Data\+Available(size\+\_\+t read\+Size) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::read\+Data\+Available (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{read\+Size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_ad48c44abccc284d6878ea73bb01feea3}


Definition at line 535 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Read(), process\+Read\+Data(), and read\+Buf\+\_\+.



Referenced by get\+H\+T\+T\+P\+Priority().


\begin{DoxyCode}
535                                                        \{
536   FOLLY\_SCOPED\_TRACE\_SECTION(
537       \textcolor{stringliteral}{"HTTPSession - readDataAvailable"}, \textcolor{stringliteral}{"readSize"}, readSize);
538   VLOG(10) << \textcolor{stringliteral}{"read completed on "} << *\textcolor{keyword}{this} << \textcolor{stringliteral}{", bytes="} << readSize;
539 
540   DestructorGuard dg(\textcolor{keyword}{this});
541   resetTimeout();
542   readBuf_.postallocate(readSize);
543 
544   \textcolor{keywordflow}{if} (infoCallback_) \{
545     infoCallback_->onRead(*\textcolor{keyword}{this}, readSize);
546   \}
547 
548   processReadData();
549 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!read\+E\+OF@{read\+E\+OF}}
\index{read\+E\+OF@{read\+E\+OF}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{read\+E\+O\+F() noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::read\+E\+OF (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_a98b41eaa29cecf1b8dad11dba197c056}


Definition at line 606 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::get\+Num\+Txn\+Served(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, proxygen\+::k\+Error\+Client\+Silent, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Ingress\+Error(), proxygen\+::\+R\+E\+A\+D\+\_\+\+E\+OF, read\+Buf\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::set\+Close\+Reason(), shutdown\+Transport(), transactions\+\_\+, and proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::transport\+Info\+\_\+.



Referenced by get\+H\+T\+T\+P\+Priority().


\begin{DoxyCode}
606                               \{
607   DestructorGuard guard(\textcolor{keyword}{this});
608   VLOG(4) << \textcolor{stringliteral}{"EOF on "} << *\textcolor{keyword}{this};
609   \textcolor{comment}{// for SSL only: error without any bytes from the client might happen}
610   \textcolor{comment}{// due to client-side issues with the SSL cert. Note that it can also}
611   \textcolor{comment}{// happen if the client sends a SPDY frame header but no body.}
612   \textcolor{keywordflow}{if} (infoCallback_
613       && transportInfo_.secure && getNumTxnServed() == 0 && readBuf_.empty()) \{
614     infoCallback_->onIngressError(*\textcolor{keyword}{this}, kErrorClientSilent);
615   \}
616 
617   \textcolor{comment}{// Shut down reads, and also shut down writes if there are no}
618   \textcolor{comment}{// transactions.  (If there are active transactions, leave the}
619   \textcolor{comment}{// write side of the socket open so those transactions can}
620   \textcolor{comment}{// finish generating responses.)}
621   setCloseReason(ConnectionCloseReason::READ_EOF);
622   shutdownTransport(\textcolor{keyword}{true}, transactions_.empty());
623 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!read\+Err@{read\+Err}}
\index{read\+Err@{read\+Err}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{read\+Err(const folly\+::\+Async\+Socket\+Exception \&) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::read\+Err (
\begin{DoxyParamCaption}
\item[{const folly\+::\+Async\+Socket\+Exception \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_a68885654760e144384fa10f8091d25c0}


Definition at line 626 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, proxygen\+::\+I\+O\+\_\+\+R\+E\+A\+D\+\_\+\+E\+R\+R\+OR, proxygen\+::k\+Error\+Client\+Renegotiation, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Ingress\+Error(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::set\+Close\+Reason(), shutdown\+Transport(), transactions\+\_\+, and proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::transport\+Info\+\_\+.



Referenced by get\+H\+T\+T\+P\+Priority().


\begin{DoxyCode}
626                                                             \{
627   DestructorGuard guard(\textcolor{keyword}{this});
628   VLOG(4) << \textcolor{stringliteral}{"read error on "} << *\textcolor{keyword}{this} << \textcolor{stringliteral}{": "} << ex.what();
629 
630   \textcolor{keyword}{auto} sslEx = \textcolor{keyword}{dynamic\_cast<}\textcolor{keyword}{const }folly::SSLException*\textcolor{keyword}{>}(&ex);
631   \textcolor{keywordflow}{if} (infoCallback_ && sslEx) \{
632     \textcolor{keywordflow}{if} (sslEx->getSSLError() == folly::SSLError::CLIENT\_RENEGOTIATION) \{
633       infoCallback_->onIngressError(*\textcolor{keyword}{this}, kErrorClientRenegotiation);
634     \}
635   \}
636 
637   \textcolor{comment}{// We're definitely finished reading. Don't close the write side}
638   \textcolor{comment}{// of the socket if there are outstanding transactions, though.}
639   \textcolor{comment}{// Instead, give the transactions a chance to produce any remaining}
640   \textcolor{comment}{// output.}
641   \textcolor{keywordflow}{if} (sslEx && sslEx->getSSLError() == folly::SSLError::SSL\_ERROR) \{
642     transportInfo_.sslError = ex.what();
643   \}
644   setCloseReason(ConnectionCloseReason::IO_READ_ERROR);
645   shutdownTransport(\textcolor{keyword}{true}, transactions_.empty(), ex.what());
646 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!reads\+Paused@{reads\+Paused}}
\index{reads\+Paused@{reads\+Paused}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{reads\+Paused() const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::reads\+Paused (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a5726d375dce946aff7f5b83c2822bc83}


Definition at line 632 of file H\+T\+T\+P\+Session.\+h.



References reads\+\_\+.



Referenced by on\+Message\+Begin(), and resume\+Reads().


\begin{DoxyCode}
632                            \{
633     \textcolor{keywordflow}{return} reads_ == SocketState::PAUSED;
634   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!reads\+Shutdown@{reads\+Shutdown}}
\index{reads\+Shutdown@{reads\+Shutdown}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{reads\+Shutdown() const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::reads\+Shutdown (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_aa7593f40c921315dbdb236c7317d793c}


Definition at line 636 of file H\+T\+T\+P\+Session.\+h.



References reads\+\_\+, and proxygen\+::\+S\+H\+U\+T\+D\+O\+WN.



Referenced by check\+For\+Shutdown(), detach(), drop\+Connection(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::is\+Closing(), on\+Delete\+Ack\+Event(), on\+Egress\+Message\+Finished(), on\+Write\+Success(), shutdown\+Transport(), and shutdown\+Transport\+With\+Reset().


\begin{DoxyCode}
636                              \{
637     \textcolor{keywordflow}{return} reads_ == SocketState::SHUTDOWN;
638   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!reads\+Unpaused@{reads\+Unpaused}}
\index{reads\+Unpaused@{reads\+Unpaused}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{reads\+Unpaused() const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::reads\+Unpaused (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_ac0ccab551f9639248c3a0557a04b0b47}


Definition at line 628 of file H\+T\+T\+P\+Session.\+h.



References reads\+\_\+.



Referenced by on\+Message\+Begin(), pause\+Reads(), process\+Read\+Data(), and run\+Loop\+Callback().


\begin{DoxyCode}
628                              \{
629     \textcolor{keywordflow}{return} reads_ == SocketState::UNPAUSED;
630   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!read\+Timeout\+Expired@{read\+Timeout\+Expired}}
\index{read\+Timeout\+Expired@{read\+Timeout\+Expired}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{read\+Timeout\+Expired() noexcept}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::read\+Timeout\+Expired (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_a8b21d699d9346a86b02f76d1bced5c38}


Definition at line 379 of file H\+T\+T\+P\+Session.\+cpp.



References drain\+Timeout\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::get\+Controller(), proxygen\+::\+H\+T\+T\+P\+Session\+Controller\+::get\+Graceful\+Shutdown\+Timeout(), live\+Transactions\+\_\+, notify\+Pending\+Shutdown(), proxygen\+::\+Wheel\+Timer\+Instance\+::schedule\+Timeout(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::set\+Close\+Reason(), proxygen\+::\+T\+I\+M\+E\+O\+UT, timeout\+\_\+, and transactions\+\_\+.



Referenced by get\+H\+T\+T\+P\+Priority(), and timeout\+Expired().


\begin{DoxyCode}
379                                          \{
380   VLOG(3) << \textcolor{stringliteral}{"session-level timeout on "} << *\textcolor{keyword}{this};
381 
382   \textcolor{keywordflow}{if} (liveTransactions_ != 0) \{
383     \textcolor{comment}{// There's at least one open transaction with a read timeout scheduled.}
384     \textcolor{comment}{// We got here because the session timeout == the transaction timeout.}
385     \textcolor{comment}{// Ignore, since the transaction is going to timeout very soon.}
386     VLOG(4) << *\textcolor{keyword}{this} <<
387         \textcolor{stringliteral}{"ignoring session timeout, transaction timeout imminent"};
388     resetTimeout();
389     \textcolor{keywordflow}{return};
390   \}
391 
392   \textcolor{keywordflow}{if} (!transactions_.empty()) \{
393     \textcolor{comment}{// There are one or more transactions, but none of them are live.}
394     \textcolor{comment}{// That's valid if they've all received their full ingress messages}
395     \textcolor{comment}{// and are waiting for their Handlers to process those messages.}
396     VLOG(4) << *\textcolor{keyword}{this} <<
397         \textcolor{stringliteral}{"ignoring session timeout, no transactions awaiting reads"};
398     resetTimeout();
399     \textcolor{keywordflow}{return};
400   \}
401 
402   VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" Timeout with nothing pending"};
403 
404   setCloseReason(ConnectionCloseReason::TIMEOUT);
405   \textcolor{keyword}{auto} controller = getController();
406   \textcolor{keywordflow}{if} (controller) \{
407     timeout_.scheduleTimeout(&drainTimeout_,
408                              controller->getGracefulShutdownTimeout());
409   \}
410   notifyPendingShutdown();
411 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!remove\+Waiting\+For\+Replay\+Safety@{remove\+Waiting\+For\+Replay\+Safety}}
\index{remove\+Waiting\+For\+Replay\+Safety@{remove\+Waiting\+For\+Replay\+Safety}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{remove\+Waiting\+For\+Replay\+Safety(\+Replay\+Safety\+Callback $\ast$callback) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::remove\+Waiting\+For\+Replay\+Safety (
\begin{DoxyParamCaption}
\item[{Replay\+Safety\+Callback $\ast$}]{callback}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_af2956ee5857459577485016ea25438c2}
Remove a Replay\+Safety\+Callback that had been waiting for replay safety (eg if a transaction waiting for replay safety is canceled). 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_a7e0526ba72d521fb439af0437a3800cd}.



Definition at line 815 of file H\+T\+T\+P\+Session.\+h.



References waiting\+For\+Replay\+Safety\+\_\+.


\begin{DoxyCode}
816                                                         \{
817     waitingForReplaySafety_.remove(callback);
818   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!reschedule\+Loop\+Callbacks@{reschedule\+Loop\+Callbacks}}
\index{reschedule\+Loop\+Callbacks@{reschedule\+Loop\+Callbacks}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{reschedule\+Loop\+Callbacks()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::reschedule\+Loop\+Callbacks (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a97304741f760e4d633033902d3380910}


Definition at line 652 of file H\+T\+T\+P\+Session.\+h.



References shutdown\+Transport\+Cb\+\_\+, and sock\+\_\+.



Referenced by proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::attach\+Thread\+Locals().


\begin{DoxyCode}
652                                  \{
653     \textcolor{keywordflow}{if} (!isLoopCallbackScheduled()) \{
654       sock_->getEventBase()->runInLoop(\textcolor{keyword}{this});
655     \}
656 
657     \textcolor{keywordflow}{if} (shutdownTransportCb_ &&
658         !shutdownTransportCb_->isLoopCallbackScheduled()) \{
659       sock_->getEventBase()->runInLoop(shutdownTransportCb_.get(), \textcolor{keyword}{true});
660     \}
661   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!resume\+Ingress@{resume\+Ingress}}
\index{resume\+Ingress@{resume\+Ingress}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{resume\+Ingress(\+H\+T\+T\+P\+Transaction $\ast$txn) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::resume\+Ingress (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Transaction} $\ast$}]{txn}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_add14dbdf706d083bf770c2aac6566cac}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_a2d5fbaa7d2eb616f56541d3189553cc6}.



Definition at line 1527 of file H\+T\+T\+P\+Session.\+cpp.



References find\+Transaction(), live\+Transactions\+\_\+, and resume\+Reads().



Referenced by detach(), and num\+Incoming\+Streams().


\begin{DoxyCode}
1527                                                              \{
1528   VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" resuming streamID="} << txn->getID() <<
1529       \textcolor{stringliteral}{", liveTransactions\_ was "} << liveTransactions_;
1530   ++liveTransactions_;
1531   \textcolor{keyword}{auto} exTxns = txn->getExTransactions();
1532   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} it = exTxns.begin(); it != exTxns.end(); ++it) \{
1533     \textcolor{keyword}{auto} exTxn = findTransaction(*it);
1534     \textcolor{keywordflow}{if} (exTxn) \{
1535       exTxn->resumeIngress();
1536     \}
1537   \}
1538 
1539   \textcolor{keywordflow}{if} (liveTransactions_ == 1) \{
1540     resumeReads();
1541   \}
1542 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!resume\+Reads@{resume\+Reads}}
\index{resume\+Reads@{resume\+Reads}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{resume\+Reads()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::resume\+Reads (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a4fc8e06ea32500b275a03eb1b9829c39}
Unpause reading from the transport. \begin{DoxyNote}{Note}
If any codec callbacks arrived while reads were paused, they will be processed before network reads resume. 
\end{DoxyNote}


Definition at line 2792 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::ingress\+Limit\+Exceeded(), reads\+Paused(), resume\+Reads\+Impl(), and proxygen\+::\+H\+T\+T\+P\+Codec\+::supports\+Parallel\+Requests().



Referenced by detach(), notify\+Ingress\+Body\+Processed(), resume\+Ingress(), session\+Byte\+Offset(), and start\+Now().


\begin{DoxyCode}
2792                          \{
2793   \textcolor{keywordflow}{if} (!readsPaused() ||
2794       (codec_->supportsParallelRequests() &&
2795        ingressLimitExceeded())) \{
2796     \textcolor{keywordflow}{return};
2797   \}
2798   resumeReadsImpl();
2799 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!resume\+Reads\+Impl@{resume\+Reads\+Impl}}
\index{resume\+Reads\+Impl@{resume\+Reads\+Impl}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{resume\+Reads\+Impl()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::resume\+Reads\+Impl (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a87e06691bb3e20921980e79a25f6072a}


Definition at line 2801 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, reads\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::set\+Parser\+Paused(), and sock\+\_\+.



Referenced by proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::attach\+Thread\+Locals(), invoke\+On\+All\+Transactions(), and resume\+Reads().


\begin{DoxyCode}
2801                                   \{
2802   VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{": resuming reads"};
2803   resetTimeout();
2804   reads_ = SocketState::UNPAUSED;
2805   codec_->setParserPaused(\textcolor{keyword}{false});
2806   \textcolor{keywordflow}{if} (!isLoopCallbackScheduled()) \{
2807     sock_->getEventBase()->runInLoop(\textcolor{keyword}{this});
2808   \}
2809 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!resume\+Transactions@{resume\+Transactions}}
\index{resume\+Transactions@{resume\+Transactions}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{resume\+Transactions()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::resume\+Transactions (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a5be562d896df4cfac6d3707dfeae5c51}


Definition at line 2862 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::egress\+Limit\+Exceeded(), in\+Resume\+\_\+, invoke\+On\+All\+Transactions(), proxygen\+::\+H\+T\+T\+P2\+Priority\+Queue\+::iterate\+B\+F\+S(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::pause\+Egress(), pending\+Pause\+\_\+, transactions\+\_\+, and txn\+Egress\+Queue\+\_\+.



Referenced by invoke\+On\+All\+Transactions(), and update\+Write\+Buf\+Size().


\begin{DoxyCode}
2862                                      \{
2863   CHECK(!inResume_);
2864   inResume_ = \textcolor{keyword}{true};
2865   DestructorGuard g(\textcolor{keyword}{this});
2866   \textcolor{keyword}{auto} resumeFn = [] (HTTP2PriorityQueue&, HTTPCodec::StreamID,
2867                       HTTPTransaction *txn, double) \{
2868     \textcolor{keywordflow}{if} (txn) \{
2869       txn->resumeEgress();
2870     \}
2871     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
2872   \};
2873   \textcolor{keyword}{auto} stopFn = [\textcolor{keyword}{this}] \{
2874     \textcolor{keywordflow}{return} (transactions_.empty() || egressLimitExceeded());
2875   \};
2876 
2877   txnEgressQueue_.iterateBFS(resumeFn, stopFn, \textcolor{keyword}{true} \textcolor{comment}{/* all */});
2878   inResume_ = \textcolor{keyword}{false};
2879   \textcolor{keywordflow}{if} (pendingPause_) \{
2880     VLOG(3) << \textcolor{stringliteral}{"Pausing txn egress for "} << *\textcolor{keyword}{this};
2881     pendingPause_ = \textcolor{keyword}{false};
2882     invokeOnAllTransactions(&HTTPTransaction::pauseEgress);
2883   \}
2884 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!run\+Loop\+Callback@{run\+Loop\+Callback}}
\index{run\+Loop\+Callback@{run\+Loop\+Callback}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{run\+Loop\+Callback() noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::run\+Loop\+Callback (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_aea78aea47cceb6d7cbcf482379f3e502}


Definition at line 2149 of file H\+T\+T\+P\+Session.\+cpp.



References body\+Bytes\+Per\+Write\+Buf\+\_\+, bytes\+Scheduled\+\_\+, check\+For\+Shutdown(), conn\+Flow\+Control\+\_\+, proxygen\+::\+Flow\+Control\+Filter\+::get\+Available\+Send(), proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::get\+Flags(), get\+Next\+To\+Send(), has\+More\+Writes(), in\+Loop\+Callback\+\_\+, invoke\+On\+All\+Transactions(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::is\+Priority\+Sampled(), num\+Active\+Writes\+\_\+, proxygen\+::\+H\+T\+T\+P2\+Priority\+Queue\+::num\+Pending\+Egress(), pending\+Writes\+\_\+, pending\+Write\+Size\+Delta\+\_\+, process\+Read\+Data(), reads\+Unpaused(), proxygen\+::\+Wheel\+Timer\+Instance\+::schedule\+Timeout(), schedule\+Write(), proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::set\+Cork(), proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::set\+E\+O\+R(), sock\+\_\+, timeout\+\_\+, txn\+Egress\+Queue\+\_\+, proxygen\+::\+H\+T\+T\+P\+Transaction\+::update\+Contentions\+Count(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::update\+Session\+Bytes\+Sheduled(), update\+Write\+Buf\+Size(), update\+Write\+Count(), proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::\+Write\+Segment(), writes\+Shutdown(), and write\+Timeout\+\_\+.



Referenced by is\+Draining(), and on\+Write\+Success().


\begin{DoxyCode}
2149                                       \{
2150   \textcolor{comment}{// We schedule this callback to run at the end of an event}
2151   \textcolor{comment}{// loop iteration if either of two conditions has happened:}
2152   \textcolor{comment}{//   * The session has generated some egress data (see scheduleWrite())}
2153   \textcolor{comment}{//   * Reads have become unpaused (see resumeReads())}
2154   DestructorGuard dg(\textcolor{keyword}{this});
2155   inLoopCallback_ = \textcolor{keyword}{true};
2156   \textcolor{keyword}{auto} scopeg = folly::makeGuard([\textcolor{keyword}{this}] \{
2157       inLoopCallback_ = \textcolor{keyword}{false};
2158       \textcolor{comment}{// This ScopeGuard needs to be under the above DestructorGuard}
2159       \textcolor{keywordflow}{if} (pendingWriteSizeDelta_) \{
2160         updateWriteBufSize(0);
2161       \}
2162       checkForShutdown();
2163     \});
2164   VLOG(5) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" in loop callback"};
2165 
2166   \textcolor{keywordflow}{for} (uint32\_t i = 0; i < kMaxWritesPerLoop; ++i) \{
2167     bodyBytesPerWriteBuf_ = 0;
2168     \textcolor{keywordflow}{if} (isPrioritySampled()) \{
2169       invokeOnAllTransactions(
2170         &HTTPTransaction::updateContentionsCount,
2171         txnEgressQueue_.numPendingEgress());
2172     \}
2173 
2174     \textcolor{keywordtype}{bool} cork = \textcolor{keyword}{true};
2175     \textcolor{keywordtype}{bool} eom = \textcolor{keyword}{false};
2176     unique\_ptr<IOBuf> writeBuf = getNextToSend(&cork, &eom);
2177 
2178     \textcolor{keywordflow}{if} (!writeBuf) \{
2179       \textcolor{keywordflow}{break};
2180     \}
2181     uint64\_t len = writeBuf->computeChainDataLength();
2182     VLOG(11) << *\textcolor{keyword}{this}
2183              << \textcolor{stringliteral}{" bytes of egress to be written: "} << len
2184              << \textcolor{stringliteral}{" cork:"} << cork << \textcolor{stringliteral}{" eom:"} << eom;
2185     \textcolor{keywordflow}{if} (len == 0) \{
2186       checkForShutdown();
2187       \textcolor{keywordflow}{return};
2188     \}
2189 
2190     \textcolor{keywordflow}{if} (isPrioritySampled()) \{
2191       invokeOnAllTransactions(
2192         &HTTPTransaction::updateSessionBytesSheduled,
2193         bodyBytesPerWriteBuf_);
2194     \}
2195 
2196     WriteSegment* segment = \textcolor{keyword}{new} WriteSegment(\textcolor{keyword}{this}, len);
2197     segment->setCork(cork);
2198     segment->setEOR(eom);
2199 
2200     pendingWrites_.push\_back(*segment);
2201     \textcolor{keywordflow}{if} (!writeTimeout_.isScheduled()) \{
2202       \textcolor{comment}{// Any performance concern here?}
2203       timeout_.scheduleTimeout(&writeTimeout_);
2204     \}
2205     numActiveWrites_++;
2206     VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" writing "} << len << \textcolor{stringliteral}{", activeWrites="}
2207              << numActiveWrites_ << \textcolor{stringliteral}{" cork="} << cork << \textcolor{stringliteral}{" eom="} << eom;
2208     bytesScheduled_ += len;
2209     sock_->writeChain(segment, std::move(writeBuf), segment->getFlags());
2210     \textcolor{keywordflow}{if} (numActiveWrites_ > 0) \{
2211       updateWriteCount();
2212       pendingWriteSizeDelta_ += len;
2213       \textcolor{comment}{// updateWriteBufSize called in scope guard}
2214       \textcolor{keywordflow}{break};
2215     \}
2216     \textcolor{comment}{// writeChain can result in a writeError and trigger the shutdown code path}
2217   \}
2218   \textcolor{keywordflow}{if} (numActiveWrites_ == 0 && !writesShutdown() && hasMoreWrites() &&
2219       (!connFlowControl_ || connFlowControl_->getAvailableSend())) \{
2220     scheduleWrite();
2221   \}
2222 
2223   \textcolor{keywordflow}{if} (readsUnpaused()) \{
2224     processReadData();
2225 
2226     \textcolor{comment}{// Install the read callback if necessary}
2227     \textcolor{keywordflow}{if} (readsUnpaused() && !sock_->getReadCallback()) \{
2228       sock_->setReadCB(\textcolor{keyword}{this});
2229     \}
2230   \}
2231   \textcolor{comment}{// checkForShutdown is now in ScopeGuard}
2232 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!schedule\+Write@{schedule\+Write}}
\index{schedule\+Write@{schedule\+Write}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{schedule\+Write()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::schedule\+Write (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_af13305c84439720b53378c575827ccf4}
Schedule a write to occur at the end of this event loop. 

Definition at line 2235 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P2\+Priority\+Queue\+::empty(), sock\+\_\+, txn\+Egress\+Queue\+\_\+, and write\+Buf\+\_\+.



Referenced by close\+When\+Idle(), drain\+Impl(), is\+Draining(), notify\+Ingress\+Body\+Processed(), notify\+Pending\+Egress(), on\+Body(), on\+Certificate\+Request(), on\+Connection\+Send\+Window\+Open(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::on\+Native\+Protocol\+Upgrade(), on\+Native\+Protocol\+Upgrade\+Impl(), on\+New\+Transaction\+Parse\+Error(), on\+Ping\+Request(), on\+Session\+Parse\+Error(), on\+Settings(), run\+Loop\+Callback(), send\+Abort(), send\+Certificate\+Request(), send\+Chunk\+Header(), send\+Chunk\+Terminator(), send\+Headers(), send\+Ping(), send\+Priority\+Impl(), send\+Settings(), send\+Window\+Update(), shutdown\+Transport(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::start\+Now(), and start\+Now().


\begin{DoxyCode}
2235                            \{
2236   \textcolor{comment}{// Do all the network writes for this connection in one batch at}
2237   \textcolor{comment}{// the end of the current event loop iteration.  Writing in a}
2238   \textcolor{comment}{// batch helps us packetize the network traffic more efficiently,}
2239   \textcolor{comment}{// as well as saving a few system calls.}
2240   \textcolor{keywordflow}{if} (!isLoopCallbackScheduled() &&
2241       (writeBuf_.front() || !txnEgressQueue_.empty())) \{
2242     VLOG(5) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" scheduling write callback"};
2243     sock_->getEventBase()->runInLoop(\textcolor{keyword}{this});
2244   \}
2245 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!send\+Abort@{send\+Abort}}
\index{send\+Abort@{send\+Abort}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{send\+Abort(\+H\+T\+T\+P\+Transaction $\ast$txn, Error\+Code status\+Code) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::send\+Abort (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Transaction} $\ast$}]{txn, }
\item[{{\bf Error\+Code}}]{status\+Code}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_a759cc6ebd094ef9363a0bdfdba2e5b3d}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_a196ee69eed048b43bdc900bb97c080fa}.



Definition at line 1791 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+Rst\+Stream(), proxygen\+::\+H\+T\+T\+P\+Codec\+::is\+Reusable(), on\+Egress\+Message\+Finished(), schedule\+Write(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::set\+Close\+Reason(), status\+Code, proxygen\+::\+T\+R\+A\+N\+S\+A\+C\+T\+I\+O\+N\+\_\+\+A\+B\+O\+RT, and write\+Buf\+\_\+.



Referenced by num\+Incoming\+Streams().


\begin{DoxyCode}
1792                                                              \{
1793   \textcolor{comment}{// Ask the codec to generate an abort indicator for the transaction.}
1794   \textcolor{comment}{// Depending on the protocol, this may be a no-op.}
1795   \textcolor{comment}{// Schedule a network write to send out whatever egress we might}
1796   \textcolor{comment}{// have queued up.}
1797   VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" sending abort for streamID="} << txn->getID();
1798   \textcolor{comment}{// drain this transaction's writeBuf instead of flushing it}
1799   \textcolor{comment}{// then enqueue the abort directly into the Session buffer,}
1800   \textcolor{comment}{// hence with max priority.}
1801   \textcolor{keywordtype}{size\_t} encodedSize = codec_->generateRstStream(writeBuf_,
1802                                                  txn->getID(),
1803                                                  statusCode);
1804 
1805   \textcolor{keywordflow}{if} (!codec_->isReusable()) \{
1806     \textcolor{comment}{// HTTP 1x codec does not support per stream abort so this will}
1807     \textcolor{comment}{// render the codec not reusable}
1808     setCloseReason(ConnectionCloseReason::TRANSACTION_ABORT);
1809   \}
1810 
1811   scheduleWrite();
1812 
1813   \textcolor{comment}{// If the codec wasn't able to write a L7 message for the abort, then}
1814   \textcolor{comment}{// fall back to closing the transport with a TCP level RST}
1815   onEgressMessageFinished(txn, !encodedSize);
1816   \textcolor{keywordflow}{return} encodedSize;
1817 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!send\+Body@{send\+Body}}
\index{send\+Body@{send\+Body}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{send\+Body(\+H\+T\+T\+P\+Transaction $\ast$txn, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$, bool include\+E\+O\+M, bool track\+Last\+Byte\+Flushed) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::send\+Body (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Transaction} $\ast$}]{txn, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{body, }
\item[{bool}]{include\+E\+OM, }
\item[{bool}]{track\+Last\+Byte\+Flushed}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_ac48b06bc64e49437711d8574f9facd67}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_a0c3f6ac1245cf283d586e216740e5b7d}.



Definition at line 1675 of file H\+T\+T\+P\+Session.\+cpp.



References body\+Bytes\+Per\+Write\+Buf\+\_\+, byte\+Event\+Tracker\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, common\+Eom(), proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+Body(), in\+Loop\+Callback\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+No\+Padding, pending\+Write\+Size\+Delta\+\_\+, session\+Byte\+Offset(), and write\+Buf\+\_\+.



Referenced by num\+Incoming\+Streams().


\begin{DoxyCode}
1678                                                           \{
1679   uint64\_t offset = sessionByteOffset();
1680   \textcolor{keywordtype}{size\_t} bodyLen = body ? body->computeChainDataLength(): 0;
1681   \textcolor{keywordtype}{size\_t} encodedSize = codec_->generateBody(writeBuf_,
1682                                             txn->getID(),
1683                                             std::move(body),
1684                                             HTTPCodec::NoPadding,
1685                                             includeEOM);
1686   CHECK(inLoopCallback_);
1687   pendingWriteSizeDelta_ -= bodyLen;
1688   bodyBytesPerWriteBuf_ += bodyLen;
1689   \textcolor{keywordflow}{if} (encodedSize > 0 && !txn->testAndSetFirstByteSent() && byteEventTracker_) \{
1690     byteEventTracker_->addFirstBodyByteEvent(offset, txn);
1691   \}
1692 
1693   \textcolor{keywordflow}{if} (trackLastByteFlushed && encodedSize > 0 && byteEventTracker_) \{
1694     byteEventTracker_->addTrackedByteEvent(txn, offset + encodedSize);
1695   \}
1696 
1697   \textcolor{keywordflow}{if} (includeEOM) \{
1698     VLOG(5) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" sending EOM in body for streamID="} << txn->getID();
1699     commonEom(txn, encodedSize, \textcolor{keyword}{true});
1700   \}
1701   \textcolor{keywordflow}{return} encodedSize;
1702 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!send\+Certificate\+Request@{send\+Certificate\+Request}}
\index{send\+Certificate\+Request@{send\+Certificate\+Request}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{send\+Certificate\+Request(std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ certificate\+Request\+Context, std\+::vector$<$ fizz\+::\+Extension $>$ extensions) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::send\+Certificate\+Request (
\begin{DoxyParamCaption}
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{certificate\+Request\+Context, }
\item[{std\+::vector$<$ fizz\+::\+Extension $>$}]{extensions}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a81217225c4cb8a8268e5c96c80ce7196}
Send a C\+E\+R\+T\+I\+F\+I\+C\+A\+T\+E\+\_\+\+R\+E\+Q\+U\+E\+ST frame. If the underlying protocol doesn\textquotesingle{}t support secondary authentication, this is a no-\/op and 0 is returned. 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_ae0d22bef37bd1144995ea4a9715f9f6b}.



Definition at line 1837 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+Certificate\+Request(), proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Egress\+Settings(), proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Ingress\+Settings(), schedule\+Write(), second\+Auth\+Manager\+\_\+, proxygen\+::\+S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+H\+T\+T\+P\+\_\+\+C\+E\+R\+T\+\_\+\+A\+U\+TH, and write\+Buf\+\_\+.



Referenced by get\+Setup\+Transport\+Info().


\begin{DoxyCode}
1839                                          \{
1840   \textcolor{comment}{// Check if both sending and receiving peer have advertised valid}
1841   \textcolor{comment}{// SETTINGS\_HTTP\_CERT\_AUTH setting. Otherwise, the frames for secondary}
1842   \textcolor{comment}{// authentication should not be sent.}
1843   \textcolor{keyword}{auto} ingressSettings = codec_->getIngressSettings();
1844   \textcolor{keyword}{auto} egressSettings = codec_->getEgressSettings();
1845   \textcolor{keywordflow}{if} (ingressSettings && egressSettings) \{
1846     \textcolor{keywordflow}{if} (ingressSettings->getSetting(SettingsId::SETTINGS_HTTP_CERT_AUTH, 0) ==
1847             0 ||
1848         egressSettings->getSetting(SettingsId::SETTINGS_HTTP_CERT_AUTH, 0) ==
1849             0) \{
1850       VLOG(4) << \textcolor{stringliteral}{"Secondary certificate authentication is not supported."};
1851       \textcolor{keywordflow}{return} 0;
1852     \}
1853   \}
1854   \textcolor{keyword}{auto} authRequest = secondAuthManager_->createAuthRequest(
1855       std::move(certificateRequestContext), std::move(extensions));
1856   \textcolor{keyword}{auto} encodedSize = codec_->generateCertificateRequest(
1857       writeBuf_, authRequest.first, std::move(authRequest.second));
1858   \textcolor{keywordflow}{if} (encodedSize > 0) \{
1859     scheduleWrite();
1860   \} \textcolor{keywordflow}{else} \{
1861     VLOG(4) << \textcolor{stringliteral}{"Failed to generate CERTIFICATE\_REQUEST frame."};
1862   \}
1863   \textcolor{keywordflow}{return} encodedSize;
1864 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!send\+Chunk\+Header@{send\+Chunk\+Header}}
\index{send\+Chunk\+Header@{send\+Chunk\+Header}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{send\+Chunk\+Header(\+H\+T\+T\+P\+Transaction $\ast$txn, size\+\_\+t length) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::send\+Chunk\+Header (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Transaction} $\ast$}]{txn, }
\item[{size\+\_\+t}]{length}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_a0de809896f039c83b33f96edd4b2823b}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_af21bcdf1b2e19d5817252a8af9bcc1d6}.



Definition at line 1704 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+Chunk\+Header(), schedule\+Write(), and write\+Buf\+\_\+.



Referenced by num\+Incoming\+Streams().


\begin{DoxyCode}
1705                             \{
1706   \textcolor{keywordtype}{size\_t} encodedSize = codec_->generateChunkHeader(writeBuf_,
1707                                                    txn->getID(),
1708                                                    length);
1709   scheduleWrite();
1710   \textcolor{keywordflow}{return} encodedSize;
1711 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!send\+Chunk\+Terminator@{send\+Chunk\+Terminator}}
\index{send\+Chunk\+Terminator@{send\+Chunk\+Terminator}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{send\+Chunk\+Terminator(\+H\+T\+T\+P\+Transaction $\ast$txn) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::send\+Chunk\+Terminator (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Transaction} $\ast$}]{txn}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_aae3c74e6afa642fe7db4db1cb912e44e}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_af62ff7bd7b8f57ee839d95fcbdecd498}.



Definition at line 1713 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+Chunk\+Terminator(), schedule\+Write(), and write\+Buf\+\_\+.



Referenced by num\+Incoming\+Streams().


\begin{DoxyCode}
1714                                    \{
1715   \textcolor{keywordtype}{size\_t} encodedSize = codec_->generateChunkTerminator(writeBuf_,
1716                                                        txn->getID());
1717   scheduleWrite();
1718   \textcolor{keywordflow}{return} encodedSize;
1719 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!send\+E\+OM@{send\+E\+OM}}
\index{send\+E\+OM@{send\+E\+OM}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{send\+E\+O\+M(\+H\+T\+T\+P\+Transaction $\ast$txn, const H\+T\+T\+P\+Headers $\ast$trailers) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::send\+E\+OM (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Transaction} $\ast$}]{txn, }
\item[{const {\bf H\+T\+T\+P\+Headers} $\ast$}]{trailers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_a158fcf7cbfa48f2974db6fcd84615673}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_ad3e8c25f82c1ab3d38602ce696fcfe70}.



Definition at line 1769 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, common\+Eom(), proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+E\+O\+M(), proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+Trailers(), proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Protocol(), proxygen\+::is\+H\+T\+T\+P2\+Codec\+Protocol(), and write\+Buf\+\_\+.



Referenced by num\+Incoming\+Streams().


\begin{DoxyCode}
1770                                                                   \{
1771 
1772   VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" sending EOM for streamID="} << txn->getID()
1773           << \textcolor{stringliteral}{" trailers="} << (trailers ? \textcolor{stringliteral}{"yes"} : \textcolor{stringliteral}{"no"});
1774 
1775   \textcolor{keywordtype}{size\_t} encodedSize = 0;
1776   \textcolor{keywordflow}{if} (trailers) \{
1777     encodedSize = codec_->generateTrailers(writeBuf_, txn->getID(), *trailers);
1778   \}
1779 
1780   \textcolor{comment}{// Don't send EOM for HTTP2, when trailers sent.}
1781   \textcolor{comment}{// sendTrailers already flagged end of stream.}
1782   \textcolor{keywordtype}{bool} http2Trailers = trailers && isHTTP2CodecProtocol(codec_->getProtocol());
1783   \textcolor{keywordflow}{if} (!http2Trailers) \{
1784     encodedSize += codec_->generateEOM(writeBuf_, txn->getID());
1785   \}
1786 
1787   commonEom(txn, encodedSize, \textcolor{keyword}{false});
1788   \textcolor{keywordflow}{return} encodedSize;
1789 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!send\+Headers@{send\+Headers}}
\index{send\+Headers@{send\+Headers}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{send\+Headers(\+H\+T\+T\+P\+Transaction $\ast$txn, const H\+T\+T\+P\+Message \&headers, H\+T\+T\+P\+Header\+Size $\ast$size, bool include\+E\+O\+M) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::send\+Headers (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Transaction} $\ast$}]{txn, }
\item[{const {\bf H\+T\+T\+P\+Message} \&}]{headers, }
\item[{{\bf H\+T\+T\+P\+Header\+Size} $\ast$}]{size, }
\item[{bool}]{include\+E\+OM}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_ac70579f6c74d966cb48ce54963623d16}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_a4471d40c95555b058e2721955e432fea}.



Definition at line 1584 of file H\+T\+T\+P\+Session.\+cpp.



References byte\+Event\+Tracker\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, common\+Eom(), drain\+Impl(), proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+Ex\+Header(), proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+Header(), proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+Push\+Promise(), get\+H\+T\+T\+P2\+Priorities\+Enabled(), get\+Message\+Priority(), increment\+Outgoing\+Streams(), is\+Downstream(), proxygen\+::\+H\+T\+T\+P\+Codec\+::is\+Reusable(), is\+Upstream(), on\+Headers\+Sent(), schedule\+Write(), session\+Byte\+Offset(), should\+Shutdown(), started\+\_\+, and write\+Buf\+\_\+.



Referenced by num\+Incoming\+Streams().


\begin{DoxyCode}
1587                                                         \{
1588   CHECK(started_);
1589   unique\_ptr<IOBuf> goawayBuf;
1590   \textcolor{keywordflow}{if} (shouldShutdown()) \{
1591     \textcolor{comment}{// For HTTP/1.1, add Connection: close}
1592     \textcolor{comment}{// For SPDY, save the goaway for AFTER the request}
1593     \textcolor{keyword}{auto} writeBuf = writeBuf_.move();
1594     drainImpl();
1595     goawayBuf = writeBuf_.move();
1596     writeBuf_.append(std::move(writeBuf));
1597   \}
1598   \textcolor{keywordflow}{if} (isUpstream() || (txn->isPushed() && headers.isRequest())) \{
1599     \textcolor{comment}{// upstream picks priority}
1600     \textcolor{keywordflow}{if} (getHTTP2PrioritiesEnabled()) \{
1601       \textcolor{keyword}{auto} pri = getMessagePriority(&headers);
1602       txn->onPriorityUpdate(pri);
1603     \}
1604   \}
1605 
1606   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} wasReusable = codec_->isReusable();
1607   \textcolor{keyword}{const} uint64\_t oldOffset = sessionByteOffset();
1608   \textcolor{keyword}{auto} exAttributes = txn->getExAttributes();
1609   \textcolor{keyword}{auto} assocStream = txn->getAssocTxnId();
1610   \textcolor{keywordflow}{if} (exAttributes) \{
1611     codec_->generateExHeader(writeBuf_,
1612                              txn->getID(),
1613                              headers,
1614                              *exAttributes,
1615                              includeEOM,
1616                              size);
1617   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (headers.isRequest() && assocStream) \{
1618     \textcolor{comment}{// Only PUSH\_PROMISE (not push response) has an associated stream}
1619     codec_->generatePushPromise(writeBuf_,
1620                                 txn->getID(),
1621                                 headers,
1622                                 *assocStream,
1623                                 includeEOM,
1624                                 size);
1625   \} \textcolor{keywordflow}{else} \{
1626     codec_->generateHeader(writeBuf_,
1627                            txn->getID(),
1628                            headers,
1629                            includeEOM,
1630                            size);
1631   \}
1632   \textcolor{keyword}{const} uint64\_t newOffset = sessionByteOffset();
1633 
1634   \textcolor{comment}{// for push response count towards the MAX\_CONCURRENT\_STREAMS limit}
1635   \textcolor{keywordflow}{if} (isDownstream() && headers.isResponse() && txn->isPushed()) \{
1636     incrementOutgoingStreams();
1637   \}
1638 
1639   \textcolor{comment}{// For all upstream headers, addFirstHeaderByteEvent should be added}
1640   \textcolor{comment}{// For all downstream, only response headers need addFirstHeaderByteEvent}
1641   \textcolor{keywordtype}{bool} shouldAddFirstHeaderByteEvent = isUpstream() ||
1642                                        (isDownstream() && headers.isResponse());
1643   \textcolor{keywordflow}{if} (shouldAddFirstHeaderByteEvent && newOffset > oldOffset &&
1644       !txn->testAndSetFirstHeaderByteSent() && byteEventTracker_) \{
1645     byteEventTracker_->addFirstHeaderByteEvent(newOffset, txn);
1646   \}
1647 
1648   \textcolor{keywordflow}{if} (size) \{
1649     VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" sending headers, size="} << size->compressed
1650             << \textcolor{stringliteral}{", uncompressedSize="} << size->uncompressed;
1651   \}
1652   \textcolor{keywordflow}{if} (goawayBuf) \{
1653     VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" moved GOAWAY to end of writeBuf"};
1654     writeBuf_.append(std::move(goawayBuf));
1655   \}
1656   \textcolor{keywordflow}{if} (includeEOM) \{
1657     commonEom(txn, 0, \textcolor{keyword}{true});
1658   \}
1659   scheduleWrite();
1660   onHeadersSent(headers, wasReusable);
1661 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!send\+Ping@{send\+Ping}}
\index{send\+Ping@{send\+Ping}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{send\+Ping() override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::send\+Ping (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_ac21aceda7a1827089fc7cd36f49aa1a6}
Causes a ping to be sent on the session. If the underlying protocol doesn\textquotesingle{}t support pings, this will return 0. Otherwise, it will return the number of bytes written on the transport to send the ping. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_a3509c8946b85d98bbd20fba77b410430}.



Definition at line 2517 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+Ping\+Request(), schedule\+Write(), and write\+Buf\+\_\+.



Referenced by get\+Setup\+Transport\+Info().


\begin{DoxyCode}
2517                              \{
2518   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} bytes = codec_->generatePingRequest(writeBuf_);
2519   \textcolor{keywordflow}{if} (bytes) \{
2520     scheduleWrite();
2521   \}
2522   \textcolor{keywordflow}{return} bytes;
2523 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!send\+Priority@{send\+Priority}}
\index{send\+Priority@{send\+Priority}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{send\+Priority(http2\+::\+Priority\+Update pri) override}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} proxygen\+::\+H\+T\+T\+P\+Session\+::send\+Priority (
\begin{DoxyParamCaption}
\item[{{\bf http2\+::\+Priority\+Update}}]{pri}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_af56ac7c2c1fa8a251141063e07f86136}
Sends a priority message on this session. If the underlying protocol doesn\textquotesingle{}t support priority, this is a no-\/op. A new stream identifier will be selected and returned. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Priority\+Map\+Factory\+Provider} \doxyref{}{p.}{classproxygen_1_1HTTPPriorityMapFactoryProvider_a1651381ee22e843bfca90b8d46064361}.



Definition at line 2525 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::create\+Stream(), and proxygen\+::\+H\+T\+T\+P\+Codec\+::supports\+Parallel\+Requests().



Referenced by get\+Setup\+Transport\+Info(), and num\+Incoming\+Streams().


\begin{DoxyCode}
2525                                                                    \{
2526   \textcolor{keywordflow}{if} (!codec_->supportsParallelRequests()) \{
2527     \textcolor{comment}{// For HTTP/1.1, don't call createStream()}
2528     \textcolor{keywordflow}{return} 0;
2529   \}
2530   \textcolor{keyword}{auto} \textcolor{keywordtype}{id} = codec_->createStream();
2531   sendPriority(\textcolor{keywordtype}{id}, pri);
2532   \textcolor{keywordflow}{return} id;
2533 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!send\+Priority@{send\+Priority}}
\index{send\+Priority@{send\+Priority}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{send\+Priority(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D id, http2\+::\+Priority\+Update pri) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::send\+Priority (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{id, }
\item[{{\bf http2\+::\+Priority\+Update}}]{pri}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_ae4f24229a8ed84336d73a25133f93c30}
As above, but updates an existing priority node. Do not use for real nodes, prefer H\+T\+T\+P\+Transaction\+::change\+Priority. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_a4f7dcd3ed81f7c3600c4394436b42cdf}.



Definition at line 2535 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P2\+Priority\+Queue\+::add\+Or\+Update\+Priority\+Node(), send\+Priority\+Impl(), and txn\+Egress\+Queue\+\_\+.


\begin{DoxyCode}
2536                                                           \{
2537   \textcolor{keyword}{auto} res = sendPriorityImpl(\textcolor{keywordtype}{id}, pri);
2538   txnEgressQueue_.addOrUpdatePriorityNode(\textcolor{keywordtype}{id}, pri);
2539   \textcolor{keywordflow}{return} res;
2540 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!send\+Priority@{send\+Priority}}
\index{send\+Priority@{send\+Priority}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{send\+Priority(\+H\+T\+T\+P\+Transaction $\ast$txn, const http2\+::\+Priority\+Update \&pri) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::send\+Priority (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Transaction} $\ast$}]{txn, }
\item[{const {\bf http2\+::\+Priority\+Update} \&}]{pri}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_a54e9e76f4d782afec9719e73b29a3b40}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_aaf57400170e2afde845b45288c4f5609}.



Definition at line 1819 of file H\+T\+T\+P\+Session.\+cpp.



References send\+Priority\+Impl().


\begin{DoxyCode}
1820                                                                           \{
1821   \textcolor{keywordflow}{return} sendPriorityImpl(txn->getID(), pri);
1822 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!send\+Priority\+Impl@{send\+Priority\+Impl}}
\index{send\+Priority\+Impl@{send\+Priority\+Impl}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{send\+Priority\+Impl(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D stream\+I\+D, http2\+::\+Priority\+Update pri)}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::send\+Priority\+Impl (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{stream\+ID, }
\item[{{\bf http2\+::\+Priority\+Update}}]{pri}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a60bf8128ff820516a76e980a1738c7c9}
Sends a priority message on this session. If the underlying protocol doesn\textquotesingle{}t support priority, this is a no-\/op. Returns the number of bytes written on the transport 

Definition at line 2543 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::http2\+::\+Priority\+Update\+::exclusive, proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+Priority(), schedule\+Write(), proxygen\+::http2\+::\+Priority\+Update\+::stream\+Dependency, proxygen\+::http2\+::\+Priority\+Update\+::weight, and write\+Buf\+\_\+.



Referenced by on\+Headers\+Sent(), and send\+Priority().


\begin{DoxyCode}
2544                                                               \{
2545   CHECK\_NE(\textcolor{keywordtype}{id}, 0);
2546   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} bytes = codec_->generatePriority(
2547     writeBuf_, \textcolor{keywordtype}{id}, std::make\_tuple(pri.streamDependency,
2548                                    pri.exclusive,
2549                                    pri.weight));
2550   \textcolor{keywordflow}{if} (bytes) \{
2551     scheduleWrite();
2552   \}
2553   \textcolor{keywordflow}{return} bytes;
2554 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!send\+Settings@{send\+Settings}}
\index{send\+Settings@{send\+Settings}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{send\+Settings() override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::send\+Settings (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a85a0e02025ed4dbf075761698f277f91}
Send a settings frame 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_a2a00c57228b4a8cbfc4bfcf97fa79fe8}.



Definition at line 1503 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+Settings(), schedule\+Write(), and write\+Buf\+\_\+.



Referenced by get\+Setup\+Transport\+Info(), and on\+Native\+Protocol\+Upgrade\+Impl().


\begin{DoxyCode}
1503                                  \{
1504   \textcolor{keywordtype}{size\_t} size = codec_->generateSettings(writeBuf_);
1505   scheduleWrite();
1506   \textcolor{keywordflow}{return} size;
1507 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!send\+Window\+Update@{send\+Window\+Update}}
\index{send\+Window\+Update@{send\+Window\+Update}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{send\+Window\+Update(\+H\+T\+T\+P\+Transaction $\ast$txn, uint32\+\_\+t bytes) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::send\+Window\+Update (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Transaction} $\ast$}]{txn, }
\item[{uint32\+\_\+t}]{bytes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_ad77ad308a105013cf6a7429b5a7fd224}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_aa7b9f0ba2b4f6743a746cb796be14760}.



Definition at line 1984 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+Window\+Update(), schedule\+Write(), and write\+Buf\+\_\+.



Referenced by num\+Incoming\+Streams().


\begin{DoxyCode}
1985                                                        \{
1986   \textcolor{keywordtype}{size\_t} sent = codec_->generateWindowUpdate(writeBuf_, txn->getID(), bytes);
1987   \textcolor{keywordflow}{if} (sent) \{
1988     scheduleWrite();
1989   \}
1990   \textcolor{keywordflow}{return} sent;
1991 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!session\+Byte\+Offset@{session\+Byte\+Offset}}
\index{session\+Byte\+Offset@{session\+Byte\+Offset}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{session\+Byte\+Offset()}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::session\+Byte\+Offset (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a0a89c569f118b1e44ce3749c8ab2bb66}
Tells us what would be the offset of the next byte to be enqueued within the whole session. 

Definition at line 513 of file H\+T\+T\+P\+Session.\+h.



References bytes\+Scheduled\+\_\+, check\+For\+Shutdown(), create\+Transaction(), proxygen\+::http2\+::\+Default\+Priority, find\+Transaction(), has\+More\+Writes(), immediate\+Shutdown(), on\+New\+Transaction\+Parse\+Error(), on\+Session\+Parse\+Error(), on\+Write\+Completed(), on\+Write\+Error(), on\+Write\+Success(), pause\+Reads(), resume\+Reads(), and write\+Buf\+\_\+.



Referenced by common\+Eom(), send\+Body(), and send\+Headers().


\begin{DoxyCode}
513                                       \{
514     \textcolor{keywordflow}{return} bytesScheduled_ + writeBuf_.chainLength();
515   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!set\+Byte\+Event\+Tracker@{set\+Byte\+Event\+Tracker}}
\index{set\+Byte\+Event\+Tracker@{set\+Byte\+Event\+Tracker}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{set\+Byte\+Event\+Tracker(std\+::shared\+\_\+ptr$<$ Byte\+Event\+Tracker $>$ byte\+Event\+Tracker)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::set\+Byte\+Event\+Tracker (
\begin{DoxyParamCaption}
\item[{std\+::shared\+\_\+ptr$<$ {\bf Byte\+Event\+Tracker} $>$}]{byte\+Event\+Tracker}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPSession_a2fec0d8847998b13b34d943e4cf61011}


Definition at line 317 of file H\+T\+T\+P\+Session.\+cpp.



References byte\+Event\+Tracker\+\_\+, and proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::session\+Stats\+\_\+.



Referenced by get\+Byte\+Event\+Tracker(), and T\+E\+S\+T().


\begin{DoxyCode}
318                                                     \{
319   \textcolor{keywordflow}{if} (byteEventTracker && byteEventTracker_) \{
320     byteEventTracker->absorb(std::move(*byteEventTracker_));
321   \}
322   byteEventTracker_ = byteEventTracker;
323   \textcolor{keywordflow}{if} (byteEventTracker_) \{
324     byteEventTracker_->setCallback(\textcolor{keyword}{this});
325     byteEventTracker_->setTTLBAStats(sessionStats_);
326   \}
327 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!set\+Egress\+Bytes\+Limit@{set\+Egress\+Bytes\+Limit}}
\index{set\+Egress\+Bytes\+Limit@{set\+Egress\+Bytes\+Limit}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{set\+Egress\+Bytes\+Limit(uint64\+\_\+t bytes\+Limit)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::set\+Egress\+Bytes\+Limit (
\begin{DoxyParamCaption}
\item[{uint64\+\_\+t}]{bytes\+Limit}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPSession_aded2a34214bbbcaf96e07253de9131c8}
Set the maximum number of bytes allowed to be egressed in the session before cutting it off 

Definition at line 373 of file H\+T\+T\+P\+Session.\+cpp.



References egress\+Bytes\+Limit\+\_\+, and started\+\_\+.



Referenced by get\+Setup\+Transport\+Info().


\begin{DoxyCode}
373                                                          \{
374   CHECK(!started_);
375   egressBytesLimit_ = bytesLimit;
376 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!set\+Egress\+Settings@{set\+Egress\+Settings}}
\index{set\+Egress\+Settings@{set\+Egress\+Settings}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{set\+Egress\+Settings(const Settings\+List \&in\+Settings) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::set\+Egress\+Settings (
\begin{DoxyParamCaption}
\item[{const {\bf Settings\+List} \&}]{in\+Settings}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_afd9f33352327dcc51e618f007797f4c8}
Set outgoing settings for this session 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_a4eb00f161f175ca1a631e580ac7e86fb}.



Definition at line 351 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Egress\+Settings(), proxygen\+::\+H\+T\+T\+P\+Settings\+::set\+Setting(), settings, and started\+\_\+.



Referenced by get\+Byte\+Event\+Tracker(), and proxygen\+::\+H\+T\+T\+P\+Session\+Acceptor\+::on\+New\+Connection().


\begin{DoxyCode}
351                                                                   \{
352   VLOG\_IF(4, started_) << \textcolor{stringliteral}{"Must flush egress settings to peer"};
353   HTTPSettings* settings = codec_->getEgressSettings();
354   \textcolor{keywordflow}{if} (settings) \{
355     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& setting: inSettings) \{
356       settings->setSetting(setting.id, setting.value);
357     \}
358   \}
359 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!set\+Flow\+Control@{set\+Flow\+Control}}
\index{set\+Flow\+Control@{set\+Flow\+Control}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{set\+Flow\+Control(size\+\_\+t initial\+Receive\+Window, size\+\_\+t receive\+Stream\+Window\+Size, size\+\_\+t receive\+Session\+Window\+Size) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::set\+Flow\+Control (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{initial\+Receive\+Window, }
\item[{size\+\_\+t}]{receive\+Stream\+Window\+Size, }
\item[{size\+\_\+t}]{receive\+Session\+Window\+Size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_abf7a8f45923ceb76bcff72f6939011a0}
Set flow control properties on the session.


\begin{DoxyParams}{Parameters}
{\em initial\+Receive\+Window} & size of initial receive window for all ingress streams; set via the initial S\+E\+T\+T\+I\+N\+GS frame \\
\hline
{\em receive\+Stream\+Window\+Size} & per-\/stream receive window for N\+EW streams; sent via a W\+I\+N\+D\+O\+W\+\_\+\+U\+P\+D\+A\+TE frame \\
\hline
{\em receive\+Session\+Window\+Size} & per-\/session receive window; sent via a W\+I\+N\+D\+O\+W\+\_\+\+U\+P\+D\+A\+TE frame \\
\hline
\end{DoxyParams}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_ae2e92325faa2256085a583798647392c}.



Definition at line 336 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Egress\+Settings(), proxygen\+::\+I\+N\+I\+T\+I\+A\+L\+\_\+\+W\+I\+N\+D\+O\+W\+\_\+\+S\+I\+ZE, initial\+Receive\+Window\+\_\+, receive\+Session\+Window\+Size\+\_\+, receive\+Stream\+Window\+Size\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::set\+Read\+Buffer\+Limit(), proxygen\+::\+H\+T\+T\+P\+Settings\+::set\+Setting(), settings, and started\+\_\+.



Referenced by H\+T\+T\+P\+Upstream\+Test$<$ S\+P\+D\+Y3\+Codec\+Pair $>$\+::common\+Set\+Up(), Curl\+Service\+::\+Curl\+Client\+::connect\+Success(), get\+Byte\+Event\+Tracker(), and proxygen\+::\+H\+T\+T\+P\+Session\+Acceptor\+::on\+New\+Connection().


\begin{DoxyCode}
338                                                                   \{
339   CHECK(!started_);
340   initialReceiveWindow_ = initialReceiveWindow;
341   receiveStreamWindowSize_ = receiveStreamWindowSize;
342   receiveSessionWindowSize_ = receiveSessionWindowSize;
343   HTTPSessionBase::setReadBufferLimit(receiveSessionWindowSize);
344   HTTPSettings* settings = codec_->getEgressSettings();
345   \textcolor{keywordflow}{if} (settings) \{
346     settings->setSetting(SettingsId::INITIAL_WINDOW_SIZE,
347                          initialReceiveWindow_);
348   \}
349 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!set\+Header\+Codec\+Stats@{set\+Header\+Codec\+Stats}}
\index{set\+Header\+Codec\+Stats@{set\+Header\+Codec\+Stats}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{set\+Header\+Codec\+Stats(\+Header\+Codec\+::\+Stats $\ast$stats) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::set\+Header\+Codec\+Stats (
\begin{DoxyParamCaption}
\item[{{\bf Header\+Codec\+::\+Stats} $\ast$}]{stats}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a4d9d59cc2df5eff2fd9e89c4ad433a9d}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_a0a1a79eed3a8ed36e51a2723656348f6}.



Definition at line 204 of file H\+T\+T\+P\+Session.\+h.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, and proxygen\+::\+H\+T\+T\+P\+Codec\+::set\+Header\+Codec\+Stats().


\begin{DoxyCode}
204                                                              \{
205     codec_->setHeaderCodecStats(stats);
206   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!set\+H\+T\+T\+P2\+Priorities\+Enabled@{set\+H\+T\+T\+P2\+Priorities\+Enabled}}
\index{set\+H\+T\+T\+P2\+Priorities\+Enabled@{set\+H\+T\+T\+P2\+Priorities\+Enabled}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{set\+H\+T\+T\+P2\+Priorities\+Enabled(bool enabled) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::set\+H\+T\+T\+P2\+Priorities\+Enabled (
\begin{DoxyParamCaption}
\item[{bool}]{enabled}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a7146166e18d78011dcb8df8685ffa31c}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_ad10b65e55937ef9a905786e48133edf0}.



Definition at line 118 of file H\+T\+T\+P\+Session.\+h.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::set\+H\+T\+T\+P2\+Priorities\+Enabled().



Referenced by proxygen\+::\+H\+T\+T\+P\+Session\+Acceptor\+::on\+New\+Connection().


\begin{DoxyCode}
118                                                         \{
119     HTTPSessionBase::setHTTP2PrioritiesEnabled(enabled);
120   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!set\+Max\+Concurrent\+Incoming\+Streams@{set\+Max\+Concurrent\+Incoming\+Streams}}
\index{set\+Max\+Concurrent\+Incoming\+Streams@{set\+Max\+Concurrent\+Incoming\+Streams}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{set\+Max\+Concurrent\+Incoming\+Streams(uint32\+\_\+t num) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::set\+Max\+Concurrent\+Incoming\+Streams (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{num}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a74cd3ad6f9e4755a65d7d8e5c92a2ce0}
Set the maximum number of transactions the remote can open at once. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_a961c0ea702af3c201dd0c83f24b87ee6}.



Definition at line 361 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Egress\+Settings(), proxygen\+::\+M\+A\+X\+\_\+\+C\+O\+N\+C\+U\+R\+R\+E\+N\+T\+\_\+\+S\+T\+R\+E\+A\+MS, max\+Concurrent\+Incoming\+Streams\+\_\+, proxygen\+::\+H\+T\+T\+P\+Settings\+::set\+Setting(), settings, started\+\_\+, and proxygen\+::\+H\+T\+T\+P\+Codec\+::supports\+Parallel\+Requests().



Referenced by get\+Setup\+Transport\+Info(), and proxygen\+::\+H\+T\+T\+P\+Session\+Acceptor\+::on\+New\+Connection().


\begin{DoxyCode}
361                                                               \{
362   CHECK(!started_);
363   \textcolor{keywordflow}{if} (codec_->supportsParallelRequests()) \{
364     maxConcurrentIncomingStreams_ = num;
365     HTTPSettings* settings = codec_->getEgressSettings();
366     \textcolor{keywordflow}{if} (settings) \{
367       settings->setSetting(SettingsId::MAX_CONCURRENT_STREAMS,
368                            maxConcurrentIncomingStreams_);
369     \}
370   \}
371 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!set\+New\+Transaction\+Pause\+State@{set\+New\+Transaction\+Pause\+State}}
\index{set\+New\+Transaction\+Pause\+State@{set\+New\+Transaction\+Pause\+State}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{set\+New\+Transaction\+Pause\+State(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D stream\+I\+D)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::set\+New\+Transaction\+Pause\+State (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{stream\+ID}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a632376e9b73b4cdafb49de77b87e7a70}


Definition at line 722 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::egress\+Limit\+Exceeded(), find\+Transaction(), and num\+Active\+Writes\+\_\+.



Referenced by new\+Ex\+Transaction(), new\+Pushed\+Transaction(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::new\+Transaction(), on\+Headers\+Sent(), and proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::setup\+On\+Headers\+Complete().


\begin{DoxyCode}
722                                                                    \{
723   \textcolor{keywordflow}{if} (!egressLimitExceeded()) \{
724     \textcolor{keywordflow}{return};
725   \}
726 
727   \textcolor{keyword}{auto} txn = findTransaction(streamID);
728   \textcolor{keywordflow}{if} (txn) \{
729     \textcolor{comment}{// If writes are paused, start this txn off in the egress paused state}
730     VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" starting streamID="} << txn->getID()
731             << \textcolor{stringliteral}{" egress paused, numActiveWrites\_="} << numActiveWrites_;
732     txn->pauseEgress();
733   \}
734 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!set\+Second\+Auth\+Manager@{set\+Second\+Auth\+Manager}}
\index{set\+Second\+Auth\+Manager@{set\+Second\+Auth\+Manager}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{set\+Second\+Auth\+Manager(std\+::unique\+\_\+ptr$<$ Secondary\+Auth\+Manager $>$ second\+Auth\+Manager)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::set\+Second\+Auth\+Manager (
\begin{DoxyParamCaption}
\item[{std\+::unique\+\_\+ptr$<$ {\bf Secondary\+Auth\+Manager} $>$}]{second\+Auth\+Manager}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPSession_a508498d569ac0f41882eb22ea7a61642}
Attach a \doxyref{Secondary\+Auth\+Manager}{p.}{classproxygen_1_1SecondaryAuthManager} to this session to control secondary certificate authentication in H\+T\+T\+P/2. 

Definition at line 1824 of file H\+T\+T\+P\+Session.\+cpp.



References second\+Auth\+Manager\+\_\+.



Referenced by conn\+Close\+By\+Remote().


\begin{DoxyCode}
1825                                                            \{
1826   secondAuthManager_ = std::move(secondAuthManager);
1827 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!set\+Session\+Stats@{set\+Session\+Stats}}
\index{set\+Session\+Stats@{set\+Session\+Stats}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{set\+Session\+Stats(\+H\+T\+T\+P\+Session\+Stats $\ast$stats) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::set\+Session\+Stats (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Session\+Stats} $\ast$}]{stats}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a480679a665d1efba1a2393a9c0608665}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_a077f02e05a034b8e282f81753edfea25}.



Definition at line 329 of file H\+T\+T\+P\+Session.\+cpp.



References byte\+Event\+Tracker\+\_\+, and proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::set\+Session\+Stats().



Referenced by proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::attach\+Thread\+Locals(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::detach\+Thread\+Locals(), get\+Byte\+Event\+Tracker(), and proxygen\+::\+H\+T\+T\+P\+Session\+Acceptor\+::on\+New\+Connection().


\begin{DoxyCode}
329                                                          \{
330   HTTPSessionBase::setSessionStats(stats);
331   \textcolor{keywordflow}{if} (byteEventTracker_) \{
332     byteEventTracker_->setTTLBAStats(stats);
333   \}
334 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!setup\+Codec@{setup\+Codec}}
\index{setup\+Codec@{setup\+Codec}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{setup\+Codec()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::setup\+Codec (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a1b6ff36da42045dd70278f3862a8ff8e}


Definition at line 243 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+Filter\+Chain$<$ T1, T2, Filter\+Type, set\+\_\+callback, Take\+Ownership $>$\+::add\+Filters(), proxygen\+::\+Filter\+Chain$<$ T1, T2, Filter\+Type, set\+\_\+callback, Take\+Ownership $>$\+::call(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, conn\+Flow\+Control\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+Connection\+Preface(), get\+Cert\+Auth\+Setting\+Val(), proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Egress\+Settings(), is\+Downstream(), proxygen\+::\+M\+A\+X\+\_\+\+C\+O\+N\+C\+U\+R\+R\+E\+N\+T\+\_\+\+S\+T\+R\+E\+A\+MS, max\+Concurrent\+Incoming\+Streams\+\_\+, max\+Concurrent\+Outgoing\+Streams\+Remote\+\_\+, second\+Auth\+Manager\+\_\+, proxygen\+::\+Filter\+Chain$<$ T1, T2, Filter\+Type, set\+\_\+callback, Take\+Ownership $>$\+::set\+Callback(), proxygen\+::\+H\+T\+T\+P\+Settings\+::set\+Setting(), settings, proxygen\+::\+S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+H\+T\+T\+P\+\_\+\+C\+E\+R\+T\+\_\+\+A\+U\+TH, proxygen\+::\+H\+T\+T\+P\+Codec\+::supports\+Parallel\+Requests(), proxygen\+::\+H\+T\+T\+P\+Codec\+::supports\+Session\+Flow\+Control(), and write\+Buf\+\_\+.



Referenced by get\+Max\+Concurrent\+Outgoing\+Streams\+Remote(), on\+Native\+Protocol\+Upgrade\+Impl(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().


\begin{DoxyCode}
243                              \{
244   \textcolor{keywordflow}{if} (!codec_->supportsParallelRequests()) \{
245     \textcolor{comment}{// until we support upstream pipelining}
246     maxConcurrentIncomingStreams_ = 1;
247     maxConcurrentOutgoingStreamsRemote_ = isDownstream() ? 0 : 1;
248   \}
249 
250   \textcolor{comment}{// If a secondary authentication manager is configured for this session, set}
251   \textcolor{comment}{// the SETTINGS\_HTTP\_CERT\_AUTH to indicate support for HTTP-layer certificate}
252   \textcolor{comment}{// authentication.}
253   uint32\_t certAuthSettingVal = 0;
254   \textcolor{keywordflow}{if} (secondAuthManager_) \{
255     certAuthSettingVal = getCertAuthSettingVal();
256   \}
257   HTTPSettings* settings = codec_->getEgressSettings();
258   \textcolor{keywordflow}{if} (settings) \{
259     settings->setSetting(SettingsId::MAX_CONCURRENT_STREAMS,
260                          maxConcurrentIncomingStreams_);
261     \textcolor{keywordflow}{if} (certAuthSettingVal != 0) \{
262       settings->setSetting(SettingsId::SETTINGS_HTTP_CERT_AUTH,
263                            certAuthSettingVal);
264     \}
265   \}
266   codec_->generateConnectionPreface(writeBuf_);
267 
268   \textcolor{keywordflow}{if} (codec_->supportsSessionFlowControl() && !connFlowControl_) \{
269     connFlowControl_ = \textcolor{keyword}{new} FlowControlFilter(*\textcolor{keyword}{this}, writeBuf_, codec_.call());
270     codec_.addFilters(std::unique\_ptr<FlowControlFilter>(connFlowControl_));
271     \textcolor{comment}{// if we really support switching from spdy <-> h2, we need to update}
272     \textcolor{comment}{// existing flow control filter}
273   \}
274 
275   codec_.setCallback(\textcolor{keyword}{this});
276 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!setup\+On\+Headers\+Complete@{setup\+On\+Headers\+Complete}}
\index{setup\+On\+Headers\+Complete@{setup\+On\+Headers\+Complete}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{setup\+On\+Headers\+Complete(\+H\+T\+T\+P\+Transaction $\ast$txn, H\+T\+T\+P\+Message $\ast$msg)=0}]{\setlength{\rightskip}{0pt plus 5cm}virtual void proxygen\+::\+H\+T\+T\+P\+Session\+::setup\+On\+Headers\+Complete (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Transaction} $\ast$}]{txn, }
\item[{{\bf H\+T\+T\+P\+Message} $\ast$}]{msg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [pure virtual]}}\label{classproxygen_1_1HTTPSession_ae180c928b2d55c4e227a1629d8b8a511}
Called by \doxyref{on\+Headers\+Complete()}{p.}{classproxygen_1_1HTTPSession_a01cf2e4876e0d44c1b7974833bef3272}. This function allows downstream and upstream to do any setup (like preparing a handler) when headers are first received from the remote side on a given transaction. 

Implemented in {\bf proxygen\+::\+H\+T\+T\+P\+Upstream\+Session} \doxyref{}{p.}{classproxygen_1_1HTTPUpstreamSession_a0bba6b0115f517de0fce6cd64a5cdfbb}, and {\bf proxygen\+::\+H\+T\+T\+P\+Downstream\+Session} \doxyref{}{p.}{classproxygen_1_1HTTPDownstreamSession_a93c34ca69d797f3e31b11da08bd64a91}.



Referenced by conn\+Close\+By\+Remote(), and on\+Headers\+Complete().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!should\+Shutdown@{should\+Shutdown}}
\index{should\+Shutdown@{should\+Shutdown}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{should\+Shutdown() const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::should\+Shutdown (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a488290b5d92a67ab804c6b0f589ad9e0}
Returns true iff this session should shutdown at this time. Default behavior is to not shutdown. 

Definition at line 2509 of file H\+T\+T\+P\+Session.\+cpp.



References all\+Transactions\+Started(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, draining\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::is\+Reusable(), is\+Upstream(), and proxygen\+::\+H\+T\+T\+P\+Codec\+::supports\+Parallel\+Requests().



Referenced by detach(), invoke\+On\+All\+Transactions(), and send\+Headers().


\begin{DoxyCode}
2509                                        \{
2510   \textcolor{keywordflow}{return} draining_ &&
2511     allTransactionsStarted() &&
2512     (!codec_->supportsParallelRequests() ||
2513      isUpstream() ||
2514      !codec_->isReusable());
2515 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!shutdown\+Transport@{shutdown\+Transport}}
\index{shutdown\+Transport@{shutdown\+Transport}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{shutdown\+Transport(bool shutdown\+Reads=true, bool shutdown\+Writes=true, const std\+::string \&error\+Msg="""")}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::shutdown\+Transport (
\begin{DoxyParamCaption}
\item[{bool}]{shutdown\+Reads = {\ttfamily true}, }
\item[{bool}]{shutdown\+Writes = {\ttfamily true}, }
\item[{const std\+::string \&}]{error\+Msg = {\ttfamily \char`\"{}\char`\"{}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a7773c16e03030dca8e168a2e41564335}
Start closing the socket. 
\begin{DoxyParams}{Parameters}
{\em shutdown\+Reads} & Whether to close the read side of the socket. All transactions which are not ingress complete will receive an error. \\
\hline
{\em shutdown\+Writes} & Whether to close the write side of the socket. All transactions which are not egress complete will receive an error. \\
\hline
{\em error\+Msg} & additional error information to pass to each transaction \\
\hline
\end{DoxyParams}


Definition at line 2295 of file H\+T\+T\+P\+Session.\+cpp.



References byte\+Event\+Tracker\+\_\+, check\+For\+Shutdown(), proxygen\+::\+H\+T\+T\+P\+Codec\+::close\+On\+Egress\+Complete(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Exception\+::\+E\+G\+R\+E\+SS, flow\+Control\+Timeout\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+Goaway(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::get\+Connection\+Close\+Reason(), proxygen\+::get\+Error\+String(), proxygen\+::\+H\+T\+T\+P\+Codec\+::get\+Last\+Incoming\+Stream\+I\+D(), get\+Peer\+Address(), has\+More\+Writes(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, proxygen\+::\+H\+T\+T\+P\+Exception\+::\+I\+N\+G\+R\+E\+SS, proxygen\+::\+H\+T\+T\+P\+Exception\+::\+I\+N\+G\+R\+E\+S\+S\+\_\+\+A\+N\+D\+\_\+\+E\+G\+R\+E\+SS, invoke\+On\+All\+Transactions(), proxygen\+::\+I\+O\+\_\+\+W\+R\+I\+T\+E\+\_\+\+E\+R\+R\+OR, proxygen\+::k\+Error\+Connection\+Reset, proxygen\+::k\+Error\+E\+OF, proxygen\+::k\+Error\+S\+SL, proxygen\+::k\+Error\+Timeout, proxygen\+::k\+Error\+Write, proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Transaction\+::on\+Error(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Ingress\+E\+O\+F(), proxygen\+::\+H\+T\+T\+P\+Codec\+::on\+Ingress\+E\+O\+F(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Ingress\+Error(), reads\+\_\+, reads\+Shutdown(), reset\+After\+Draining\+Writes\+\_\+, reset\+Socket\+On\+Shutdown\+\_\+, schedule\+Write(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::set\+Close\+Reason(), proxygen\+::\+H\+T\+T\+P\+Codec\+::set\+Parser\+Paused(), proxygen\+::\+Exception\+::set\+Proxygen\+Error(), proxygen\+::\+S\+H\+U\+T\+D\+O\+WN, sock\+\_\+, proxygen\+::\+T\+I\+M\+E\+O\+UT, transactions\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::transport\+Info\+\_\+, proxygen\+::\+U\+N\+K\+N\+O\+WN, write\+Buf\+\_\+, writes\+\_\+, writes\+Draining\+\_\+, and writes\+Shutdown().



Referenced by detach(), drain(), drop\+Connection(), flow\+Control\+Timeout\+Expired(), is\+Draining(), on\+Delete\+Ack\+Event(), on\+Egress\+Message\+Finished(), on\+Error(), on\+Message\+Complete(), on\+Session\+Parse\+Error(), on\+Write\+Completed(), on\+Write\+Success(), read\+E\+O\+F(), read\+Err(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Shutdown\+Transport\+Callback\+::run\+Loop\+Callback().


\begin{DoxyCode}
2297                                                           \{
2298   DestructorGuard guard(\textcolor{keyword}{this});
2299 
2300   \textcolor{comment}{// shutdowns not accounted for, shouldn't see any}
2301   setCloseReason(ConnectionCloseReason::UNKNOWN);
2302 
2303   VLOG(4) << \textcolor{stringliteral}{"shutdown request for "} << *\textcolor{keyword}{this} << \textcolor{stringliteral}{": reads="}
2304           << shutdownReads << \textcolor{stringliteral}{" (currently "} << readsShutdown()
2305           << \textcolor{stringliteral}{"), writes="} << shutdownWrites << \textcolor{stringliteral}{" (currently "}
2306           << writesShutdown() << \textcolor{stringliteral}{")"};
2307 
2308   \textcolor{keywordtype}{bool} notifyEgressShutdown = \textcolor{keyword}{false};
2309   \textcolor{keywordtype}{bool} notifyIngressShutdown = \textcolor{keyword}{false};
2310 
2311   ProxygenError error;
2312   \textcolor{keywordflow}{if} (!transportInfo_.sslError.empty()) \{
2313     error = kErrorSSL;
2314   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (sock_->error()) \{
2315     VLOG(3) << \textcolor{stringliteral}{"shutdown request for "} << *\textcolor{keyword}{this}
2316       << \textcolor{stringliteral}{" on bad socket. Shutting down writes too."};
2317     \textcolor{keywordflow}{if} (getConnectionCloseReason() == ConnectionCloseReason::IO_WRITE_ERROR) \{
2318       error = kErrorWrite;
2319     \} \textcolor{keywordflow}{else} \{
2320       error = kErrorConnectionReset;
2321     \}
2322     shutdownWrites = \textcolor{keyword}{true};
2323   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (getConnectionCloseReason() == ConnectionCloseReason::TIMEOUT) \{
2324     error = kErrorTimeout;
2325   \} \textcolor{keywordflow}{else} \{
2326     error = kErrorEOF;
2327   \}
2328 
2329   \textcolor{keywordflow}{if} (shutdownReads && !shutdownWrites && flowControlTimeout_.isScheduled()) \{
2330     \textcolor{comment}{// reads are dead and writes are blocked on a window update that will never}
2331     \textcolor{comment}{// come.  shutdown writes too.}
2332     VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" Converting read shutdown to read/write due to"}
2333       \textcolor{stringliteral}{" flow control"};
2334     shutdownWrites = \textcolor{keyword}{true};
2335   \}
2336 
2337   \textcolor{keywordflow}{if} (shutdownWrites && !writesShutdown()) \{
2338     \textcolor{keywordflow}{if} (codec_->generateGoaway(writeBuf_,
2339                                codec_->getLastIncomingStreamID(),
2340                                ErrorCode::NO_ERROR)) \{
2341       scheduleWrite();
2342     \}
2343     \textcolor{keywordflow}{if} (!hasMoreWrites() &&
2344         (transactions_.empty() || codec_->closeOnEgressComplete())) \{
2345       writes_ = SocketState::SHUTDOWN;
2346       \textcolor{keywordflow}{if} (byteEventTracker_) \{
2347         byteEventTracker_->drainByteEvents();
2348       \}
2349       \textcolor{keywordflow}{if} (resetAfterDrainingWrites_) \{
2350         VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" writes drained, sending RST"};
2351         resetSocketOnShutdown_ = \textcolor{keyword}{true};
2352         shutdownReads = \textcolor{keyword}{true};
2353       \} \textcolor{keywordflow}{else} \{
2354         VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" writes drained, closing"};
2355         sock_->shutdownWriteNow();
2356       \}
2357       notifyEgressShutdown = \textcolor{keyword}{true};
2358     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!writesDraining_) \{
2359       writesDraining_ = \textcolor{keyword}{true};
2360       notifyEgressShutdown = \textcolor{keyword}{true};
2361     \} \textcolor{comment}{// else writes are already draining; don't double notify}
2362   \}
2363 
2364   \textcolor{keywordflow}{if} (shutdownReads && !readsShutdown()) \{
2365     notifyIngressShutdown = \textcolor{keyword}{true};
2366     \textcolor{comment}{// TODO: send an RST if readBuf\_ is non empty?}
2367     sock_->setReadCB(\textcolor{keyword}{nullptr});
2368     reads_ = SocketState::SHUTDOWN;
2369     \textcolor{keywordflow}{if} (!transactions_.empty() && error == kErrorConnectionReset) \{
2370       \textcolor{keywordflow}{if} (infoCallback_ != \textcolor{keyword}{nullptr}) \{
2371         infoCallback_->onIngressError(*\textcolor{keyword}{this}, error);
2372       \}
2373     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (error == kErrorEOF) \{
2374       \textcolor{comment}{// Report to the codec that the ingress stream has ended}
2375       codec_->onIngressEOF();
2376       \textcolor{keywordflow}{if} (infoCallback_) \{
2377         infoCallback_->onIngressEOF();
2378       \}
2379     \}
2380     \textcolor{comment}{// Once reads are shutdown the parser should stop processing}
2381     codec_->setParserPaused(\textcolor{keyword}{true});
2382   \}
2383 
2384   \textcolor{keywordflow}{if} (notifyIngressShutdown || notifyEgressShutdown) \{
2385     \textcolor{keyword}{auto} dir = (notifyIngressShutdown && notifyEgressShutdown)
2386                    ? HTTPException::Direction::INGRESS_AND_EGRESS
2387                    : (notifyIngressShutdown ? HTTPException::Direction::INGRESS
2388                                             : HTTPException::Direction::EGRESS);
2389     HTTPException ex(
2390         dir,
2391         folly::to<std::string>(\textcolor{stringliteral}{"Shutdown transport: "}, getErrorString(error),
2392                                errorMsg.empty() ? \textcolor{stringliteral}{""} : \textcolor{stringliteral}{" "}, errorMsg, \textcolor{stringliteral}{", "},
2393                                getPeerAddress().describe()));
2394     ex.setProxygenError(error);
2395     invokeOnAllTransactions(&HTTPTransaction::onError, ex);
2396   \}
2397 
2398   \textcolor{comment}{// Close the socket only after the onError() callback on the txns}
2399   \textcolor{comment}{// and handler has been detached.}
2400   checkForShutdown();
2401 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!shutdown\+Transport\+With\+Reset@{shutdown\+Transport\+With\+Reset}}
\index{shutdown\+Transport\+With\+Reset@{shutdown\+Transport\+With\+Reset}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{shutdown\+Transport\+With\+Reset(\+Proxygen\+Error error\+Code, const std\+::string \&error\+Msg="""")}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::shutdown\+Transport\+With\+Reset (
\begin{DoxyParamCaption}
\item[{{\bf Proxygen\+Error}}]{error\+Code, }
\item[{const std\+::string \&}]{error\+Msg = {\ttfamily \char`\"{}\char`\"{}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_adba39f5cba4a8eaa5a2c54c774fad9ed}
Immediately close the socket in both directions, discarding any queued writes that haven\textquotesingle{}t yet been transferred to the kernel, and send a R\+ST to the client. All transactions receive on\+Write\+Error.


\begin{DoxyParams}{Parameters}
{\em error\+Code} & Error code sent with the on\+Write\+Error to transactions. \\
\hline
{\em error\+Msg} & Error string included in the final error msg. \\
\hline
\end{DoxyParams}


Definition at line 2403 of file H\+T\+T\+P\+Session.\+cpp.



References byte\+Event\+Tracker\+\_\+, check\+For\+Shutdown(), error\+On\+All\+Transactions(), num\+Active\+Writes\+\_\+, pending\+Writes\+\_\+, reads\+\_\+, reads\+Shutdown(), reset\+Socket\+On\+Shutdown\+\_\+, proxygen\+::\+S\+H\+U\+T\+D\+O\+WN, sock\+\_\+, write\+Buf\+\_\+, writes\+\_\+, writes\+Shutdown(), and write\+Timeout\+\_\+.



Referenced by drop\+Connection(), is\+Draining(), on\+Write\+Error(), and write\+Timeout\+Expired().


\begin{DoxyCode}
2405                                \{
2406   DestructorGuard guard(\textcolor{keyword}{this});
2407   VLOG(4) << \textcolor{stringliteral}{"shutdownTransportWithReset"};
2408 
2409   \textcolor{keywordflow}{if} (!readsShutdown()) \{
2410     sock_->setReadCB(\textcolor{keyword}{nullptr});
2411     reads_ = SocketState::SHUTDOWN;
2412   \}
2413 
2414   \textcolor{keywordflow}{if} (!writesShutdown()) \{
2415     writes_ = SocketState::SHUTDOWN;
2416     IOBuf::destroy(writeBuf_.move());
2417     \textcolor{keywordflow}{while} (!pendingWrites_.empty()) \{
2418       pendingWrites_.front().detach();
2419       numActiveWrites_--;
2420     \}
2421     VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" cancel write timer"};
2422     writeTimeout_.cancelTimeout();
2423     resetSocketOnShutdown_ = \textcolor{keyword}{true};
2424   \}
2425 
2426   errorOnAllTransactions(errorCode, errorMsg);
2427   \textcolor{comment}{// drainByteEvents() can call detach(txn), which can in turn call}
2428   \textcolor{comment}{// shutdownTransport if we were already draining. To prevent double}
2429   \textcolor{comment}{// calling onError() to the transactions, we call drainByteEvents()}
2430   \textcolor{comment}{// after we've given the explicit error.}
2431   \textcolor{keywordflow}{if} (byteEventTracker_) \{
2432     byteEventTracker_->drainByteEvents();
2433   \}
2434 
2435   \textcolor{comment}{// HTTPTransaction::onError could theoretically schedule more callbacks,}
2436   \textcolor{comment}{// so do this last.}
2437   \textcolor{keywordflow}{if} (isLoopCallbackScheduled()) \{
2438     cancelLoopCallback();
2439   \}
2440   \textcolor{comment}{// onError() callbacks or drainByteEvents() could result in txns detaching}
2441   \textcolor{comment}{// due to CallbackGuards going out of scope. Close the socket only after}
2442   \textcolor{comment}{// the txns are detached.}
2443   checkForShutdown();
2444 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!start\+Now@{start\+Now}}
\index{start\+Now@{start\+Now}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{start\+Now() override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::start\+Now (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTPSession_a9a89f7a8498e8afae9ee48c61f1c8bdc}
Start reading from the transport and send any introductory messages to the remote side. This function must be called once per session to begin reads. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Session\+Base} \doxyref{}{p.}{classproxygen_1_1HTTPSessionBase_afb0355245a0beec339f0e493870a6114}.



Reimplemented in {\bf proxygen\+::\+H\+T\+T\+P\+Upstream\+Session} \doxyref{}{p.}{classproxygen_1_1HTTPUpstreamSession_a242b4223b8ff63d7dd7407cc8e312365}.



Definition at line 297 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, conn\+Flow\+Control\+\_\+, draining\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+Goaway(), proxygen\+::\+H\+T\+T\+P\+Codec\+::generate\+Settings(), get\+Graceful\+Goaway\+Ack(), proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, receive\+Session\+Window\+Size\+\_\+, resume\+Reads(), schedule\+Write(), proxygen\+::\+Flow\+Control\+Filter\+::set\+Receive\+Window\+Size(), started\+\_\+, and write\+Buf\+\_\+.



Referenced by get\+Setup\+Transport\+Info(), proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::start\+Now(), and proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::start\+Now().


\begin{DoxyCode}
297                            \{
298   CHECK(!started_);
299   started_ = \textcolor{keyword}{true};
300   codec_->generateSettings(writeBuf_);
301   \textcolor{keywordflow}{if} (connFlowControl_) \{
302     connFlowControl_->setReceiveWindowSize(writeBuf_,
303                                            receiveSessionWindowSize_);
304   \}
305   \textcolor{comment}{// For HTTP/2 if we are currently draining it means we got notified to}
306   \textcolor{comment}{// shutdown before we sent a SETTINGS frame, so we defer sending a GOAWAY}
307   \textcolor{comment}{// util we've started and sent SETTINGS.}
308   \textcolor{keywordflow}{if} (draining_) \{
309     codec_->generateGoaway(writeBuf_,
310                            getGracefulGoawayAck(),
311                            ErrorCode::NO_ERROR);
312   \}
313   scheduleWrite();
314   resumeReads();
315 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!timeout\+Expired@{timeout\+Expired}}
\index{timeout\+Expired@{timeout\+Expired}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{timeout\+Expired() noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::timeout\+Expired (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_aee0c2edc0dd6e8c306b814276a6f661d}


Definition at line 190 of file H\+T\+T\+P\+Session.\+h.



References close\+When\+Idle(), describe(), drop\+Connection(), dump\+Connection\+State(), get\+Current\+Transport\+Info\+Without\+Update(), is\+Busy(), notify\+Pending\+Shutdown(), and read\+Timeout\+Expired().


\begin{DoxyCode}
190                                           \{
191       readTimeoutExpired();
192   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!transaction\+Timeout@{transaction\+Timeout}}
\index{transaction\+Timeout@{transaction\+Timeout}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{transaction\+Timeout(\+H\+T\+T\+P\+Transaction $\ast$txn) noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::transaction\+Timeout (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Transaction} $\ast$}]{txn}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [protected]}, {\ttfamily [virtual]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_a27a75b63b2d5d2e397fbf482209e6188}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Transaction\+::\+Transport} \doxyref{}{p.}{classproxygen_1_1HTTPTransaction_1_1Transport_a4805d62c2895d90c91bd43b396a6fa68}.



Definition at line 1545 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::codec\+\_\+, get\+Transaction\+Timeout\+Handler(), proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::info\+Callback\+\_\+, ingress\+Error\+\_\+, proxygen\+::k\+Error\+Timeout, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::\+Info\+Callback\+::on\+Ingress\+Error(), and proxygen\+::\+H\+T\+T\+P\+Codec\+::supports\+Parallel\+Requests().



Referenced by num\+Incoming\+Streams().


\begin{DoxyCode}
1545                                                              \{
1546   \textcolor{comment}{// A transaction has timed out.  If the transaction does not have}
1547   \textcolor{comment}{// a Handler yet, because we haven't yet received the full request}
1548   \textcolor{comment}{// headers, we give it a DirectResponseHandler that generates an}
1549   \textcolor{comment}{// error page.}
1550   VLOG(3) << \textcolor{stringliteral}{"Transaction timeout for streamID="} << txn->getID();
1551   \textcolor{keywordflow}{if} (!codec_->supportsParallelRequests()) \{
1552     \textcolor{comment}{// this error should only prevent us from reading/handling more errors}
1553     \textcolor{comment}{// on serial streams}
1554     ingressError_ = \textcolor{keyword}{true};
1555   \}
1556 
1557   \textcolor{keywordflow}{if} (!txn->getHandler() &&
1558       txn->getEgressState() == HTTPTransactionEgressSM::State::Start) \{
1559     VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" Timed out receiving headers"};
1560     \textcolor{keywordflow}{if} (infoCallback_) \{
1561       infoCallback_->onIngressError(*\textcolor{keyword}{this}, kErrorTimeout);
1562     \}
1563     \textcolor{keywordflow}{if} (codec_->supportsParallelRequests()) \{
1564       \textcolor{comment}{// This can only happen with HTTP/2 where the HEADERS frame is incomplete}
1565       \textcolor{comment}{// and we time out waiting for the CONTINUATION.  Abort the request.}
1566       \textcolor{comment}{//}
1567       \textcolor{comment}{// It would maybe be a little nicer to use the timeout handler for these}
1568       \textcolor{comment}{// also.}
1569       txn->sendAbort();
1570       \textcolor{keywordflow}{return};
1571     \}
1572 
1573     VLOG(4) << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" creating direct error handler"};
1574     \textcolor{keyword}{auto} handler = getTransactionTimeoutHandler(txn);
1575     txn->setHandler(handler);
1576   \}
1577 
1578   \textcolor{comment}{// Tell the transaction about the timeout.  The transaction will}
1579   \textcolor{comment}{// communicate the timeout to the handler, and the handler will}
1580   \textcolor{comment}{// decide how to proceed.}
1581   txn->onIngressTimeout();
1582 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!update\+Write\+Buf\+Size@{update\+Write\+Buf\+Size}}
\index{update\+Write\+Buf\+Size@{update\+Write\+Buf\+Size}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{update\+Write\+Buf\+Size(int64\+\_\+t delta)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::update\+Write\+Buf\+Size (
\begin{DoxyParamCaption}
\item[{int64\+\_\+t}]{delta}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a1cdd56f14df7e2a12dd42f7de1fc868f}


Definition at line 2261 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::egress\+Limit\+Exceeded(), in\+Resume\+\_\+, invoke\+On\+All\+Transactions(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::pause\+Egress(), pending\+Pause\+\_\+, pending\+Write\+Size\+Delta\+\_\+, resume\+Transactions(), and proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::update\+Pending\+Write\+Size().



Referenced by is\+Draining(), notify\+Egress\+Body\+Buffered(), on\+Write\+Success(), and run\+Loop\+Callback().


\begin{DoxyCode}
2261                                              \{
2262   \textcolor{comment}{// This is the sum of body bytes buffered within transactions\_ and in}
2263   \textcolor{comment}{// the sock\_'s write buffer.}
2264   delta += pendingWriteSizeDelta_;
2265   pendingWriteSizeDelta_ = 0;
2266   \textcolor{keywordtype}{bool} wasExceeded = egressLimitExceeded();
2267   updatePendingWriteSize(delta);
2268 
2269   \textcolor{keywordflow}{if} (egressLimitExceeded() && !wasExceeded) \{
2270     \textcolor{comment}{// Exceeded limit. Pause reading on the incoming stream.}
2271     \textcolor{keywordflow}{if} (inResume_) \{
2272       VLOG(3) << \textcolor{stringliteral}{"Pausing txn egress for "} << *\textcolor{keyword}{this} << \textcolor{stringliteral}{" deferred"};
2273       pendingPause_ = \textcolor{keyword}{true};
2274     \} \textcolor{keywordflow}{else} \{
2275       VLOG(3) << \textcolor{stringliteral}{"Pausing txn egress for "} << *\textcolor{keyword}{this};
2276       invokeOnAllTransactions(&HTTPTransaction::pauseEgress);
2277     \}
2278   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!egressLimitExceeded() && wasExceeded) \{
2279     \textcolor{comment}{// Dropped below limit. Resume reading on the incoming stream if needed.}
2280     \textcolor{keywordflow}{if} (inResume_) \{
2281       \textcolor{keywordflow}{if} (pendingPause_) \{
2282         VLOG(3) << \textcolor{stringliteral}{"Cancel deferred txn egress pause for "} << *\textcolor{keyword}{this};
2283         pendingPause_ = \textcolor{keyword}{false};
2284       \} \textcolor{keywordflow}{else} \{
2285         VLOG(3) << \textcolor{stringliteral}{"Ignoring redundant resume for "} << *\textcolor{keyword}{this};
2286       \}
2287     \} \textcolor{keywordflow}{else} \{
2288       VLOG(3) << \textcolor{stringliteral}{"Resuming txn egress for "} << *\textcolor{keyword}{this};
2289       resumeTransactions();
2290     \}
2291   \}
2292 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!update\+Write\+Count@{update\+Write\+Count}}
\index{update\+Write\+Count@{update\+Write\+Count}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{update\+Write\+Count()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::update\+Write\+Count (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a1c5714d761137dccb8d6e864b00b657f}
Update the size of the unwritten egress data and invoke callbacks if the size has crossed the buffering limit. 

Definition at line 2248 of file H\+T\+T\+P\+Session.\+cpp.



References num\+Active\+Writes\+\_\+, writes\+\_\+, writes\+Paused(), and writes\+Unpaused().



Referenced by is\+Draining(), on\+Write\+Success(), and run\+Loop\+Callback().


\begin{DoxyCode}
2248                               \{
2249   \textcolor{keywordflow}{if} (numActiveWrites_ > 0 && writesUnpaused()) \{
2250     \textcolor{comment}{// Exceeded limit. Pause reading on the incoming stream.}
2251     VLOG(3) << \textcolor{stringliteral}{"Pausing egress for "} << *\textcolor{keyword}{this};
2252     writes_ = SocketState::PAUSED;
2253   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (numActiveWrites_ == 0 && writesPaused()) \{
2254     \textcolor{comment}{// Dropped below limit. Resume reading on the incoming stream if needed.}
2255     VLOG(3) << \textcolor{stringliteral}{"Resuming egress for "} << *\textcolor{keyword}{this};
2256     writes_ = SocketState::UNPAUSED;
2257   \}
2258 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!verify\+Cert\+Auth\+Setting@{verify\+Cert\+Auth\+Setting}}
\index{verify\+Cert\+Auth\+Setting@{verify\+Cert\+Auth\+Setting}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{verify\+Cert\+Auth\+Setting(uint32\+\_\+t value)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::verify\+Cert\+Auth\+Setting (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a183cf22d134789ec0e2c0a75ec301224}


Definition at line 211 of file H\+T\+T\+P\+Session.\+cpp.



References get\+Transport(), and is\+Upstream().



Referenced by get\+Max\+Concurrent\+Outgoing\+Streams\+Remote(), and on\+Settings().


\begin{DoxyCode}
211                                                       \{
212   uint32\_t certAuthSettingVal = 0;
213   constexpr uint16\_t settingLen = 4;
214   std::unique\_ptr<folly::IOBuf> ekm;
215   folly::StringPiece label;
216   \textcolor{keywordflow}{if} (isUpstream()) \{
217     label = kServerLabel;
218   \} \textcolor{keywordflow}{else} \{
219     label = kClientLabel;
220   \}
221   \textcolor{keyword}{auto} fizzBase = getTransport()->getUnderlyingTransport<AsyncFizzBase>();
222   \textcolor{keywordflow}{if} (fizzBase) \{
223     ekm = fizzBase->getEkm(label, \textcolor{keyword}{nullptr}, settingLen);
224   \} \textcolor{keywordflow}{else} \{
225     VLOG(4) << \textcolor{stringliteral}{"Underlying transport does not support secondary "}
226                \textcolor{stringliteral}{"authentication."};
227     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
228   \}
229   \textcolor{keywordflow}{if} (ekm && ekm->computeChainDataLength() == settingLen) \{
230     folly::io::Cursor cursor(ekm.get());
231     uint32\_t ekmVal = cursor.readBE<uint32\_t>();
232     certAuthSettingVal = (ekmVal & 0x3fffffff) | 0x80000000;
233   \} \textcolor{keywordflow}{else} \{
234     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
235   \}
236   \textcolor{keywordflow}{if} (certAuthSettingVal == value) \{
237     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
238   \} \textcolor{keywordflow}{else} \{
239     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
240   \}
241 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!writes\+Paused@{writes\+Paused}}
\index{writes\+Paused@{writes\+Paused}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{writes\+Paused() const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::writes\+Paused (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_aba6d20c0b92566b1a7f562b8f9501040}


Definition at line 644 of file H\+T\+T\+P\+Session.\+h.



References writes\+\_\+.



Referenced by is\+Detachable(), and update\+Write\+Count().


\begin{DoxyCode}
644                             \{
645     \textcolor{keywordflow}{return} writes_ == SocketState::PAUSED;
646   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!writes\+Shutdown@{writes\+Shutdown}}
\index{writes\+Shutdown@{writes\+Shutdown}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{writes\+Shutdown() const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::writes\+Shutdown (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a82766ffaff2fd71996d82c908fb5abeb}


Definition at line 648 of file H\+T\+T\+P\+Session.\+h.



References proxygen\+::\+S\+H\+U\+T\+D\+O\+WN, and writes\+\_\+.



Referenced by check\+For\+Shutdown(), detach(), drop\+Connection(), get\+Next\+To\+Send(), immediate\+Shutdown(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::is\+Closing(), run\+Loop\+Callback(), shutdown\+Transport(), and shutdown\+Transport\+With\+Reset().


\begin{DoxyCode}
648                               \{
649     \textcolor{keywordflow}{return} writes_ == SocketState::SHUTDOWN;
650   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!writes\+Unpaused@{writes\+Unpaused}}
\index{writes\+Unpaused@{writes\+Unpaused}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{writes\+Unpaused() const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::writes\+Unpaused (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_af3022f6742364b83e3f0e2eb009996a3}


Definition at line 640 of file H\+T\+T\+P\+Session.\+h.



References writes\+\_\+.



Referenced by update\+Write\+Count().


\begin{DoxyCode}
640                               \{
641     \textcolor{keywordflow}{return} writes_ == SocketState::UNPAUSED;
642   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!write\+Timeout\+Expired@{write\+Timeout\+Expired}}
\index{write\+Timeout\+Expired@{write\+Timeout\+Expired}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{write\+Timeout\+Expired() noexcept}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Session\+::write\+Timeout\+Expired (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [protected]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPSession_a664004e8860ec5a5f401cda328a0762e}


Definition at line 414 of file H\+T\+T\+P\+Session.\+cpp.



References proxygen\+::k\+Error\+Write\+Timeout, pending\+Writes\+\_\+, proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::set\+Close\+Reason(), shutdown\+Transport\+With\+Reset(), and proxygen\+::\+T\+I\+M\+E\+O\+UT.



Referenced by get\+H\+T\+T\+P\+Priority(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Timeout\+::timeout\+Expired().


\begin{DoxyCode}
414                                           \{
415   VLOG(4) << \textcolor{stringliteral}{"Write timeout for "} << *\textcolor{keyword}{this};
416 
417   CHECK(!pendingWrites_.empty());
418   DestructorGuard g(\textcolor{keyword}{this});
419 
420   setCloseReason(ConnectionCloseReason::TIMEOUT);
421   shutdownTransportWithReset(kErrorWriteTimeout);
422 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!body\+Bytes\+Per\+Write\+Buf\+\_\+@{body\+Bytes\+Per\+Write\+Buf\+\_\+}}
\index{body\+Bytes\+Per\+Write\+Buf\+\_\+@{body\+Bytes\+Per\+Write\+Buf\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{body\+Bytes\+Per\+Write\+Buf\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::body\+Bytes\+Per\+Write\+Buf\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a28cf2cb8599e3a919902015ab672c77a}
Number of body un-\/encoded bytes in the write buffer per write iteration. 

Definition at line 961 of file H\+T\+T\+P\+Session.\+h.



Referenced by run\+Loop\+Callback(), and send\+Body().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!byte\+Event\+Tracker\+\_\+@{byte\+Event\+Tracker\+\_\+}}
\index{byte\+Event\+Tracker\+\_\+@{byte\+Event\+Tracker\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{byte\+Event\+Tracker\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::shared\+\_\+ptr$<${\bf Byte\+Event\+Tracker}$>$ proxygen\+::\+H\+T\+T\+P\+Session\+::byte\+Event\+Tracker\+\_\+ \{{\bf nullptr}\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a3cbbe5f3b63dec5fc66d34b96fde70db}


Definition at line 968 of file H\+T\+T\+P\+Session.\+h.



Referenced by common\+Eom(), get\+Byte\+Event\+Tracker(), get\+Next\+To\+Send(), on\+Last\+Byte\+Event(), on\+Message\+Begin(), on\+Ping\+Request(), on\+Write\+Success(), send\+Body(), send\+Headers(), set\+Byte\+Event\+Tracker(), set\+Session\+Stats(), shutdown\+Transport(), shutdown\+Transport\+With\+Reset(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!bytes\+Scheduled\+\_\+@{bytes\+Scheduled\+\_\+}}
\index{bytes\+Scheduled\+\_\+@{bytes\+Scheduled\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{bytes\+Scheduled\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::bytes\+Scheduled\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a07c84a0d9fdce8ead342f0058e8233be}
Number of bytes scheduled so far. 

Definition at line 950 of file H\+T\+T\+P\+Session.\+h.



Referenced by on\+Ping\+Request(), run\+Loop\+Callback(), and session\+Byte\+Offset().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!bytes\+Written\+\_\+@{bytes\+Written\+\_\+}}
\index{bytes\+Written\+\_\+@{bytes\+Written\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{bytes\+Written\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::bytes\+Written\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a08ca602333f5e1f4a17bb00918bce3f7}
Number of bytes written so far. 

Definition at line 945 of file H\+T\+T\+P\+Session.\+h.



Referenced by get\+Next\+To\+Send(), and on\+Write\+Success().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!conn\+Flow\+Control\+\_\+@{conn\+Flow\+Control\+\_\+}}
\index{conn\+Flow\+Control\+\_\+@{conn\+Flow\+Control\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{conn\+Flow\+Control\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Flow\+Control\+Filter}$\ast$ proxygen\+::\+H\+T\+T\+P\+Session\+::conn\+Flow\+Control\+\_\+ \{{\bf nullptr}\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a9c2b389afc4e09cf0bfdeac210ff195c}
Connection level flow control for S\+P\+DY $>$= 3.\+1 and H\+T\+T\+P/2 

Definition at line 915 of file H\+T\+T\+P\+Session.\+h.



Referenced by get\+Next\+To\+Send(), is\+Conn\+Window\+Full(), notify\+Ingress\+Body\+Processed(), on\+Body(), on\+Native\+Protocol\+Upgrade\+Impl(), run\+Loop\+Callback(), setup\+Codec(), and start\+Now().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!draining\+\_\+@{draining\+\_\+}}
\index{draining\+\_\+@{draining\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{draining\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::draining\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a05846ac95dc0538cada7dfd6543e5e3b}
Indicates if the session is waiting for existing transactions to close. Once all transactions close, the session will be deleted. 

Definition at line 713 of file H\+T\+T\+P\+Session.\+h.



Referenced by drain(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::is\+Closing(), is\+Draining(), new\+Ex\+Transaction(), new\+Pushed\+Transaction(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::new\+Transaction(), should\+Shutdown(), start\+Now(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!drain\+Timeout\+\_\+@{drain\+Timeout\+\_\+}}
\index{drain\+Timeout\+\_\+@{drain\+Timeout\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{drain\+Timeout\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Drain\+Timeout} proxygen\+::\+H\+T\+T\+P\+Session\+::drain\+Timeout\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a2d1984c14bd93f65bcf31ec1c2dc9f70}


Definition at line 1035 of file H\+T\+T\+P\+Session.\+h.



Referenced by is\+Detachable(), read\+Timeout\+Expired(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!egress\+Bytes\+Limit\+\_\+@{egress\+Bytes\+Limit\+\_\+}}
\index{egress\+Bytes\+Limit\+\_\+@{egress\+Bytes\+Limit\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{egress\+Bytes\+Limit\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::egress\+Bytes\+Limit\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_af101f4605f3474ccc175e3f42c5f5c81}
Max number of bytes to egress per session 

Definition at line 973 of file H\+T\+T\+P\+Session.\+h.



Referenced by on\+Write\+Success(), and set\+Egress\+Bytes\+Limit().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!flow\+Control\+Timeout\+\_\+@{flow\+Control\+Timeout\+\_\+}}
\index{flow\+Control\+Timeout\+\_\+@{flow\+Control\+Timeout\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{flow\+Control\+Timeout\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Flow\+Control\+Timeout} proxygen\+::\+H\+T\+T\+P\+Session\+::flow\+Control\+Timeout\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a9aaa7a89fa2b7ee4ab992ce8fa8c2733}


Definition at line 1022 of file H\+T\+T\+P\+Session.\+h.



Referenced by is\+Detachable(), on\+Connection\+Send\+Window\+Closed(), on\+Connection\+Send\+Window\+Open(), shutdown\+Transport(), proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err(), and $\sim$\+H\+T\+T\+P\+Session().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!incoming\+Streams\+\_\+@{incoming\+Streams\+\_\+}}
\index{incoming\+Streams\+\_\+@{incoming\+Streams\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{incoming\+Streams\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::incoming\+Streams\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a64491ffbd72ca47924907cf4c51aa750}
The number of concurrent transactions initiated by this sessions\textquotesingle{}s peer 

Definition at line 940 of file H\+T\+T\+P\+Session.\+h.



Referenced by create\+Transaction(), decrement\+Transaction\+Count(), get\+Num\+Incoming\+Streams(), get\+Pipeline\+Stream\+Count(), and num\+Incoming\+Streams().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!ingress\+Error\+\_\+@{ingress\+Error\+\_\+}}
\index{ingress\+Error\+\_\+@{ingress\+Error\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{ingress\+Error\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::ingress\+Error\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_af9b8fc565cfb8e86162b22921995e08b}


Definition at line 719 of file H\+T\+T\+P\+Session.\+h.



Referenced by proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::is\+Reusable(), on\+Error(), process\+Read\+Data(), transaction\+Timeout(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!ingress\+Upgraded\+\_\+@{ingress\+Upgraded\+\_\+}}
\index{ingress\+Upgraded\+\_\+@{ingress\+Upgraded\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{ingress\+Upgraded\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::ingress\+Upgraded\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_ac83695509c095c66650708aaecd21400}
Indicates whether an upgrade request has been received from the codec. 

Definition at line 1049 of file H\+T\+T\+P\+Session.\+h.



Referenced by on\+Message\+Complete(), proxygen\+::\+H\+T\+T\+P\+Session\+::\+Shutdown\+Transport\+Callback\+::run\+Loop\+Callback(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!initial\+Receive\+Window\+\_\+@{initial\+Receive\+Window\+\_\+}}
\index{initial\+Receive\+Window\+\_\+@{initial\+Receive\+Window\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{initial\+Receive\+Window\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::initial\+Receive\+Window\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a413ea44bdc24970646f7de55683f2cd7}


Definition at line 976 of file H\+T\+T\+P\+Session.\+h.



Referenced by create\+Transaction(), on\+Native\+Protocol\+Upgrade\+Impl(), set\+Flow\+Control(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!in\+Loop\+Callback\+\_\+@{in\+Loop\+Callback\+\_\+}}
\index{in\+Loop\+Callback\+\_\+@{in\+Loop\+Callback\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{in\+Loop\+Callback\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::in\+Loop\+Callback\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a0d6ad6ab9f62dbe8bf1afac20d86b1b2}


Definition at line 1052 of file H\+T\+T\+P\+Session.\+h.



Referenced by on\+Write\+Success(), run\+Loop\+Callback(), send\+Body(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!in\+Resume\+\_\+@{in\+Resume\+\_\+}}
\index{in\+Resume\+\_\+@{in\+Resume\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{in\+Resume\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::in\+Resume\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a3d74976679fc043aa6a344795f303244}


Definition at line 1053 of file H\+T\+T\+P\+Session.\+h.



Referenced by resume\+Transactions(), update\+Write\+Buf\+Size(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!live\+Transactions\+\_\+@{live\+Transactions\+\_\+}}
\index{live\+Transactions\+\_\+@{live\+Transactions\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{live\+Transactions\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::live\+Transactions\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a47f5ec6835388f0c485cf435bc972c81}
Count of transactions awaiting input 

Definition at line 697 of file H\+T\+T\+P\+Session.\+h.



Referenced by create\+Transaction(), detach(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::is\+Reusable(), on\+Message\+Begin(), pause\+Ingress(), read\+Timeout\+Expired(), and resume\+Ingress().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!max\+Concurrent\+Incoming\+Streams\+\_\+@{max\+Concurrent\+Incoming\+Streams\+\_\+}}
\index{max\+Concurrent\+Incoming\+Streams\+\_\+@{max\+Concurrent\+Incoming\+Streams\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{max\+Concurrent\+Incoming\+Streams\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::max\+Concurrent\+Incoming\+Streams\+\_\+ \{100\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a1b45a7c1cdf90d9d8e7425055d7ab24c}
The maximum number of concurrent transactions that this session\textquotesingle{}s peer may create. 

Definition at line 930 of file H\+T\+T\+P\+Session.\+h.



Referenced by on\+Native\+Protocol\+Upgrade\+Impl(), set\+Max\+Concurrent\+Incoming\+Streams(), setup\+Codec(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!max\+Concurrent\+Outgoing\+Streams\+Remote\+\_\+@{max\+Concurrent\+Outgoing\+Streams\+Remote\+\_\+}}
\index{max\+Concurrent\+Outgoing\+Streams\+Remote\+\_\+@{max\+Concurrent\+Outgoing\+Streams\+Remote\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{max\+Concurrent\+Outgoing\+Streams\+Remote\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::max\+Concurrent\+Outgoing\+Streams\+Remote\+\_\+ \{100000\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_ad5433004842e58bc21e71d0219bd2153}
The received setting for the maximum number of concurrent transactions that this session may create. We may assume the remote allows unlimited transactions until we get a S\+E\+T\+T\+I\+N\+GS frame, but to be reasonable, assume the remote doesn\textquotesingle{}t allow more than 100K concurrent transactions on one connection. 

Definition at line 924 of file H\+T\+T\+P\+Session.\+h.



Referenced by get\+Max\+Concurrent\+Outgoing\+Streams\+Remote(), new\+Ex\+Transaction(), new\+Pushed\+Transaction(), on\+Native\+Protocol\+Upgrade\+Impl(), on\+Set\+Max\+Initiated\+Streams(), and setup\+Codec().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!next\+Egress\+Results\+\_\+@{next\+Egress\+Results\+\_\+}}
\index{next\+Egress\+Results\+\_\+@{next\+Egress\+Results\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{next\+Egress\+Results\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P2\+Priority\+Queue\+::\+Next\+Egress\+Result} proxygen\+::\+H\+T\+T\+P\+Session\+::next\+Egress\+Results\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a2f9532f2d59face8b9b10294f617f2a6}
Container to hold the results of \doxyref{H\+T\+T\+P2\+Priority\+Queue\+::next\+Egress}{p.}{classproxygen_1_1HTTP2PriorityQueue_ae7a98e71ef297cccaa40e64ded686951} 

Definition at line 966 of file H\+T\+T\+P\+Session.\+h.



Referenced by get\+Next\+To\+Send(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!num\+Active\+Writes\+\_\+@{num\+Active\+Writes\+\_\+}}
\index{num\+Active\+Writes\+\_\+@{num\+Active\+Writes\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{num\+Active\+Writes\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}unsigned proxygen\+::\+H\+T\+T\+P\+Session\+::num\+Active\+Writes\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a4f46b55ba092df2d05b86aa7fb3c434c}
Number of writes submitted to the transport for which we haven\textquotesingle{}t yet received completion or failure callbacks. 

Definition at line 707 of file H\+T\+T\+P\+Session.\+h.



Referenced by get\+Next\+To\+Send(), has\+More\+Writes(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::is\+Reusable(), on\+Write\+Completed(), on\+Write\+Success(), run\+Loop\+Callback(), set\+New\+Transaction\+Pause\+State(), shutdown\+Transport\+With\+Reset(), and update\+Write\+Count().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!outgoing\+Streams\+\_\+@{outgoing\+Streams\+\_\+}}
\index{outgoing\+Streams\+\_\+@{outgoing\+Streams\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{outgoing\+Streams\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::outgoing\+Streams\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a6eb0d2db14d16430ef88861c902b8d85}
The number concurrent transactions initiated by this session 

Definition at line 935 of file H\+T\+T\+P\+Session.\+h.



Referenced by decrement\+Transaction\+Count(), get\+Num\+Outgoing\+Streams(), increment\+Outgoing\+Streams(), new\+Ex\+Transaction(), new\+Pushed\+Transaction(), and num\+Outgoing\+Streams().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!pending\+Pause\+\_\+@{pending\+Pause\+\_\+}}
\index{pending\+Pause\+\_\+@{pending\+Pause\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{pending\+Pause\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::pending\+Pause\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a4b66b11da8b330ef5b8697c649b60489}


Definition at line 1054 of file H\+T\+T\+P\+Session.\+h.



Referenced by resume\+Transactions(), update\+Write\+Buf\+Size(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!pending\+Writes\+\_\+@{pending\+Writes\+\_\+}}
\index{pending\+Writes\+\_\+@{pending\+Writes\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{pending\+Writes\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Write\+Segment\+List} proxygen\+::\+H\+T\+T\+P\+Session\+::pending\+Writes\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a7a243fae036a60d472f8e4a5264e6a05}


Definition at line 910 of file H\+T\+T\+P\+Session.\+h.



Referenced by has\+More\+Writes(), on\+Write\+Completed(), on\+Write\+Success(), run\+Loop\+Callback(), shutdown\+Transport\+With\+Reset(), and write\+Timeout\+Expired().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!pending\+Write\+Size\+Delta\+\_\+@{pending\+Write\+Size\+Delta\+\_\+}}
\index{pending\+Write\+Size\+Delta\+\_\+@{pending\+Write\+Size\+Delta\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{pending\+Write\+Size\+Delta\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}int64\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::pending\+Write\+Size\+Delta\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_aca40d2fb247e55369cef0e1a94c4e91a}
The net change this event loop in the amount of buffered bytes for all this session\textquotesingle{}s txns and socket write buffer. 

Definition at line 956 of file H\+T\+T\+P\+Session.\+h.



Referenced by notify\+Egress\+Body\+Buffered(), run\+Loop\+Callback(), send\+Body(), and update\+Write\+Buf\+Size().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!read\+Buf\+\_\+@{read\+Buf\+\_\+}}
\index{read\+Buf\+\_\+@{read\+Buf\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{read\+Buf\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+I\+O\+Buf\+Queue proxygen\+::\+H\+T\+T\+P\+Session\+::read\+Buf\+\_\+ \{folly\+::\+I\+O\+Buf\+Queue\+::cache\+Chain\+Length()\}\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a7b5d0529cb70ae5090632b85f2684fd0}
Chain of ingress I\+O\+Bufs 

Definition at line 689 of file H\+T\+T\+P\+Session.\+h.



Referenced by get\+Read\+Buffer(), process\+Read\+Data(), read\+Buffer\+Available(), read\+Data\+Available(), and read\+E\+O\+F().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!reads\+\_\+@{reads\+\_\+}}
\index{reads\+\_\+@{reads\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{reads\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Socket\+State} proxygen\+::\+H\+T\+T\+P\+Session\+::reads\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a378187e6c569630532de4ba485bebcee}


Definition at line 1043 of file H\+T\+T\+P\+Session.\+h.



Referenced by check\+For\+Shutdown(), pause\+Reads\+Impl(), reads\+Paused(), reads\+Shutdown(), reads\+Unpaused(), resume\+Reads\+Impl(), shutdown\+Transport(), shutdown\+Transport\+With\+Reset(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!receive\+Session\+Window\+Size\+\_\+@{receive\+Session\+Window\+Size\+\_\+}}
\index{receive\+Session\+Window\+Size\+\_\+@{receive\+Session\+Window\+Size\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{receive\+Session\+Window\+Size\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::receive\+Session\+Window\+Size\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_aa73dd8103a1fb5e6872fc5be1c68074b}


Definition at line 978 of file H\+T\+T\+P\+Session.\+h.



Referenced by on\+Native\+Protocol\+Upgrade\+Impl(), set\+Flow\+Control(), start\+Now(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!receive\+Stream\+Window\+Size\+\_\+@{receive\+Stream\+Window\+Size\+\_\+}}
\index{receive\+Stream\+Window\+Size\+\_\+@{receive\+Stream\+Window\+Size\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{receive\+Stream\+Window\+Size\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P\+Session\+::receive\+Stream\+Window\+Size\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_abc226c0df6041bba580806abb129fb04}


Definition at line 977 of file H\+T\+T\+P\+Session.\+h.



Referenced by create\+Transaction(), on\+Native\+Protocol\+Upgrade\+Impl(), set\+Flow\+Control(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!reset\+After\+Draining\+Writes\+\_\+@{reset\+After\+Draining\+Writes\+\_\+}}
\index{reset\+After\+Draining\+Writes\+\_\+@{reset\+After\+Draining\+Writes\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{reset\+After\+Draining\+Writes\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::reset\+After\+Draining\+Writes\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_aec31815c425ec8ab1aa94988eb9e79a5}


Definition at line 718 of file H\+T\+T\+P\+Session.\+h.



Referenced by proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::is\+Closing(), on\+Egress\+Message\+Finished(), shutdown\+Transport(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!reset\+Socket\+On\+Shutdown\+\_\+@{reset\+Socket\+On\+Shutdown\+\_\+}}
\index{reset\+Socket\+On\+Shutdown\+\_\+@{reset\+Socket\+On\+Shutdown\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{reset\+Socket\+On\+Shutdown\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::reset\+Socket\+On\+Shutdown\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a94168a3dc69f32035b1f0bcf97897793}


Definition at line 1050 of file H\+T\+T\+P\+Session.\+h.



Referenced by check\+For\+Shutdown(), shutdown\+Transport(), shutdown\+Transport\+With\+Reset(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!second\+Auth\+Manager\+\_\+@{second\+Auth\+Manager\+\_\+}}
\index{second\+Auth\+Manager\+\_\+@{second\+Auth\+Manager\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{second\+Auth\+Manager\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<${\bf Secondary\+Auth\+Manager}$>$ proxygen\+::\+H\+T\+T\+P\+Session\+::second\+Auth\+Manager\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a2f1fa1f46d328890e336be404fa4ce47}


Definition at line 1057 of file H\+T\+T\+P\+Session.\+h.



Referenced by get\+Second\+Auth\+Manager(), on\+Certificate(), on\+Certificate\+Request(), send\+Certificate\+Request(), set\+Second\+Auth\+Manager(), and setup\+Codec().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!shutdown\+Transport\+Cb\+\_\+@{shutdown\+Transport\+Cb\+\_\+}}
\index{shutdown\+Transport\+Cb\+\_\+@{shutdown\+Transport\+Cb\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{shutdown\+Transport\+Cb\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<${\bf Shutdown\+Transport\+Callback}$>$ proxygen\+::\+H\+T\+T\+P\+Session\+::shutdown\+Transport\+Cb\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_ae8b034c072c3eebdfea9a3718a5edb8f}


Definition at line 1000 of file H\+T\+T\+P\+Session.\+h.



Referenced by cancel\+Loop\+Callbacks(), immediate\+Shutdown(), on\+Egress\+Message\+Finished(), and reschedule\+Loop\+Callbacks().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!sock\+\_\+@{sock\+\_\+}}
\index{sock\+\_\+@{sock\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{sock\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+Async\+Transport\+Wrapper\+::\+Unique\+Ptr proxygen\+::\+H\+T\+T\+P\+Session\+::sock\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a6f4805ceb03264def58181d9b628de92}


Definition at line 699 of file H\+T\+T\+P\+Session.\+h.



Referenced by proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::attach\+Thread\+Locals(), check\+For\+Shutdown(), create\+Transaction(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::detach\+Thread\+Locals(), drop\+Connection(), get\+Current\+Transport\+Info\+Without\+Update(), get\+Event\+Base(), get\+Security\+Protocol(), get\+Transport(), get\+Underlying\+Transport(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::\+H\+T\+T\+P\+Upstream\+Session(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::is\+Closing(), is\+Detachable(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::is\+Replay\+Safe(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::is\+Reusable(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::maybe\+Attach\+S\+S\+L\+Context(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::maybe\+Detach\+S\+S\+L\+Context(), notify\+Egress\+Body\+Buffered(), on\+Egress\+Message\+Finished(), on\+Last\+Byte\+Event(), on\+Native\+Protocol\+Upgrade\+Impl(), on\+Replay\+Safe(), pause\+Reads\+Impl(), reschedule\+Loop\+Callbacks(), resume\+Reads\+Impl(), run\+Loop\+Callback(), schedule\+Write(), shutdown\+Transport(), shutdown\+Transport\+With\+Reset(), proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err(), and $\sim$\+H\+T\+T\+P\+Session().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!started\+\_\+@{started\+\_\+}}
\index{started\+\_\+@{started\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{started\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::started\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a468c2c8d059e0c0dc23bc854bfc20c09}


Definition at line 715 of file H\+T\+T\+P\+Session.\+h.



Referenced by drain\+Impl(), new\+Ex\+Transaction(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::new\+Transaction(), send\+Headers(), set\+Egress\+Bytes\+Limit(), set\+Egress\+Settings(), set\+Flow\+Control(), set\+Max\+Concurrent\+Incoming\+Streams(), start\+Now(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!timeout\+\_\+@{timeout\+\_\+}}
\index{timeout\+\_\+@{timeout\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{timeout\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Wheel\+Timer\+Instance} proxygen\+::\+H\+T\+T\+P\+Session\+::timeout\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a19770f973e94f1a2ced58dcd064040ed}


Definition at line 701 of file H\+T\+T\+P\+Session.\+h.



Referenced by proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::attach\+Thread\+Locals(), create\+Transaction(), on\+Connection\+Send\+Window\+Closed(), on\+Write\+Success(), read\+Timeout\+Expired(), run\+Loop\+Callback(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!transactions\+\_\+@{transactions\+\_\+}}
\index{transactions\+\_\+@{transactions\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{transactions\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::map$<${\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}, {\bf H\+T\+T\+P\+Transaction}$>$ proxygen\+::\+H\+T\+T\+P\+Session\+::transactions\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a67c0735026efb30fefac325da7362a7b}


Definition at line 694 of file H\+T\+T\+P\+Session.\+h.



Referenced by proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::all\+Transactions\+Started(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::all\+Transactions\+Started(), check\+For\+Shutdown(), create\+Transaction(), detach(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::detach\+Thread\+Locals(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::detach\+Transactions(), drain(), drop\+Connection(), error\+On\+All\+Transactions(), find\+Transaction(), has\+Active\+Transactions(), immediate\+Shutdown(), invoke\+On\+All\+Transactions(), is\+Busy(), is\+Detachable(), maybe\+Resume\+Paused\+Pipelined\+Transaction(), on\+Delete\+Ack\+Event(), on\+Egress\+Message\+Finished(), on\+Error(), on\+Goaway(), on\+Message\+Begin(), on\+Write\+Success(), read\+E\+O\+F(), read\+Err(), read\+Timeout\+Expired(), resume\+Transactions(), shutdown\+Transport(), and $\sim$\+H\+T\+T\+P\+Session().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!txn\+Egress\+Queue\+\_\+@{txn\+Egress\+Queue\+\_\+}}
\index{txn\+Egress\+Queue\+\_\+@{txn\+Egress\+Queue\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{txn\+Egress\+Queue\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P2\+Priority\+Queue} proxygen\+::\+H\+T\+T\+P\+Session\+::txn\+Egress\+Queue\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a23a9806ebce88b25cdb0410e06902f9e}
Priority tree of transactions 

Definition at line 692 of file H\+T\+T\+P\+Session.\+h.



Referenced by proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::attach\+Thread\+Locals(), create\+Transaction(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::detach\+Thread\+Locals(), get\+Next\+To\+Send(), has\+More\+Writes(), on\+Connection\+Send\+Window\+Closed(), proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::on\+Native\+Protocol\+Upgrade(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::on\+Native\+Protocol\+Upgrade(), on\+Priority(), resume\+Transactions(), run\+Loop\+Callback(), schedule\+Write(), send\+Priority(), proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::start\+Now(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::start\+Now(), proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err(), and $\sim$\+H\+T\+T\+P\+Session().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!waiting\+For\+Replay\+Safety\+\_\+@{waiting\+For\+Replay\+Safety\+\_\+}}
\index{waiting\+For\+Replay\+Safety\+\_\+@{waiting\+For\+Replay\+Safety\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{waiting\+For\+Replay\+Safety\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::list$<$Replay\+Safety\+Callback$\ast$$>$ proxygen\+::\+H\+T\+T\+P\+Session\+::waiting\+For\+Replay\+Safety\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_ae0f18679ebd4860a833b6195b5a743e6}


Definition at line 848 of file H\+T\+T\+P\+Session.\+h.



Referenced by add\+Waiting\+For\+Replay\+Safety(), need\+To\+Block\+For\+Replay\+Safety(), on\+Replay\+Safe(), and remove\+Waiting\+For\+Replay\+Safety().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!write\+Buf\+\_\+@{write\+Buf\+\_\+}}
\index{write\+Buf\+\_\+@{write\+Buf\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{write\+Buf\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+I\+O\+Buf\+Queue proxygen\+::\+H\+T\+T\+P\+Session\+::write\+Buf\+\_\+ \{folly\+::\+I\+O\+Buf\+Queue\+::cache\+Chain\+Length()\}\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_ad6a139c1478a5d1e3b811b02dfed236d}
Queue of egress I\+O\+Bufs 

Definition at line 686 of file H\+T\+T\+P\+Session.\+h.



Referenced by close\+When\+Idle(), drain\+Impl(), get\+Next\+To\+Send(), has\+More\+Writes(), notify\+Ingress\+Body\+Processed(), on\+Body(), on\+Certificate\+Request(), proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::on\+Native\+Protocol\+Upgrade(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::on\+Native\+Protocol\+Upgrade(), on\+Native\+Protocol\+Upgrade\+Impl(), on\+New\+Transaction\+Parse\+Error(), on\+Ping\+Request(), on\+Session\+Parse\+Error(), on\+Settings(), schedule\+Write(), send\+Abort(), send\+Body(), send\+Certificate\+Request(), send\+Chunk\+Header(), send\+Chunk\+Terminator(), send\+E\+O\+M(), send\+Headers(), send\+Ping(), send\+Priority\+Impl(), send\+Settings(), send\+Window\+Update(), session\+Byte\+Offset(), setup\+Codec(), shutdown\+Transport(), shutdown\+Transport\+With\+Reset(), proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::start\+Now(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::start\+Now(), and start\+Now().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!writes\+\_\+@{writes\+\_\+}}
\index{writes\+\_\+@{writes\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{writes\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Socket\+State} proxygen\+::\+H\+T\+T\+P\+Session\+::writes\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPSession_a0350e37d74db0188183efccedee6eba7}


Definition at line 1044 of file H\+T\+T\+P\+Session.\+h.



Referenced by shutdown\+Transport(), shutdown\+Transport\+With\+Reset(), update\+Write\+Count(), proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err(), writes\+Paused(), writes\+Shutdown(), and writes\+Unpaused().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!writes\+Draining\+\_\+@{writes\+Draining\+\_\+}}
\index{writes\+Draining\+\_\+@{writes\+Draining\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{writes\+Draining\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Session\+::writes\+Draining\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_a2161afe8ad9e128e3f1640ef4e4cc234}


Definition at line 717 of file H\+T\+T\+P\+Session.\+h.



Referenced by detach(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::is\+Closing(), on\+Write\+Completed(), shutdown\+Transport(), and proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err().

\index{proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}!write\+Timeout\+\_\+@{write\+Timeout\+\_\+}}
\index{write\+Timeout\+\_\+@{write\+Timeout\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Session@{proxygen\+::\+H\+T\+T\+P\+Session}}
\subsubsection[{write\+Timeout\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Write\+Timeout} proxygen\+::\+H\+T\+T\+P\+Session\+::write\+Timeout\+\_\+\hspace{0.3cm}{\ttfamily [protected]}}\label{classproxygen_1_1HTTPSession_ac1b99af891c8036812baaeb567d5e042}


Definition at line 683 of file H\+T\+T\+P\+Session.\+h.



Referenced by is\+Detachable(), proxygen\+::\+H\+T\+T\+P\+Upstream\+Session\+::is\+Reusable(), on\+Write\+Success(), run\+Loop\+Callback(), shutdown\+Transport\+With\+Reset(), proxygen\+::\+H\+T\+T\+P\+Session\+::\+Write\+Segment\+::write\+Err(), and $\sim$\+H\+T\+T\+P\+Session().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
proxygen/lib/http/session/{\bf H\+T\+T\+P\+Session.\+h}\item 
proxygen/lib/http/session/{\bf H\+T\+T\+P\+Session.\+cpp}\end{DoxyCompactItemize}
