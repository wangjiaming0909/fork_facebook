\section{proxygen\+:\+:R\+F\+C1867\+Codec Class Reference}
\label{classproxygen_1_1RFC1867Codec}\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}


{\ttfamily \#include $<$R\+F\+C1867.\+h$>$}

Inheritance diagram for proxygen\+:\+:R\+F\+C1867\+Codec\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classproxygen_1_1RFC1867Codec}
\end{center}
\end{figure}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class {\bf Callback}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf R\+F\+C1867\+Codec} (const std\+::string \&boundary)
\item 
void {\bf set\+Callback} ({\bf Callback} $\ast$callback)
\item 
std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ {\bf on\+Ingress} (std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ data)
\item 
void {\bf on\+Ingress\+E\+OM} ()
\item 
uint64\+\_\+t {\bf get\+Bytes\+Processed} () const 
\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
enum {\bf Parser\+State} \{ \\*
{\bf Parser\+State\+::\+S\+T\+A\+RT}, 
{\bf Parser\+State\+::\+H\+E\+A\+D\+E\+R\+S\+\_\+\+S\+T\+A\+RT}, 
{\bf Parser\+State\+::\+H\+E\+A\+D\+E\+RS}, 
{\bf Parser\+State\+::\+F\+I\+E\+L\+D\+\_\+\+D\+A\+TA}, 
\\*
{\bf Parser\+State\+::\+D\+O\+NE}, 
{\bf Parser\+State\+::\+E\+R\+R\+OR}
 \}
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void {\bf on\+Message\+Begin} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}, {\bf H\+T\+T\+P\+Message} $\ast$) override
\item 
void {\bf on\+Headers\+Complete} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} {\bf stream}, std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Message} $>$ msg) override
\item 
void {\bf on\+Body} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$, uint16\+\_\+t) override
\item 
void {\bf on\+Trailers\+Complete} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}, std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Headers} $>$) override
\item 
void {\bf on\+Message\+Complete} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}, bool) override
\item 
void {\bf on\+Error} ({\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}, const {\bf H\+T\+T\+P\+Exception} \&, bool) override
\item 
folly\+::\+I\+O\+Buf\+Queue {\bf read\+To\+Boundary} (bool \&found\+Boundary)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::string {\bf boundary\+\_\+}
\item 
{\bf Callback} $\ast$ {\bf callback\+\_\+} \{{\bf nullptr}\}
\item 
{\bf Parser\+State} {\bf state\+\_\+} \{{\bf Parser\+State\+::\+S\+T\+A\+RT}\}
\item 
{\bf H\+T\+T\+P1x\+Codec} {\bf header\+Parser\+\_\+} \{{\bf Transport\+Direction\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM}\}
\item 
std\+::string {\bf field\+\_\+}
\item 
folly\+::\+I\+O\+Buf\+Queue {\bf input\+\_\+} \{folly\+::\+I\+O\+Buf\+Queue\+::cache\+Chain\+Length()\}
\item 
folly\+::\+I\+O\+Buf\+Queue {\bf value\+\_\+}
\item 
std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ {\bf pending\+C\+R\+\_\+}
\item 
uint64\+\_\+t {\bf bytes\+Processed\+\_\+} \{0\}
\item 
bool {\bf parse\+Error\+\_\+} \{false\}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
Class for stream-\/parsing R\+FC 1867 style post data. At present it does not support nested multi-\/part content (multipart/mixed). Can parse multiple P\+O\+ST bodies unless one of them invokes the \doxyref{on\+Error()}{p.}{classproxygen_1_1RFC1867Codec_a072b62abe677260b50cf8b2b5b93f9c2} callback. After that, the codec is no longer usable. 

Definition at line 24 of file R\+F\+C1867.\+h.



\subsection{Member Enumeration Documentation}
\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!Parser\+State@{Parser\+State}}
\index{Parser\+State@{Parser\+State}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}
\subsubsection[{Parser\+State}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+R\+F\+C1867\+Codec\+::\+Parser\+State}\hspace{0.3cm}{\ttfamily [strong]}, {\ttfamily [private]}}\label{classproxygen_1_1RFC1867Codec_a487763d1a7aec33037bcb17f88aabf87}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{S\+T\+A\+RT@{S\+T\+A\+RT}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!S\+T\+A\+RT@{S\+T\+A\+RT}}\item[{\em 
S\+T\+A\+RT\label{classproxygen_1_1RFC1867Codec_a487763d1a7aec33037bcb17f88aabf87ab078ffd28db767c502ac367053f6e0ac}
}]\index{H\+E\+A\+D\+E\+R\+S\+\_\+\+S\+T\+A\+RT@{H\+E\+A\+D\+E\+R\+S\+\_\+\+S\+T\+A\+RT}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!H\+E\+A\+D\+E\+R\+S\+\_\+\+S\+T\+A\+RT@{H\+E\+A\+D\+E\+R\+S\+\_\+\+S\+T\+A\+RT}}\item[{\em 
H\+E\+A\+D\+E\+R\+S\+\_\+\+S\+T\+A\+RT\label{classproxygen_1_1RFC1867Codec_a487763d1a7aec33037bcb17f88aabf87a2e1eece8b8087988e868ded00d626fdb}
}]\index{H\+E\+A\+D\+E\+RS@{H\+E\+A\+D\+E\+RS}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!H\+E\+A\+D\+E\+RS@{H\+E\+A\+D\+E\+RS}}\item[{\em 
H\+E\+A\+D\+E\+RS\label{classproxygen_1_1RFC1867Codec_a487763d1a7aec33037bcb17f88aabf87a1242249ca7c09fa7634e292cf2819f85}
}]\index{F\+I\+E\+L\+D\+\_\+\+D\+A\+TA@{F\+I\+E\+L\+D\+\_\+\+D\+A\+TA}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!F\+I\+E\+L\+D\+\_\+\+D\+A\+TA@{F\+I\+E\+L\+D\+\_\+\+D\+A\+TA}}\item[{\em 
F\+I\+E\+L\+D\+\_\+\+D\+A\+TA\label{classproxygen_1_1RFC1867Codec_a487763d1a7aec33037bcb17f88aabf87a3d1c73d760327171efe9c9f77f5f55f4}
}]\index{D\+O\+NE@{D\+O\+NE}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!D\+O\+NE@{D\+O\+NE}}\item[{\em 
D\+O\+NE\label{classproxygen_1_1RFC1867Codec_a487763d1a7aec33037bcb17f88aabf87a2ba22e58ca17bb728d522bba36cf8350}
}]\index{E\+R\+R\+OR@{E\+R\+R\+OR}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!E\+R\+R\+OR@{E\+R\+R\+OR}}\item[{\em 
E\+R\+R\+OR\label{classproxygen_1_1RFC1867Codec_a487763d1a7aec33037bcb17f88aabf87abb1ca97ec761fc37101737ba0aa2e7c5}
}]\end{description}
\end{Desc}


Definition at line 71 of file R\+F\+C1867.\+h.


\begin{DoxyCode}
71                          \{
72     START,
73     HEADERS\_START,
74     HEADERS,
75     FIELD\_DATA,  \textcolor{comment}{// part, or field, not only file}
76     DONE,
77     ERROR
78   \};
\end{DoxyCode}


\subsection{Constructor \& Destructor Documentation}
\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!R\+F\+C1867\+Codec@{R\+F\+C1867\+Codec}}
\index{R\+F\+C1867\+Codec@{R\+F\+C1867\+Codec}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}
\subsubsection[{R\+F\+C1867\+Codec(const std\+::string \&boundary)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+R\+F\+C1867\+Codec\+::\+R\+F\+C1867\+Codec (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{boundary}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}\label{classproxygen_1_1RFC1867Codec_a86191baca7540a39f7b2a6e6e5b1c733}


Definition at line 48 of file R\+F\+C1867.\+h.



References boundary\+\_\+, header\+Parser\+\_\+, and proxygen\+::\+H\+T\+T\+P1x\+Codec\+::set\+Callback().


\begin{DoxyCode}
48                                                    \{
49     CHECK(!boundary.empty());
50     boundary_ = folly::to<std::string>(\textcolor{stringliteral}{"\(\backslash\)n--"}, boundary);
51     headerParser_.setCallback(\textcolor{keyword}{this});
52   \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!get\+Bytes\+Processed@{get\+Bytes\+Processed}}
\index{get\+Bytes\+Processed@{get\+Bytes\+Processed}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}
\subsubsection[{get\+Bytes\+Processed() const }]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t proxygen\+::\+R\+F\+C1867\+Codec\+::get\+Bytes\+Processed (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1RFC1867Codec_a52ed029d97cd7d8066ea90c9af26824c}


Definition at line 66 of file R\+F\+C1867.\+h.



References bytes\+Processed\+\_\+.


\begin{DoxyCode}
66                                      \{
67     \textcolor{keywordflow}{return} bytesProcessed_;
68   \}
\end{DoxyCode}
\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!on\+Body@{on\+Body}}
\index{on\+Body@{on\+Body}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}
\subsubsection[{on\+Body(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$, uint16\+\_\+t) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+R\+F\+C1867\+Codec\+::on\+Body (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{stream, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{chain, }
\item[{uint16\+\_\+t}]{padding}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}\label{classproxygen_1_1RFC1867Codec_a4a6f31403b32e593888d89274023614a}
Called for each block of message body data 
\begin{DoxyParams}{Parameters}
{\em stream} & The stream ID \\
\hline
{\em chain} & One or more buffers of body data. The codec will remove any protocol framing, such as H\+T\+T\+P/1.\+1 chunk headers, from the buffers before calling this function. \\
\hline
{\em padding} & Number of pad bytes that came with the data segment \\
\hline
\end{DoxyParams}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_af6661786cb419aa6b0138ed1d8085d52}.



Definition at line 85 of file R\+F\+C1867.\+h.



References header\+Parser\+\_\+, parse\+Error\+\_\+, and proxygen\+::\+H\+T\+T\+P1x\+Codec\+::set\+Parser\+Paused().


\begin{DoxyCode}
87                                    \{
88     parseError_ = \textcolor{keyword}{true};
89     headerParser_.setParserPaused(\textcolor{keyword}{true});
90   \}
\end{DoxyCode}
\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!on\+Error@{on\+Error}}
\index{on\+Error@{on\+Error}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}
\subsubsection[{on\+Error(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D, const H\+T\+T\+P\+Exception \&, bool) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+R\+F\+C1867\+Codec\+::on\+Error (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{stream, }
\item[{const {\bf H\+T\+T\+P\+Exception} \&}]{error, }
\item[{bool}]{new\+Txn}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}\label{classproxygen_1_1RFC1867Codec_a072b62abe677260b50cf8b2b5b93f9c2}
Called when a parsing or protocol error has occurred 
\begin{DoxyParams}{Parameters}
{\em stream} & The stream ID \\
\hline
{\em error} & Description of the error \\
\hline
{\em new\+Txn} & true if on\+Message\+Begin has not been called for txn \\
\hline
\end{DoxyParams}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_a39e04260da7dd1a074393fe473d6ac34}.



Definition at line 101 of file R\+F\+C1867.\+h.



References header\+Parser\+\_\+, parse\+Error\+\_\+, read\+To\+Boundary(), and proxygen\+::\+H\+T\+T\+P1x\+Codec\+::set\+Parser\+Paused().


\begin{DoxyCode}
103                                 \{
104     parseError_ = \textcolor{keyword}{true};
105     headerParser_.setParserPaused(\textcolor{keyword}{true});
106   \}
\end{DoxyCode}
\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!on\+Headers\+Complete@{on\+Headers\+Complete}}
\index{on\+Headers\+Complete@{on\+Headers\+Complete}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}
\subsubsection[{on\+Headers\+Complete(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D stream, std\+::unique\+\_\+ptr$<$ H\+T\+T\+P\+Message $>$ msg) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+R\+F\+C1867\+Codec\+::on\+Headers\+Complete (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{stream, }
\item[{std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Message} $>$}]{msg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}\label{classproxygen_1_1RFC1867Codec_a9e01714bafae9a4c2c5aaa7df2182974}
Called when all the headers of an ingress message have been parsed 
\begin{DoxyParams}{Parameters}
{\em stream} & The stream ID \\
\hline
{\em msg} & The message \\
\hline
{\em size} & Size of the ingress header \\
\hline
\end{DoxyParams}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_a7c462d2b3485d0d1077a9ba775f90ebc}.



Definition at line 178 of file R\+F\+C1867.\+cpp.



References proxygen\+::\+E\+R\+R\+OR, and name.



Referenced by on\+Message\+Begin().


\begin{DoxyCode}
179                                                                      \{
180   \textcolor{keyword}{static} \textcolor{keyword}{const} StringPiece kName(\textcolor{stringliteral}{"name"}, 4);
181   \textcolor{keyword}{static} \textcolor{keyword}{const} StringPiece kFilename(\textcolor{stringliteral}{"filename"}, 8);
182   \textcolor{keyword}{static} \textcolor{keyword}{const} StringPiece kFormData(\textcolor{stringliteral}{"form-data"}, 9);
183 
184   \textcolor{keyword}{const} \textcolor{keyword}{auto}& contentDisp =
185     msg->getHeaders().getSingleOrEmpty(HTTP\_HEADER\_CONTENT\_DISPOSITION);
186   \textcolor{keywordtype}{string} name;
187   folly::Optional<string> filename; \textcolor{comment}{// filename is optional}
188   HTTPMessage::splitNameValuePieces(
189     contentDisp, \textcolor{charliteral}{';'}, \textcolor{charliteral}{'='},
190     [&] (folly::StringPiece parameter, folly::StringPiece value) \{
191       \textcolor{comment}{// TODO: Trim whitespace first}
192       \textcolor{comment}{// Strip quotes if present}
193       \textcolor{keywordflow}{if} (value.size() >= 2 && value[0] == \textcolor{charliteral}{'\(\backslash\)"'} &&
194           value[value.size() - 1] == \textcolor{charliteral}{'\(\backslash\)"'}) \{
195         value.reset(value.data() + 1, value.size() - 2);
196       \}
197       \textcolor{keywordflow}{if} (parameter == kName) \{
198         name = value.str();
199       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (parameter == kFilename) \{
200         filename = value.str();
201       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (parameter != kFormData) \{
202         LOG(WARNING) << \textcolor{stringliteral}{"Ignoring parameter "} << parameter << \textcolor{stringliteral}{" value \(\backslash\)""}
203                      << value << \textcolor{charliteral}{'"'};
204       \}
205     \});
206   \textcolor{keywordflow}{if} (name.empty()) \{
207     \textcolor{keywordflow}{if} (callback_) \{
208       LOG(ERROR) << \textcolor{stringliteral}{"name empty"};
209       callback_->onError();
210     \}
211     state_ = ParserState::ERROR;
212     \textcolor{keywordflow}{return};
213   \} \textcolor{keywordflow}{else} \{
214     state_ = ParserState::FIELD_DATA;
215     \textcolor{keywordflow}{if} (callback_ && callback_->onFieldStart(name, filename,
216                                             std::move(msg),
217                                             bytesProcessed_) < 0) \{
218     field_ = name;
219       LOG(WARNING) << \textcolor{stringliteral}{"Callback returned error"};
220       state_ = ParserState::ERROR;
221     \}
222   \}
223 \}
\end{DoxyCode}
\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!on\+Ingress@{on\+Ingress}}
\index{on\+Ingress@{on\+Ingress}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}
\subsubsection[{on\+Ingress(std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ data)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ proxygen\+::\+R\+F\+C1867\+Codec\+::on\+Ingress (
\begin{DoxyParamCaption}
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{data}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1RFC1867Codec_acecbf9e2334578bc5f9123ccccb8d29f}


Definition at line 61 of file R\+F\+C1867.\+cpp.



References proxygen\+::\+E\+R\+R\+OR, and proxygen\+::spdy\+::\+H\+E\+A\+D\+E\+RS.



Referenced by set\+Callback().


\begin{DoxyCode}
61                                                                       \{
62   \textcolor{keyword}{static} \textcolor{keyword}{auto} dummyBuf = IOBuf::wrapBuffer(kDummyGet.data(),
63                                            kDummyGet.length());
64   IOBufQueue result\{IOBufQueue::cacheChainLength()\};
65   \textcolor{keywordtype}{bool} foundBoundary = \textcolor{keyword}{false};
66   BoundaryResult br = BoundaryResult::NO;
67 
68   input_.append(std::move(data));
69   \textcolor{keywordflow}{while} (!input_.empty()) \{
70     \textcolor{keywordflow}{switch} (state_) \{
71       \textcolor{keywordflow}{case} ParserState::START:
72         \textcolor{comment}{// first time, must start with boundary without leading \(\backslash\)n}
73         br = isBoundary(*input_.front(), 0, boundary_.data() + 1,
74                         boundary_.length() - 1);
75         \textcolor{keywordflow}{if} (br == BoundaryResult::NO) \{
76           \textcolor{keywordflow}{if} (callback_) \{
77             LOG(ERROR) << \textcolor{stringliteral}{"Invalid starting sequence"};
78             callback_->onError();
79           \}
80           state_ = ParserState::ERROR;
81           \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};
82         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (br == BoundaryResult::PARTIAL) \{
83           \textcolor{keywordflow}{return} input_.move();
84         \}
85         input_.trimStart(boundary_.length() - 1);
86         bytesProcessed_ += boundary_.length() - 1;
87         state_ = ParserState::HEADERS_START;
88         \textcolor{comment}{// fall through}
89 
90       \textcolor{keywordflow}{case} ParserState::HEADERS_START:
91         \{
92           \textcolor{keywordflow}{if} (input_.chainLength() < 3) \{
93             \textcolor{keywordflow}{return} input_.move();
94           \}
95           Cursor c(input_.front());
96           \textcolor{keywordtype}{char} firstTwo[2];
97           c.pull(firstTwo, 2);
98           \textcolor{comment}{// We have at least 3 chars available to read}
99           uint8\_t toTrim = 3;
100           \textcolor{keywordflow}{if} (memcmp(firstTwo, \textcolor{stringliteral}{"--"}, 2) == 0) \{
101             \textcolor{keywordflow}{do} \{
102               \textcolor{keyword}{auto} ch = c.read<\textcolor{keywordtype}{char}>();
103               \textcolor{keywordflow}{if} (ch == \textcolor{charliteral}{'\(\backslash\)n'}) \{
104                 input_.trimStart(toTrim);
105                 state_ = ParserState::DONE;
106               \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ch == \textcolor{charliteral}{'\(\backslash\)r'}) \{
107                 \textcolor{comment}{// Every \(\backslash\)r we encounter is a char we must trim but we must}
108                 \textcolor{comment}{// make sure we have sufficient data available in input\_ to}
109                 \textcolor{comment}{// keep reading (toTrim is always one pos ahead to handle the}
110                 \textcolor{comment}{// expected \(\backslash\)n)}
111                 ++toTrim;
112                 \textcolor{keywordflow}{if} (input_.chainLength() < toTrim) \{
113                   \textcolor{keywordflow}{return} input_.move();
114                 \}
115               \} \textcolor{keywordflow}{else} \{
116                 state_ = ParserState::ERROR;
117               \}
118             \} \textcolor{keywordflow}{while} (state_ == ParserState::HEADERS_START);
119             \textcolor{keywordflow}{break};
120           \}
121         \}
122         headerParser_.setParserPaused(\textcolor{keyword}{false});
123         headerParser_.onIngress(*dummyBuf);
124         CHECK(!parseError_);
125         state_ = ParserState::HEADERS;
126         \textcolor{comment}{// fall through}
127 
128       \textcolor{keywordflow}{case} ParserState::HEADERS:
129         \textcolor{keywordflow}{while} (!parseError_ && input_.front() &&
130                state_ == ParserState::HEADERS) \{
131           \textcolor{keywordtype}{size\_t} bytesParsed = headerParser_.onIngress(*input_.front());
132           input_.trimStart(bytesParsed);
133           bytesProcessed_ += bytesParsed;
134         \}
135         \textcolor{keywordflow}{if} (parseError_) \{
136           \textcolor{keywordflow}{if} (callback_) \{
137             LOG(ERROR) << \textcolor{stringliteral}{"Error parsing header data: "};
138             VLOG(3) << IOBufPrinter::printHexFolly(input_.front());
139             callback_->onError();
140           \}
141           state_ = ParserState::ERROR;
142           \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};
143         \}
144         \textcolor{keywordflow}{break};
145 
146       \textcolor{keywordflow}{case} ParserState::FIELD_DATA:
147         result = readToBoundary(foundBoundary);
148         value_.append(result.move());
149         \textcolor{keywordflow}{if} (!value_.empty() && callback_) \{
150           \textcolor{keywordflow}{if} (callback_->onFieldData(value_.move(), bytesProcessed_) < 0) \{
151             LOG(ERROR) << \textcolor{stringliteral}{"Callback returned error"};
152             state_ = ParserState::ERROR;
153             \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};
154           \}
155         \}
156         \textcolor{keywordflow}{if} (foundBoundary) \{
157           \textcolor{keywordflow}{if} (callback_) \{
158             callback_->onFieldEnd(\textcolor{keyword}{true}, bytesProcessed_);
159           \}
160           state_ = ParserState::HEADERS_START;
161         \} \textcolor{keywordflow}{else} \{
162           \textcolor{keywordflow}{if} (input_.chainLength() > 0) \{
163             VLOG(5) << \textcolor{stringliteral}{"Trailing input="}
164                     << IOBufPrinter::printHexFolly(input_.front());
165           \}
166           \textcolor{keywordflow}{return} input_.move();
167         \}
168         \textcolor{keywordflow}{break};
169       \textcolor{keywordflow}{case} ParserState::DONE:
170       \textcolor{keywordflow}{case} ParserState::ERROR:
171         \textcolor{comment}{// abort, consume all input}
172         \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};
173     \}
174   \}
175   \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};
176 \}
\end{DoxyCode}
\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!on\+Ingress\+E\+OM@{on\+Ingress\+E\+OM}}
\index{on\+Ingress\+E\+OM@{on\+Ingress\+E\+OM}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}
\subsubsection[{on\+Ingress\+E\+O\+M()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+R\+F\+C1867\+Codec\+::on\+Ingress\+E\+OM (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1RFC1867Codec_a7341d1160f4b487d8c69d583a552341e}


Definition at line 299 of file R\+F\+C1867.\+cpp.



References proxygen\+::\+E\+R\+R\+OR.



Referenced by set\+Callback().


\begin{DoxyCode}
299                                 \{
300   \textcolor{keywordflow}{if} (state_ == ParserState::FIELD_DATA) \{
301     LOG(WARNING) << \textcolor{stringliteral}{"Field not terminated by boundary"};
302     \textcolor{keywordflow}{if} (callback_) \{
303       callback_->onFieldEnd(\textcolor{keyword}{false}, bytesProcessed_);
304     \}
305   \}
306   \textcolor{keywordflow}{if} (state_ != ParserState::HEADERS_START && state_ != ParserState::ERROR &&
307       state_ != ParserState::DONE) \{
308     \textcolor{keywordflow}{if} (callback_) \{
309       LOG(ERROR) << \textcolor{stringliteral}{"onIngressEOM with state\_="} << (uint8\_t)state_;
310       callback_->onError();
311     \}
312   \}
313   state_ = ParserState::START;
314 \}
\end{DoxyCode}
\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!on\+Message\+Begin@{on\+Message\+Begin}}
\index{on\+Message\+Begin@{on\+Message\+Begin}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}
\subsubsection[{on\+Message\+Begin(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D, H\+T\+T\+P\+Message $\ast$) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+R\+F\+C1867\+Codec\+::on\+Message\+Begin (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{stream, }
\item[{{\bf H\+T\+T\+P\+Message} $\ast$}]{msg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}\label{classproxygen_1_1RFC1867Codec_a68fcd8fdcd4cf0701b738580998c0973}
Called when a new message is seen while parsing the ingress 
\begin{DoxyParams}{Parameters}
{\em stream} & The stream ID \\
\hline
{\em msg} & A newly allocated \doxyref{H\+T\+T\+P\+Message}{p.}{classproxygen_1_1HTTPMessage} \\
\hline
\end{DoxyParams}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_a7bcd0c639fd05f92b31806cee4f4b1aa}.



Definition at line 81 of file R\+F\+C1867.\+h.



References on\+Headers\+Complete().


\begin{DoxyCode}
82                                                \{\}
\end{DoxyCode}
\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!on\+Message\+Complete@{on\+Message\+Complete}}
\index{on\+Message\+Complete@{on\+Message\+Complete}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}
\subsubsection[{on\+Message\+Complete(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D, bool) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+R\+F\+C1867\+Codec\+::on\+Message\+Complete (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{stream, }
\item[{bool}]{upgrade}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}\label{classproxygen_1_1RFC1867Codec_ae24ab3cb16d38f484a3c659949c250b3}
Called at end of a message (including body and trailers, if applicable) 
\begin{DoxyParams}{Parameters}
{\em stream} & The stream ID \\
\hline
{\em upgrade} & Whether the connection has been upgraded to another protocol. \\
\hline
\end{DoxyParams}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_a8b42c169cc7f48b42be7f97b463db08e}.



Definition at line 96 of file R\+F\+C1867.\+h.



References header\+Parser\+\_\+, and proxygen\+::\+H\+T\+T\+P1x\+Codec\+::set\+Parser\+Paused().


\begin{DoxyCode}
97                                           \{
98     headerParser_.setParserPaused(\textcolor{keyword}{true});
99   \}
\end{DoxyCode}
\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!on\+Trailers\+Complete@{on\+Trailers\+Complete}}
\index{on\+Trailers\+Complete@{on\+Trailers\+Complete}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}
\subsubsection[{on\+Trailers\+Complete(\+H\+T\+T\+P\+Codec\+::\+Stream\+I\+D, std\+::unique\+\_\+ptr$<$ H\+T\+T\+P\+Headers $>$) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+R\+F\+C1867\+Codec\+::on\+Trailers\+Complete (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID}}]{stream, }
\item[{std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Headers} $>$}]{trailers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [private]}, {\ttfamily [virtual]}}\label{classproxygen_1_1RFC1867Codec_a7fd36951ef46b15fdc75149fa3976d72}
Called when all the trailers of an ingress message have been parsed, but only if the number of trailers is nonzero. 
\begin{DoxyParams}{Parameters}
{\em stream} & The stream ID \\
\hline
{\em trailers} & The message trailers \\
\hline
\end{DoxyParams}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_1_1Callback_aa3ecee42ce8c09840aa67ee824c5cfe3}.



Definition at line 91 of file R\+F\+C1867.\+h.



References header\+Parser\+\_\+, parse\+Error\+\_\+, and proxygen\+::\+H\+T\+T\+P1x\+Codec\+::set\+Parser\+Paused().


\begin{DoxyCode}
92                                                                  \{
93     parseError_ = \textcolor{keyword}{true};
94     headerParser_.setParserPaused(\textcolor{keyword}{true});
95   \}
\end{DoxyCode}
\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!read\+To\+Boundary@{read\+To\+Boundary}}
\index{read\+To\+Boundary@{read\+To\+Boundary}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}
\subsubsection[{read\+To\+Boundary(bool \&found\+Boundary)}]{\setlength{\rightskip}{0pt plus 5cm}I\+O\+Buf\+Queue proxygen\+::\+R\+F\+C1867\+Codec\+::read\+To\+Boundary (
\begin{DoxyParamCaption}
\item[{bool \&}]{found\+Boundary}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1RFC1867Codec_a91eeca7db92b4dc2a637ae288770544e}


Definition at line 225 of file R\+F\+C1867.\+cpp.



Referenced by on\+Error().


\begin{DoxyCode}
225                                                            \{
226   IOBufQueue result\{IOBufQueue::cacheChainLength()\};
227   BoundaryResult boundaryResult = BoundaryResult::NO;
228 
229   \textcolor{keywordflow}{while} (!input_.empty() && boundaryResult != BoundaryResult::PARTIAL) \{
230     \textcolor{keyword}{const} IOBuf* head = input_.front();
231     uint64\_t len = head->length();
232     \textcolor{keyword}{const} uint8\_t *ptr = head->data();
233 
234     \textcolor{comment}{/* iterate through first character matches */}
235     \textcolor{keywordflow}{while} (len > 0 && (ptr = (\textcolor{keyword}{const} uint8\_t*)memchr(ptr, boundary_[0], len))) \{
236       \textcolor{comment}{/* calculate length after match */}
237       uint64\_t readlen = (ptr - head->data());
238       len = head->length() - readlen;
239       boundaryResult =
240         isBoundary(*head, readlen, boundary_.data(), boundary_.length());
241       \textcolor{keywordflow}{if} (boundaryResult == BoundaryResult::YES) \{
242         CHECK(readlen < head->length());
243         \textcolor{keywordtype}{bool} hasCr = \textcolor{keyword}{false};
244         \textcolor{keywordflow}{if} (readlen == 0 && pendingCR_) \{
245           pendingCR_.reset();
246         \}
247         \textcolor{keywordflow}{if} (readlen > 0) \{
248           \textcolor{comment}{// If the last read char is a CR omit from result}
249           Cursor c(head);
250           c.skip(readlen - 1);
251           uint8\_t ch = c.read<uint8\_t>();
252           \textcolor{keywordflow}{if} (ch == \textcolor{charliteral}{'\(\backslash\)r'}) \{
253             --readlen;
254             hasCr = \textcolor{keyword}{true};
255           \}
256         \}
257         result.append(std::move(pendingCR_));
258         result.append(input_.split(readlen));
259         uint32\_t trimLen = boundary_.length() + (hasCr ? 1 : 0);
260         input_.trimStart(trimLen);
261         bytesProcessed_ += readlen + trimLen;
262         foundBoundary = \textcolor{keyword}{true};
263         \textcolor{keywordflow}{return} result;
264       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (boundaryResult == BoundaryResult::PARTIAL) \{
265         \textcolor{keywordflow}{break};
266       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (pendingCR_) \{
267         \textcolor{comment}{// not a match, append pending CR to result}
268         result.append(std::move(pendingCR_));
269       \}
270 
271       \textcolor{comment}{/* next character */}
272       ptr++; len--;
273     \}
274     uint64\_t resultLen = ptr ? ptr - head->data() : head->length();
275     \textcolor{comment}{// Put pendingCR\_ in result if there was no partial match in head, or a}
276     \textcolor{comment}{// partial match starting after the first character}
277     \textcolor{keywordflow}{if} ((boundaryResult == BoundaryResult::NO || resultLen > 0) &&
278         pendingCR_) \{
279       result.append(std::move(pendingCR_));
280     \}
281     \textcolor{comment}{// the boundary does not start through resultLen, append it}
282     \textcolor{comment}{// to result, except maybe the last char if it's a CR.}
283     \textcolor{keywordflow}{if} (resultLen > 0 && head->data()[resultLen - 1] == \textcolor{charliteral}{'\(\backslash\)r'}) \{
284       result.append(input_.split(resultLen - 1));
285       CHECK(!pendingCR_);
286       pendingCR_ = input_.split(1);
287     \} \textcolor{keywordflow}{else} \{
288       result.append(input_.split(resultLen));
289     \}
290     bytesProcessed_ += resultLen;
291   \}
292 
293   \textcolor{comment}{// reached the end but no boundary found}
294   foundBoundary = \textcolor{keyword}{false};
295 
296   \textcolor{keywordflow}{return} result;
297 \}
\end{DoxyCode}
\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!set\+Callback@{set\+Callback}}
\index{set\+Callback@{set\+Callback}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}
\subsubsection[{set\+Callback(\+Callback $\ast$callback)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+R\+F\+C1867\+Codec\+::set\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Callback} $\ast$}]{callback}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1RFC1867Codec_a054d21fc613c53acccee527d1aa04e9d}


Definition at line 54 of file R\+F\+C1867.\+h.



References callback\+\_\+, on\+Ingress(), and on\+Ingress\+E\+O\+M().


\begin{DoxyCode}
54                                        \{
55     callback_ = callback;
56   \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!boundary\+\_\+@{boundary\+\_\+}}
\index{boundary\+\_\+@{boundary\+\_\+}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}
\subsubsection[{boundary\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string proxygen\+::\+R\+F\+C1867\+Codec\+::boundary\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1RFC1867Codec_adc4ff18f3d77f0deb1c78f47c65c1009}


Definition at line 110 of file R\+F\+C1867.\+h.



Referenced by R\+F\+C1867\+Codec().

\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!bytes\+Processed\+\_\+@{bytes\+Processed\+\_\+}}
\index{bytes\+Processed\+\_\+@{bytes\+Processed\+\_\+}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}
\subsubsection[{bytes\+Processed\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t proxygen\+::\+R\+F\+C1867\+Codec\+::bytes\+Processed\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1RFC1867Codec_adcad19fe3ee0c7044f26bd354af06251}


Definition at line 118 of file R\+F\+C1867.\+h.



Referenced by get\+Bytes\+Processed().

\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!callback\+\_\+@{callback\+\_\+}}
\index{callback\+\_\+@{callback\+\_\+}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}
\subsubsection[{callback\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Callback}$\ast$ proxygen\+::\+R\+F\+C1867\+Codec\+::callback\+\_\+ \{{\bf nullptr}\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1RFC1867Codec_a4517b92881d94a051d07da260add224e}


Definition at line 111 of file R\+F\+C1867.\+h.



Referenced by set\+Callback().

\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!field\+\_\+@{field\+\_\+}}
\index{field\+\_\+@{field\+\_\+}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}
\subsubsection[{field\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string proxygen\+::\+R\+F\+C1867\+Codec\+::field\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1RFC1867Codec_a57416153ab8624865688c18de6acfe4c}


Definition at line 114 of file R\+F\+C1867.\+h.

\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!header\+Parser\+\_\+@{header\+Parser\+\_\+}}
\index{header\+Parser\+\_\+@{header\+Parser\+\_\+}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}
\subsubsection[{header\+Parser\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P1x\+Codec} proxygen\+::\+R\+F\+C1867\+Codec\+::header\+Parser\+\_\+ \{{\bf Transport\+Direction\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM}\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1RFC1867Codec_a50e04436799ac5de24ef92357a6a254f}


Definition at line 113 of file R\+F\+C1867.\+h.



Referenced by on\+Body(), on\+Error(), on\+Message\+Complete(), on\+Trailers\+Complete(), and R\+F\+C1867\+Codec().

\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!input\+\_\+@{input\+\_\+}}
\index{input\+\_\+@{input\+\_\+}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}
\subsubsection[{input\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+I\+O\+Buf\+Queue proxygen\+::\+R\+F\+C1867\+Codec\+::input\+\_\+ \{folly\+::\+I\+O\+Buf\+Queue\+::cache\+Chain\+Length()\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1RFC1867Codec_afbdb9b8ad9d744acd07d0bde23979372}


Definition at line 115 of file R\+F\+C1867.\+h.

\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!parse\+Error\+\_\+@{parse\+Error\+\_\+}}
\index{parse\+Error\+\_\+@{parse\+Error\+\_\+}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}
\subsubsection[{parse\+Error\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+R\+F\+C1867\+Codec\+::parse\+Error\+\_\+ \{false\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1RFC1867Codec_a2c404b3c3c05caae606b972c53f617b2}


Definition at line 119 of file R\+F\+C1867.\+h.



Referenced by on\+Body(), on\+Error(), and on\+Trailers\+Complete().

\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!pending\+C\+R\+\_\+@{pending\+C\+R\+\_\+}}
\index{pending\+C\+R\+\_\+@{pending\+C\+R\+\_\+}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}
\subsubsection[{pending\+C\+R\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<$folly\+::\+I\+O\+Buf$>$ proxygen\+::\+R\+F\+C1867\+Codec\+::pending\+C\+R\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1RFC1867Codec_ae500f534ae06bf1de67efd8b7e3c0f86}


Definition at line 117 of file R\+F\+C1867.\+h.

\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!state\+\_\+@{state\+\_\+}}
\index{state\+\_\+@{state\+\_\+}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}
\subsubsection[{state\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Parser\+State} proxygen\+::\+R\+F\+C1867\+Codec\+::state\+\_\+ \{{\bf Parser\+State\+::\+S\+T\+A\+RT}\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1RFC1867Codec_a9ec795e8a03c1ea28e16cadd96f91d8d}


Definition at line 112 of file R\+F\+C1867.\+h.

\index{proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}!value\+\_\+@{value\+\_\+}}
\index{value\+\_\+@{value\+\_\+}!proxygen\+::\+R\+F\+C1867\+Codec@{proxygen\+::\+R\+F\+C1867\+Codec}}
\subsubsection[{value\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+I\+O\+Buf\+Queue proxygen\+::\+R\+F\+C1867\+Codec\+::value\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1RFC1867Codec_ad40fd305b9a60cde5b5868feed006729}


Definition at line 116 of file R\+F\+C1867.\+h.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
proxygen/lib/http/experimental/{\bf R\+F\+C1867.\+h}\item 
proxygen/lib/http/experimental/{\bf R\+F\+C1867.\+cpp}\end{DoxyCompactItemize}
