\section{proxygen\+:\+:H\+T\+T\+P\+Headers Class Reference}
\label{classproxygen_1_1HTTPHeaders}\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}


{\ttfamily \#include $<$H\+T\+T\+P\+Headers.\+h$>$}

\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct {\bf H\+T\+T\+P\+Header\+Name}
\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using {\bf headers\+\_\+initializer\+\_\+list} = std\+::initializer\+\_\+list$<$ std\+::pair$<$ {\bf H\+T\+T\+P\+Header\+Name}, folly\+::\+String\+Piece $>$$>$
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf F\+B\+\_\+\+E\+X\+P\+O\+RT} {\bf H\+T\+T\+P\+Headers} ()
\item 
{\bf F\+B\+\_\+\+E\+X\+P\+O\+RT} {\bf $\sim$\+H\+T\+T\+P\+Headers} ()
\item 
{\bf F\+B\+\_\+\+E\+X\+P\+O\+RT} {\bf H\+T\+T\+P\+Headers} (const {\bf H\+T\+T\+P\+Headers} \&)
\item 
{\bf F\+B\+\_\+\+E\+X\+P\+O\+RT} {\bf H\+T\+T\+P\+Headers} \& {\bf operator=} (const {\bf H\+T\+T\+P\+Headers} \&)
\item 
{\bf F\+B\+\_\+\+E\+X\+P\+O\+RT} {\bf H\+T\+T\+P\+Headers} ({\bf H\+T\+T\+P\+Headers} \&\&) noexcept
\item 
{\bf F\+B\+\_\+\+E\+X\+P\+O\+RT} {\bf H\+T\+T\+P\+Headers} \& {\bf operator=} ({\bf H\+T\+T\+P\+Headers} \&\&)
\item 
void {\bf add} (folly\+::\+String\+Piece {\bf name}, folly\+::\+String\+Piece value)
\item 
{\footnotesize template$<$typename T $>$ }\\void {\bf add} (folly\+::\+String\+Piece {\bf name}, {\bf T} \&\&value)
\item 
{\footnotesize template$<$typename T $>$ }\\void {\bf add} ({\bf H\+T\+T\+P\+Header\+Code} code, {\bf T} \&\&value)
\item 
void {\bf add} ({\bf headers\+\_\+initializer\+\_\+list} l)
\item 
void {\bf raw\+Add} (const std\+::string \&{\bf name}, const std\+::string \&value)
\item 
void {\bf add\+From\+Codec} (const char $\ast$str, size\+\_\+t len, std\+::string \&\&value)
\item 
void {\bf set} (folly\+::\+String\+Piece {\bf name}, const std\+::string \&value)
\item 
void {\bf set} ({\bf H\+T\+T\+P\+Header\+Code} code, const std\+::string \&value)
\item 
void {\bf raw\+Set} (const std\+::string \&{\bf name}, const std\+::string \&value)
\item 
bool {\bf exists} (folly\+::\+String\+Piece {\bf name}) const 
\item 
bool {\bf exists} ({\bf H\+T\+T\+P\+Header\+Code} code) const 
\item 
bool {\bf raw\+Exists} (std\+::string \&{\bf name}) const 
\item 
{\footnotesize template$<$typename T $>$ }\\std\+::string {\bf combine} (const {\bf T} \&header, const std\+::string \&separator={\bf C\+O\+M\+B\+I\+N\+E\+\_\+\+S\+E\+P\+A\+R\+A\+T\+OR}) const 
\item 
{\footnotesize template$<$typename L\+A\+M\+B\+DA $>$ }\\void {\bf for\+Each} (L\+A\+M\+B\+DA func) const 
\item 
{\footnotesize template$<$typename L\+A\+M\+B\+DA $>$ }\\void {\bf for\+Each\+With\+Code} (L\+A\+M\+B\+DA func) const 
\item 
{\footnotesize template$<$typename L\+A\+M\+B\+DA $>$ }\\bool {\bf remove\+By\+Predicate} (L\+A\+M\+B\+DA func)
\item 
{\footnotesize template$<$typename T $>$ }\\const std\+::string \& {\bf get\+Single\+Or\+Empty} (const {\bf T} \&name\+Or\+Code) const 
\item 
const std\+::string {\bf raw\+Get} (const std\+::string \&header) const 
\item 
size\+\_\+t {\bf get\+Number\+Of\+Values} ({\bf H\+T\+T\+P\+Header\+Code} code) const 
\item 
size\+\_\+t {\bf get\+Number\+Of\+Values} (folly\+::\+String\+Piece {\bf name}) const 
\item 
{\footnotesize template$<$typename L\+A\+M\+B\+DA $>$ }\\bool {\bf for\+Each\+Value\+Of\+Header} (folly\+::\+String\+Piece {\bf name}, L\+A\+M\+B\+DA func) const 
\item 
{\footnotesize template$<$typename L\+A\+M\+B\+DA $>$ }\\bool {\bf for\+Each\+Value\+Of\+Header} ({\bf H\+T\+T\+P\+Header\+Code} code, L\+A\+M\+B\+DA func) const 
\item 
bool {\bf remove} (folly\+::\+String\+Piece {\bf name})
\item 
bool {\bf remove} ({\bf H\+T\+T\+P\+Header\+Code} code)
\item 
void {\bf raw\+Remove} (const std\+::string \&{\bf name})
\item 
bool {\bf remove\+All\+Versions} ({\bf H\+T\+T\+P\+Header\+Code} code, folly\+::\+String\+Piece {\bf name})
\item 
void {\bf remove\+All} ()
\item 
void {\bf strip\+Per\+Hop\+Headers} ({\bf H\+T\+T\+P\+Headers} \&stripped\+Headers)
\item 
size\+\_\+t {\bf size} () const 
\item 
void {\bf copy\+To} ({\bf H\+T\+T\+P\+Headers} \&hdrs) const 
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static std\+::bitset$<$ 256 $>$ \& {\bf per\+Hop\+Header\+Codes} ()
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const std\+::string {\bf C\+O\+M\+B\+I\+N\+E\+\_\+\+S\+E\+P\+A\+R\+A\+T\+OR} = \char`\"{}, \char`\"{}
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
bool {\bf transfer\+Header\+If\+Present} (folly\+::\+String\+Piece {\bf name}, {\bf H\+T\+T\+P\+Headers} \&dest)
\item 
void {\bf dispose\+Of\+Header\+Names} ()
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
folly\+::fbvector$<$ {\bf H\+T\+T\+P\+Header\+Code} $>$ {\bf codes\+\_\+}
\item 
folly\+::fbvector$<$ const std\+::string $\ast$ $>$ {\bf header\+Names\+\_\+}
\item 
folly\+::fbvector$<$ std\+::string $>$ {\bf header\+Values\+\_\+}
\item 
size\+\_\+t {\bf deleted\+Count\+\_\+}
\end{DoxyCompactItemize}
\subsection*{Static Private Attributes}
\begin{DoxyCompactItemize}
\item 
static const size\+\_\+t {\bf k\+Initial\+Vector\+Reserve} = 16
\end{DoxyCompactItemize}


\subsection{Detailed Description}
A collection of H\+T\+TP headers.

This is broken out from \doxyref{H\+T\+T\+P\+Message}{p.}{classproxygen_1_1HTTPMessage}, as it\textquotesingle{}s convenient for other things to be able to use collections of H\+T\+TP headers that are easy to work with. The structure is optimized for real-\/life header collection sizes.

Headers are stored as Name/\+Value pairs, in the order they are received on the wire. We hash the names of all common H\+T\+TP headers (using a static perfect hash function generated using gperf from H\+T\+T\+P\+Common\+Headers.\+gperf) into 1-\/byte hashes (we call them \char`\"{}codes\char`\"{}) and only store these. We search them using memchr, which has an x86\+\_\+64 assembly implementation with complexity O(n/16) ;)

Instead of creating strings with header names, we point to a static array of strings in \doxyref{H\+T\+T\+P\+Common\+Headers}{p.}{classproxygen_1_1HTTPCommonHeaders}. If the header name is not in our set of common header names (this is considered unlikely, because we intend this set to be very complete), then we create a new string with its name (we own that pointer then). For such headers, we store the code H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER.

The code H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+N\+O\+NE signifies a header that has been removed.

Most methods which take a header name have two versions\+: one accepting a string, and one accepting a code. It is recommended to use the latter if possible, as in\+: headers.\+add(\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+L\+O\+C\+A\+T\+I\+O\+N, location); rather than\+: headers.\+add(\char`\"{}\+Location\char`\"{}, location); 

Definition at line 68 of file H\+T\+T\+P\+Headers.\+h.



\subsection{Member Typedef Documentation}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!headers\+\_\+initializer\+\_\+list@{headers\+\_\+initializer\+\_\+list}}
\index{headers\+\_\+initializer\+\_\+list@{headers\+\_\+initializer\+\_\+list}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{headers\+\_\+initializer\+\_\+list}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::\+H\+T\+T\+P\+Headers\+::headers\+\_\+initializer\+\_\+list} =  std\+::initializer\+\_\+list$<$ std\+::pair$<${\bf H\+T\+T\+P\+Header\+Name},folly\+::\+String\+Piece$>$$>$}\label{classproxygen_1_1HTTPHeaders_a15d33c7ab0b820a6caed5c04f4586aa5}


Definition at line 86 of file H\+T\+T\+P\+Headers.\+h.



\subsection{Constructor \& Destructor Documentation}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!H\+T\+T\+P\+Headers@{H\+T\+T\+P\+Headers}}
\index{H\+T\+T\+P\+Headers@{H\+T\+T\+P\+Headers}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{H\+T\+T\+P\+Headers()}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+H\+T\+T\+P\+Headers\+::\+H\+T\+T\+P\+Headers (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPHeaders_ab2519337540c5c578d64ccb620a2d3c5}


Definition at line 45 of file H\+T\+T\+P\+Headers.\+cpp.



References codes\+\_\+, header\+Names\+\_\+, header\+Values\+\_\+, and k\+Initial\+Vector\+Reserve.


\begin{DoxyCode}
45                          :
46   deletedCount_(0) \{
47   codes_.reserve(kInitialVectorReserve);
48   headerNames_.reserve(kInitialVectorReserve);
49   headerValues_.reserve(kInitialVectorReserve);
50 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!````~H\+T\+T\+P\+Headers@{$\sim$\+H\+T\+T\+P\+Headers}}
\index{````~H\+T\+T\+P\+Headers@{$\sim$\+H\+T\+T\+P\+Headers}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{$\sim$\+H\+T\+T\+P\+Headers()}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+H\+T\+T\+P\+Headers\+::$\sim$\+H\+T\+T\+P\+Headers (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPHeaders_a4939dc444663bb42f42f07d8dbc8a016}


Definition at line 172 of file H\+T\+T\+P\+Headers.\+cpp.



References dispose\+Of\+Header\+Names().


\begin{DoxyCode}
172                            \{
173   disposeOfHeaderNames();
174 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!H\+T\+T\+P\+Headers@{H\+T\+T\+P\+Headers}}
\index{H\+T\+T\+P\+Headers@{H\+T\+T\+P\+Headers}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{H\+T\+T\+P\+Headers(const H\+T\+T\+P\+Headers \&)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+H\+T\+T\+P\+Headers\+::\+H\+T\+T\+P\+Headers (
\begin{DoxyParamCaption}
\item[{const {\bf H\+T\+T\+P\+Headers} \&}]{hdrs}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPHeaders_a396cbd0833313d7251233ae61bf92b82}


Definition at line 176 of file H\+T\+T\+P\+Headers.\+cpp.



References codes\+\_\+, header\+Names\+\_\+, and proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER.


\begin{DoxyCode}
176                                                 :
177   codes_(hdrs.codes\_),
178   headerNames_(hdrs.headerNames\_),
179   headerValues_(hdrs.headerValues\_),
180   deletedCount_(hdrs.deletedCount\_) \{
181   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < codes_.size(); ++i) \{
182     \textcolor{keywordflow}{if} (codes_[i] == HTTP_HEADER_OTHER) \{
183       headerNames_[i] = \textcolor{keyword}{new} string(*hdrs.headerNames\_[i]);
184     \}
185   \}
186 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!H\+T\+T\+P\+Headers@{H\+T\+T\+P\+Headers}}
\index{H\+T\+T\+P\+Headers@{H\+T\+T\+P\+Headers}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{H\+T\+T\+P\+Headers(\+H\+T\+T\+P\+Headers \&\&) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+H\+T\+T\+P\+Headers\+::\+H\+T\+T\+P\+Headers (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Headers} \&\&}]{hdrs}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{classproxygen_1_1HTTPHeaders_abfc69945a95b3236127fecfd03852036}


Definition at line 188 of file H\+T\+T\+P\+Headers.\+cpp.


\begin{DoxyCode}
188                                                     :
189     codes_(std::move(hdrs.codes\_)),
190     headerNames_(std::move(hdrs.headerNames\_)),
191     headerValues_(std::move(hdrs.headerValues\_)),
192     deletedCount_(hdrs.deletedCount\_) \{
193   hdrs.removeAll();
194 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!add@{add}}
\index{add@{add}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{add(folly\+::\+String\+Piece name, folly\+::\+String\+Piece value)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Headers\+::add (
\begin{DoxyParamCaption}
\item[{folly\+::\+String\+Piece}]{name, }
\item[{folly\+::\+String\+Piece}]{value}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPHeaders_a16adcba8d8703095108ee809f84b62a4}
Add the header \textquotesingle{}name\textquotesingle{} with value \textquotesingle{}value\textquotesingle{}; if other instances of this header name exist, they will be retained. 

Definition at line 52 of file H\+T\+T\+P\+Headers.\+cpp.



References codes\+\_\+, proxygen\+::\+H\+T\+T\+P\+Common\+Headers\+::get\+Pointer\+To\+Header\+Name(), proxygen\+::\+H\+T\+T\+P\+Common\+Headers\+::hash(), header\+Names\+\_\+, header\+Values\+\_\+, and proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER.



Referenced by add(), Test\+Priority\+Map\+Builder\+::create\+Virtual\+Streams(), Curl\+Service\+::\+Curl\+Client\+::\+Curl\+Client(), proxygen\+::\+H\+T\+T\+P\+Message\+::ensure\+Host\+Header(), proxygen\+::get\+Big\+Get\+Request(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Push\+Status\+Code(), proxygen\+::compress\+::\+Sim\+Streaming\+Callback\+::on\+Header(), proxygen\+::\+H\+T\+T\+P\+Direct\+Response\+Handler\+::on\+Headers\+Complete(), Curl\+Service\+::\+Curl\+Client\+::parse\+Headers(), proxygen\+::\+S\+P\+D\+Y\+Codec\+::parse\+Headers(), proxygen\+::\+H\+T\+T\+P1x\+Codec\+::push\+Header\+Name\+And\+Value(), raw\+Add(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::send\+Chunked\+Reply\+With\+Body(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::send\+Headers(), proxygen\+::\+Mock\+H\+T\+T\+P\+Push\+Handler\+::send\+Push\+Headers(), proxygen\+::\+H\+T\+T\+P\+Handler\+Base\+::send\+Reply\+With\+Body(), Curl\+Service\+::\+Curl\+Client\+::send\+Request(), set(), proxygen\+::\+H\+T\+T\+P\+Request\+Verifier\+::set\+Authority(), T\+E\+S\+T(), T\+E\+S\+T\+\_\+\+F(), T\+E\+S\+T\+\_\+\+P(), and H\+T\+T\+P2\+Codec\+Test\+::test\+Header\+List\+Size().


\begin{DoxyCode}
52                                                                    \{
53   CHECK(name.size());
54   \textcolor{keyword}{const} HTTPHeaderCode code = HTTPCommonHeaders::hash(name.data(), name.size());
55   codes_.push\_back(code);
56   headerNames_.push\_back((code == HTTP_HEADER_OTHER)
57       ? \textcolor{keyword}{new} std::string(name.data(), name.size())
58       : HTTPCommonHeaders::getPointerToHeaderName(code));
59   headerValues_.emplace\_back(value.data(), value.size());
60 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!add@{add}}
\index{add@{add}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{add(folly\+::\+String\+Piece name, T \&\&value)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ void proxygen\+::\+H\+T\+T\+P\+Headers\+::add (
\begin{DoxyParamCaption}
\item[{folly\+::\+String\+Piece}]{name, }
\item[{{\bf T} \&\&}]{value}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPHeaders_ac0fa2c282eaa51313cf7a813ca86a9d2}


Definition at line 303 of file H\+T\+T\+P\+Headers.\+h.



References codes\+\_\+, proxygen\+::\+H\+T\+T\+P\+Common\+Headers\+::get\+Pointer\+To\+Header\+Name(), proxygen\+::\+H\+T\+T\+P\+Common\+Headers\+::hash(), header\+Names\+\_\+, header\+Values\+\_\+, and proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER.


\begin{DoxyCode}
303                                                       \{
304   assert(name.size());
305   \textcolor{keyword}{const} HTTPHeaderCode code = HTTPCommonHeaders::hash(name.data(), name.size());
306   codes_.push\_back(code);
307   headerNames_.push\_back((code == HTTP_HEADER_OTHER)
308       ? \textcolor{keyword}{new} std::string(name.data(), name.size())
309       : HTTPCommonHeaders::getPointerToHeaderName(code));
310   headerValues_.emplace\_back(std::forward<T>(value));
311 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!add@{add}}
\index{add@{add}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{add(\+H\+T\+T\+P\+Header\+Code code, T \&\&value)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ void proxygen\+::\+H\+T\+T\+P\+Headers\+::add (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Header\+Code}}]{code, }
\item[{{\bf T} \&\&}]{value}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPHeaders_ac96886704a2e2bd5e7a60f70f92313ff}


Definition at line 314 of file H\+T\+T\+P\+Headers.\+h.



References codes\+\_\+, proxygen\+::\+H\+T\+T\+P\+Common\+Headers\+::get\+Pointer\+To\+Header\+Name(), header\+Names\+\_\+, and header\+Values\+\_\+.


\begin{DoxyCode}
314                                                     \{
315   codes_.push\_back(code);
316   headerNames_.push\_back(HTTPCommonHeaders::getPointerToHeaderName(code));
317   headerValues_.emplace\_back(std::forward<T>(value));
318 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!add@{add}}
\index{add@{add}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{add(headers\+\_\+initializer\+\_\+list l)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Headers\+::add (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Headers\+::headers\+\_\+initializer\+\_\+list}}]{l}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPHeaders_a98aca6c641c7a9100eefeb6b466f8cec}


Definition at line 62 of file H\+T\+T\+P\+Headers.\+cpp.



References add(), and proxygen\+::\+H\+T\+T\+P\+Headers\+::\+H\+T\+T\+P\+Header\+Name\+::\+C\+O\+DE.


\begin{DoxyCode}
62                                                            \{
63   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}& p : l) \{
64     \textcolor{keywordflow}{if} (p.first.type\_ == HTTPHeaderName::CODE) \{
65       add(p.first.code\_, std::string(p.second.data(), p.second.size()));
66     \}
67     \textcolor{keywordflow}{else} \{
68       add(p.first.name\_, std::string(p.second.data(), p.second.size()));
69     \}
70   \}
71 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!add\+From\+Codec@{add\+From\+Codec}}
\index{add\+From\+Codec@{add\+From\+Codec}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{add\+From\+Codec(const char $\ast$str, size\+\_\+t len, std\+::string \&\&value)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Headers\+::add\+From\+Codec (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{str, }
\item[{size\+\_\+t}]{len, }
\item[{std\+::string \&\&}]{value}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPHeaders_af3eb235712c6d8c22e67cfd30fd4983c}


Definition at line 77 of file H\+T\+T\+P\+Headers.\+cpp.



References codes\+\_\+, proxygen\+::\+H\+T\+T\+P\+Common\+Headers\+::get\+Pointer\+To\+Header\+Name(), proxygen\+::\+H\+T\+T\+P\+Common\+Headers\+::hash(), header\+Names\+\_\+, header\+Values\+\_\+, and proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER.



Referenced by proxygen\+::\+H\+T\+T\+P1x\+Codec\+::push\+Header\+Name\+And\+Value().


\begin{DoxyCode}
77                                                                           \{
78   \textcolor{keyword}{const} HTTPHeaderCode code = HTTPCommonHeaders::hash(str, len);
79   codes_.push\_back(code);
80   headerNames_.push\_back((code == HTTP_HEADER_OTHER)
81       ? \textcolor{keyword}{new} \textcolor{keywordtype}{string}(str, len)
82       : HTTPCommonHeaders::getPointerToHeaderName(code));
83   headerValues_.emplace\_back(std::move(value));
84 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!combine@{combine}}
\index{combine@{combine}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{combine(const T \&header, const std\+::string \&separator=\+C\+O\+M\+B\+I\+N\+E\+\_\+\+S\+E\+P\+A\+R\+A\+T\+O\+R) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ std\+::string proxygen\+::\+H\+T\+T\+P\+Headers\+::combine (
\begin{DoxyParamCaption}
\item[{const {\bf T} \&}]{header, }
\item[{const std\+::string \&}]{separator = {\ttfamily {\bf C\+O\+M\+B\+I\+N\+E\+\_\+\+S\+E\+P\+A\+R\+A\+T\+OR}}}
\end{DoxyParamCaption}
) const}\label{classproxygen_1_1HTTPHeaders_abc45708d05c739080750678b10f34e42}
combine all the value for this header into a string 

Definition at line 396 of file H\+T\+T\+P\+Headers.\+h.



References for\+Each\+Value\+Of\+Header().



Referenced by proxygen\+::\+Header\+Decode\+Info\+::on\+Headers\+Complete(), proxygen\+::compress\+::\+Sim\+Streaming\+Callback\+::on\+Headers\+Complete(), raw\+Exists(), and T\+E\+S\+T().


\begin{DoxyCode}
397                                                                    \{
398   std::string combined = \textcolor{stringliteral}{""};
399   forEachValueOfHeader(header, [&] (\textcolor{keyword}{const} std::string& value) -> \textcolor{keywordtype}{bool} \{
400       \textcolor{keywordflow}{if} (combined.empty()) \{
401         combined.append(value);
402       \} \textcolor{keywordflow}{else} \{
403         combined.append(separator).append(value);
404       \}
405       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
406     \});
407   \textcolor{keywordflow}{return} combined;
408 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!copy\+To@{copy\+To}}
\index{copy\+To@{copy\+To}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{copy\+To(\+H\+T\+T\+P\+Headers \&hdrs) const }]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Headers\+::copy\+To (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Headers} \&}]{hdrs}
\end{DoxyParamCaption}
) const}\label{classproxygen_1_1HTTPHeaders_a3652b9245acd3a9c754e6edc2d7c135a}
Copy all headers from this to hdrs. 

Definition at line 327 of file H\+T\+T\+P\+Headers.\+cpp.



References codes\+\_\+, header\+Names\+\_\+, header\+Values\+\_\+, proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+N\+O\+NE, and proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER.



Referenced by raw\+Remove().


\begin{DoxyCode}
327                                                 \{
328   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < codes_.size(); ++i) \{
329     \textcolor{keywordflow}{if} (codes_[i] != HTTP_HEADER_NONE) \{
330       hdrs.codes\_.push\_back(codes_[i]);
331       hdrs.headerNames\_.push\_back((codes_[i] == HTTP_HEADER_OTHER) ?
332           \textcolor{keyword}{new} \textcolor{keywordtype}{string}(*headerNames_[i]) : headerNames_[i]);
333       hdrs.headerValues\_.push\_back(headerValues_[i]);
334     \}
335   \}
336 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!dispose\+Of\+Header\+Names@{dispose\+Of\+Header\+Names}}
\index{dispose\+Of\+Header\+Names@{dispose\+Of\+Header\+Names}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{dispose\+Of\+Header\+Names()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Headers\+::dispose\+Of\+Header\+Names (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPHeaders_ae3f5ede749f8ca97c11799701c1ff46f}


Definition at line 164 of file H\+T\+T\+P\+Headers.\+cpp.



References codes\+\_\+, header\+Names\+\_\+, and proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER.



Referenced by operator=(), remove\+All(), and $\sim$\+H\+T\+T\+P\+Headers().


\begin{DoxyCode}
164                                        \{
165   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < codes_.size(); ++i) \{
166     \textcolor{keywordflow}{if} (codes_[i] == HTTP_HEADER_OTHER) \{
167       \textcolor{keyword}{delete} headerNames_[i];
168     \}
169   \}
170 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!exists@{exists}}
\index{exists@{exists}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{exists(folly\+::\+String\+Piece name) const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Headers\+::exists (
\begin{DoxyParamCaption}
\item[{folly\+::\+String\+Piece}]{name}
\end{DoxyParamCaption}
) const}\label{classproxygen_1_1HTTPHeaders_a17bf2d2b701f809136a4e5023d67ed51}
Do we have an instance of the given header? 

Definition at line 86 of file H\+T\+T\+P\+Headers.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Common\+Headers\+::hash(), proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER, and I\+T\+E\+R\+A\+T\+E\+\_\+\+O\+V\+E\+R\+\_\+\+S\+T\+R\+I\+N\+GS.



Referenced by proxygen\+::\+R\+F\+C2616\+::body\+Implied(), proxygen\+::\+H\+T\+T\+P\+Message\+::ensure\+Host\+Header(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Push\+Status\+Code(), proxygen\+::\+S\+P\+D\+Y\+Codec\+::parse\+Headers(), raw\+Exists(), raw\+Set(), proxygen\+::\+S\+P\+D\+Y\+Codec\+::serialize\+Request\+Headers(), proxygen\+::\+S\+P\+D\+Y\+Codec\+::serialize\+Response\+Headers(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
86                                                     \{
87   \textcolor{keyword}{const} HTTPHeaderCode code = HTTPCommonHeaders::hash(name.data(),
88                                                       name.size());
89   \textcolor{keywordflow}{if} (code != HTTP_HEADER_OTHER) \{
90     \textcolor{keywordflow}{return} exists(code);
91   \} \textcolor{keywordflow}{else} \{
92     ITERATE_OVER_STRINGS(name, \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \});
93     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
94   \}
95 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!exists@{exists}}
\index{exists@{exists}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{exists(\+H\+T\+T\+P\+Header\+Code code) const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Headers\+::exists (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Header\+Code}}]{code}
\end{DoxyParamCaption}
) const}\label{classproxygen_1_1HTTPHeaders_a87c848329dea6fd5bc3c7c355f68f4cd}


Definition at line 97 of file H\+T\+T\+P\+Headers.\+cpp.



References codes\+\_\+.


\begin{DoxyCode}
97                                                   \{
98   \textcolor{keywordflow}{if} (codes_.data() == \textcolor{keyword}{nullptr}) \{
99       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
100   \}
101   \textcolor{keywordflow}{return} memchr((\textcolor{keywordtype}{void}*)codes_.data(), code, codes_.size()) != \textcolor{keyword}{nullptr};
102 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!for\+Each@{for\+Each}}
\index{for\+Each@{for\+Each}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{for\+Each(\+L\+A\+M\+B\+D\+A func) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename L\+A\+M\+B\+DA $>$ void proxygen\+::\+H\+T\+T\+P\+Headers\+::for\+Each (
\begin{DoxyParamCaption}
\item[{L\+A\+M\+B\+DA}]{func}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HTTPHeaders_a311992fee680eafe64c90dc75dbb50c7}
Process the list of all headers, in the order that they were seen\+: for each header\+:value pair, the function/functor/lambda-\/expression given as the second parameter will be executed. It should take two const string \& parameters and return void. Example use\+: hdrs.\+for\+Each([\&] (const string\& header, const string\& val) \{ std\+::cout $<$$<$ header $<$$<$ \char`\"{}\+: \char`\"{} $<$$<$ val; \}); 

Definition at line 351 of file H\+T\+T\+P\+Headers.\+h.



References codes\+\_\+, header\+Names\+\_\+, header\+Values\+\_\+, and proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+N\+O\+NE.



Referenced by proxygen\+::\+H\+T\+T\+P\+Archive\+::convert\+To\+H\+P\+A\+C\+K(), Curl\+Service\+::\+Curl\+Client\+::\+Curl\+Client(), proxygen\+::\+H\+T\+T\+P\+Message\+::describe(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::encode\+Headers(), proxygen\+::\+H\+T\+T\+P1x\+Codec\+::generate\+Trailers(), proxygen\+::\+H\+T\+T\+P\+Archive\+::get\+Size(), proxygen\+::\+Has\+H\+T\+T\+P\+Header\+Matcher\+Impl\+::\+Match\+And\+Explain(), and raw\+Exists().


\begin{DoxyCode}
351                                            \{
352   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < codes_.size(); ++i) \{
353     \textcolor{keywordflow}{if} (codes_[i] != HTTP_HEADER_NONE) \{
354       func(*headerNames_[i], headerValues_[i]);
355     \}
356   \}
357 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!for\+Each\+Value\+Of\+Header@{for\+Each\+Value\+Of\+Header}}
\index{for\+Each\+Value\+Of\+Header@{for\+Each\+Value\+Of\+Header}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{for\+Each\+Value\+Of\+Header(folly\+::\+String\+Piece name, L\+A\+M\+B\+D\+A func) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename L\+A\+M\+B\+DA $>$ bool proxygen\+::\+H\+T\+T\+P\+Headers\+::for\+Each\+Value\+Of\+Header (
\begin{DoxyParamCaption}
\item[{folly\+::\+String\+Piece}]{name, }
\item[{L\+A\+M\+B\+DA}]{func}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HTTPHeaders_a1a4f3182a9e17c94a2944f72d5e4146c}
Process the ordered list of values for the given header name\+: for each value, the function/functor/lambda-\/expression given as the second parameter will be executed. It should take one const string \& parameter and return bool (false to keep processing, true to stop it). Example use\+: hdrs.\+for\+Each\+Value\+Of\+Header(\char`\"{}someheader\char`\"{}, [\&] (const string\& val) \{ std\+::cout $<$$<$ val; return false; \}); This method returns true if processing was stopped (by func returning true), and false otherwise. 

Definition at line 369 of file H\+T\+T\+P\+Headers.\+h.



References proxygen\+::\+H\+T\+T\+P\+Common\+Headers\+::hash(), header\+Values\+\_\+, proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER, and I\+T\+E\+R\+A\+T\+E\+\_\+\+O\+V\+E\+R\+\_\+\+S\+T\+R\+I\+N\+GS.



Referenced by combine(), proxygen\+::\+H\+T\+T\+P\+Message\+::do\+Header\+Token\+Check(), get\+Number\+Of\+Values(), get\+Single\+Or\+Empty(), proxygen\+::\+H\+T\+T\+P\+Message\+::parse\+Cookies(), raw\+Get(), and strip\+Per\+Hop\+Headers().


\begin{DoxyCode}
370                                                           \{
371   \textcolor{keyword}{const} HTTPHeaderCode code = HTTPCommonHeaders::hash(name.data(), name.size());
372   \textcolor{keywordflow}{if} (code != HTTP_HEADER_OTHER) \{
373     \textcolor{keywordflow}{return} forEachValueOfHeader(code, func);
374   \} \textcolor{keywordflow}{else} \{
375     ITERATE_OVER_STRINGS(name, \{
376       \textcolor{keywordflow}{if} (func(headerValues_[pos])) \{
377         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
378       \}
379     \});
380     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
381   \}
382 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!for\+Each\+Value\+Of\+Header@{for\+Each\+Value\+Of\+Header}}
\index{for\+Each\+Value\+Of\+Header@{for\+Each\+Value\+Of\+Header}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{for\+Each\+Value\+Of\+Header(\+H\+T\+T\+P\+Header\+Code code, L\+A\+M\+B\+D\+A func) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename L\+A\+M\+B\+DA $>$ bool proxygen\+::\+H\+T\+T\+P\+Headers\+::for\+Each\+Value\+Of\+Header (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Header\+Code}}]{code, }
\item[{L\+A\+M\+B\+DA}]{func}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HTTPHeaders_a858f354fd379ff8c112ffe46dc193c2e}


Definition at line 385 of file H\+T\+T\+P\+Headers.\+h.



References header\+Values\+\_\+, and I\+T\+E\+R\+A\+T\+E\+\_\+\+O\+V\+E\+R\+\_\+\+C\+O\+D\+ES.


\begin{DoxyCode}
386                                                           \{
387   ITERATE_OVER_CODES(code, \{
388     \textcolor{keywordflow}{if} (func(headerValues_[pos])) \{
389       \textcolor{keywordflow}{return} \textcolor{keyword}{true};
390     \}
391   \});
392   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
393 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!for\+Each\+With\+Code@{for\+Each\+With\+Code}}
\index{for\+Each\+With\+Code@{for\+Each\+With\+Code}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{for\+Each\+With\+Code(\+L\+A\+M\+B\+D\+A func) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename L\+A\+M\+B\+DA $>$ void proxygen\+::\+H\+T\+T\+P\+Headers\+::for\+Each\+With\+Code (
\begin{DoxyParamCaption}
\item[{L\+A\+M\+B\+DA}]{func}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HTTPHeaders_ac7eb57e21eab4dd473e8e259a2ec0661}
Process the list of all headers, in the order that they were seen\+: for each header\+:value pair, the function/functor/lambda-\/expression given as the second parameter will be executed. It should take one H\+T\+T\+P\+Header\+Code (code) parameter, two const string \& parameters and return void. Example use\+: hdrs.\+for\+Each\+With\+Code([\&] (H\+T\+T\+P\+Header\+Code code, const string\& header, const string\& val) \{ std\+::cout $<$$<$ header $<$$<$ \char`\"{}(\char`\"{} $<$$<$ code $<$$<$ \char`\"{})\+: \char`\"{} $<$$<$ val; \}); 

Definition at line 360 of file H\+T\+T\+P\+Headers.\+h.



References codes\+\_\+, header\+Names\+\_\+, header\+Values\+\_\+, and proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+N\+O\+NE.



Referenced by proxygen\+::\+Codec\+Util\+::append\+Headers(), proxygen\+::\+S\+P\+D\+Y\+Codec\+::encode\+Headers(), proxygen\+::\+H\+T\+T\+P1x\+Codec\+::generate\+Header(), proxygen\+::compress\+::prepare\+Message\+For\+Compression(), and raw\+Exists().


\begin{DoxyCode}
360                                                    \{
361   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < codes_.size(); ++i) \{
362     \textcolor{keywordflow}{if} (codes_[i] != HTTP_HEADER_NONE) \{
363       func(codes_[i], *headerNames_[i], headerValues_[i]);
364     \}
365   \}
366 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!get\+Number\+Of\+Values@{get\+Number\+Of\+Values}}
\index{get\+Number\+Of\+Values@{get\+Number\+Of\+Values}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{get\+Number\+Of\+Values(\+H\+T\+T\+P\+Header\+Code code) const }]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P\+Headers\+::get\+Number\+Of\+Values (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Header\+Code}}]{code}
\end{DoxyParamCaption}
) const}\label{classproxygen_1_1HTTPHeaders_aefeb4c65545703160247bd10334f3a17}
Get the number of values corresponding to a given header name. 

Definition at line 104 of file H\+T\+T\+P\+Headers.\+cpp.



References I\+T\+E\+R\+A\+T\+E\+\_\+\+O\+V\+E\+R\+\_\+\+C\+O\+D\+ES.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::on\+Ingress\+Upgrade\+Message(), raw\+Get(), Curl\+Service\+::\+Curl\+Client\+::send\+Request(), T\+E\+S\+T(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
104                                                                \{
105   \textcolor{keywordtype}{size\_t} count = 0;
106   ITERATE_OVER_CODES(code, \{
107       (void)pos;
108       ++count;
109   \});
110   \textcolor{keywordflow}{return} count;
111 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!get\+Number\+Of\+Values@{get\+Number\+Of\+Values}}
\index{get\+Number\+Of\+Values@{get\+Number\+Of\+Values}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{get\+Number\+Of\+Values(folly\+::\+String\+Piece name) const }]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P\+Headers\+::get\+Number\+Of\+Values (
\begin{DoxyParamCaption}
\item[{folly\+::\+String\+Piece}]{name}
\end{DoxyParamCaption}
) const}\label{classproxygen_1_1HTTPHeaders_ab48e4bdf15702bf70e419610cef8e8fd}


Definition at line 113 of file H\+T\+T\+P\+Headers.\+cpp.



References for\+Each\+Value\+Of\+Header().


\begin{DoxyCode}
113                                                                  \{
114   \textcolor{keywordtype}{size\_t} count = 0;
115   forEachValueOfHeader(name, [&] (folly::StringPiece \textcolor{comment}{/*value*/}) -> \textcolor{keywordtype}{bool} \{
116     ++count;
117     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
118   \});
119   \textcolor{keywordflow}{return} count;
120 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!get\+Single\+Or\+Empty@{get\+Single\+Or\+Empty}}
\index{get\+Single\+Or\+Empty@{get\+Single\+Or\+Empty}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{get\+Single\+Or\+Empty(const T \&name\+Or\+Code) const }]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename T $>$ const std\+::string \& proxygen\+::\+H\+T\+T\+P\+Headers\+::get\+Single\+Or\+Empty (
\begin{DoxyParamCaption}
\item[{const {\bf T} \&}]{name\+Or\+Code}
\end{DoxyParamCaption}
) const}\label{classproxygen_1_1HTTPHeaders_aa14bc0e99fc0ebe98fb95b7cff1bb598}
Returns the value of the header if it\textquotesingle{}s found in the message and is the only value under the given name. If either of these is violated, returns empty\+\_\+string. 

Definition at line 434 of file H\+T\+T\+P\+Headers.\+h.



References proxygen\+::empty\+\_\+string, and for\+Each\+Value\+Of\+Header().



Referenced by H\+T\+T\+P\+Downstream\+Test$<$ S\+P\+D\+Y3\+\_\+1\+Codec\+Pair $>$\+::expect101(), Push\+Service\+::generate\+Url(), Curl\+Service\+::\+Curl\+Client\+::get\+Server\+Name(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::on\+Ingress\+Upgrade\+Message(), proxygen\+::\+S\+P\+D\+Y\+Codec\+::parse\+Headers(), proxygen\+::compress\+::prepare\+Message\+For\+Compression(), proxygen\+::\+Codec\+Util\+::prepare\+Message\+For\+Compression(), proxygen\+::\+H\+T\+T\+P\+Message\+::process\+Max\+Forwards(), raw\+Exists(), raw\+Get(), proxygen\+::\+H\+T\+T\+P\+Transaction\+::send\+Headers\+With\+Optional\+E\+O\+M(), proxygen\+::\+S\+P\+D\+Y\+Codec\+::serialize\+Request\+Headers(), T\+E\+S\+T(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
434                                                                          \{
435   \textcolor{keyword}{const} std::string* res = \textcolor{keyword}{nullptr};
436   forEachValueOfHeader(nameOrCode, [&] (\textcolor{keyword}{const} std::string& value) -> \textcolor{keywordtype}{bool} \{
437     \textcolor{keywordflow}{if} (res != \textcolor{keyword}{nullptr}) \{
438       \textcolor{comment}{// a second value is found}
439       res = \textcolor{keyword}{nullptr};
440       \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \textcolor{comment}{// stop processing}
441     \} \textcolor{keywordflow}{else} \{
442       \textcolor{comment}{// the first value is found}
443       res = &value;
444       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
445     \}
446   \});
447   \textcolor{keywordflow}{if} (res == \textcolor{keyword}{nullptr}) \{
448     \textcolor{keywordflow}{return} empty_string;
449   \} \textcolor{keywordflow}{else} \{
450     \textcolor{keywordflow}{return} *res;
451   \}
452 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!operator=@{operator=}}
\index{operator=@{operator=}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{operator=(const H\+T\+T\+P\+Headers \&)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Headers} \& proxygen\+::\+H\+T\+T\+P\+Headers\+::operator= (
\begin{DoxyParamCaption}
\item[{const {\bf H\+T\+T\+P\+Headers} \&}]{hdrs}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPHeaders_a2cb998cac22b5231b17bd03a94705bd6}


Definition at line 196 of file H\+T\+T\+P\+Headers.\+cpp.



References codes\+\_\+, deleted\+Count\+\_\+, dispose\+Of\+Header\+Names(), header\+Names\+\_\+, header\+Values\+\_\+, and proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER.


\begin{DoxyCode}
196                                                             \{
197   \textcolor{keywordflow}{if} (\textcolor{keyword}{this} != &hdrs) \{
198     disposeOfHeaderNames();
199     codes_ = hdrs.codes\_;
200     headerNames_ = hdrs.headerNames\_;
201     headerValues_ = hdrs.headerValues\_;
202     deletedCount_ = hdrs.deletedCount\_;
203     \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < codes_.size(); ++i) \{
204       \textcolor{keywordflow}{if} (codes_[i] == HTTP_HEADER_OTHER) \{
205         headerNames_[i] = \textcolor{keyword}{new} string(*hdrs.headerNames\_[i]);
206       \}
207     \}
208   \}
209   \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
210 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!operator=@{operator=}}
\index{operator=@{operator=}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{operator=(\+H\+T\+T\+P\+Headers \&\&)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Headers} \& proxygen\+::\+H\+T\+T\+P\+Headers\+::operator= (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Headers} \&\&}]{hdrs}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPHeaders_a881e3db96185f9a9f8196a129f25f9ef}


Definition at line 212 of file H\+T\+T\+P\+Headers.\+cpp.



References codes\+\_\+, deleted\+Count\+\_\+, header\+Names\+\_\+, and header\+Values\+\_\+.


\begin{DoxyCode}
212                                                        \{
213   \textcolor{keywordflow}{if} (\textcolor{keyword}{this} != &hdrs) \{
214     codes_ = std::move(hdrs.codes\_);
215     headerNames_ = std::move(hdrs.headerNames\_);
216     headerValues_ = std::move(hdrs.headerValues\_);
217     deletedCount_ = hdrs.deletedCount\_;
218 
219     hdrs.removeAll();
220   \}
221 
222   \textcolor{keywordflow}{return} *\textcolor{keyword}{this};
223 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!per\+Hop\+Header\+Codes@{per\+Hop\+Header\+Codes}}
\index{per\+Hop\+Header\+Codes@{per\+Hop\+Header\+Codes}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{per\+Hop\+Header\+Codes()}]{\setlength{\rightskip}{0pt plus 5cm}bitset$<$ 256 $>$ \& proxygen\+::\+H\+T\+T\+P\+Headers\+::per\+Hop\+Header\+Codes (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classproxygen_1_1HTTPHeaders_a870e9d23cbaeaa090bb57240ffa9e78e}
Determines whether header with a given code is a per-\/hop header, which should be stripped by \doxyref{strip\+Per\+Hop\+Headers()}{p.}{classproxygen_1_1HTTPHeaders_a143fad9c43bb499043e7ccb82974c7f6}. 

Definition at line 26 of file H\+T\+T\+P\+Headers.\+cpp.



Referenced by raw\+Remove(), and strip\+Per\+Hop\+Headers().


\begin{DoxyCode}
26                                             \{
27   \textcolor{keyword}{static} bitset<256> perHopHeaderCodes\{
28     [] \{
29       bitset<256> bs;
30       bs[HTTP\_HEADER\_CONNECTION] = \textcolor{keyword}{true};
31       bs[HTTP\_HEADER\_KEEP\_ALIVE] = \textcolor{keyword}{true};
32       bs[HTTP\_HEADER\_PROXY\_AUTHENTICATE] = \textcolor{keyword}{true};
33       bs[HTTP\_HEADER\_PROXY\_AUTHORIZATION] = \textcolor{keyword}{true};
34       bs[HTTP\_HEADER\_PROXY\_CONNECTION] = \textcolor{keyword}{true};
35       bs[HTTP\_HEADER\_TE] = \textcolor{keyword}{true};
36       bs[HTTP\_HEADER\_TRAILER] = \textcolor{keyword}{true};
37       bs[HTTP\_HEADER\_TRANSFER\_ENCODING] = \textcolor{keyword}{true};
38       bs[HTTP\_HEADER\_UPGRADE] = \textcolor{keyword}{true};
39       \textcolor{keywordflow}{return} bs;
40     \}()
41   \};
42   \textcolor{keywordflow}{return} perHopHeaderCodes;
43 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!raw\+Add@{raw\+Add}}
\index{raw\+Add@{raw\+Add}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{raw\+Add(const std\+::string \&name, const std\+::string \&value)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Headers\+::raw\+Add (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{name, }
\item[{const std\+::string \&}]{value}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPHeaders_ac11c805d49ec9dc809e155810ea2ee93}


Definition at line 73 of file H\+T\+T\+P\+Headers.\+cpp.



References add().


\begin{DoxyCode}
73                                                                       \{
74   add(name, value);
75 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!raw\+Exists@{raw\+Exists}}
\index{raw\+Exists@{raw\+Exists}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{raw\+Exists(std\+::string \&name) const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Headers\+::raw\+Exists (
\begin{DoxyParamCaption}
\item[{std\+::string \&}]{name}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HTTPHeaders_a4ee38d5a381d1e66a85940d0664a3d04}


Definition at line 137 of file H\+T\+T\+P\+Headers.\+h.



References combine(), exists(), for\+Each(), for\+Each\+With\+Code(), get\+Single\+Or\+Empty(), remove\+By\+Predicate(), and T.


\begin{DoxyCode}
137                                         \{
138     \textcolor{keywordflow}{return} exists(name);
139   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!raw\+Get@{raw\+Get}}
\index{raw\+Get@{raw\+Get}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{raw\+Get(const std\+::string \&header) const }]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string proxygen\+::\+H\+T\+T\+P\+Headers\+::raw\+Get (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{header}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HTTPHeaders_a5295679965ad6fa7ee81e0aa699fe289}


Definition at line 199 of file H\+T\+T\+P\+Headers.\+h.



References for\+Each\+Value\+Of\+Header(), get\+Number\+Of\+Values(), get\+Single\+Or\+Empty(), and name.


\begin{DoxyCode}
199                                                         \{
200     \textcolor{keywordflow}{return} getSingleOrEmpty(header);
201   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!raw\+Remove@{raw\+Remove}}
\index{raw\+Remove@{raw\+Remove}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{raw\+Remove(const std\+::string \&name)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Headers\+::raw\+Remove (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HTTPHeaders_acac0a28ddd6a753f9c9ce73b2927c6e1}


Definition at line 232 of file H\+T\+T\+P\+Headers.\+h.



References copy\+To(), name, per\+Hop\+Header\+Codes(), remove\+All(), remove\+All\+Versions(), size(), and strip\+Per\+Hop\+Headers().


\begin{DoxyCode}
232                                         \{
233     \textcolor{keyword}{remove}(name);
234   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!raw\+Set@{raw\+Set}}
\index{raw\+Set@{raw\+Set}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{raw\+Set(const std\+::string \&name, const std\+::string \&value)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Headers\+::raw\+Set (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{name, }
\item[{const std\+::string \&}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HTTPHeaders_a63e1d741d4ca6035f5f677394b2bf1df}


Definition at line 128 of file H\+T\+T\+P\+Headers.\+h.



References exists(), and name.


\begin{DoxyCode}
128                                                              \{
129     \textcolor{keyword}{set}(name, value);
130   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!remove@{remove}}
\index{remove@{remove}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{remove(folly\+::\+String\+Piece name)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Headers\+::remove (
\begin{DoxyParamCaption}
\item[{folly\+::\+String\+Piece}]{name}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPHeaders_ae5a8af9ab19787174a983c317291f334}
Remove all instances of the given header, returning true if anything was removed and false if this header didn\textquotesingle{}t exist in our set. 

Definition at line 122 of file H\+T\+T\+P\+Headers.\+cpp.



References codes\+\_\+, deleted\+Count\+\_\+, proxygen\+::\+H\+T\+T\+P\+Common\+Headers\+::hash(), header\+Names\+\_\+, proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+N\+O\+NE, proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER, and I\+T\+E\+R\+A\+T\+E\+\_\+\+O\+V\+E\+R\+\_\+\+S\+T\+R\+I\+N\+GS.



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
122                                               \{
123   \textcolor{keyword}{const} HTTPHeaderCode code = HTTPCommonHeaders::hash(name.data(),
124                                                       name.size());
125   \textcolor{keywordflow}{if} (code != HTTP_HEADER_OTHER) \{
126     \textcolor{keywordflow}{return} \textcolor{keyword}{remove}(code);
127   \} \textcolor{keywordflow}{else} \{
128     \textcolor{keywordtype}{bool} removed = \textcolor{keyword}{false};
129     ITERATE_OVER_STRINGS(name, \{
130       \textcolor{keyword}{delete} headerNames_[pos];
131       codes_[pos] = HTTP_HEADER_NONE;
132       removed = \textcolor{keyword}{true};
133       ++deletedCount_;
134     \});
135     \textcolor{keywordflow}{return} removed;
136   \}
137 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!remove@{remove}}
\index{remove@{remove}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{remove(\+H\+T\+T\+P\+Header\+Code code)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Headers\+::remove (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Header\+Code}}]{code}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPHeaders_ab65689784efba8886d7daface9d0b2e3}


Definition at line 139 of file H\+T\+T\+P\+Headers.\+cpp.



References codes\+\_\+, deleted\+Count\+\_\+, proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+N\+O\+NE, and I\+T\+E\+R\+A\+T\+E\+\_\+\+O\+V\+E\+R\+\_\+\+C\+O\+D\+ES.


\begin{DoxyCode}
139                                             \{
140   \textcolor{keywordtype}{bool} removed = \textcolor{keyword}{false};
141   ITERATE_OVER_CODES(code, \{
142     codes_[pos] = HTTP_HEADER_NONE;
143     removed = \textcolor{keyword}{true};
144     ++deletedCount_;
145   \});
146   \textcolor{keywordflow}{return} removed;
147 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!remove\+All@{remove\+All}}
\index{remove\+All@{remove\+All}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{remove\+All()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Headers\+::remove\+All (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPHeaders_a1fc218b33620ad60c1f1cc35bfed3854}
Remove all headers. 

Definition at line 225 of file H\+T\+T\+P\+Headers.\+cpp.



References codes\+\_\+, deleted\+Count\+\_\+, dispose\+Of\+Header\+Names(), header\+Names\+\_\+, and header\+Values\+\_\+.



Referenced by raw\+Remove(), and proxygen\+::\+H\+T\+T\+P\+Message\+::strip\+Per\+Hop\+Headers().


\begin{DoxyCode}
225                             \{
226   disposeOfHeaderNames();
227 
228   codes_.clear();
229   headerNames_.clear();
230   headerValues_.clear();
231   deletedCount_ = 0;
232 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!remove\+All\+Versions@{remove\+All\+Versions}}
\index{remove\+All\+Versions@{remove\+All\+Versions}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{remove\+All\+Versions(\+H\+T\+T\+P\+Header\+Code code, folly\+::\+String\+Piece name)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Headers\+::remove\+All\+Versions (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Header\+Code}}]{code, }
\item[{folly\+::\+String\+Piece}]{name}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPHeaders_a268b24bc7d8dd0716650e1e4f2b82501}
Remove all possible versions of header eg. if x-\/y-\/z is the argument it will remove x-\/y\+\_\+z, x\+\_\+y-\/z and x\+\_\+y\+\_\+z too. 

Definition at line 149 of file H\+T\+T\+P\+Headers.\+cpp.



References codes\+\_\+, deleted\+Count\+\_\+, header\+Names\+\_\+, proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+N\+O\+NE, proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER, and I\+T\+E\+R\+A\+T\+E\+\_\+\+O\+V\+E\+R\+\_\+\+S\+T\+R\+I\+N\+G\+S\+\_\+\+A\+L\+L\+\_\+\+V\+E\+R\+S\+I\+ON.



Referenced by raw\+Remove(), and T\+E\+S\+T().


\begin{DoxyCode}
150                          \{
151   \textcolor{keywordtype}{bool} removed = \textcolor{keyword}{false};
152   \textcolor{keywordflow}{if}(code != HTTP_HEADER_OTHER) \{
153     removed = \textcolor{keyword}{remove}(code);
154   \}
155   ITERATE_OVER_STRINGS_ALL_VERSION(name, \{
156     \textcolor{keyword}{delete} headerNames_[pos];
157     codes_[pos] = HTTP_HEADER_NONE;
158     removed = \textcolor{keyword}{true};
159     ++deletedCount_;
160   \});
161   \textcolor{keywordflow}{return} removed;
162 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!remove\+By\+Predicate@{remove\+By\+Predicate}}
\index{remove\+By\+Predicate@{remove\+By\+Predicate}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{remove\+By\+Predicate(\+L\+A\+M\+B\+D\+A func)}]{\setlength{\rightskip}{0pt plus 5cm}template$<$typename L\+A\+M\+B\+DA $>$ bool proxygen\+::\+H\+T\+T\+P\+Headers\+::remove\+By\+Predicate (
\begin{DoxyParamCaption}
\item[{L\+A\+M\+B\+DA}]{func}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HTTPHeaders_a06644cca9049aa398ac28617309454e5}
Process the list of all headers, in the order that they were seen\+: for each header\+:value pair, the function/functor/lambda-\/expression given as the parameter will be executed to determine whether the header should be removed. Example use\+: \begin{DoxyVerb}hdrs.removeByPredicate([&] (HTTPHeaderCode code,
                            const string& header,
                            const string& val) {
  return boost::regex_match(header, "^X-Fb-.*");
});
\end{DoxyVerb}


return true only if one or more headers are removed. 

Definition at line 412 of file H\+T\+T\+P\+Headers.\+h.



References codes\+\_\+, deleted\+Count\+\_\+, header\+Names\+\_\+, header\+Values\+\_\+, proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+N\+O\+NE, and proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER.



Referenced by raw\+Exists().


\begin{DoxyCode}
412                                                \{
413   \textcolor{keywordtype}{bool} removed = \textcolor{keyword}{false};
414   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < codes_.size(); ++i) \{
415     \textcolor{keywordflow}{if} (codes_[i] == HTTP_HEADER_NONE ||
416         !func(codes_[i], *headerNames_[i], headerValues_[i])) \{
417       \textcolor{keywordflow}{continue};
418     \}
419 
420     \textcolor{keywordflow}{if} (codes_[i] == HTTP_HEADER_OTHER) \{
421       \textcolor{keyword}{delete} headerNames_[i];
422       headerNames_[i] = \textcolor{keyword}{nullptr};
423     \}
424 
425     codes_[i] = HTTP_HEADER_NONE;
426     ++deletedCount_;
427     removed = \textcolor{keyword}{true};
428   \}
429 
430   \textcolor{keywordflow}{return} removed;
431 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!set@{set}}
\index{set@{set}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{set(folly\+::\+String\+Piece name, const std\+::string \&value)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Headers\+::set (
\begin{DoxyParamCaption}
\item[{folly\+::\+String\+Piece}]{name, }
\item[{const std\+::string \&}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HTTPHeaders_a98de32ef8d9de8f8ab0198cc1a6dc747}
For the header \textquotesingle{}name\textquotesingle{}, set its value to the single header \textquotesingle{}value\textquotesingle{}, removing any other instances of this header. 

Definition at line 119 of file H\+T\+T\+P\+Headers.\+h.



References add(), and name.



Referenced by Test\+Priority\+Map\+Builder\+::create\+Virtual\+Streams(), do\+Empty\+Header\+Value\+Test(), Zlib\+Server\+Filter\+Test\+::exercise\+\_\+compression(), proxygen\+::get\+Big\+Get\+Request(), proxygen\+::get\+Chunked\+Post\+Request(), proxygen\+::get\+Get\+Request(), proxygen\+::get\+Post\+Request(), proxygen\+::get\+Pub\+Request(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Push\+Status\+Code(), proxygen\+::get\+Response(), get\+Syn\+Stream(), proxygen\+::get\+Upgrade\+Request(), proxygen\+::\+Header\+Decode\+Info\+::on\+Headers\+Complete(), proxygen\+::compress\+::\+Sim\+Streaming\+Callback\+::on\+Headers\+Complete(), proxygen\+::\+H\+T\+T\+P\+Downstream\+Session\+::on\+Native\+Protocol\+Upgrade(), proxygen\+::\+S\+P\+D\+Y\+Codec\+::parse\+Headers(), proxygen\+::\+H\+T\+T\+P\+Message\+::process\+Max\+Forwards(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::request\+Upgrade(), proxygen\+::\+Mock\+H\+T\+T\+P\+Push\+Handler\+::send\+Push\+Headers(), T\+E\+S\+T(), T\+E\+S\+T\+\_\+\+F(), and H\+T\+T\+P\+Upstream\+Test$<$ C $>$\+::test\+Basic\+Request\+Http10().


\begin{DoxyCode}
119                                                           \{
120     \textcolor{comment}{// this could be somewhat optimized but probably not an issue yet}
121     \textcolor{keyword}{remove}(name);
122     add(name, value);
123   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!set@{set}}
\index{set@{set}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{set(\+H\+T\+T\+P\+Header\+Code code, const std\+::string \&value)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Headers\+::set (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Header\+Code}}]{code, }
\item[{const std\+::string \&}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HTTPHeaders_ae6a487d954b2ec508730da8fe2ae430c}


Definition at line 124 of file H\+T\+T\+P\+Headers.\+h.



References add().


\begin{DoxyCode}
124                                                         \{
125     \textcolor{keyword}{remove}(code);
126     add(code, value);
127   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!size@{size}}
\index{size@{size}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{size() const }]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P\+Headers\+::size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classproxygen_1_1HTTPHeaders_a63958050d64b868c92960dccf830ca30}
Get the total number of headers. 

Definition at line 234 of file H\+T\+T\+P\+Headers.\+cpp.



References codes\+\_\+, and deleted\+Count\+\_\+.



Referenced by proxygen\+::\+H\+T\+T\+P\+Message\+::describe(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::encode\+Headers(), H\+T\+T\+P\+Downstream\+Test$<$ S\+P\+D\+Y3\+\_\+1\+Codec\+Pair $>$\+::expect101(), proxygen\+::\+H\+T\+T\+P\+Archive\+::from\+File(), proxygen\+::\+H\+T\+T\+P\+Archive\+::from\+Public\+File(), raw\+Remove(), proxygen\+::\+S\+P\+D\+Y\+Codec\+::serialize\+Request\+Headers(), proxygen\+::\+S\+P\+D\+Y\+Codec\+::serialize\+Response\+Headers(), T\+E\+S\+T(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
234                                \{
235   \textcolor{keywordflow}{return} codes_.size() - deletedCount_;
236 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!strip\+Per\+Hop\+Headers@{strip\+Per\+Hop\+Headers}}
\index{strip\+Per\+Hop\+Headers@{strip\+Per\+Hop\+Headers}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{strip\+Per\+Hop\+Headers(\+H\+T\+T\+P\+Headers \&stripped\+Headers)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Headers\+::strip\+Per\+Hop\+Headers (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Headers} \&}]{stripped\+Headers}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPHeaders_a143fad9c43bb499043e7ccb82974c7f6}
Remove per-\/hop-\/headers and headers named in the Connection header and place the value in stripped\+Headers 

Definition at line 268 of file H\+T\+T\+P\+Headers.\+cpp.



References codes\+\_\+, deleted\+Count\+\_\+, for\+Each\+Value\+Of\+Header(), header\+Names\+\_\+, header\+Values\+\_\+, proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+N\+O\+NE, proxygen\+::is\+L\+W\+S(), per\+Hop\+Header\+Codes(), and transfer\+Header\+If\+Present().



Referenced by raw\+Remove(), and proxygen\+::\+H\+T\+T\+P\+Message\+::strip\+Per\+Hop\+Headers().


\begin{DoxyCode}
268                                                             \{
269   \textcolor{keywordtype}{int} len;
270   forEachValueOfHeader(HTTP\_HEADER\_CONNECTION, [&]
271                        (\textcolor{keyword}{const} \textcolor{keywordtype}{string}& stdStr) -> \textcolor{keywordtype}{bool} \{
272     \textcolor{comment}{// Remove all headers specified in Connection header}
273     \textcolor{comment}{// look for multiple values separated by commas}
274     \textcolor{keywordtype}{char} \textcolor{keyword}{const}* str = stdStr.c\_str();
275 
276     \textcolor{comment}{// skip leading whitespace}
277     \textcolor{keywordflow}{while} (isLWS(*str)) str++;
278 
279     \textcolor{keywordflow}{while} (*str != 0) \{
280       \textcolor{keywordtype}{char} \textcolor{keyword}{const}* pos = strchr(str, \textcolor{charliteral}{','});
281       \textcolor{keywordflow}{if} (pos == \textcolor{keyword}{nullptr}) \{
282         \textcolor{comment}{// last (or only) token, done}
283 
284         \textcolor{comment}{// count chars in the token}
285         len = 0;
286         \textcolor{keywordflow}{while} (str[len] != 0 && !isLWS(str[len])) len++;
287         \textcolor{keywordflow}{if} (len > 0) \{
288           \textcolor{keywordtype}{string} hdr(str, len);
289           \textcolor{keywordflow}{if} (transferHeaderIfPresent(hdr, strippedHeaders)) \{
290             VLOG(3) << \textcolor{stringliteral}{"Stripped connection-named hop-by-hop header "} << hdr;
291           \}
292         \}
293         \textcolor{keywordflow}{break};
294       \}
295       len = pos - str;
296       \textcolor{comment}{// strip trailing whitespace}
297       \textcolor{keywordflow}{while} (len > 0 && isLWS(str[len - 1])) len--;
298       \textcolor{keywordflow}{if} (len > 0) \{
299         \textcolor{comment}{// non-empty token}
300         \textcolor{keywordtype}{string} hdr(str, len);
301         \textcolor{keywordflow}{if} (transferHeaderIfPresent(hdr, strippedHeaders)) \{
302           VLOG(3) << \textcolor{stringliteral}{"Stripped connection-named hop-by-hop header "} << hdr;
303         \}
304       \} \textcolor{comment}{// else empty token, no-op}
305       str = pos + 1;
306 
307       \textcolor{comment}{// skip whitespace}
308       \textcolor{keywordflow}{while} (isLWS(*str)) str++;
309     \}
310     \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \textcolor{comment}{// continue processing "connection" headers}
311   \});
312 
313   \textcolor{comment}{// Strip hop-by-hop headers}
314   \textcolor{keyword}{auto}& perHopHeaders = perHopHeaderCodes();
315   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{size\_t} i = 0; i < codes_.size(); ++i) \{
316     \textcolor{keywordflow}{if} (perHopHeaders[codes_[i]]) \{
317       strippedHeaders.codes\_.push\_back(codes_[i]);
318       strippedHeaders.headerNames\_.push\_back(headerNames_[i]);
319       strippedHeaders.headerValues\_.push\_back(headerValues_[i]);
320       codes_[i] = HTTP_HEADER_NONE;
321       ++deletedCount_;
322       VLOG(5) << \textcolor{stringliteral}{"Stripped hop-by-hop header "} << *headerNames_[i];
323     \}
324   \}
325 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!transfer\+Header\+If\+Present@{transfer\+Header\+If\+Present}}
\index{transfer\+Header\+If\+Present@{transfer\+Header\+If\+Present}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{transfer\+Header\+If\+Present(folly\+::\+String\+Piece name, H\+T\+T\+P\+Headers \&dest)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P\+Headers\+::transfer\+Header\+If\+Present (
\begin{DoxyParamCaption}
\item[{folly\+::\+String\+Piece}]{name, }
\item[{{\bf H\+T\+T\+P\+Headers} \&}]{dest}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPHeaders_a95a23c2e396845f6208fdc21276d28f6}
Moves the named header and values from this group to the destination group. No-\/op if the header doesn\textquotesingle{}t exist. Returns true if header(s) were moved. 

Definition at line 239 of file H\+T\+T\+P\+Headers.\+cpp.



References codes\+\_\+, deleted\+Count\+\_\+, proxygen\+::\+H\+T\+T\+P\+Common\+Headers\+::hash(), header\+Names\+\_\+, header\+Values\+\_\+, proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+N\+O\+NE, proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER, I\+T\+E\+R\+A\+T\+E\+\_\+\+O\+V\+E\+R\+\_\+\+C\+O\+D\+ES, and I\+T\+E\+R\+A\+T\+E\+\_\+\+O\+V\+E\+R\+\_\+\+S\+T\+R\+I\+N\+GS.



Referenced by strip\+Per\+Hop\+Headers().


\begin{DoxyCode}
240                                                                    \{
241   \textcolor{keywordtype}{bool} transferred = \textcolor{keyword}{false};
242   \textcolor{keyword}{const} HTTPHeaderCode code = HTTPCommonHeaders::hash(name.data(),
243                                                       name.size());
244   \textcolor{keywordflow}{if} (code == HTTP_HEADER_OTHER) \{
245     ITERATE_OVER_STRINGS(name, \{
246       strippedHeaders.codes\_.push\_back(HTTP_HEADER_OTHER);
247       \textcolor{comment}{// in the next line, ownership of pointer goes to strippedHeaders}
248       strippedHeaders.headerNames\_.push\_back(headerNames_[pos]);
249       strippedHeaders.headerValues\_.push\_back(headerValues_[pos]);
250       codes_[pos] = HTTP_HEADER_NONE;
251       transferred = \textcolor{keyword}{true};
252       ++deletedCount_;
253     \});
254   \} \textcolor{keywordflow}{else} \{ \textcolor{comment}{// code != HTTP\_HEADER\_OTHER}
255     ITERATE_OVER_CODES(code, \{
256       strippedHeaders.codes\_.push\_back(code);
257       strippedHeaders.headerNames\_.push\_back(headerNames_[pos]);
258       strippedHeaders.headerValues\_.push\_back(headerValues_[pos]);
259       codes_[pos] = HTTP_HEADER_NONE;
260       transferred = \textcolor{keyword}{true};
261       ++deletedCount_;
262     \});
263   \}
264   \textcolor{keywordflow}{return} transferred;
265 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!codes\+\_\+@{codes\+\_\+}}
\index{codes\+\_\+@{codes\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{codes\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::fbvector$<${\bf H\+T\+T\+P\+Header\+Code}$>$ proxygen\+::\+H\+T\+T\+P\+Headers\+::codes\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPHeaders_abf05cdad361221fd42c1da90e43fdb12}


Definition at line 271 of file H\+T\+T\+P\+Headers.\+h.



Referenced by add(), add\+From\+Codec(), copy\+To(), dispose\+Of\+Header\+Names(), exists(), for\+Each(), for\+Each\+With\+Code(), H\+T\+T\+P\+Headers(), operator=(), remove(), remove\+All(), remove\+All\+Versions(), remove\+By\+Predicate(), size(), strip\+Per\+Hop\+Headers(), and transfer\+Header\+If\+Present().

\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!C\+O\+M\+B\+I\+N\+E\+\_\+\+S\+E\+P\+A\+R\+A\+T\+OR@{C\+O\+M\+B\+I\+N\+E\+\_\+\+S\+E\+P\+A\+R\+A\+T\+OR}}
\index{C\+O\+M\+B\+I\+N\+E\+\_\+\+S\+E\+P\+A\+R\+A\+T\+OR@{C\+O\+M\+B\+I\+N\+E\+\_\+\+S\+E\+P\+A\+R\+A\+T\+OR}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{C\+O\+M\+B\+I\+N\+E\+\_\+\+S\+E\+P\+A\+R\+A\+T\+OR}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string proxygen\+::\+H\+T\+T\+P\+Headers\+::\+C\+O\+M\+B\+I\+N\+E\+\_\+\+S\+E\+P\+A\+R\+A\+T\+OR = \char`\"{}, \char`\"{}\hspace{0.3cm}{\ttfamily [static]}}\label{classproxygen_1_1HTTPHeaders_aab918956a96d5f2ad6f789af8f19bf72}


Definition at line 92 of file H\+T\+T\+P\+Headers.\+h.

\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!deleted\+Count\+\_\+@{deleted\+Count\+\_\+}}
\index{deleted\+Count\+\_\+@{deleted\+Count\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{deleted\+Count\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P\+Headers\+::deleted\+Count\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPHeaders_aa6fc6076c9cc053be36944365f80e100}


Definition at line 281 of file H\+T\+T\+P\+Headers.\+h.



Referenced by operator=(), remove(), remove\+All(), remove\+All\+Versions(), remove\+By\+Predicate(), size(), strip\+Per\+Hop\+Headers(), and transfer\+Header\+If\+Present().

\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!header\+Names\+\_\+@{header\+Names\+\_\+}}
\index{header\+Names\+\_\+@{header\+Names\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{header\+Names\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::fbvector$<$const std\+::string $\ast$$>$ proxygen\+::\+H\+T\+T\+P\+Headers\+::header\+Names\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPHeaders_a16e92e2c116d7b97d029d611f49ec40a}
Vector storing pointers to header names; we own those pointers which correspond to H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER codes. 

Definition at line 277 of file H\+T\+T\+P\+Headers.\+h.



Referenced by add(), add\+From\+Codec(), copy\+To(), dispose\+Of\+Header\+Names(), for\+Each(), for\+Each\+With\+Code(), H\+T\+T\+P\+Headers(), operator=(), remove(), remove\+All(), remove\+All\+Versions(), remove\+By\+Predicate(), strip\+Per\+Hop\+Headers(), and transfer\+Header\+If\+Present().

\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!header\+Values\+\_\+@{header\+Values\+\_\+}}
\index{header\+Values\+\_\+@{header\+Values\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{header\+Values\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::fbvector$<$std\+::string$>$ proxygen\+::\+H\+T\+T\+P\+Headers\+::header\+Values\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPHeaders_a873147c7d97f5e18530b5c8c6fd8e6a5}


Definition at line 279 of file H\+T\+T\+P\+Headers.\+h.



Referenced by add(), add\+From\+Codec(), copy\+To(), for\+Each(), for\+Each\+Value\+Of\+Header(), for\+Each\+With\+Code(), H\+T\+T\+P\+Headers(), operator=(), remove\+All(), remove\+By\+Predicate(), strip\+Per\+Hop\+Headers(), and transfer\+Header\+If\+Present().

\index{proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}!k\+Initial\+Vector\+Reserve@{k\+Initial\+Vector\+Reserve}}
\index{k\+Initial\+Vector\+Reserve@{k\+Initial\+Vector\+Reserve}!proxygen\+::\+H\+T\+T\+P\+Headers@{proxygen\+::\+H\+T\+T\+P\+Headers}}
\subsubsection[{k\+Initial\+Vector\+Reserve}]{\setlength{\rightskip}{0pt plus 5cm}const size\+\_\+t proxygen\+::\+H\+T\+T\+P\+Headers\+::k\+Initial\+Vector\+Reserve = 16\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTPHeaders_a382e84d469777626c4cb74c6623827f0}
The initial capacity of the three vectors, reserved right after construction. 

Definition at line 287 of file H\+T\+T\+P\+Headers.\+h.



Referenced by H\+T\+T\+P\+Headers().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
proxygen/lib/http/{\bf H\+T\+T\+P\+Headers.\+h}\item 
proxygen/lib/http/{\bf H\+T\+T\+P\+Headers.\+cpp}\end{DoxyCompactItemize}
