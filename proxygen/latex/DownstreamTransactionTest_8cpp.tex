\section{proxygen/lib/http/session/test/\+Downstream\+Transaction\+Test.cpp File Reference}
\label{DownstreamTransactionTest_8cpp}\index{proxygen/lib/http/session/test/\+Downstream\+Transaction\+Test.\+cpp@{proxygen/lib/http/session/test/\+Downstream\+Transaction\+Test.\+cpp}}
{\ttfamily \#include $<$folly/io/async/\+Event\+Base.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/\+S\+P\+D\+Y\+Constants.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/test/\+Mock\+H\+T\+T\+P\+Codec.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/codec/test/\+Test\+Utils.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/session/test/\+H\+T\+T\+P\+Session\+Mocks.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/session/test/\+H\+T\+T\+P\+Transaction\+Mocks.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/test/\+Test\+Async\+Transport.\+h$>$}\\*
{\ttfamily \#include $<$folly/io/async/test/\+Mock\+Async\+Transport.\+h$>$}\\*
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class {\bf Downstream\+Transaction\+Test}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Downstream\+Transaction\+Test}, Simple\+Callback\+Forwarding)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Downstream\+Transaction\+Test}, Regular\+Window\+Update)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Downstream\+Transaction\+Test}, No\+Window\+Update)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Downstream\+Transaction\+Test}, Expecting\+Window\+Update)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Downstream\+Transaction\+Test}, No\+Window\+Update\+After\+Done\+Sending)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Downstream\+Transaction\+Test}, Window\+Increase)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Downstream\+Transaction\+Test}, Window\+Decrease)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Downstream\+Transaction\+Test}, Parse\+Error\+Cbs)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Downstream\+Transaction\+Test}, Detach\+From\+Notify)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Downstream\+Transaction\+Test}, Deferred\+Egress)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Downstream\+Transaction\+Test}, Internal\+Error)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf Downstream\+Transaction\+Test}, Unpaused\+Flow\+Control\+Violation)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{Downstream\+Transaction\+Test.\+cpp@{Downstream\+Transaction\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Downstream\+Transaction\+Test.\+cpp@{Downstream\+Transaction\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Downstream\+Transaction\+Test, Simple\+Callback\+Forwarding)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Downstream\+Transaction\+Test}}]{, }
\item[{Simple\+Callback\+Forwarding}]{}
\end{DoxyParamCaption}
)}\label{DownstreamTransactionTest_8cpp_a951c215b9176c8fc5df67866a6b29326}
Test that the the transaction properly forwards callbacks to the handler and that it interacts with its transport as expected. 

Definition at line 113 of file Downstream\+Transaction\+Test.\+cpp.



References proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, and proxygen\+::make\+Get\+Request().


\begin{DoxyCode}
113                                                             \{
114   \textcolor{comment}{// flow control is disabled}
115   HTTPTransaction txn(
116     TransportDirection::DOWNSTREAM,
117     HTTPCodec::StreamID(1), 1, transport\_,
118     txnEgressQueue\_, transactionTimeouts\_.get(),
119     std::chrono::milliseconds(500));
120   setupRequestResponseFlow(&txn, 100);
121 
122   txn.onIngressHeadersComplete(makeGetRequest());
123   eventBase\_.loop();
124 \}
\end{DoxyCode}
\index{Downstream\+Transaction\+Test.\+cpp@{Downstream\+Transaction\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Downstream\+Transaction\+Test.\+cpp@{Downstream\+Transaction\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Downstream\+Transaction\+Test, Regular\+Window\+Update)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Downstream\+Transaction\+Test}}]{, }
\item[{Regular\+Window\+Update}]{}
\end{DoxyParamCaption}
)}\label{DownstreamTransactionTest_8cpp_af82408174843a958607e7e8b3b8c5b74}
Testing that we\textquotesingle{}re sending a window update for simple requests 

Definition at line 129 of file Downstream\+Transaction\+Test.\+cpp.



References proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, proxygen\+::spdy\+::k\+Initial\+Window, and proxygen\+::make\+Get\+Request().


\begin{DoxyCode}
129                                                        \{
130   HTTPTransaction txn(
131     TransportDirection::DOWNSTREAM,
132     HTTPCodec::StreamID(1), 1, transport\_,
133     txnEgressQueue\_, transactionTimeouts\_.get(),
134     std::chrono::milliseconds(500),
135     \textcolor{keyword}{nullptr},
136     \textcolor{keyword}{true}, \textcolor{comment}{// flow control enabled}
137     400,
138     spdy::kInitialWindow);
139   uint32\_t reqBodySize = 220;
140   setupRequestResponseFlow(&txn, reqBodySize);
141 
142   \textcolor{comment}{// test that the window update is generated}
143   EXPECT\_CALL(transport\_, sendWindowUpdate(\_, reqBodySize));
144 
145   \textcolor{comment}{// run the test}
146   txn.onIngressHeadersComplete(makeGetRequest());
147   eventBase\_.loop();
148 \}
\end{DoxyCode}
\index{Downstream\+Transaction\+Test.\+cpp@{Downstream\+Transaction\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Downstream\+Transaction\+Test.\+cpp@{Downstream\+Transaction\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Downstream\+Transaction\+Test, No\+Window\+Update)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Downstream\+Transaction\+Test}}]{, }
\item[{No\+Window\+Update}]{}
\end{DoxyParamCaption}
)}\label{DownstreamTransactionTest_8cpp_af092746c74b4942f5e27d47950f5835b}


Definition at line 150 of file Downstream\+Transaction\+Test.\+cpp.



References proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, proxygen\+::spdy\+::k\+Initial\+Window, proxygen\+::make\+Buf(), proxygen\+::make\+Get\+Request(), and proxygen\+::make\+Response().


\begin{DoxyCode}
150                                                   \{
151   HTTPTransaction txn(
152     TransportDirection::DOWNSTREAM,
153     HTTPCodec::StreamID(1), 1, transport\_,
154     txnEgressQueue\_, transactionTimeouts\_.get(),
155     std::chrono::milliseconds(500),
156     \textcolor{keyword}{nullptr},
157     \textcolor{keyword}{true}, \textcolor{comment}{// flow control enabled}
158     450, \textcolor{comment}{// more than 2x req size}
159     spdy::kInitialWindow);
160   uint32\_t reqBodySize = 220;
161   setupRequestResponseFlow(&txn, reqBodySize, \textcolor{keyword}{true});
162 
163   EXPECT\_CALL(transport\_, sendWindowUpdate(\_, reqBodySize))
164     .Times(0);
165 
166   \textcolor{comment}{// run the test}
167   txn.onIngressHeadersComplete(makeGetRequest());
168   txn.onIngressBody(makeBuf(reqBodySize), 0);
169   txn.onIngressEOM();
170   \textcolor{keyword}{auto} response = makeResponse(200);
171   txn.sendHeaders(*response.get());
172   txn.sendBody(makeBuf(reqBodySize));
173   txn.sendEOM();
174   eventBase\_.loop();
175 \}
\end{DoxyCode}
\index{Downstream\+Transaction\+Test.\+cpp@{Downstream\+Transaction\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Downstream\+Transaction\+Test.\+cpp@{Downstream\+Transaction\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Downstream\+Transaction\+Test, Expecting\+Window\+Update)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Downstream\+Transaction\+Test}}]{, }
\item[{Expecting\+Window\+Update}]{}
\end{DoxyParamCaption}
)}\label{DownstreamTransactionTest_8cpp_a931f267896c053197be7b236d11c6b56}


Definition at line 177 of file Downstream\+Transaction\+Test.\+cpp.



References proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, proxygen\+::make\+Buf(), proxygen\+::make\+Get\+Request(), proxygen\+::make\+Response(), and proxygen\+::\+H\+T\+T\+P\+Transaction\+::on\+Ingress\+Headers\+Complete().


\begin{DoxyCode}
177                                                          \{
178   HTTPTransaction txn(
179     TransportDirection::DOWNSTREAM,
180     HTTPCodec::StreamID(1), 1, transport\_,
181     txnEgressQueue\_, transactionTimeouts\_.get(),
182     std::chrono::milliseconds(157784760000),
183     \textcolor{keyword}{nullptr},
184     \textcolor{keyword}{true},
185     450,
186     100);
187   uint32\_t reqBodySize = 220;
188 
189   \textcolor{comment}{// Get a request, pause ingress, fill up the sendWindow, then expect for a}
190   \textcolor{comment}{// timeout to be scheduled.}
191   txn.onIngressHeadersComplete(makeGetRequest());
192   txn.pauseIngress();
193   txn.onIngressBody(makeBuf(reqBodySize), 0);
194   txn.onIngressEOM();
195   \textcolor{keyword}{auto} response = makeResponse(200);
196   txn.sendHeaders(*response.get());
197   txn.sendBody(makeBuf(reqBodySize));
198   txn.sendEOM();
199   txn.onWriteReady(1000, 1);
200   EXPECT\_EQ(transactionTimeouts\_->count(), 1);
201 \}
\end{DoxyCode}
\index{Downstream\+Transaction\+Test.\+cpp@{Downstream\+Transaction\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Downstream\+Transaction\+Test.\+cpp@{Downstream\+Transaction\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Downstream\+Transaction\+Test, No\+Window\+Update\+After\+Done\+Sending)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Downstream\+Transaction\+Test}}]{, }
\item[{No\+Window\+Update\+After\+Done\+Sending}]{}
\end{DoxyParamCaption}
)}\label{DownstreamTransactionTest_8cpp_ae2ef1f1fb7720f1d7198a424a57f03ce}


Definition at line 203 of file Downstream\+Transaction\+Test.\+cpp.



References proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, proxygen\+::make\+Buf(), proxygen\+::make\+Get\+Request(), proxygen\+::make\+Response(), and proxygen\+::\+H\+T\+T\+P\+Transaction\+::on\+Ingress\+Headers\+Complete().


\begin{DoxyCode}
203                                                                   \{
204   HTTPTransaction txn(
205     TransportDirection::DOWNSTREAM,
206     HTTPCodec::StreamID(1), 1, transport\_,
207     txnEgressQueue\_, transactionTimeouts\_.get(),
208     std::chrono::milliseconds(157784760000),
209     \textcolor{keyword}{nullptr},
210     \textcolor{keyword}{true},
211     450,
212     220);
213   uint32\_t reqBodySize = 220;
214 
215   \textcolor{comment}{// Ensure that after flushing an EOM we are not expecting window update.}
216   txn.onIngressHeadersComplete(makeGetRequest());
217   txn.onIngressBody(makeBuf(reqBodySize), 0);
218   \textcolor{keyword}{auto} response = makeResponse(200);
219   txn.sendHeaders(*response.get());
220   txn.sendBody(makeBuf(reqBodySize));
221   txn.sendEOM();
222   txn.onWriteReady(1000, 1);
223   txn.pauseIngress();
224   txn.onIngressEOM();
225   EXPECT\_EQ(transactionTimeouts\_->count(), 0);
226 \}
\end{DoxyCode}
\index{Downstream\+Transaction\+Test.\+cpp@{Downstream\+Transaction\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Downstream\+Transaction\+Test.\+cpp@{Downstream\+Transaction\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Downstream\+Transaction\+Test, Window\+Increase)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Downstream\+Transaction\+Test}}]{, }
\item[{Window\+Increase}]{}
\end{DoxyParamCaption}
)}\label{DownstreamTransactionTest_8cpp_a106175b881765cf0dcdf7391da5f0013}
Testing window increase using window update; we\textquotesingle{}re actually using this in production to avoid bumping the window using the S\+E\+T\+T\+I\+N\+GS frame 

Definition at line 232 of file Downstream\+Transaction\+Test.\+cpp.



References proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, proxygen\+::spdy\+::k\+Initial\+Window, and proxygen\+::make\+Get\+Request().


\begin{DoxyCode}
232                                                   \{
233   \textcolor{comment}{// set initial window size higher than per-stream window}
234   HTTPTransaction txn(
235     TransportDirection::DOWNSTREAM,
236     HTTPCodec::StreamID(1), 1, transport\_,
237     txnEgressQueue\_, transactionTimeouts\_.get(),
238     std::chrono::milliseconds(500),
239     \textcolor{keyword}{nullptr},
240     \textcolor{keyword}{true}, \textcolor{comment}{// flow control enabled}
241     spdy::kInitialWindow,
242     spdy::kInitialWindow);
243   uint32\_t reqSize = 500;
244   setupRequestResponseFlow(&txn, reqSize);
245 
246   \textcolor{comment}{// we expect the difference from the per stream window and the initial window,}
247   \textcolor{comment}{// together with the bytes sent in the request}
248   uint32\_t perStreamWindow = spdy::kInitialWindow + 1024 * 1024;
249   uint32\_t expectedWindowUpdate =
250     perStreamWindow - spdy::kInitialWindow;
251   EXPECT\_CALL(transport\_, sendWindowUpdate(\_, expectedWindowUpdate));
252 
253   \textcolor{comment}{// use a higher window}
254   txn.setReceiveWindow(perStreamWindow);
255 
256   txn.onIngressHeadersComplete(makeGetRequest());
257   eventBase\_.loop();
258 \}
\end{DoxyCode}
\index{Downstream\+Transaction\+Test.\+cpp@{Downstream\+Transaction\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Downstream\+Transaction\+Test.\+cpp@{Downstream\+Transaction\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Downstream\+Transaction\+Test, Window\+Decrease)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Downstream\+Transaction\+Test}}]{, }
\item[{Window\+Decrease}]{}
\end{DoxyParamCaption}
)}\label{DownstreamTransactionTest_8cpp_afdb0f865ed98c6d8c3ec15603121286d}
Testing that we\textquotesingle{}re not sending window update when per-\/stream window size is smaller than the initial window size 

Definition at line 264 of file Downstream\+Transaction\+Test.\+cpp.



References proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, proxygen\+::spdy\+::k\+Initial\+Window, and proxygen\+::make\+Get\+Request().


\begin{DoxyCode}
264                                                   \{
265   \textcolor{comment}{// set initial window size higher than per-stream window}
266   HTTPTransaction txn(
267     TransportDirection::DOWNSTREAM,
268     HTTPCodec::StreamID(1), 1, transport\_,
269     txnEgressQueue\_, transactionTimeouts\_.get(),
270     std::chrono::milliseconds(500),
271     \textcolor{keyword}{nullptr},
272     \textcolor{keyword}{true}, \textcolor{comment}{// flow control enabled}
273     spdy::kInitialWindow,
274     spdy::kInitialWindow);
275   setupRequestResponseFlow(&txn, 500);
276 
277   \textcolor{comment}{// in this case, there should be no window update, as we decrease the window}
278   \textcolor{comment}{// below the number of bytes we're sending}
279   EXPECT\_CALL(transport\_, sendWindowUpdate(\_, \_)).Times(0);
280 
281   \textcolor{comment}{// use a smaller window}
282   uint32\_t perStreamWindow = spdy::kInitialWindow - 1000;
283   txn.setReceiveWindow(perStreamWindow);
284 
285   txn.onIngressHeadersComplete(makeGetRequest());
286   eventBase\_.loop();
287 \}
\end{DoxyCode}
\index{Downstream\+Transaction\+Test.\+cpp@{Downstream\+Transaction\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Downstream\+Transaction\+Test.\+cpp@{Downstream\+Transaction\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Downstream\+Transaction\+Test, Parse\+Error\+Cbs)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Downstream\+Transaction\+Test}}]{, }
\item[{Parse\+Error\+Cbs}]{}
\end{DoxyParamCaption}
)}\label{DownstreamTransactionTest_8cpp_aeb23f50d131dc8186d5361a69f096e1a}


Definition at line 289 of file Downstream\+Transaction\+Test.\+cpp.



References proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, proxygen\+::\+H\+T\+T\+P\+Exception\+::get\+Direction(), proxygen\+::\+H\+T\+T\+P\+Exception\+::\+I\+N\+G\+R\+E\+SS, proxygen\+::make\+Buf(), and proxygen\+::\+Exception\+::what().


\begin{DoxyCode}
289                                                  \{
290   \textcolor{comment}{// Test where the transaction gets on parse error and then a body}
291   \textcolor{comment}{// callback. This is possible because codecs are stateless between}
292   \textcolor{comment}{// frames.}
293 
294   HTTPTransaction txn(
295     TransportDirection::DOWNSTREAM,
296     HTTPCodec::StreamID(1), 1, transport\_,
297     txnEgressQueue\_, transactionTimeouts\_.get(),
298     std::chrono::milliseconds(500));
299 
300   HTTPException err(HTTPException::Direction::INGRESS, \textcolor{stringliteral}{"test"});
301   err.setHttpStatusCode(400);
302 
303   InSequence dummy;
304 
305   EXPECT\_CALL(handler\_, setTransaction(&txn));
306   EXPECT\_CALL(handler\_, onError(\_))
307     .WillOnce(Invoke([] (\textcolor{keyword}{const} HTTPException& ex) \{
308           ASSERT\_EQ(ex.getDirection(), HTTPException::Direction::INGRESS);
309           ASSERT\_EQ(std::string(ex.what()), \textcolor{stringliteral}{"test"});
310         \}));
311   \textcolor{comment}{// onBody() is suppressed since ingress is complete after ingress onError()}
312   \textcolor{comment}{// onEOM() is suppressed since ingress is complete after ingress onError()}
313   EXPECT\_CALL(transport\_, sendAbort(\_, \_));
314   EXPECT\_CALL(handler\_, detachTransaction());
315   EXPECT\_CALL(transport\_, detach(&txn));
316 
317   txn.setHandler(&handler\_);
318   txn.onError(err);
319   \textcolor{comment}{// Since the transaction is already closed for ingress, giving it}
320   \textcolor{comment}{// ingress body causes the transaction to be aborted and closed}
321   \textcolor{comment}{// immediately.}
322   txn.onIngressBody(makeBuf(10), 0);
323 
324   eventBase\_.loop();
325 \}
\end{DoxyCode}
\index{Downstream\+Transaction\+Test.\+cpp@{Downstream\+Transaction\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Downstream\+Transaction\+Test.\+cpp@{Downstream\+Transaction\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Downstream\+Transaction\+Test, Detach\+From\+Notify)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Downstream\+Transaction\+Test}}]{, }
\item[{Detach\+From\+Notify}]{}
\end{DoxyParamCaption}
)}\label{DownstreamTransactionTest_8cpp_a8add580a1b9d3042ab8442751d88fea1}


Definition at line 327 of file Downstream\+Transaction\+Test.\+cpp.



References proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Status\+Code(), proxygen\+::\+H\+T\+T\+P\+Exception\+::\+I\+N\+G\+R\+E\+S\+S\+\_\+\+A\+N\+D\+\_\+\+E\+G\+R\+E\+SS, proxygen\+::make\+Buf(), proxygen\+::make\+Get\+Request(), and proxygen\+::make\+Response().


\begin{DoxyCode}
327                                                     \{
328   unique\_ptr<StrictMock<MockHTTPHandler>> handler(
329     \textcolor{keyword}{new} StrictMock<MockHTTPHandler>);
330 
331   HTTPTransaction txn(
332     TransportDirection::DOWNSTREAM,
333     HTTPCodec::StreamID(1), 1, transport\_,
334     txnEgressQueue\_, transactionTimeouts\_.get(),
335     std::chrono::milliseconds(500));
336 
337   InSequence dummy;
338 
339   EXPECT\_CALL(*handler, setTransaction(&txn));
340   EXPECT\_CALL(*handler, onHeadersComplete(\_))
341       .WillOnce(Invoke([&](std::shared\_ptr<HTTPMessage> \textcolor{comment}{/*msg*/}) \{
342         \textcolor{keyword}{auto} response = makeResponse(200);
343         txn.sendHeaders(*response.get());
344         txn.sendBody(makeBuf(10));
345       \}));
346   EXPECT\_CALL(transport\_, sendHeaders(&txn, \_, \_, \_))
347     .WillOnce(Invoke([&](Unused, \textcolor{keyword}{const} HTTPMessage& headers, Unused, Unused) \{
348           EXPECT\_EQ(headers.getStatusCode(), 200);
349         \}));
350   EXPECT\_CALL(transport\_, notifyEgressBodyBuffered(10));
351   EXPECT\_CALL(transport\_, notifyEgressBodyBuffered(-10))
352     .WillOnce(InvokeWithoutArgs([&] () \{
353           txn.setHandler(\textcolor{keyword}{nullptr});
354           handler.reset();
355         \}));
356   EXPECT\_CALL(transport\_, detach(&txn));
357 
358   HTTPException err(HTTPException::Direction::INGRESS\_AND\_EGRESS, \textcolor{stringliteral}{"test"});
359 
360   txn.setHandler(handler.get());
361   txn.onIngressHeadersComplete(makeGetRequest());
362   txn.onError(err);
363 \}
\end{DoxyCode}
\index{Downstream\+Transaction\+Test.\+cpp@{Downstream\+Transaction\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Downstream\+Transaction\+Test.\+cpp@{Downstream\+Transaction\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Downstream\+Transaction\+Test, Deferred\+Egress)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Downstream\+Transaction\+Test}}]{, }
\item[{Deferred\+Egress}]{}
\end{DoxyParamCaption}
)}\label{DownstreamTransactionTest_8cpp_ac3853d5fea858bfdd615e419f56b9874}


Definition at line 365 of file Downstream\+Transaction\+Test.\+cpp.



References proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Status\+Code(), proxygen\+::\+H\+T\+T\+P\+Exception\+::\+I\+N\+G\+R\+E\+S\+S\+\_\+\+A\+N\+D\+\_\+\+E\+G\+R\+E\+SS, proxygen\+::make\+Buf(), proxygen\+::make\+Get\+Request(), and proxygen\+::make\+Response().


\begin{DoxyCode}
365                                                   \{
366   EXPECT\_CALL(transport\_, describe(\_))
367     .WillRepeatedly(Return());
368   EXPECT\_CALL(transport\_, notifyPendingEgress())
369     .WillRepeatedly(Return());
370 
371   HTTPTransaction txn(
372     TransportDirection::DOWNSTREAM,
373     HTTPCodec::StreamID(1), 1, transport\_,
374     txnEgressQueue\_, transactionTimeouts\_.get(),
375     std::chrono::milliseconds(500),
376     \textcolor{keyword}{nullptr}, \textcolor{keyword}{true}, 10, 10);
377 
378   InSequence dummy;
379 
380   EXPECT\_CALL(handler\_, setTransaction(&txn));
381   EXPECT\_CALL(handler\_, onHeadersComplete(\_))
382       .WillOnce(Invoke([&](std::shared\_ptr<HTTPMessage> \textcolor{comment}{/*msg*/}) \{
383         \textcolor{keyword}{auto} response = makeResponse(200);
384         txn.sendHeaders(*response.get());
385         txn.sendBody(makeBuf(10));
386         txn.sendBody(makeBuf(20));
387       \}));
388   EXPECT\_CALL(transport\_, sendHeaders(&txn, \_, \_, \_))
389     .WillOnce(Invoke([&](Unused, \textcolor{keyword}{const} HTTPMessage& headers, Unused, Unused) \{
390           EXPECT\_EQ(headers.getStatusCode(), 200);
391         \}));
392 
393   \textcolor{comment}{// when enqueued}
394   EXPECT\_CALL(transport\_, notifyEgressBodyBuffered(10));
395   EXPECT\_CALL(handler\_, onEgressPaused());
396   \textcolor{comment}{// sendBody}
397   EXPECT\_CALL(transport\_, notifyEgressBodyBuffered(20));
398 
399   txn.setHandler(&handler\_);
400   txn.onIngressHeadersComplete(makeGetRequest());
401 
402   \textcolor{comment}{// onWriteReady, send, then dequeue (SPDY window now full)}
403   EXPECT\_CALL(transport\_, notifyEgressBodyBuffered(-20));
404 
405   EXPECT\_EQ(txn.onWriteReady(20, 1), \textcolor{keyword}{false});
406 
407   \textcolor{comment}{// enqueued after window update}
408   EXPECT\_CALL(transport\_, notifyEgressBodyBuffered(20));
409 
410   txn.onIngressWindowUpdate(20);
411 
412   \textcolor{comment}{// Buffer released on error}
413   EXPECT\_CALL(transport\_, notifyEgressBodyBuffered(-20));
414   EXPECT\_CALL(handler\_, onError(\_));
415   EXPECT\_CALL(handler\_, detachTransaction());
416   EXPECT\_CALL(transport\_, detach(&txn));
417 
418   HTTPException err(HTTPException::Direction::INGRESS\_AND\_EGRESS, \textcolor{stringliteral}{"test"});
419   txn.onError(err);
420 \}
\end{DoxyCode}
\index{Downstream\+Transaction\+Test.\+cpp@{Downstream\+Transaction\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Downstream\+Transaction\+Test.\+cpp@{Downstream\+Transaction\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Downstream\+Transaction\+Test, Internal\+Error)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Downstream\+Transaction\+Test}}]{, }
\item[{Internal\+Error}]{}
\end{DoxyParamCaption}
)}\label{DownstreamTransactionTest_8cpp_acd0fc7ecc2d7004cbe1f15b6a3c61876}


Definition at line 422 of file Downstream\+Transaction\+Test.\+cpp.



References proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Status\+Code(), proxygen\+::\+H\+T\+T\+P\+Exception\+::\+I\+N\+G\+R\+E\+S\+S\+\_\+\+A\+N\+D\+\_\+\+E\+G\+R\+E\+SS, proxygen\+::\+I\+N\+T\+E\+R\+N\+A\+L\+\_\+\+E\+R\+R\+OR, proxygen\+::make\+Get\+Request(), and proxygen\+::make\+Response().


\begin{DoxyCode}
422                                                  \{
423   unique\_ptr<StrictMock<MockHTTPHandler>> handler(
424     \textcolor{keyword}{new} StrictMock<MockHTTPHandler>);
425 
426   HTTPTransaction txn(
427     TransportDirection::DOWNSTREAM,
428     HTTPCodec::StreamID(1), 1, transport\_,
429     txnEgressQueue\_, transactionTimeouts\_.get(),
430     std::chrono::milliseconds(500));
431 
432   InSequence dummy;
433 
434   EXPECT\_CALL(*handler, setTransaction(&txn));
435   EXPECT\_CALL(*handler, onHeadersComplete(\_))
436       .WillOnce(Invoke([&](std::shared\_ptr<HTTPMessage> \textcolor{comment}{/*msg*/}) \{
437         \textcolor{keyword}{auto} response = makeResponse(200);
438         txn.sendHeaders(*response.get());
439       \}));
440   EXPECT\_CALL(transport\_, sendHeaders(&txn, \_, \_, \_))
441     .WillOnce(Invoke([&](Unused, \textcolor{keyword}{const} HTTPMessage& headers, Unused, Unused) \{
442           EXPECT\_EQ(headers.getStatusCode(), 200);
443         \}));
444   EXPECT\_CALL(transport\_, sendAbort(&txn, ErrorCode::INTERNAL\_ERROR));
445   EXPECT\_CALL(*handler, detachTransaction());
446   EXPECT\_CALL(transport\_, detach(&txn));
447 
448   HTTPException err(HTTPException::Direction::INGRESS\_AND\_EGRESS, \textcolor{stringliteral}{"test"});
449 
450   txn.setHandler(handler.get());
451   txn.onIngressHeadersComplete(makeGetRequest());
452   txn.sendAbort();
453 \}
\end{DoxyCode}
\index{Downstream\+Transaction\+Test.\+cpp@{Downstream\+Transaction\+Test.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!Downstream\+Transaction\+Test.\+cpp@{Downstream\+Transaction\+Test.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+Downstream\+Transaction\+Test, Unpaused\+Flow\+Control\+Violation)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf Downstream\+Transaction\+Test}}]{, }
\item[{Unpaused\+Flow\+Control\+Violation}]{}
\end{DoxyParamCaption}
)}\label{DownstreamTransactionTest_8cpp_a671e6fc922b171b07e735e37d370220a}


Definition at line 455 of file Downstream\+Transaction\+Test.\+cpp.



References proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, proxygen\+::\+F\+L\+O\+W\+\_\+\+C\+O\+N\+T\+R\+O\+L\+\_\+\+E\+R\+R\+OR, proxygen\+::spdy\+::k\+Initial\+Window, proxygen\+::make\+Buf(), and proxygen\+::make\+Post\+Request().


\begin{DoxyCode}
455                                                                 \{
456   StrictMock<MockHTTPHandler> handler;
457 
458   InSequence enforceOrder;
459   HTTPTransaction txn(
460     TransportDirection::DOWNSTREAM,
461     HTTPCodec::StreamID(1), 1, transport\_,
462     txnEgressQueue\_, transactionTimeouts\_.get(),
463     std::chrono::milliseconds(500),
464     \textcolor{keyword}{nullptr},
465     \textcolor{keyword}{true}, \textcolor{comment}{// flow control enabled}
466     400,
467     spdy::kInitialWindow);
468 
469   EXPECT\_CALL(handler, setTransaction(&txn));
470   EXPECT\_CALL(handler, onHeadersComplete(\_));
471   EXPECT\_CALL(transport\_, sendAbort(&txn, ErrorCode::FLOW\_CONTROL\_ERROR));
472   EXPECT\_CALL(handler, detachTransaction());
473   EXPECT\_CALL(transport\_, detach(&txn));
474 
475   txn.setHandler(&handler);
476   txn.onIngressHeadersComplete(makePostRequest(401));
477   txn.onIngressBody(makeBuf(401), 0);
478 \}
\end{DoxyCode}
