\section{proxygen\+:\+:S\+P\+D\+Y\+Codec Class Reference}
\label{classproxygen_1_1SPDYCodec}\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}


{\ttfamily \#include $<$S\+P\+D\+Y\+Codec.\+h$>$}

Inheritance diagram for proxygen\+:\+:S\+P\+D\+Y\+Codec\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{classproxygen_1_1SPDYCodec}
\end{center}
\end{figure}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct {\bf Setting\+Data}
\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
using {\bf Setting\+List} = std\+::vector$<$ {\bf Setting\+Data} $>$
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf S\+P\+D\+Y\+Codec} ({\bf Transport\+Direction} direction, {\bf S\+P\+D\+Y\+Version} version, int spdy\+Compression\+Level=Z\+\_\+\+N\+O\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+ON)
\item 
{\bf $\sim$\+S\+P\+D\+Y\+Codec} () override
\item 
{\bf Codec\+Protocol} {\bf get\+Protocol} () const override
\item 
const std\+::string \& {\bf get\+User\+Agent} () const override
\item 
bool {\bf supports\+Stream\+Flow\+Control} () const override
\item 
bool {\bf supports\+Session\+Flow\+Control} () const override
\item 
size\+\_\+t {\bf on\+Ingress} (const folly\+::\+I\+O\+Buf \&buf) override
\item 
bool {\bf supports\+Push\+Transactions} () const override
\item 
void {\bf generate\+Header} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} {\bf stream}, const {\bf H\+T\+T\+P\+Message} \&msg, bool eom=false, {\bf H\+T\+T\+P\+Header\+Size} $\ast$size={\bf nullptr}) override
\item 
void {\bf generate\+Push\+Promise} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} {\bf stream}, const {\bf H\+T\+T\+P\+Message} \&msg, {\bf Stream\+ID} assocstream, bool eom=false, {\bf H\+T\+T\+P\+Header\+Size} $\ast$size={\bf nullptr}) override
\item 
size\+\_\+t {\bf generate\+Body} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} {\bf stream}, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ chain, folly\+::\+Optional$<$ uint8\+\_\+t $>$ padding, bool eom) override
\item 
size\+\_\+t {\bf generate\+Chunk\+Header} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} {\bf stream}, size\+\_\+t length) override
\item 
size\+\_\+t {\bf generate\+Chunk\+Terminator} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} {\bf stream}) override
\item 
size\+\_\+t {\bf generate\+Trailers} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} {\bf stream}, const {\bf H\+T\+T\+P\+Headers} \&trailers) override
\item 
size\+\_\+t {\bf generate\+E\+OM} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} {\bf stream}) override
\item 
size\+\_\+t {\bf generate\+Rst\+Stream} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} txn, {\bf Error\+Code} {\bf status\+Code}) override
\item 
size\+\_\+t {\bf generate\+Goaway} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} last\+Stream, {\bf Error\+Code} {\bf status\+Code}, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ debug\+Data={\bf nullptr}) override
\item 
size\+\_\+t {\bf generate\+Ping\+Request} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf) override
\item 
size\+\_\+t {\bf generate\+Ping\+Reply} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint64\+\_\+t unique\+ID) override
\item 
size\+\_\+t {\bf generate\+Settings} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf) override
\item 
size\+\_\+t {\bf generate\+Window\+Update} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} {\bf stream}, uint32\+\_\+t delta) override
\item 
const {\bf H\+T\+T\+P\+Settings} $\ast$ {\bf get\+Ingress\+Settings} () const override
\item 
{\bf H\+T\+T\+P\+Settings} $\ast$ {\bf get\+Egress\+Settings} () override
\item 
uint32\+\_\+t {\bf get\+Default\+Window\+Size} () const override
\item 
uint8\+\_\+t {\bf get\+Version} () const 
\item 
uint8\+\_\+t {\bf get\+Minor\+Version} () const 
\item 
void {\bf set\+Max\+Frame\+Length} (uint32\+\_\+t max\+Frame\+Length)
\item 
void {\bf set\+Max\+Uncompressed\+Headers} (uint32\+\_\+t max\+Uncompressed)
\item 
void {\bf set\+Header\+Codec\+Stats} ({\bf Header\+Codec\+::\+Stats} $\ast$stats) override
\item 
size\+\_\+t {\bf add\+Priority\+Nodes} ({\bf Priority\+Queue} \&queue, folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint8\+\_\+t max\+Level) override
\item 
{\bf Stream\+ID} {\bf map\+Priority\+To\+Dependency} (uint8\+\_\+t priority) const override
\item 
int8\+\_\+t {\bf map\+Dependency\+To\+Priority} ({\bf Stream\+ID} parent) const override
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static const {\bf S\+P\+D\+Y\+Version\+Settings} \& {\bf get\+Version\+Settings} ({\bf S\+P\+D\+Y\+Version} version)
\item 
static folly\+::\+Optional$<$ {\bf S\+P\+D\+Y\+Version} $>$ {\bf get\+Version} (const std\+::string \&protocol)
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const {\bf Stream\+ID} {\bf No\+Stream} = 0
\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
enum {\bf Frame\+State} \{ {\bf F\+R\+A\+M\+E\+\_\+\+H\+E\+A\+D\+ER} = 0, 
{\bf C\+T\+R\+L\+\_\+\+F\+R\+A\+M\+E\+\_\+\+D\+A\+TA} = 1, 
{\bf D\+A\+T\+A\+\_\+\+F\+R\+A\+M\+E\+\_\+\+D\+A\+TA} = 2
 \}
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void {\bf generate\+Syn\+Stream} ({\bf Stream\+ID} {\bf stream}, {\bf Stream\+ID} assoc\+Stream, folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, const {\bf H\+T\+T\+P\+Message} \&msg, bool eom, {\bf H\+T\+T\+P\+Header\+Size} $\ast$size)
\item 
void {\bf generate\+Syn\+Reply} ({\bf Stream\+ID} {\bf stream}, folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, const {\bf H\+T\+T\+P\+Message} \&msg, bool eom, {\bf H\+T\+T\+P\+Header\+Size} $\ast$size)
\item 
size\+\_\+t {\bf generate\+Ping\+Common} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint64\+\_\+t unique\+ID)
\item 
size\+\_\+t {\bf parse\+Ingress} (const folly\+::\+I\+O\+Buf \&buf)
\item 
void {\bf on\+Syn\+Stream} (uint32\+\_\+t assoc\+Stream, uint8\+\_\+t pri, uint8\+\_\+t slot, const {\bf compress\+::\+Header\+Piece\+List} \&headers, const {\bf H\+T\+T\+P\+Header\+Size} \&size)
\item 
void {\bf on\+Syn\+Reply} (const {\bf compress\+::\+Header\+Piece\+List} \&headers, const {\bf H\+T\+T\+P\+Header\+Size} \&size)
\item 
void {\bf on\+Rst\+Stream} (uint32\+\_\+t {\bf status\+Code}) noexcept
\item 
void {\bf on\+Settings} (const {\bf Setting\+List} \&{\bf settings})
\item 
void {\bf on\+Ping} (uint32\+\_\+t unique\+ID) noexcept
\item 
void {\bf on\+Goaway} (uint32\+\_\+t last\+Good\+Stream, uint32\+\_\+t {\bf status\+Code}) noexcept
\item 
void {\bf on\+Headers} (const {\bf compress\+::\+Header\+Piece\+List} \&headers) noexcept
\item 
void {\bf on\+Window\+Update} (uint32\+\_\+t delta) noexcept
\item 
std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Message} $>$ {\bf parse\+Headers} ({\bf Transport\+Direction} direction, {\bf Stream\+ID} {\bf stream\+ID}, {\bf Stream\+ID} assoc\+Stream\+ID, const {\bf compress\+::\+Header\+Piece\+List} \&headers)
\item 
void {\bf on\+Control\+Frame} (folly\+::io\+::\+Cursor \&cursor)
\item 
void {\bf on\+Syn\+Common} ({\bf Stream\+ID} {\bf stream\+ID}, {\bf Stream\+ID} assoc\+Stream\+ID, const {\bf compress\+::\+Header\+Piece\+List} \&headers, int8\+\_\+t pri, const {\bf H\+T\+T\+P\+Header\+Size} \&size)
\item 
void {\bf deliver\+On\+Message\+Begin} ({\bf Stream\+ID} {\bf stream\+ID}, {\bf Stream\+ID} assoc\+Stream\+ID, {\bf H\+T\+T\+P\+Message} $\ast$msg)
\item 
size\+\_\+t {\bf generate\+Data\+Frame} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint32\+\_\+t {\bf stream\+ID}, uint8\+\_\+t {\bf flags}, uint32\+\_\+t length, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ payload)
\item 
std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ {\bf serialize\+Request\+Headers} (const {\bf H\+T\+T\+P\+Message} \&msg, bool is\+Pushed, uint32\+\_\+t headroom=0, {\bf H\+T\+T\+P\+Header\+Size} $\ast$size={\bf nullptr})
\item 
std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ {\bf serialize\+Response\+Headers} (const {\bf H\+T\+T\+P\+Message} \&msg, uint32\+\_\+t headroom=0, {\bf H\+T\+T\+P\+Header\+Size} $\ast$size={\bf nullptr})
\item 
std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ {\bf encode\+Headers} (const {\bf H\+T\+T\+P\+Message} \&msg, std\+::vector$<$ {\bf compress\+::\+Header} $>$ \&headers, uint32\+\_\+t headroom=0, {\bf H\+T\+T\+P\+Header\+Size} $\ast$size={\bf nullptr})
\item 
void {\bf fail\+Stream} (bool new\+Txn, {\bf Stream\+ID} {\bf stream\+ID}, uint32\+\_\+t code, std\+::string exc\+Str={\bf empty\+\_\+string})
\item 
void {\bf fail\+Session} (uint32\+\_\+t {\bf status\+Code})
\item 
{\bf Header\+Decode\+Result} {\bf decode\+Headers} (folly\+::io\+::\+Cursor \&cursor)
\item 
void {\bf check\+Length} (uint32\+\_\+t expected\+Length, const std\+::string \&msg)
\item 
void {\bf check\+Min\+Length} (uint32\+\_\+t min\+Length, const std\+::string \&msg)
\item 
bool {\bf is\+S\+P\+D\+Y\+Reserved} (const std\+::string \&{\bf name})
\item 
bool {\bf rst\+Status\+Supported} (int {\bf status\+Code}) const 
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
folly\+::fbvector$<$ {\bf Stream\+ID} $>$ {\bf closed\+Streams\+\_\+}
\item 
const {\bf S\+P\+D\+Y\+Version\+Settings} \& {\bf version\+Settings\+\_\+}
\item 
{\bf H\+T\+T\+P\+Settings} {\bf ingress\+Settings\+\_\+}
\item 
{\bf H\+T\+T\+P\+Settings} {\bf egress\+Settings\+\_\+}
\item 
std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Message} $>$ {\bf partial\+Msg\+\_\+}
\item 
std\+::string {\bf user\+Agent\+\_\+}
\item 
const folly\+::\+I\+O\+Buf $\ast$ {\bf current\+Ingress\+Buf\+\_\+} \{{\bf nullptr}\}
\item 
{\bf Stream\+ID} {\bf next\+Egress\+Ping\+I\+D\+\_\+}
\item 
uint32\+\_\+t {\bf max\+Frame\+Length\+\_\+} \{{\bf spdy\+::k\+Max\+Frame\+Length}\}
\item 
uint32\+\_\+t {\bf stream\+Id\+\_\+} \{0\}
\item 
uint32\+\_\+t {\bf length\+\_\+} \{0\}
\item 
uint16\+\_\+t {\bf version\+\_\+} \{0\}
\item 
uint16\+\_\+t {\bf type\+\_\+} \{0xffff\}
\item 
uint8\+\_\+t {\bf flags\+\_\+} \{0\}
\item 
enum {\bf proxygen\+::\+S\+P\+D\+Y\+Codec\+::\+Frame\+State} {\bf frame\+State\+\_\+}
\item 
bool {\bf ctrl\+\_\+}\+:1
\item 
{\bf Gzip\+Header\+Codec} {\bf header\+Codec\+\_\+}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
An implementation of the framing layer for all versions of S\+P\+DY. Instances of this class must not be used from multiple threads concurrently. 

Definition at line 36 of file S\+P\+D\+Y\+Codec.\+h.



\subsection{Member Typedef Documentation}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!Setting\+List@{Setting\+List}}
\index{Setting\+List@{Setting\+List}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{Setting\+List}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::\+S\+P\+D\+Y\+Codec\+::\+Setting\+List} =  std\+::vector$<${\bf Setting\+Data}$>$}\label{classproxygen_1_1SPDYCodec_a88822bd85299aebc0ff3bc398c5c9a7d}


Definition at line 153 of file S\+P\+D\+Y\+Codec.\+h.



\subsection{Member Enumeration Documentation}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!Frame\+State@{Frame\+State}}
\index{Frame\+State@{Frame\+State}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{Frame\+State}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+S\+P\+D\+Y\+Codec\+::\+Frame\+State}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a28fcff901adcd93c3b57e44727448bd1}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{F\+R\+A\+M\+E\+\_\+\+H\+E\+A\+D\+ER@{F\+R\+A\+M\+E\+\_\+\+H\+E\+A\+D\+ER}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!F\+R\+A\+M\+E\+\_\+\+H\+E\+A\+D\+ER@{F\+R\+A\+M\+E\+\_\+\+H\+E\+A\+D\+ER}}\item[{\em 
F\+R\+A\+M\+E\+\_\+\+H\+E\+A\+D\+ER\label{classproxygen_1_1SPDYCodec_a28fcff901adcd93c3b57e44727448bd1a6353dc35bf2a3cc76a92cab5f79ce49a}
}]\index{C\+T\+R\+L\+\_\+\+F\+R\+A\+M\+E\+\_\+\+D\+A\+TA@{C\+T\+R\+L\+\_\+\+F\+R\+A\+M\+E\+\_\+\+D\+A\+TA}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!C\+T\+R\+L\+\_\+\+F\+R\+A\+M\+E\+\_\+\+D\+A\+TA@{C\+T\+R\+L\+\_\+\+F\+R\+A\+M\+E\+\_\+\+D\+A\+TA}}\item[{\em 
C\+T\+R\+L\+\_\+\+F\+R\+A\+M\+E\+\_\+\+D\+A\+TA\label{classproxygen_1_1SPDYCodec_a28fcff901adcd93c3b57e44727448bd1a0404e7c6385a39e410728b88d5d1f14c}
}]\index{D\+A\+T\+A\+\_\+\+F\+R\+A\+M\+E\+\_\+\+D\+A\+TA@{D\+A\+T\+A\+\_\+\+F\+R\+A\+M\+E\+\_\+\+D\+A\+TA}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!D\+A\+T\+A\+\_\+\+F\+R\+A\+M\+E\+\_\+\+D\+A\+TA@{D\+A\+T\+A\+\_\+\+F\+R\+A\+M\+E\+\_\+\+D\+A\+TA}}\item[{\em 
D\+A\+T\+A\+\_\+\+F\+R\+A\+M\+E\+\_\+\+D\+A\+TA\label{classproxygen_1_1SPDYCodec_a28fcff901adcd93c3b57e44727448bd1a53bc2ea474269f373d73cc6c685b8fc0}
}]\end{description}
\end{Desc}


Definition at line 369 of file S\+P\+D\+Y\+Codec.\+h.


\begin{DoxyCode}
369                   \{
370     FRAME_HEADER = 0,
371     CTRL_FRAME_DATA = 1,
372     DATA_FRAME_DATA = 2,
373   \} frameState_:2;
\end{DoxyCode}


\subsection{Constructor \& Destructor Documentation}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!S\+P\+D\+Y\+Codec@{S\+P\+D\+Y\+Codec}}
\index{S\+P\+D\+Y\+Codec@{S\+P\+D\+Y\+Codec}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{S\+P\+D\+Y\+Codec(\+Transport\+Direction direction, S\+P\+D\+Y\+Version version, int spdy\+Compression\+Level=\+Z\+\_\+\+N\+O\+\_\+\+C\+O\+M\+P\+R\+E\+S\+S\+I\+O\+N)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+S\+P\+D\+Y\+Codec\+::\+S\+P\+D\+Y\+Codec (
\begin{DoxyParamCaption}
\item[{{\bf Transport\+Direction}}]{direction, }
\item[{{\bf S\+P\+D\+Y\+Version}}]{version, }
\item[{int}]{spdy\+Compression\+Level = {\ttfamily Z\+\_\+NO\+\_\+COMPRESSION}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [explicit]}}\label{classproxygen_1_1SPDYCodec_a10c9727b876c546115c0aefbb02ba20a}


Definition at line 170 of file S\+P\+D\+Y\+Codec.\+cpp.



References header\+Codec\+\_\+, proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::major\+Version, proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::minor\+Version, next\+Egress\+Ping\+I\+D\+\_\+, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::next\+Egress\+Stream\+I\+D\+\_\+, proxygen\+::\+Header\+Codec\+::set\+Max\+Uncompressed(), and version\+Settings\+\_\+.


\begin{DoxyCode}
172   : HTTPParallelCodec(direction),
173     versionSettings_(getVersionSettings(version)),
174     frameState_(FrameState::FRAME\_HEADER),
175     ctrl_(\textcolor{keyword}{false}),
176     headerCodec_(spdyCompressionLevel, versionSettings_) \{
177   VLOG(4) << \textcolor{stringliteral}{"creating SPDY/"} << \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{int}\textcolor{keyword}{>}(versionSettings_.majorVersion)
178           << \textcolor{stringliteral}{"."} << static\_cast<int>(versionSettings_.minorVersion)
179           << \textcolor{stringliteral}{" codec"};
180 
181   \textcolor{comment}{// Limit uncompressed headers to 128kb}
182   headerCodec_.setMaxUncompressed(kMaxUncompressed);
183   nextEgressPingID_ = nextEgressStreamID_;
184 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!````~S\+P\+D\+Y\+Codec@{$\sim$\+S\+P\+D\+Y\+Codec}}
\index{````~S\+P\+D\+Y\+Codec@{$\sim$\+S\+P\+D\+Y\+Codec}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{$\sim$\+S\+P\+D\+Y\+Codec() override}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+S\+P\+D\+Y\+Codec\+::$\sim$\+S\+P\+D\+Y\+Codec (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}}\label{classproxygen_1_1SPDYCodec_a95362cdc0b13b81a70e2ca52f861eaf1}


Definition at line 186 of file S\+P\+D\+Y\+Codec.\+cpp.


\begin{DoxyCode}
186                       \{
187 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!add\+Priority\+Nodes@{add\+Priority\+Nodes}}
\index{add\+Priority\+Nodes@{add\+Priority\+Nodes}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{add\+Priority\+Nodes(\+Priority\+Queue \&queue, folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint8\+\_\+t max\+Level) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::add\+Priority\+Nodes (
\begin{DoxyParamCaption}
\item[{{\bf Priority\+Queue} \&}]{, }
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{, }
\item[{uint8\+\_\+t}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_a0e2bfa5a275fae947a671239f2c5474b}
Create virtual nodes in H\+T\+T\+P/2 priority tree. Some protocols (S\+P\+DY) have a linear priority structure which must be simulated in the H\+T\+T\+P/2 tree structure with \char`\"{}virtual\char`\"{} nodes representing different priority bands. There are other cases we simply want a \char`\"{}plain\char`\"{} linear priority structure even with H\+T\+T\+P/2. In that case a Priority frame will also be sent out for each virtual node created so that peer will have the same linear structure.


\begin{DoxyParams}{Parameters}
{\em queue} & the priority queue to add nodes \\
\hline
{\em write\+Buf} & I\+O\+Buf\+Queue to append priority frames to send. For S\+P\+DY, the write\+Buf will be ignored. \\
\hline
{\em max\+Lavel} & the max level of virtual priority nodes to create. For S\+P\+DY, this value will be ignored. \\
\hline
\end{DoxyParams}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a5735debb82295d27f6d8491ab07e9b4f}.



Definition at line 1010 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Priority\+Queue\+::add\+Priority\+Node(), and proxygen\+::\+H\+T\+T\+P\+Codec\+::\+M\+A\+X\+\_\+\+S\+T\+R\+E\+A\+M\+\_\+\+ID.


\begin{DoxyCode}
1013              \{
1014   HTTPCodec::StreamID parent = 0;
1015   \textcolor{comment}{// For SPDY, we always create 8 virtual nodes regardless of maxLevel}
1016   \textcolor{keywordflow}{for} (uint8\_t pri = 0; pri < 8; pri++) \{
1017     queue.addPriorityNode(HTTPCodec::MAX_STREAM_ID + pri, parent);
1018     parent = HTTPCodec::MAX_STREAM_ID + pri;
1019   \}
1020   \textcolor{keywordflow}{return} 0;
1021 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!check\+Length@{check\+Length}}
\index{check\+Length@{check\+Length}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{check\+Length(uint32\+\_\+t expected\+Length, const std\+::string \&msg)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+S\+P\+D\+Y\+Codec\+::check\+Length (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{expected\+Length, }
\item[{const std\+::string \&}]{msg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_aedc3ae47eba3524e75c4241150e102b6}


Definition at line 219 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+E\+R\+R\+OR, proxygen\+::spdy\+::\+G\+O\+A\+W\+A\+Y\+\_\+\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, and length\+\_\+.



Referenced by on\+Control\+Frame().


\begin{DoxyCode}
219                                                                          \{
220   \textcolor{keywordflow}{if} (length_ != expectedLength) \{
221     LOG\_IF(ERROR, length_ == 4 && msg != \textcolor{stringliteral}{"GOAWAY"})
222       << msg << \textcolor{stringliteral}{": invalid length "} << length_ << \textcolor{stringliteral}{" != "} << expectedLength;
223     \textcolor{keywordflow}{throw} SPDYSessionFailed(spdy::GOAWAY_PROTOCOL_ERROR);
224   \}
225 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!check\+Min\+Length@{check\+Min\+Length}}
\index{check\+Min\+Length@{check\+Min\+Length}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{check\+Min\+Length(uint32\+\_\+t min\+Length, const std\+::string \&msg)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+S\+P\+D\+Y\+Codec\+::check\+Min\+Length (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{min\+Length, }
\item[{const std\+::string \&}]{msg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a4ca234bcc857909da8b530583da41161}


Definition at line 227 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+E\+R\+R\+OR, proxygen\+::spdy\+::\+G\+O\+A\+W\+A\+Y\+\_\+\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, and length\+\_\+.



Referenced by on\+Control\+Frame().


\begin{DoxyCode}
227                                                                        \{
228   \textcolor{keywordflow}{if} (length_ < minLength) \{
229     LOG(ERROR) << msg << \textcolor{stringliteral}{": invalid length "} << length_ << \textcolor{stringliteral}{" < "} << minLength;
230     \textcolor{keywordflow}{throw} SPDYSessionFailed(spdy::GOAWAY_PROTOCOL_ERROR);
231   \}
232 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!decode\+Headers@{decode\+Headers}}
\index{decode\+Headers@{decode\+Headers}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{decode\+Headers(folly\+::io\+::\+Cursor \&cursor)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Header\+Decode\+Result} proxygen\+::\+S\+P\+D\+Y\+Codec\+::decode\+Headers (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a2b16ac04e3cda756ca11d95b294ed5ae}
Decodes the headers from the cursor and returns the result. 

Definition at line 466 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+B\+A\+D\+\_\+\+E\+N\+C\+O\+D\+I\+NG, proxygen\+::\+Gzip\+Header\+Codec\+::decode(), fail\+Stream(), proxygen\+::spdy\+::\+G\+O\+A\+W\+A\+Y\+\_\+\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, header\+Codec\+\_\+, proxygen\+::spdy\+::\+H\+E\+A\+D\+E\+RS, proxygen\+::\+H\+E\+A\+D\+E\+R\+S\+\_\+\+T\+O\+O\+\_\+\+L\+A\+R\+GE, proxygen\+::\+I\+N\+F\+L\+A\+T\+E\+\_\+\+D\+I\+C\+T\+I\+O\+N\+A\+RY, length\+\_\+, proxygen\+::spdy\+::\+R\+S\+T\+\_\+\+F\+R\+A\+M\+E\+\_\+\+T\+O\+O\+\_\+\+L\+A\+R\+GE, proxygen\+::spdy\+::\+R\+S\+T\+\_\+\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, stream\+Id\+\_\+, and type\+\_\+.



Referenced by on\+Control\+Frame().


\begin{DoxyCode}
466                                                           \{
467   \textcolor{keyword}{auto} result = headerCodec_.decode(cursor, length_);
468   \textcolor{keywordflow}{if} (result.hasError()) \{
469     \textcolor{keyword}{auto} err = result.error();
470     \textcolor{keywordflow}{if} (err == GzipDecodeError::HEADERS_TOO_LARGE ||
471         err == GzipDecodeError::INFLATE_DICTIONARY ||
472         err == GzipDecodeError::BAD_ENCODING) \{
473       \textcolor{comment}{// Fail stream only for FRAME\_TOO\_LARGE error}
474       \textcolor{keywordflow}{if} (err == GzipDecodeError::HEADERS_TOO_LARGE) \{
475         failStream(\textcolor{keyword}{true}, streamId_, spdy::RST_FRAME_TOO_LARGE);
476       \}
477       \textcolor{keywordflow}{throw} SPDYSessionFailed(spdy::GOAWAY_PROTOCOL_ERROR);
478     \}
479     \textcolor{comment}{// For other types of errors we throw a stream error}
480     \textcolor{keywordtype}{bool} newStream = (type_ != spdy::HEADERS);
481     \textcolor{keywordflow}{throw} SPDYStreamFailed(newStream, streamId_, spdy::RST_PROTOCOL_ERROR,
482                            \textcolor{stringliteral}{"Error parsing header: "} + folly::to<string>(err));
483   \}
484 
485   length_ -= result->bytesConsumed;
486   \textcolor{keywordflow}{return} *result;
487 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!deliver\+On\+Message\+Begin@{deliver\+On\+Message\+Begin}}
\index{deliver\+On\+Message\+Begin@{deliver\+On\+Message\+Begin}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{deliver\+On\+Message\+Begin(\+Stream\+I\+D stream\+I\+D, Stream\+I\+D assoc\+Stream\+I\+D, H\+T\+T\+P\+Message $\ast$msg)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+S\+P\+D\+Y\+Codec\+::deliver\+On\+Message\+Begin (
\begin{DoxyParamCaption}
\item[{{\bf Stream\+ID}}]{stream\+ID, }
\item[{{\bf Stream\+ID}}]{assoc\+Stream\+ID, }
\item[{{\bf H\+T\+T\+P\+Message} $\ast$}]{msg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a5742f2e461d9d3d940625369fc7d8e77}


Definition at line 1271 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::deliver\+Callback\+If\+Allowed(), proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Message\+Begin(), and proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Push\+Message\+Begin().



Referenced by on\+Syn\+Common(), and parse\+Headers().


\begin{DoxyCode}
1272                                                         \{
1273   \textcolor{keywordflow}{if} (assocStreamID) \{
1274     deliverCallbackIfAllowed(&HTTPCodec::Callback::onPushMessageBegin,
1275                              \textcolor{stringliteral}{"onPushMessageBegin"}, streamID, assocStreamID,
1276                              msg);
1277   \} \textcolor{keywordflow}{else} \{
1278     deliverCallbackIfAllowed(&HTTPCodec::Callback::onMessageBegin,
1279                              \textcolor{stringliteral}{"onMessageBegin"}, streamID, msg);
1280   \}
1281 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!encode\+Headers@{encode\+Headers}}
\index{encode\+Headers@{encode\+Headers}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{encode\+Headers(const H\+T\+T\+P\+Message \&msg, std\+::vector$<$ compress\+::\+Header $>$ \&headers, uint32\+\_\+t headroom=0, H\+T\+T\+P\+Header\+Size $\ast$size=nullptr)}]{\setlength{\rightskip}{0pt plus 5cm}unique\+\_\+ptr$<$ I\+O\+Buf $>$ proxygen\+::\+S\+P\+D\+Y\+Codec\+::encode\+Headers (
\begin{DoxyParamCaption}
\item[{const {\bf H\+T\+T\+P\+Message} \&}]{msg, }
\item[{std\+::vector$<$ {\bf compress\+::\+Header} $>$ \&}]{headers, }
\item[{uint32\+\_\+t}]{headroom = {\ttfamily 0}, }
\item[{{\bf H\+T\+T\+P\+Header\+Size} $\ast$}]{size = {\ttfamily {\bf nullptr}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a8304a1f1c65b6e99df85fb5dcea53a17}
Helper function to create the compressed Name/\+Value representation of a message\textquotesingle{}s headers. 
\begin{DoxyParams}{Parameters}
{\em msg} & The message containing headers to serialize. \\
\hline
{\em headers} & A vector containing any extra headers to serialize \\
\hline
{\em size} & Size of the serialized headers before and after compression \\
\hline
{\em headroom} & Optional amount of headroom to reserve at the front of the returned I\+O\+Buf, in case the caller wants to put some other data there. \\
\hline
\end{DoxyParams}


Definition at line 503 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+Gzip\+Header\+Codec\+::encode(), proxygen\+::\+H\+T\+T\+P\+Headers\+::for\+Each\+With\+Code(), proxygen\+::\+Header\+Codec\+::get\+Encoded\+Size(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), header\+Codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER, proxygen\+::spdy\+::http\+Version, is\+S\+P\+D\+Y\+Reserved(), proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::major\+Version, name, proxygen\+::\+Header\+Codec\+::set\+Encode\+Headroom(), version\+Settings\+\_\+, and proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::version\+Str.



Referenced by serialize\+Request\+Headers(), and serialize\+Response\+Headers().


\begin{DoxyCode}
505                                            \{
506 
507   \textcolor{comment}{// We explicitly provide both the code and header name here}
508   \textcolor{comment}{// as HTTP\_HEADER\_OTHER does not map to kNameVersionv3 and we don't want a}
509   \textcolor{comment}{// perf penalty hash kNameVersionv3 to HTTP\_HEADER\_OTHER}
510   allHeaders.emplace\_back(
511     HTTP_HEADER_OTHER, versionSettings_.versionStr, spdy::httpVersion);
512 
513   \textcolor{comment}{// Add the HTTP headers supplied by the caller, but skip}
514   \textcolor{comment}{// any per-hop headers that aren't supported in SPDY.}
515   msg.getHeaders().forEachWithCode([&] (HTTPHeaderCode code,
516                                         \textcolor{keyword}{const} \textcolor{keywordtype}{string}& name,
517                                         \textcolor{keyword}{const} \textcolor{keywordtype}{string}& value) \{
518     \textcolor{keyword}{static} \textcolor{keyword}{const} std::bitset<256> s\_perHopHeaderCodes\{
519       [] \{
520         std::bitset<256> bs;
521         \textcolor{comment}{// SPDY per-hop headers}
522         bs[HTTP\_HEADER\_CONNECTION] = \textcolor{keyword}{true};
523         bs[HTTP\_HEADER\_HOST] = \textcolor{keyword}{true};
524         bs[HTTP\_HEADER\_KEEP\_ALIVE] = \textcolor{keyword}{true};
525         bs[HTTP\_HEADER\_PROXY\_CONNECTION] = \textcolor{keyword}{true};
526         bs[HTTP\_HEADER\_TRANSFER\_ENCODING] = \textcolor{keyword}{true};
527         bs[HTTP\_HEADER\_UPGRADE] = \textcolor{keyword}{true};
528         \textcolor{keywordflow}{return} bs;
529       \}()
530     \};
531 
532     \textcolor{keywordflow}{if} (s\_perHopHeaderCodes[code] || isSPDYReserved(name)) \{
533       VLOG(3) << \textcolor{stringliteral}{"Dropping SPDY reserved header "} << name;
534       \textcolor{keywordflow}{return};
535     \}
536     \textcolor{keywordflow}{if} (name.length() == 0) \{
537       VLOG(2) << \textcolor{stringliteral}{"Dropping header with empty name"};
538       \textcolor{keywordflow}{return};
539     \}
540     \textcolor{keywordflow}{if} (versionSettings_.majorVersion == 2 && value.length() == 0) \{
541       VLOG(2) << \textcolor{stringliteral}{"Dropping header \(\backslash\)""} << name
542               << \textcolor{stringliteral}{"\(\backslash\)" with empty value for spdy/2"};
543       \textcolor{keywordflow}{return};
544     \}
545     allHeaders.emplace\_back(code, name, value);
546   \});
547 
548   headerCodec_.setEncodeHeadroom(headroom);
549   \textcolor{keyword}{auto} out = headerCodec_.encode(allHeaders);
550   \textcolor{keywordflow}{if} (size) \{
551     *size = headerCodec_.getEncodedSize();
552   \}
553 
554   \textcolor{keywordflow}{return} out;
555 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!fail\+Session@{fail\+Session}}
\index{fail\+Session@{fail\+Session}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{fail\+Session(uint32\+\_\+t status\+Code)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+S\+P\+D\+Y\+Codec\+::fail\+Session (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{status\+Code}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_ae4178590c3cc7e321672fdf6e87eb66d}


Definition at line 1474 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::callback\+\_\+, current\+Ingress\+Buf\+\_\+, proxygen\+::spdy\+::goaway\+To\+Error\+Code(), proxygen\+::\+H\+T\+T\+P\+Exception\+::\+I\+N\+G\+R\+E\+S\+S\+\_\+\+A\+N\+D\+\_\+\+E\+G\+R\+E\+SS, proxygen\+::k\+Error\+Parse\+Header, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::last\+Stream\+I\+D\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Error(), proxygen\+::\+H\+T\+T\+P\+Exception\+::set\+Codec\+Status\+Code(), proxygen\+::\+H\+T\+T\+P\+Exception\+::set\+Current\+Ingress\+Buf(), and proxygen\+::\+Exception\+::set\+Proxygen\+Error().



Referenced by on\+Ingress().


\begin{DoxyCode}
1474                                          \{
1475   HTTPException err(
1476     HTTPException::Direction::INGRESS_AND_EGRESS,
1477     folly::to<std::string>(\textcolor{stringliteral}{"SPDYCodec session error: "}
1478       \textcolor{stringliteral}{"lastGoodStream="}, lastStreamID_, \textcolor{stringliteral}{" status="}, code));
1479   err.setCodecStatusCode(spdy::goawayToErrorCode(spdy::GoawayStatusCode(code)));
1480   err.setProxygenError(kErrorParseHeader);
1481 
1482   \textcolor{comment}{// store the ingress buffer}
1483   \textcolor{keywordflow}{if} (currentIngressBuf_) \{
1484     err.setCurrentIngressBuf(currentIngressBuf_->clone());
1485   \}
1486   callback_->onError(0, err);
1487 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!fail\+Stream@{fail\+Stream}}
\index{fail\+Stream@{fail\+Stream}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{fail\+Stream(bool new\+Txn, Stream\+I\+D stream\+I\+D, uint32\+\_\+t code, std\+::string exc\+Str=empty\+\_\+string)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+S\+P\+D\+Y\+Codec\+::fail\+Stream (
\begin{DoxyParamCaption}
\item[{bool}]{new\+Txn, }
\item[{{\bf Stream\+ID}}]{stream\+ID, }
\item[{uint32\+\_\+t}]{code, }
\item[{std\+::string}]{exc\+Str = {\ttfamily {\bf empty\+\_\+string}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_ad5b755bcc5cff27b875886c20b50bcf6}


Definition at line 1444 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::callback\+\_\+, proxygen\+::spdy\+::\+C\+T\+R\+L\+\_\+\+F\+L\+A\+G\+\_\+\+F\+IN, current\+Ingress\+Buf\+\_\+, flags\+\_\+, proxygen\+::\+H\+T\+T\+P\+Exception\+::\+I\+N\+G\+R\+E\+SS, proxygen\+::\+H\+T\+T\+P\+Exception\+::\+I\+N\+G\+R\+E\+S\+S\+\_\+\+A\+N\+D\+\_\+\+E\+G\+R\+E\+SS, proxygen\+::k\+Error\+Parse\+Header, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Error(), partial\+Msg\+\_\+, proxygen\+::spdy\+::rst\+To\+Error\+Code(), proxygen\+::\+H\+T\+T\+P\+Exception\+::set\+Codec\+Status\+Code(), proxygen\+::\+H\+T\+T\+P\+Exception\+::set\+Current\+Ingress\+Buf(), proxygen\+::\+H\+T\+T\+P\+Exception\+::set\+Http\+Status\+Code(), proxygen\+::\+H\+T\+T\+P\+Exception\+::set\+Partial\+Msg(), proxygen\+::\+Exception\+::set\+Proxygen\+Error(), and stream\+Id\+\_\+.



Referenced by decode\+Headers(), and parse\+Ingress().


\begin{DoxyCode}
1445                                                          \{
1446   \textcolor{comment}{// Suppress any EOM callback for the current frame.}
1447   \textcolor{keywordflow}{if} (streamID == streamId_) \{
1448     flags_ &= ~spdy::CTRL_FLAG_FIN;
1449   \}
1450 
1451   HTTPException err(
1452     code >= 100 ?
1453     HTTPException::Direction::INGRESS :
1454     HTTPException::Direction::INGRESS_AND_EGRESS,
1455     folly::to<std::string>(\textcolor{stringliteral}{"SPDYCodec stream error: stream="},
1456       streamID, \textcolor{stringliteral}{" status="}, code, \textcolor{stringliteral}{" exception: "}, excStr));
1457   \textcolor{keywordflow}{if} (code >= 100) \{
1458     err.setHttpStatusCode(code);
1459   \} \textcolor{keywordflow}{else} \{
1460     err.setCodecStatusCode(spdy::rstToErrorCode(spdy::ResetStatusCode(code)));
1461   \}
1462   err.setProxygenError(kErrorParseHeader);
1463 
1464   \textcolor{keywordflow}{if} (partialMsg_) \{
1465     err.setPartialMsg(std::move(partialMsg_));
1466   \}
1467   \textcolor{comment}{// store the ingress buffer}
1468   \textcolor{keywordflow}{if} (currentIngressBuf_) \{
1469     err.setCurrentIngressBuf(currentIngressBuf_->clone());
1470   \}
1471   callback_->onError(streamID, err, newStream);
1472 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!generate\+Body@{generate\+Body}}
\index{generate\+Body@{generate\+Body}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{generate\+Body(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D stream, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ chain, folly\+::\+Optional$<$ uint8\+\_\+t $>$ padding, bool eom) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::generate\+Body (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{chain, }
\item[{folly\+::\+Optional$<$ uint8\+\_\+t $>$}]{padding, }
\item[{bool}]{eom}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_af4b2d43be6f4255a8d248f9e4e8a9564}
Write part of an egress message body.

This will automatically generate a chunk header and footer around the data if necessary (e.\+g. you haven\textquotesingle{}t manually sent a chunk header and the message should be chunked).


\begin{DoxyParams}{Parameters}
{\em padding} & Optionally add padding bytes to the body if possible \\
\hline
{\em eom} & implicitly generate the E\+OM marker with this body frame\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of bytes written 
\end{DoxyReturn}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_ad914e07a10cf00dc93e9cb9e0c0205b3}.



Definition at line 765 of file S\+P\+D\+Y\+Codec.\+cpp.



References generate\+Data\+Frame(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::ingress\+Goaway\+Ack\+\_\+, and proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::is\+Stream\+Ingress\+Egress\+Allowed().



Referenced by T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
769                                          \{
770   \textcolor{keywordflow}{if} (!isStreamIngressEgressAllowed(stream)) \{
771     VLOG(2) << \textcolor{stringliteral}{"Suppressing DATA for stream="} << stream <<
772       \textcolor{stringliteral}{" ingressGoawayAck\_="} << ingressGoawayAck_;
773     \textcolor{keywordflow}{return} 0;
774   \}
775   \textcolor{keywordtype}{size\_t} len = chain->computeChainDataLength();
776   \textcolor{keywordflow}{if} (len == 0) \{
777     \textcolor{keywordflow}{return} len;
778   \}
779 
780   \textcolor{comment}{// TODO if the data length is 2^24 or greater, split it into}
781   \textcolor{comment}{// multiple data frames.  Proxygen should never be writing that}
782   \textcolor{comment}{// much data at once, but other apps that use this codec might.}
783   CHECK\_LT(len, (1 << 24));
784 
785   uint8\_t flags = (eom) ? kFlagFin : 0;
786   generateDataFrame(writeBuf, uint32\_t(stream), flags, len, std::move(chain));
787   \textcolor{keywordflow}{return} len;
788 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!generate\+Chunk\+Header@{generate\+Chunk\+Header}}
\index{generate\+Chunk\+Header@{generate\+Chunk\+Header}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{generate\+Chunk\+Header(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D stream, size\+\_\+t length) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::generate\+Chunk\+Header (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream, }
\item[{size\+\_\+t}]{length}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_aca7d18c287026d8ff821cbc06eb78d29}
Write a body chunk header, if relevant. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a10a3cf44e3748bddd22d260a028c152c}.



Definition at line 790 of file S\+P\+D\+Y\+Codec.\+cpp.


\begin{DoxyCode}
792                                                 \{
793   \textcolor{comment}{// SPDY chunk headers are built into the data frames}
794   \textcolor{keywordflow}{return} 0;
795 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!generate\+Chunk\+Terminator@{generate\+Chunk\+Terminator}}
\index{generate\+Chunk\+Terminator@{generate\+Chunk\+Terminator}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{generate\+Chunk\+Terminator(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D stream) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::generate\+Chunk\+Terminator (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_a2954e7168273600f247c476b6fa405f0}
Write a body chunk terminator, if relevant. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a6e20271ad023252b6fa877d95b413f26}.



Definition at line 797 of file S\+P\+D\+Y\+Codec.\+cpp.


\begin{DoxyCode}
798                                                       \{
799   \textcolor{comment}{// SPDY has no chunk terminator}
800   \textcolor{keywordflow}{return} 0;
801 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!generate\+Data\+Frame@{generate\+Data\+Frame}}
\index{generate\+Data\+Frame@{generate\+Data\+Frame}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{generate\+Data\+Frame(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint32\+\_\+t stream\+I\+D, uint8\+\_\+t flags, uint32\+\_\+t length, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ payload)}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::generate\+Data\+Frame (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{uint32\+\_\+t}]{stream\+ID, }
\item[{uint8\+\_\+t}]{flags, }
\item[{uint32\+\_\+t}]{length, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{payload}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_ae33591725cbebb7146545ff7e31a8c11}
Generate the header for a S\+P\+DY data frame 
\begin{DoxyParams}{Parameters}
{\em write\+Buf} & Buffer queue to which the control frame is written. \\
\hline
{\em stream\+ID} & Stream ID. \\
\hline
{\em flags} & Bitmap of flags, as defined in the S\+P\+DY spec. \\
\hline
{\em length} & Length of the data, in bytes. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
length Length of the encoded bytes 

payload data payload 
\end{DoxyReturn}


Definition at line 1031 of file S\+P\+D\+Y\+Codec.\+cpp.



Referenced by generate\+Body(), and generate\+E\+O\+M().


\begin{DoxyCode}
1034                                                                \{
1035   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} frameSize = kFrameSizeDataCommon;
1036   uint64\_t payloadLength = 0;
1037   \textcolor{keywordflow}{if} (payload && !payload->isSharedOne() &&
1038       payload->headroom() >= frameSize &&
1039       writeBuf.tailroom() < frameSize) \{
1040     \textcolor{comment}{// Use the headroom in payload for the frame header.}
1041     \textcolor{comment}{// Make it appear that the payload IOBuf is empty and retreat so}
1042     \textcolor{comment}{// appender can access the headroom}
1043     payloadLength = payload->length();
1044     payload->trimEnd(payloadLength);
1045     payload->retreat(frameSize);
1046     \textcolor{keyword}{auto} tail = payload->pop();
1047     writeBuf.append(std::move(payload));
1048     payload = std::move(tail);
1049   \}
1050   QueueAppender cursor(&writeBuf, frameSize);
1051   cursor.writeBE(uint32\_t(streamID));
1052   cursor.writeBE(flagsAndLength(flags, length));
1053   writeBuf.postallocate(payloadLength);
1054   writeBuf.append(std::move(payload));
1055   \textcolor{keywordflow}{return} kFrameSizeDataCommon + length;
1056 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!generate\+E\+OM@{generate\+E\+OM}}
\index{generate\+E\+OM@{generate\+E\+OM}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{generate\+E\+O\+M(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D stream) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::generate\+E\+OM (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_a756dc90bf27d70737fe0b1c9cf7fa55d}
Generate any protocol framing needed to finalize an egress message. This method must be called to complete a stream.

\begin{DoxyReturn}{Returns}
number of bytes written 
\end{DoxyReturn}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_aefa134de8aff8e9000092a9996546bd5}.



Definition at line 812 of file S\+P\+D\+Y\+Codec.\+cpp.



References generate\+Data\+Frame(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::ingress\+Goaway\+Ack\+\_\+, and proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::is\+Stream\+Ingress\+Egress\+Allowed().



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
813                                                \{
814   VLOG(4) << \textcolor{stringliteral}{"sending EOM for stream="} << stream;
815   \textcolor{keywordflow}{if} (!isStreamIngressEgressAllowed(stream)) \{
816     VLOG(2) << \textcolor{stringliteral}{"Suppressing EOM for stream="} << stream <<
817       \textcolor{stringliteral}{" ingressGoawayAck\_="} << ingressGoawayAck_;
818     \textcolor{keywordflow}{return} 0;
819   \}
820   generateDataFrame(writeBuf, uint32\_t(stream), kFlagFin, 0, \textcolor{keyword}{nullptr});
821   \textcolor{keywordflow}{return} 8; \textcolor{comment}{// size of data frame header}
822 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!generate\+Goaway@{generate\+Goaway}}
\index{generate\+Goaway@{generate\+Goaway}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{generate\+Goaway(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D last\+Stream, Error\+Code status\+Code, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ debug\+Data=nullptr) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::generate\+Goaway (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{last\+Stream, }
\item[{{\bf Error\+Code}}]{code, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{debug\+Data = {\ttfamily {\bf nullptr}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_af254e0ae14f92818b4527bb45d7d97fd}
Generate any protocol framing needed to abort a connection. \begin{DoxyReturn}{Returns}
number of bytes written 
\end{DoxyReturn}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a22dec1b6d4dde73ea7380a28b937e545}.



Definition at line 856 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::control\+Version, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::egress\+Goaway\+Ack\+\_\+, proxygen\+::spdy\+::error\+Code\+To\+Goaway(), proxygen\+::get\+Error\+Code\+String(), proxygen\+::spdy\+::\+G\+O\+A\+W\+AY, proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::goaway\+Size, proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::major\+Version, proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::session\+Closing\+\_\+, status\+Code, and version\+Settings\+\_\+.



Referenced by T\+E\+S\+T(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
859                                                                       \{
860   \textcolor{keyword}{const} uint32\_t statusCode = (uint32\_t) spdy::errorCodeToGoaway(code);
861   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} frameSize = kFrameSizeControlCommon +
862     (size\_t)versionSettings_.goawaySize;
863 
864   DCHECK\_LE(lastStream, egressGoawayAck_) << \textcolor{stringliteral}{"Cannot increase last good stream"};
865   egressGoawayAck_ = lastStream;
866   \textcolor{keywordflow}{if} (sessionClosing_ == ClosingState::CLOSING) \{
867     VLOG(4) << \textcolor{stringliteral}{"Not sending GOAWAY for closed session"};
868     \textcolor{keywordflow}{return} 0;
869   \}
870   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} expectedLength = writeBuf.chainLength() + frameSize;
871   QueueAppender appender(&writeBuf, frameSize);
872   appender.writeBE(versionSettings_.controlVersion);
873 
874   \textcolor{keywordflow}{if} (code != ErrorCode::NO_ERROR) \{
875     sessionClosing_ = ClosingState::CLOSING;
876   \}
877 
878   \textcolor{keywordtype}{string} debugInfo = (debugData) ?
879     folly::to<string>(\textcolor{stringliteral}{" with debug info="},
880                       (\textcolor{keywordtype}{char}*)debugData->data()) : \textcolor{stringliteral}{""};
881   VLOG(4) << \textcolor{stringliteral}{"Sending GOAWAY with last acknowledged stream="}
882           << lastStream << \textcolor{stringliteral}{" with code="} << getErrorCodeString(code)
883           << debugInfo;
884 
885   appender.writeBE(uint16\_t(spdy::GOAWAY));
886   appender.writeBE(flagsAndLength(0, versionSettings_.goawaySize));
887   appender.writeBE(uint32\_t(lastStream));
888   \textcolor{keywordflow}{if} (versionSettings_.majorVersion == 3) \{
889     appender.writeBE(statusCode);
890   \}
891   \textcolor{keywordflow}{switch} (sessionClosing_) \{
892     \textcolor{keywordflow}{case} ClosingState::OPEN:
893       sessionClosing_ = ClosingState::CLOSING;
894       \textcolor{keywordflow}{break};
895     \textcolor{keywordflow}{case} ClosingState::OPEN\_WITH\_GRACEFUL\_DRAIN\_ENABLED:
896       \textcolor{keywordflow}{if} (lastStream == std::numeric\_limits<int32\_t>::max()) \{
897         sessionClosing_ = ClosingState::FIRST\_GOAWAY\_SENT;
898       \} \textcolor{keywordflow}{else} \{
899         \textcolor{comment}{// The user of this codec decided not to do the double goaway}
900         \textcolor{comment}{// drain}
901         sessionClosing_ = ClosingState::CLOSING;
902       \}
903       \textcolor{keywordflow}{break};
904     \textcolor{keywordflow}{case} ClosingState::FIRST\_GOAWAY\_SENT:
905       sessionClosing_ = ClosingState::CLOSING;
906       \textcolor{keywordflow}{break};
907     \textcolor{keywordflow}{case} ClosingState::CLOSING:
908       \textcolor{keywordflow}{break};
909     \textcolor{keywordflow}{case} ClosingState::CLOSED:
910       LOG(FATAL) << \textcolor{stringliteral}{"unreachable"};
911       \textcolor{keywordflow}{break};
912   \}
913   DCHECK\_EQ(writeBuf.chainLength(), expectedLength);
914   \textcolor{keywordflow}{return} frameSize;
915 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!generate\+Header@{generate\+Header}}
\index{generate\+Header@{generate\+Header}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{generate\+Header(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D stream, const H\+T\+T\+P\+Message \&msg, bool eom=false, H\+T\+T\+P\+Header\+Size $\ast$size=nullptr) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+S\+P\+D\+Y\+Codec\+::generate\+Header (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream, }
\item[{const {\bf H\+T\+T\+P\+Message} \&}]{msg, }
\item[{bool}]{eom = {\ttfamily false}, }
\item[{{\bf H\+T\+T\+P\+Header\+Size} $\ast$}]{size = {\ttfamily {\bf nullptr}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_ae2173f2d02d25e5119b1901d599edcd3}
Write an egress message header. For pushed streams, you must specify the assoc\+Stream. 
\begin{DoxyRetVals}{Return values}
{\em size} & the size of the generated message, both the actual size and the size of the uncompressed data. \\
\hline
\end{DoxyRetVals}
\begin{DoxyReturn}{Returns}
None 
\end{DoxyReturn}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a572e25a01e0d36bb527db2dc39ca26b3}.



Definition at line 625 of file S\+P\+D\+Y\+Codec.\+cpp.



References generate\+Syn\+Reply(), generate\+Syn\+Stream(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::ingress\+Goaway\+Ack\+\_\+, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::is\+Stream\+Ingress\+Egress\+Allowed(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::transport\+Direction\+\_\+, and proxygen\+::\+U\+P\+S\+T\+R\+E\+AM.



Referenced by T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
629                                                      \{
630   \textcolor{keywordflow}{if} (!isStreamIngressEgressAllowed(stream)) \{
631     VLOG(2) << \textcolor{stringliteral}{"Suppressing SYN\_STREAM/REPLY for stream="} << stream <<
632       \textcolor{stringliteral}{" ingressGoawayAck\_="} << ingressGoawayAck_;
633     \textcolor{keywordflow}{if} (size) \{
634       size->compressed = 0;
635       size->uncompressed = 0;
636     \}
637     \textcolor{keywordflow}{return};
638   \}
639   \textcolor{keywordflow}{if} (transportDirection_ == TransportDirection::UPSTREAM) \{
640     generateSynStream(stream, 0, writeBuf, msg, eom, size);
641   \} \textcolor{keywordflow}{else} \{
642     generateSynReply(stream, writeBuf, msg, eom, size);
643   \}
644 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!generate\+Ping\+Common@{generate\+Ping\+Common}}
\index{generate\+Ping\+Common@{generate\+Ping\+Common}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{generate\+Ping\+Common(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint64\+\_\+t unique\+I\+D)}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::generate\+Ping\+Common (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{uint64\+\_\+t}]{unique\+ID}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_afc4bada78f27bf0d0c016ca01f729b4e}
Generates the shared parts of a ping request and reply. 

Definition at line 929 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::control\+Version, proxygen\+::spdy\+::\+P\+I\+NG, and version\+Settings\+\_\+.



Referenced by generate\+Ping\+Reply(), and generate\+Ping\+Request().


\begin{DoxyCode}
929                                                                             \{
930   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} frameSize = kFrameSizeControlCommon + kFrameSizePing;
931   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} expectedLength = writeBuf.chainLength() + frameSize;
932   QueueAppender appender(&writeBuf, frameSize);
933   appender.writeBE(versionSettings_.controlVersion);
934   appender.writeBE(uint16\_t(spdy::PING));
935   appender.writeBE(flagsAndLength(0, kFrameSizePing));
936   appender.writeBE(uint32\_t(uniqueID));
937   DCHECK\_EQ(writeBuf.chainLength(), expectedLength);
938   \textcolor{keywordflow}{return} frameSize;
939 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!generate\+Ping\+Reply@{generate\+Ping\+Reply}}
\index{generate\+Ping\+Reply@{generate\+Ping\+Reply}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{generate\+Ping\+Reply(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint64\+\_\+t unique\+I\+D) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::generate\+Ping\+Reply (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{, }
\item[{uint64\+\_\+t}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_afa84e8c3ec08e93782854aa09f9b2463}
Generate a reply to a ping message, if supported in the protocol implemented by the codec. 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_aeb8c597c8604bc7159e58b74c1874de3}.



Definition at line 924 of file S\+P\+D\+Y\+Codec.\+cpp.



References generate\+Ping\+Common().



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
924                                                                            \{
925   VLOG(4) << \textcolor{stringliteral}{"Generating ping reply with id="} << uniqueID;
926   \textcolor{keywordflow}{return} generatePingCommon(writeBuf, uniqueID);
927 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!generate\+Ping\+Request@{generate\+Ping\+Request}}
\index{generate\+Ping\+Request@{generate\+Ping\+Request}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{generate\+Ping\+Request(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::generate\+Ping\+Request (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_a03d5b7ac2b85cba27a990c497b898357}
If the protocol supports it, generate a ping message that the other side should respond to. 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a70731ca9f30fe9890817034be4e78c28}.



Definition at line 917 of file S\+P\+D\+Y\+Codec.\+cpp.



References generate\+Ping\+Common(), and next\+Egress\+Ping\+I\+D\+\_\+.



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
917                                                           \{
918   \textcolor{keyword}{const} \textcolor{keyword}{auto} \textcolor{keywordtype}{id} = nextEgressPingID_;
919   nextEgressPingID_ += 2;
920   VLOG(4) << \textcolor{stringliteral}{"Generating ping request with id="} << id;
921   \textcolor{keywordflow}{return} generatePingCommon(writeBuf, \textcolor{keywordtype}{id});
922 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!generate\+Push\+Promise@{generate\+Push\+Promise}}
\index{generate\+Push\+Promise@{generate\+Push\+Promise}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{generate\+Push\+Promise(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D stream, const H\+T\+T\+P\+Message \&msg, Stream\+I\+D assocstream, bool eom=false, H\+T\+T\+P\+Header\+Size $\ast$size=nullptr) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+S\+P\+D\+Y\+Codec\+::generate\+Push\+Promise (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream, }
\item[{const {\bf H\+T\+T\+P\+Message} \&}]{msg, }
\item[{{\bf Stream\+ID}}]{assocstream, }
\item[{bool}]{eom = {\ttfamily false}, }
\item[{{\bf H\+T\+T\+P\+Header\+Size} $\ast$}]{size = {\ttfamily {\bf nullptr}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_af3cb46ddff92037acbbbe7d6dd566040}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a087b49a9fb21bf2219125ce63a96ea11}.



Definition at line 646 of file S\+P\+D\+Y\+Codec.\+cpp.



References generate\+Syn\+Stream(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::ingress\+Goaway\+Ack\+\_\+, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::is\+Stream\+Ingress\+Egress\+Allowed(), and No\+Stream.



Referenced by T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
651                                                           \{
652   DCHECK(assocStream != NoStream);
653   \textcolor{keywordflow}{if} (!isStreamIngressEgressAllowed(stream)) \{
654     VLOG(2) << \textcolor{stringliteral}{"Suppressing SYN\_STREAM/REPLY for stream="} << stream <<
655       \textcolor{stringliteral}{" ingressGoawayAck\_="} << ingressGoawayAck_;
656     \textcolor{keywordflow}{if} (size) \{
657       size->compressed = 0;
658       size->uncompressed = 0;
659     \}
660     \textcolor{keywordflow}{return};
661   \}
662   generateSynStream(stream, assocStream, writeBuf, msg, eom, size);
663 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!generate\+Rst\+Stream@{generate\+Rst\+Stream}}
\index{generate\+Rst\+Stream@{generate\+Rst\+Stream}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{generate\+Rst\+Stream(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D txn, Error\+Code status\+Code) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::generate\+Rst\+Stream (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream, }
\item[{{\bf Error\+Code}}]{code}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_afad4b1328e51b17b82547a4ab1e42ad7}
Generate any protocol framing needed to abort a stream. \begin{DoxyReturn}{Returns}
number of bytes written 
\end{DoxyReturn}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_adfb41670b50d0608a8beb934494109be}.



Definition at line 824 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::control\+Version, proxygen\+::spdy\+::\+C\+T\+R\+L\+\_\+\+F\+L\+A\+G\+\_\+\+F\+IN, proxygen\+::spdy\+::error\+Code\+To\+Reset(), flags\+\_\+, proxygen\+::get\+Error\+Code\+String(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::ingress\+Goaway\+Ack\+\_\+, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::is\+Stream\+Ingress\+Egress\+Allowed(), proxygen\+::spdy\+::\+R\+S\+T\+\_\+\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, proxygen\+::spdy\+::\+R\+S\+T\+\_\+\+S\+T\+R\+E\+AM, rst\+Status\+Supported(), status\+Code, stream\+Id\+\_\+, and version\+Settings\+\_\+.



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
826                                                     \{
827   DCHECK\_GT(stream, 0);
828   VLOG(4) << \textcolor{stringliteral}{"sending RST\_STREAM for stream="} << stream
829           << \textcolor{stringliteral}{" with code="} << getErrorCodeString(code);
830 
831   \textcolor{comment}{// Suppress any EOM callback for the current frame.}
832   \textcolor{keywordflow}{if} (stream == streamId_) \{
833     flags_ &= ~spdy::CTRL_FLAG_FIN;
834   \}
835 
836   \textcolor{keywordflow}{if} (!isStreamIngressEgressAllowed(stream)) \{
837     VLOG(2) << \textcolor{stringliteral}{"Suppressing RST\_STREAM for stream="} << stream <<
838       \textcolor{stringliteral}{" ingressGoawayAck\_="} << ingressGoawayAck_;
839     \textcolor{keywordflow}{return} 0;
840   \}
841 
842   \textcolor{keyword}{const} uint32\_t statusCode = (uint32\_t) spdy::errorCodeToReset(code);
843   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} frameSize = kFrameSizeControlCommon + kFrameSizeRstStream;
844   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} expectedLength = writeBuf.chainLength() + frameSize;
845   QueueAppender appender(&writeBuf, frameSize);
846   appender.writeBE(versionSettings_.controlVersion);
847   appender.writeBE(uint16\_t(spdy::RST_STREAM));
848   appender.writeBE(flagsAndLength(0, kFrameSizeRstStream));
849   appender.writeBE(uint32\_t(stream));
850   appender.writeBE(rstStatusSupported(statusCode) ?
851                    statusCode : (uint32\_t)spdy::RST_PROTOCOL_ERROR);
852   DCHECK\_EQ(writeBuf.chainLength(), expectedLength);
853   \textcolor{keywordflow}{return} frameSize;
854 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!generate\+Settings@{generate\+Settings}}
\index{generate\+Settings@{generate\+Settings}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{generate\+Settings(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::generate\+Settings (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_a98a9f8c8caf4be13de82012a93969fd2}
Generate a settings message, if supported in the protocol implemented by the codec. 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_ab55cd5f8412d9d930ff6a28e0aa711b6}.



Definition at line 941 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::control\+Version, egress\+Settings\+\_\+, proxygen\+::spdy\+::\+F\+L\+A\+G\+\_\+\+S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+C\+L\+E\+A\+R\+\_\+\+S\+E\+T\+T\+I\+N\+GS, proxygen\+::\+H\+T\+T\+P\+Settings\+::get\+All\+Settings(), proxygen\+::\+H\+T\+T\+P\+Settings\+::get\+Num\+Settings(), proxygen\+::spdy\+::http\+To\+Spdy\+Settings\+Id(), proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::major\+Version, proxygen\+::spdy\+::\+S\+E\+T\+T\+I\+N\+GS, and version\+Settings\+\_\+.



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
941                                                             \{
942   \textcolor{keyword}{auto} numSettings = egressSettings_.getNumSettings();
943   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& setting: egressSettings_.getAllSettings()) \{
944     \textcolor{keywordflow}{if} (!spdy::httpToSpdySettingsId(setting.id)) \{
945       numSettings--;
946     \}
947   \}
948   VLOG(4) << \textcolor{stringliteral}{"generating "} << (unsigned)numSettings << \textcolor{stringliteral}{" settings"};
949   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} frameSize = kFrameSizeControlCommon + kFrameSizeSettings +
950     (kFrameSizeSettingsEntry * numSettings);
951   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} expectedLength = writeBuf.chainLength() + frameSize;
952   QueueAppender appender(&writeBuf, frameSize);
953   appender.writeBE(versionSettings_.controlVersion);
954   appender.writeBE(uint16\_t(spdy::SETTINGS));
955   appender.writeBE(flagsAndLength(spdy::FLAG_SETTINGS_CLEAR_SETTINGS,
956                                   kFrameSizeSettings +
957                                   kFrameSizeSettingsEntry * numSettings));
958   appender.writeBE(uint32\_t(numSettings));
959   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& setting: egressSettings_.getAllSettings()) \{
960     \textcolor{keyword}{auto} settingId = spdy::httpToSpdySettingsId(setting.id);
961     \textcolor{keywordflow}{if} (!settingId) \{
962       LOG(WARNING) << \textcolor{stringliteral}{"Invalid SpdySetting "} << (uint32\_t)setting.id;
963       \textcolor{keywordflow}{continue};
964     \}
965     VLOG(5) << \textcolor{stringliteral}{" writing setting with id="} << *settingId
966             << \textcolor{stringliteral}{", value="} << setting.value;
967     \textcolor{keywordflow}{if} (versionSettings_.majorVersion == 2) \{
968       \textcolor{comment}{// ID: 24-bits in little-endian byte order.}
969       \textcolor{comment}{// This is inconsistent with other values in SPDY and}
970       \textcolor{comment}{// is the result of a bug in the initial v2 implementation.}
971       appender.writeLE(flagsAndLength(0, *settingId));
972     \} \textcolor{keywordflow}{else} \{
973       appender.writeBE(flagsAndLength(0, *settingId));
974     \}
975     appender.writeBE<uint32\_t>(setting.value);
976   \}
977   DCHECK\_EQ(writeBuf.chainLength(), expectedLength);
978   \textcolor{keywordflow}{return} frameSize;
979 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!generate\+Syn\+Reply@{generate\+Syn\+Reply}}
\index{generate\+Syn\+Reply@{generate\+Syn\+Reply}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{generate\+Syn\+Reply(\+Stream\+I\+D stream, folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, const H\+T\+T\+P\+Message \&msg, bool eom, H\+T\+T\+P\+Header\+Size $\ast$size)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+S\+P\+D\+Y\+Codec\+::generate\+Syn\+Reply (
\begin{DoxyParamCaption}
\item[{{\bf Stream\+ID}}]{stream, }
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{const {\bf H\+T\+T\+P\+Message} \&}]{msg, }
\item[{bool}]{eom, }
\item[{{\bf H\+T\+T\+P\+Header\+Size} $\ast$}]{size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a12d385679667213ca5995b2af4faedf8}
Generates a frame of type S\+Y\+N\+\_\+\+R\+E\+P\+LY 

Definition at line 724 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::control\+Version, proxygen\+::spdy\+::\+C\+T\+R\+L\+\_\+\+F\+L\+A\+G\+\_\+\+F\+IN, proxygen\+::spdy\+::\+C\+T\+R\+L\+\_\+\+F\+L\+A\+G\+\_\+\+N\+O\+NE, proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::major\+Version, serialize\+Response\+Headers(), proxygen\+::spdy\+::\+S\+Y\+N\+\_\+\+R\+E\+P\+LY, proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::syn\+Reply\+Size, and version\+Settings\+\_\+.



Referenced by generate\+Header().


\begin{DoxyCode}
728                                                        \{
729   \textcolor{comment}{// Serialize the compressed representation of the headers}
730   \textcolor{comment}{// first because we need to write its length.  The}
731   \textcolor{comment}{// serializeResponseHeaders() method allocates an IOBuf to}
732   \textcolor{comment}{// hold the headers, but we can tell it to reserve}
733   \textcolor{comment}{// enough headroom at the start of the IOBuf to hold}
734   \textcolor{comment}{// the metadata we'll need to add once we know the}
735   \textcolor{comment}{// length.}
736   uint32\_t headroom = kFrameSizeControlCommon + versionSettings_.synReplySize;
737   unique\_ptr<IOBuf> out(serializeResponseHeaders(msg, headroom, size));
738 
739   \textcolor{comment}{// The length field in the SYN\_REPLY header holds the number}
740   \textcolor{comment}{// of bytes that follow it.  That's the length of the fields}
741   \textcolor{comment}{// specific to the SYN\_REPLY message (all of which come after}
742   \textcolor{comment}{// the length field) plus the length of the serialized header}
743   \textcolor{comment}{// name/value block.}
744   uint32\_t len = versionSettings_.synReplySize + out->computeChainDataLength();
745 
746   \textcolor{comment}{// Generate a control frame header of type SYN\_REPLY within}
747   \textcolor{comment}{// the headroom that we serializeResponseHeaders() reserved for us}
748   \textcolor{comment}{// at the start of the IOBuf.1}
749   uint8\_t flags = eom ? spdy::CTRL_FLAG_FIN : spdy::CTRL_FLAG_NONE;
750   out->prepend(headroom);
751   RWPrivateCursor cursor(out.get());
752   cursor.writeBE(versionSettings_.controlVersion);
753   cursor.writeBE(uint16\_t(spdy::SYN_REPLY));
754   cursor.writeBE(flagsAndLength(flags, len));
755   cursor.writeBE(uint32\_t(stream)); \textcolor{comment}{// TODO: stream should never be bigger than 2^31}
756   \textcolor{keywordflow}{if} (versionSettings_.majorVersion == 2) \{
757     cursor.writeBE(uint16\_t(0));
758   \}
759 
760   \textcolor{comment}{// Now that we have a complete SYN\_REPLY control frame, append}
761   \textcolor{comment}{// it to the writeBuf.}
762   writeBuf.append(std::move(out));
763 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!generate\+Syn\+Stream@{generate\+Syn\+Stream}}
\index{generate\+Syn\+Stream@{generate\+Syn\+Stream}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{generate\+Syn\+Stream(\+Stream\+I\+D stream, Stream\+I\+D assoc\+Stream, folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, const H\+T\+T\+P\+Message \&msg, bool eom, H\+T\+T\+P\+Header\+Size $\ast$size)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+S\+P\+D\+Y\+Codec\+::generate\+Syn\+Stream (
\begin{DoxyParamCaption}
\item[{{\bf Stream\+ID}}]{stream, }
\item[{{\bf Stream\+ID}}]{assoc\+Stream, }
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{const {\bf H\+T\+T\+P\+Message} \&}]{msg, }
\item[{bool}]{eom, }
\item[{{\bf H\+T\+T\+P\+Header\+Size} $\ast$}]{size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a698abed0aab26fc15fae354f72018028}
Generates a frame of type S\+Y\+N\+\_\+\+S\+T\+R\+E\+AM 

Definition at line 665 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::control\+Version, proxygen\+::spdy\+::\+C\+T\+R\+L\+\_\+\+F\+L\+A\+G\+\_\+\+F\+IN, proxygen\+::spdy\+::\+C\+T\+R\+L\+\_\+\+F\+L\+A\+G\+\_\+\+N\+O\+NE, proxygen\+::spdy\+::\+C\+T\+R\+L\+\_\+\+F\+L\+A\+G\+\_\+\+U\+N\+I\+D\+I\+R\+E\+C\+T\+I\+O\+N\+AL, proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Priority(), proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::major\+Version, No\+Stream, proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::pri\+Shift, serialize\+Request\+Headers(), proxygen\+::spdy\+::\+S\+Y\+N\+\_\+\+S\+T\+R\+E\+AM, and version\+Settings\+\_\+.



Referenced by generate\+Header(), and generate\+Push\+Promise().


\begin{DoxyCode}
670                                                         \{
671   \textcolor{comment}{// Pushed streams must have an even streamId and an odd assocStream}
672   CHECK((assocStream == NoStream && (stream % 2 == 1)) ||
673         ((stream % 2 == 0) && (assocStream % 2 == 1))) <<
674     \textcolor{stringliteral}{"Invalid stream ids stream="} << stream << \textcolor{stringliteral}{" assocStream="} << assocStream;
675 
676   \textcolor{comment}{// Serialize the compressed representation of the headers}
677   \textcolor{comment}{// first because we need to write its length.  The}
678   \textcolor{comment}{// serializeRequestHeaders() method allocates an IOBuf to}
679   \textcolor{comment}{// hold the headers, but we can tell it to reserve}
680   \textcolor{comment}{// enough headroom at the start of the IOBuf to hold}
681   \textcolor{comment}{// the metadata we'll need to add once we know the}
682   \textcolor{comment}{// length.}
683   uint32\_t fieldsSize = kFrameSizeSynStream;
684   uint32\_t headroom = kFrameSizeControlCommon + fieldsSize;
685   \textcolor{keywordtype}{bool} isPushed = (assocStream != NoStream);
686   unique\_ptr<IOBuf> out(serializeRequestHeaders(msg, isPushed,
687                                                 headroom, size));
688 
689   \textcolor{comment}{// The length field in the SYN\_STREAM header holds the number}
690   \textcolor{comment}{// of bytes that follow it.  That's the length of the fields}
691   \textcolor{comment}{// specific to the SYN\_STREAM message (all of which come after}
692   \textcolor{comment}{// the length field) plus the length of the serialized header}
693   \textcolor{comment}{// name/value block.}
694   uint32\_t len = fieldsSize + out->computeChainDataLength();
695 
696   \textcolor{comment}{// Generate a control frame header of type SYN\_STREAM within}
697   \textcolor{comment}{// the headroom that serializeRequestHeaders() reserved for us}
698   \textcolor{comment}{// at the start of the IOBuf.}
699   uint8\_t flags = spdy::CTRL_FLAG_NONE;
700   \textcolor{keywordflow}{if} (assocStream != NoStream) \{
701     flags |= spdy::CTRL_FLAG_UNIDIRECTIONAL;
702   \}
703   \textcolor{keywordflow}{if} (eom) \{
704     flags |= spdy::CTRL_FLAG_FIN;
705   \}
706   out->prepend(headroom);
707   RWPrivateCursor cursor(out.get());
708   cursor.writeBE(versionSettings_.controlVersion);
709   cursor.writeBE(uint16\_t(spdy::SYN_STREAM));
710   cursor.writeBE(flagsAndLength(flags, len));
711   cursor.writeBE(uint32\_t(stream));
712   cursor.writeBE(uint32\_t(assocStream));
713   \textcolor{comment}{// If the message set HTTP/2 priority instead of SPDY priority, we lose}
714   \textcolor{comment}{// priority information since we can't collapse it.}
715   \textcolor{comment}{// halve priority for SPDY/2}
716   uint8\_t pri = msg.getPriority() >> (3 - versionSettings_.majorVersion);
717   cursor.writeBE(uint16\_t(pri << (versionSettings_.priShift + 8)));
718 
719   \textcolor{comment}{// Now that we have a complete SYN\_STREAM control frame, append}
720   \textcolor{comment}{// it to the writeBuf.}
721   writeBuf.append(std::move(out));
722 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!generate\+Trailers@{generate\+Trailers}}
\index{generate\+Trailers@{generate\+Trailers}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{generate\+Trailers(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D stream, const H\+T\+T\+P\+Headers \&trailers) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::generate\+Trailers (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream, }
\item[{const {\bf H\+T\+T\+P\+Headers} \&}]{trailers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_a0e9a1096139d8eeccc30891d26b4d45b}
Write the message trailers \begin{DoxyReturn}{Returns}
number of bytes written 
\end{DoxyReturn}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a097d1fa44f042101b2eeeb775de65289}.



Definition at line 803 of file S\+P\+D\+Y\+Codec.\+cpp.


\begin{DoxyCode}
805                                                          \{
806   \textcolor{comment}{// TODO generate a HEADERS frame?  An additional HEADERS frame}
807   \textcolor{comment}{// somewhere after the SYN\_REPLY seems to be the SPDY equivalent}
808   \textcolor{comment}{// of HTTP/1.1's trailers.}
809   \textcolor{keywordflow}{return} 0;
810 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!generate\+Window\+Update@{generate\+Window\+Update}}
\index{generate\+Window\+Update@{generate\+Window\+Update}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{generate\+Window\+Update(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D stream, uint32\+\_\+t delta) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::generate\+Window\+Update (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream, }
\item[{uint32\+\_\+t}]{delta}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_a99ba5081bb5c440eef8c26df70007de8}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a8b80a75b703ace1377f76bd574d81b00}.



Definition at line 981 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::control\+Version, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::ingress\+Goaway\+Ack\+\_\+, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::is\+Stream\+Ingress\+Egress\+Allowed(), proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::major\+Version, proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::minor\+Version, No\+Stream, version\+Settings\+\_\+, and proxygen\+::spdy\+::\+W\+I\+N\+D\+O\+W\+\_\+\+U\+P\+D\+A\+TE.


\begin{DoxyCode}
983                                                        \{
984   \textcolor{keywordflow}{if} (versionSettings_.majorVersion < 3 ||
985       (stream == NoStream && versionSettings_.majorVersion == 3 &&
986        versionSettings_.minorVersion == 0)) \{
987     \textcolor{keywordflow}{return} 0;
988   \}
989 
990   \textcolor{keywordflow}{if} (!isStreamIngressEgressAllowed(stream)) \{
991     VLOG(2) << \textcolor{stringliteral}{"Suppressing WINDOW\_UPDATE for stream="} << stream <<
992       \textcolor{stringliteral}{" ingressGoawayAck\_="} << ingressGoawayAck_;
993     \textcolor{keywordflow}{return} 0;
994   \}
995 
996   VLOG(4) << \textcolor{stringliteral}{"generating window update for stream="} << stream
997           << \textcolor{stringliteral}{": Processed "} << delta << \textcolor{stringliteral}{" bytes"};
998   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} frameSize = kFrameSizeControlCommon + kFrameSizeWindowUpdate;
999   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} expectedLength = writeBuf.chainLength() + frameSize;
1000   QueueAppender appender(&writeBuf, frameSize);
1001   appender.writeBE(versionSettings_.controlVersion);
1002   appender.writeBE(uint16\_t(spdy::WINDOW_UPDATE));
1003   appender.writeBE(flagsAndLength(0, kFrameSizeWindowUpdate));
1004   appender.writeBE(uint32\_t(stream)); \textcolor{comment}{// TODO: ensure stream < 2^31}
1005   appender.writeBE(delta); \textcolor{comment}{// TODO: delta should never be bigger than 2^31}
1006   DCHECK\_EQ(writeBuf.chainLength(), expectedLength);
1007   \textcolor{keywordflow}{return} frameSize;
1008 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!get\+Default\+Window\+Size@{get\+Default\+Window\+Size}}
\index{get\+Default\+Window\+Size@{get\+Default\+Window\+Size}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{get\+Default\+Window\+Size() const override}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::get\+Default\+Window\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_a1744a790d78eb719b43b4bfdccd23def}
Get the default size of flow control windows for this protocol 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_af4516328c1b427f975f86909cd3ed01e}.



Definition at line 108 of file S\+P\+D\+Y\+Codec.\+h.



References proxygen\+::http2\+::k\+Initial\+Window.


\begin{DoxyCode}
108                                                  \{
109     \textcolor{keywordflow}{return} spdy::kInitialWindow;
110   \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!get\+Egress\+Settings@{get\+Egress\+Settings}}
\index{get\+Egress\+Settings@{get\+Egress\+Settings}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{get\+Egress\+Settings() override}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Settings}$\ast$ proxygen\+::\+S\+P\+D\+Y\+Codec\+::get\+Egress\+Settings (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_a5afb171c440975eb19543a257163480b}
Returns a reference to the egress settings 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a13245f4e4f749a752c87275396cf9879}.



Definition at line 107 of file S\+P\+D\+Y\+Codec.\+h.



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
107 \{ \textcolor{keywordflow}{return} &egressSettings_; \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!get\+Ingress\+Settings@{get\+Ingress\+Settings}}
\index{get\+Ingress\+Settings@{get\+Ingress\+Settings}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{get\+Ingress\+Settings() const override}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf H\+T\+T\+P\+Settings}$\ast$ proxygen\+::\+S\+P\+D\+Y\+Codec\+::get\+Ingress\+Settings (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_a307fb14458df072cf742549493a686db}
Returns a const reference to the ingress settings. Since ingress settings are set by the remote end, it doesn\textquotesingle{}t make sense for these to be mutable outside the codec. 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_aedbff2455d784b58ee452d648858cc9a}.



Definition at line 101 of file S\+P\+D\+Y\+Codec.\+h.


\begin{DoxyCode}
101                                                           \{
102     \textcolor{keywordflow}{return} &ingressSettings_;
103   \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!get\+Minor\+Version@{get\+Minor\+Version}}
\index{get\+Minor\+Version@{get\+Minor\+Version}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{get\+Minor\+Version() const }]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::get\+Minor\+Version (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classproxygen_1_1SPDYCodec_a6e33198933497eb0c2e25ed00e9d2a0d}


Definition at line 1027 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::minor\+Version, and version\+Settings\+\_\+.


\begin{DoxyCode}
1027                                          \{
1028   \textcolor{keywordflow}{return} versionSettings_.minorVersion;
1029 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!get\+Protocol@{get\+Protocol}}
\index{get\+Protocol@{get\+Protocol}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{get\+Protocol() const override}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Codec\+Protocol} proxygen\+::\+S\+P\+D\+Y\+Codec\+::get\+Protocol (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_aa0f2ca3eec4dbeb182f3370c6b75d318}
Gets the session protocol currently used by the codec. This can be mapped to a string for logging and diagnostic use. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a3818f5333dbb3c19312984ac5f069969}.



Definition at line 197 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+S\+P\+D\+Y3, proxygen\+::\+S\+P\+D\+Y3\+\_\+1, proxygen\+::\+S\+P\+D\+Y\+\_\+3, proxygen\+::\+S\+P\+D\+Y\+\_\+3\+\_\+1, proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::version, and version\+Settings\+\_\+.



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
197                                            \{
198   \textcolor{keywordflow}{switch} (versionSettings_.version) \{
199     \textcolor{keywordflow}{case} SPDYVersion::SPDY3: \textcolor{keywordflow}{return} CodecProtocol::SPDY_3;
200     \textcolor{keywordflow}{case} SPDYVersion::SPDY3_1: \textcolor{keywordflow}{return} CodecProtocol::SPDY_3_1;
201   \};
202   LOG(FATAL) << \textcolor{stringliteral}{"unreachable"};
203   \textcolor{keywordflow}{return} CodecProtocol::SPDY_3_1;
204 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!get\+User\+Agent@{get\+User\+Agent}}
\index{get\+User\+Agent@{get\+User\+Agent}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{get\+User\+Agent() const override}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string \& proxygen\+::\+S\+P\+D\+Y\+Codec\+::get\+User\+Agent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_a32213f66302ec3045e8c90af8ad6f87f}
Gets the user agent string of the client. Thus, it is only meaningful for a D\+O\+W\+N\+S\+T\+R\+E\+AM session. Note that the value is available after on\+Headers\+Complete(). It can help in diagnosing the interactions between different codec implementation. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a0fc1b54808088c79076892d0d0d53275}.



Definition at line 206 of file S\+P\+D\+Y\+Codec.\+cpp.



References user\+Agent\+\_\+.


\begin{DoxyCode}
206                                                \{
207   \textcolor{keywordflow}{return} userAgent_;
208 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!get\+Version@{get\+Version}}
\index{get\+Version@{get\+Version}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{get\+Version() const }]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::get\+Version (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classproxygen_1_1SPDYCodec_aaeb8718a6c393ce31f8c4d91d4328c5f}


Definition at line 1023 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::major\+Version, and version\+Settings\+\_\+.



Referenced by proxygen\+::\+Default\+H\+T\+T\+P\+Codec\+Factory\+::get\+Codec(), proxygen\+::\+H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+::get\+Codec(), proxygen\+::\+H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+::\+H\+T\+T\+P\+Default\+Session\+Codec\+Factory(), and T\+E\+S\+T().


\begin{DoxyCode}
1023                                     \{
1024   \textcolor{keywordflow}{return} versionSettings_.majorVersion;
1025 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!get\+Version@{get\+Version}}
\index{get\+Version@{get\+Version}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{get\+Version(const std\+::string \&protocol)}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+Optional$<$ {\bf S\+P\+D\+Y\+Version} $>$ proxygen\+::\+S\+P\+D\+Y\+Codec\+::get\+Version (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{protocol}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classproxygen_1_1SPDYCodec_ad11622dd38cbb68f943e0dca8ef69829}
Returns the S\+P\+D\+Y\+Version for the given protocol string, or none otherwise. 

Definition at line 1501 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+S\+P\+D\+Y3, and proxygen\+::\+S\+P\+D\+Y3\+\_\+1.


\begin{DoxyCode}
1501                                                \{
1502   \textcolor{comment}{// Fail fast if it's not possible for the protocol string to define a}
1503   \textcolor{comment}{// SPDY protocol. strlen("spdy/1") == 6}
1504   \textcolor{keywordflow}{if} (protocol.length() < 6) \{
1505     \textcolor{keywordflow}{return} folly::none;
1506   \}
1507 
1508   \textcolor{keywordflow}{if} (protocol == \textcolor{stringliteral}{"spdy/3.1"}) \{
1509     \textcolor{keywordflow}{return} SPDYVersion::SPDY3_1;
1510   \}
1511   \textcolor{keywordflow}{if} (protocol == \textcolor{stringliteral}{"spdy/3"}) \{
1512     \textcolor{keywordflow}{return} SPDYVersion::SPDY3;
1513   \}
1514 
1515   \textcolor{keywordflow}{return} folly::none;
1516 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!get\+Version\+Settings@{get\+Version\+Settings}}
\index{get\+Version\+Settings@{get\+Version\+Settings}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{get\+Version\+Settings(\+S\+P\+D\+Y\+Version version)}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf S\+P\+D\+Y\+Version\+Settings} \& proxygen\+::\+S\+P\+D\+Y\+Codec\+::get\+Version\+Settings (
\begin{DoxyParamCaption}
\item[{{\bf S\+P\+D\+Y\+Version}}]{version}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classproxygen_1_1SPDYCodec_ad6335a8c88f6648b52f7cb118b3dde4f}


Definition at line 138 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::spdy\+::k\+Name\+Hostv3, proxygen\+::spdy\+::k\+Name\+Methodv3, proxygen\+::spdy\+::k\+Name\+Pathv3, proxygen\+::spdy\+::k\+Name\+Schemev3, proxygen\+::spdy\+::k\+Name\+Statusv3, proxygen\+::spdy\+::k\+Name\+Versionv3, proxygen\+::spdy\+::k\+Session\+Proto\+Name\+S\+P\+D\+Y3, proxygen\+::k\+S\+P\+D\+Yv3\+Dictionary, proxygen\+::spdy\+::k\+Version\+Strv3, proxygen\+::spdy\+::k\+Version\+Strv31, proxygen\+::\+S\+P\+D\+Y3, and proxygen\+::\+S\+P\+D\+Y3\+\_\+1.


\begin{DoxyCode}
138                                                                             \{
139   \textcolor{comment}{// XXX: We new and leak the static here intentionally so it doesn't get}
140   \textcolor{comment}{// destroyed during a call to exit() when threads are still processing}
141   \textcolor{comment}{// requests resulting in spurious shutdown crashes.}
142 
143   \textcolor{comment}{// Indexed by SPDYVersion}
144   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keyword}{auto} spdyVersions = \textcolor{keyword}{new} std::vector<SPDYVersionSettings> \{
145   \textcolor{comment}{// SPDY2 no longer supported; should it ever be added back the lines in which}
146   \textcolor{comment}{// this codec creates compress/Header objects need to be updated as SPDY2}
147   \textcolor{comment}{// constant header names are different from the set of common header names.}
148   \textcolor{comment}{// SPDY3}
149     \{spdy::kNameVersionv3, spdy::kNameStatusv3, spdy::kNameMethodv3,
150     spdy::kNamePathv3, spdy::kNameSchemev3, spdy::kNameHostv3,
151     spdy::kSessionProtoNameSPDY3, parseUint32, appendUint32,
152     (\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)kSPDYv3Dictionary, \textcolor{keyword}{sizeof}(kSPDYv3Dictionary),
153     0x8003, kFrameSizeSynReplyv3, kFrameSizeNameValuev3,
154      kFrameSizeGoawayv3, kPriShiftv3, 3, 0, SPDYVersion::SPDY3,
155      spdy::kVersionStrv3\},
156   \textcolor{comment}{// SPDY3.1}
157     \{spdy::kNameVersionv3, spdy::kNameStatusv3, spdy::kNameMethodv3,
158     spdy::kNamePathv3, spdy::kNameSchemev3, spdy::kNameHostv3,
159     spdy::kSessionProtoNameSPDY3, parseUint32, appendUint32,
160     (\textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char}*)kSPDYv3Dictionary, \textcolor{keyword}{sizeof}(kSPDYv3Dictionary),
161     0x8003, kFrameSizeSynReplyv3, kFrameSizeNameValuev3,
162      kFrameSizeGoawayv3, kPriShiftv3, 3, 1, SPDYVersion::SPDY3_1,
163      spdy::kVersionStrv31\}
164   \};
165   \textcolor{keyword}{auto} intVersion = \textcolor{keyword}{static\_cast<}\textcolor{keywordtype}{unsigned}\textcolor{keyword}{>}(version);
166   CHECK\_LT(intVersion, spdyVersions->size());
167   \textcolor{keywordflow}{return} (*spdyVersions)[intVersion];
168 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!is\+S\+P\+D\+Y\+Reserved@{is\+S\+P\+D\+Y\+Reserved}}
\index{is\+S\+P\+D\+Y\+Reserved@{is\+S\+P\+D\+Y\+Reserved}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{is\+S\+P\+D\+Y\+Reserved(const std\+::string \&name)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+S\+P\+D\+Y\+Codec\+::is\+S\+P\+D\+Y\+Reserved (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_ae0ed625c0c2fcfbb5f935ceb18f3b1ad}


Definition at line 489 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::case\+Insensitive\+Equal(), proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, proxygen\+::spdy\+::k\+Name\+Methodv2, proxygen\+::spdy\+::k\+Name\+Pathv2, proxygen\+::spdy\+::k\+Name\+Schemev2, proxygen\+::spdy\+::k\+Name\+Statusv2, proxygen\+::spdy\+::k\+Name\+Versionv2, proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::major\+Version, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::transport\+Direction\+\_\+, proxygen\+::\+U\+P\+S\+T\+R\+E\+AM, and version\+Settings\+\_\+.



Referenced by encode\+Headers().


\begin{DoxyCode}
489                                                     \{
490   \textcolor{keywordflow}{return} (versionSettings_.majorVersion == 2 &&
491           ((transportDirection_ == TransportDirection::DOWNSTREAM &&
492             (caseInsensitiveEqual(name, spdy::kNameStatusv2) ||
493              caseInsensitiveEqual(name, spdy::kNameVersionv2))) ||
494            (transportDirection_ == TransportDirection::UPSTREAM &&
495             (caseInsensitiveEqual(name, spdy::kNameMethodv2) ||
496              caseInsensitiveEqual(name, spdy::kNameSchemev2) ||
497              caseInsensitiveEqual(name, spdy::kNamePathv2) ||
498              caseInsensitiveEqual(name, spdy::kNameVersionv2)))));
499 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!map\+Dependency\+To\+Priority@{map\+Dependency\+To\+Priority}}
\index{map\+Dependency\+To\+Priority@{map\+Dependency\+To\+Priority}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{map\+Dependency\+To\+Priority(\+Stream\+I\+D parent) const override}]{\setlength{\rightskip}{0pt plus 5cm}int8\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::map\+Dependency\+To\+Priority (
\begin{DoxyParamCaption}
\item[{{\bf Stream\+ID}}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_afee654bf987b86908d803c8c7cb0b48a}
Map the parent back to the priority, -\/1 if this doesn\textquotesingle{}t make sense. 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a97b36f9ee89eb8441e655126df2ebe5c}.



Definition at line 136 of file S\+P\+D\+Y\+Codec.\+h.


\begin{DoxyCode}
136                                                                  \{
137     \textcolor{keywordflow}{if} (parent >= MAX_STREAM_ID) \{
138       \textcolor{keywordflow}{return} parent - MAX_STREAM_ID;
139     \}
140     \textcolor{keywordflow}{return} -1;
141   \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!map\+Priority\+To\+Dependency@{map\+Priority\+To\+Dependency}}
\index{map\+Priority\+To\+Dependency@{map\+Priority\+To\+Dependency}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{map\+Priority\+To\+Dependency(uint8\+\_\+t priority) const override}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stream\+ID} proxygen\+::\+S\+P\+D\+Y\+Codec\+::map\+Priority\+To\+Dependency (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_acde10d6e811a88aca88c411aed979f7c}
Map the given linear priority to the correct parent node dependency 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_ad3f2df6e146618da881c36c5bd68c7e3}.



Definition at line 132 of file S\+P\+D\+Y\+Codec.\+h.


\begin{DoxyCode}
132                                                                     \{
133     \textcolor{keywordflow}{return} MAX_STREAM_ID + priority;
134   \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!on\+Control\+Frame@{on\+Control\+Frame}}
\index{on\+Control\+Frame@{on\+Control\+Frame}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{on\+Control\+Frame(folly\+::io\+::\+Cursor \&cursor)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+S\+P\+D\+Y\+Codec\+::on\+Control\+Frame (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a3cced5f9bf173cdf21cd264fb94fcae6}
Helper function to parse out a control frame and execute its handler. All errors are thrown as exceptions. 

Definition at line 335 of file S\+P\+D\+Y\+Codec.\+cpp.



References check\+Length(), check\+Min\+Length(), proxygen\+::spdy\+::\+C\+R\+E\+D\+E\+N\+T\+I\+AL, decode\+Headers(), D\+E\+L\+T\+A\+\_\+\+W\+I\+N\+D\+O\+W\+\_\+\+S\+I\+Z\+E\+\_\+\+M\+A\+SK, proxygen\+::\+E\+R\+R\+OR, F\+L\+A\+G\+S\+\_\+\+M\+A\+SK, proxygen\+::\+Gzip\+Header\+Codec\+::get\+Decoded\+Size(), proxygen\+::spdy\+::\+G\+O\+A\+W\+AY, proxygen\+::spdy\+::\+G\+O\+A\+W\+A\+Y\+\_\+\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::goaway\+Size, header\+Codec\+\_\+, proxygen\+::spdy\+::\+H\+E\+A\+D\+E\+RS, length\+\_\+, proxygen\+::spdy\+::\+N\+O\+OP, on\+Goaway(), on\+Headers(), on\+Ping(), on\+Rst\+Stream(), on\+Settings(), on\+Syn\+Reply(), on\+Syn\+Stream(), on\+Window\+Update(), proxygen\+::spdy\+::\+P\+I\+NG, proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::pri\+Shift, proxygen\+::spdy\+::\+R\+S\+T\+\_\+\+S\+T\+R\+E\+AM, proxygen\+::spdy\+::\+S\+E\+T\+T\+I\+N\+GS, settings, status\+Code, S\+T\+R\+E\+A\+M\+\_\+\+I\+D\+\_\+\+M\+A\+SK, stream\+Id\+\_\+, proxygen\+::spdy\+::\+S\+Y\+N\+\_\+\+R\+E\+P\+LY, proxygen\+::spdy\+::\+S\+Y\+N\+\_\+\+S\+T\+R\+E\+AM, proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::syn\+Reply\+Size, type\+\_\+, version\+\_\+, version\+Settings\+\_\+, and proxygen\+::spdy\+::\+W\+I\+N\+D\+O\+W\+\_\+\+U\+P\+D\+A\+TE.



Referenced by parse\+Ingress().


\begin{DoxyCode}
335                                              \{
336   \textcolor{keywordflow}{switch} (type_) \{
337     \textcolor{keywordflow}{case} spdy::SYN_STREAM:
338     \{
339       checkMinLength(kFrameSizeSynStream, \textcolor{stringliteral}{"SYN\_STREAM"});
340       streamId_ = cursor.readBE<uint32\_t>() & STREAM_ID_MASK;
341       uint32\_t assocStream = cursor.readBE<uint32\_t>();
342       uint8\_t pri = cursor.read<uint8\_t>() >> versionSettings_.priShift;
343       uint8\_t slot = cursor.read<uint8\_t>();
344       length_ -= kFrameSizeSynStream;
345       \textcolor{keyword}{auto} result = decodeHeaders(cursor);
346       checkLength(0, \textcolor{stringliteral}{"SYN\_STREAM"});
347       onSynStream(assocStream, pri, slot,
348                   result.headers, headerCodec_.getDecodedSize());
349       \textcolor{keywordflow}{break};
350     \}
351     \textcolor{keywordflow}{case} spdy::SYN_REPLY:
352     \{
353       checkMinLength(versionSettings_.synReplySize, \textcolor{stringliteral}{"SYN\_REPLY"});
354       streamId_ = cursor.readBE<uint32\_t>() & STREAM_ID_MASK;
355       length_ -= versionSettings_.synReplySize;
356       \textcolor{keywordflow}{if} (version_ == 2) \{
357         \textcolor{comment}{// 2 byte unused}
358         cursor.skip(2);
359       \}
360       \textcolor{keyword}{auto} result = decodeHeaders(cursor);
361       checkLength(0, \textcolor{stringliteral}{"SYN\_REPLY"});
362       onSynReply(result.headers,
363                  headerCodec_.getDecodedSize());
364       \textcolor{keywordflow}{break};
365     \}
366     \textcolor{keywordflow}{case} spdy::RST_STREAM:
367     \{
368       checkLength(kFrameSizeRstStream, \textcolor{stringliteral}{"RST"});
369       streamId_ = cursor.readBE<uint32\_t>() & STREAM_ID_MASK;
370       uint32\_t statusCode = cursor.readBE<uint32\_t>();
371       onRstStream(statusCode);
372       \textcolor{keywordflow}{break};
373     \}
374     \textcolor{keywordflow}{case} spdy::SETTINGS:
375     \{
376       checkMinLength(kFrameSizeSettings, \textcolor{stringliteral}{"SETTINGS"});
377       uint32\_t numSettings = cursor.readBE<uint32\_t>();
378       length\_ -= \textcolor{keyword}{sizeof}(uint32\_t);
379       \textcolor{keywordflow}{if} (length\_ / 8 < numSettings) \{
380         LOG(ERROR) << \textcolor{stringliteral}{"SETTINGS: number of settings to high. "}
381                    << length\_ << \textcolor{stringliteral}{" < 8 * "} << numSettings;
382         \textcolor{keywordflow}{throw} SPDYSessionFailed(spdy::GOAWAY_PROTOCOL_ERROR);
383       \}
384       SettingList settings;
385       \textcolor{keywordflow}{for} (uint32\_t i = 0; i < numSettings; i++) \{
386         uint32\_t \textcolor{keywordtype}{id} = 0;
387         \textcolor{keywordflow}{if} (version_ == 2) \{
388           \textcolor{keywordtype}{id} = cursor.readLE<uint32\_t>();
389         \} \textcolor{keywordflow}{else} \{
390           \textcolor{keywordtype}{id} = cursor.readBE<uint32\_t>();
391         \}
392         uint32\_t value = cursor.readBE<uint32\_t>();
393         uint8\_t flags = (\textcolor{keywordtype}{id} & FLAGS_MASK) >> 24;
394         \textcolor{keywordtype}{id} &= ~FLAGS_MASK;
395         settings.emplace\_back(flags, \textcolor{keywordtype}{id}, value);
396       \}
397       onSettings(settings);
398       \textcolor{keywordflow}{break};
399     \}
400     \textcolor{keywordflow}{case} spdy::NOOP:
401       VLOG(4) << \textcolor{stringliteral}{"Noop received. Doing nothing."};
402       checkLength(0, \textcolor{stringliteral}{"NOOP"});
403       \textcolor{keywordflow}{break};
404     \textcolor{keywordflow}{case} spdy::PING:
405     \{
406       checkLength(kFrameSizePing, \textcolor{stringliteral}{"PING"});
407       uint32\_t unique\_id = cursor.readBE<uint32\_t>();
408       onPing(unique\_id);
409       \textcolor{keywordflow}{break};
410     \}
411     \textcolor{keywordflow}{case} spdy::GOAWAY:
412     \{
413       checkLength(versionSettings_.goawaySize, \textcolor{stringliteral}{"GOAWAY"});
414       uint32\_t lastStream = cursor.readBE<uint32\_t>();
415       uint32\_t statusCode = 0;
416       \textcolor{keywordflow}{if} (version_ == 3) \{
417         statusCode = cursor.readBE<uint32\_t>();
418       \}
419       onGoaway(lastStream, statusCode);
420       \textcolor{keywordflow}{break};
421     \}
422     \textcolor{keywordflow}{case} spdy::HEADERS:
423     \{
424       \textcolor{comment}{// Note: this is for the HEADERS frame type, not the initial headers}
425       checkMinLength(kFrameSizeHeaders, \textcolor{stringliteral}{"HEADERS"});
426       streamId_ = cursor.readBE<uint32\_t>() & STREAM_ID_MASK;
427       length\_ -= kFrameSizeHeaders;
428       \textcolor{keywordflow}{if} (version_ == 2) \{
429         \textcolor{comment}{// 2 byte unused}
430         cursor.skip(2);
431         length\_ -= 2;
432       \}
433       \textcolor{keyword}{auto} result = decodeHeaders(cursor);
434       checkLength(0, \textcolor{stringliteral}{"HEADERS"});
435       onHeaders(result.headers);
436       \textcolor{keywordflow}{break};
437     \}
438     \textcolor{keywordflow}{case} spdy::WINDOW_UPDATE:
439     \{
440       checkLength(kFrameSizeWindowUpdate, \textcolor{stringliteral}{"WINDOW\_UPDATE"});
441       streamId_ = cursor.readBE<uint32\_t>() & STREAM_ID_MASK;
442       uint32\_t delta = cursor.readBE<uint32\_t>() & DELTA_WINDOW_SIZE_MASK;
443       onWindowUpdate(delta);
444       \textcolor{keywordflow}{break};
445     \}
446     \textcolor{keywordflow}{case} spdy::CREDENTIAL:
447     \{
448       VLOG(4) << \textcolor{stringliteral}{"Skipping unsupported/deprecated CREDENTIAL frame"};
449       \textcolor{comment}{// Fall through to default case}
450     \}
451     \textcolor{keywordflow}{default}:
452       VLOG(3) << \textcolor{stringliteral}{"unimplemented control frame type "} << type_
453               << \textcolor{stringliteral}{", frame length: "} << length_;
454       \textcolor{comment}{// From spdy spec:}
455       \textcolor{comment}{// Control frame processing requirements:}
456       \textcolor{comment}{// If an endpoint receives a control frame for a type it does not}
457       \textcolor{comment}{// recognize, it must ignore the frame.}
458 
459       \textcolor{comment}{// Consume rest of the frame to skip processing it further}
460       cursor.skip(length\_);
461       length\_ = 0;
462       \textcolor{keywordflow}{return};
463   \}
464 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!on\+Goaway@{on\+Goaway}}
\index{on\+Goaway@{on\+Goaway}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{on\+Goaway(uint32\+\_\+t last\+Good\+Stream, uint32\+\_\+t status\+Code) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+S\+P\+D\+Y\+Codec\+::on\+Goaway (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{last\+Good\+Stream, }
\item[{uint32\+\_\+t}]{status\+Code}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1SPDYCodec_a51383e696acaa70ed92e3d9f079a425e}


Definition at line 1416 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::callback\+\_\+, proxygen\+::spdy\+::\+G\+O\+A\+W\+A\+Y\+\_\+\+F\+L\+O\+W\+\_\+\+C\+O\+N\+T\+R\+O\+L\+\_\+\+E\+R\+R\+OR, proxygen\+::spdy\+::goaway\+To\+Error\+Code(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::ingress\+Goaway\+Ack\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Goaway(), proxygen\+::\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, and status\+Code.



Referenced by on\+Control\+Frame().


\begin{DoxyCode}
1417                                                        \{
1418   VLOG(4) << \textcolor{stringliteral}{"Got GOAWAY, lastGoodStream="} << lastGoodStream
1419           << \textcolor{stringliteral}{", statusCode="} << statusCode;
1420 
1421   \textcolor{keywordflow}{if} (lastGoodStream < ingressGoawayAck_) \{
1422     ingressGoawayAck_ = lastGoodStream;
1423     \textcolor{comment}{// Drain all streams <= lastGoodStream}
1424     \textcolor{comment}{// and abort streams > lastGoodStream}
1425     \textcolor{keyword}{auto} errorCode = ErrorCode::PROTOCOL_ERROR;
1426     \textcolor{keywordflow}{if} (statusCode <= spdy::GoawayStatusCode::GOAWAY_FLOW_CONTROL_ERROR) \{
1427       errorCode = spdy::goawayToErrorCode(spdy::GoawayStatusCode(statusCode));
1428     \}
1429     callback_->onGoaway(lastGoodStream, errorCode);
1430   \} \textcolor{keywordflow}{else} \{
1431     LOG(WARNING) << \textcolor{stringliteral}{"Received multiple GOAWAY with increasing ack"};
1432   \}
1433 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!on\+Headers@{on\+Headers}}
\index{on\+Headers@{on\+Headers}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{on\+Headers(const compress\+::\+Header\+Piece\+List \&headers) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+S\+P\+D\+Y\+Codec\+::on\+Headers (
\begin{DoxyParamCaption}
\item[{const {\bf compress\+::\+Header\+Piece\+List} \&}]{headers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1SPDYCodec_a60189b6878e6190f664effaa47237a96}
Handle a H\+E\+A\+D\+E\+RS frame. This is {\itshape not} invoked when the first headers on a stream are received. This is called when the remote endpoint sends us any additional headers. 

Definition at line 1435 of file S\+P\+D\+Y\+Codec.\+cpp.



Referenced by on\+Control\+Frame().


\begin{DoxyCode}
1435                                                            \{
1436   VLOG(3) << \textcolor{stringliteral}{"onHeaders is unimplemented."};
1437 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!on\+Ingress@{on\+Ingress}}
\index{on\+Ingress@{on\+Ingress}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{on\+Ingress(const folly\+::\+I\+O\+Buf \&buf) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::on\+Ingress (
\begin{DoxyParamCaption}
\item[{const folly\+::\+I\+O\+Buf \&}]{buf}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_aa92e867e2aca890328fc3a0c1539fe58}
Parse ingress data. 
\begin{DoxyParams}{Parameters}
{\em buf} & A single I\+O\+Buf of data to parse \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of bytes consumed. 
\end{DoxyReturn}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a44a623c547735db83ae472ba7f1af6df}.



Definition at line 234 of file S\+P\+D\+Y\+Codec.\+cpp.



References current\+Ingress\+Buf\+\_\+, fail\+Session(), and parse\+Ingress().



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
234                                                  \{
235   \textcolor{keywordtype}{size\_t} bytesParsed = 0;
236   currentIngressBuf_ = &buf;
237   \textcolor{keywordflow}{try} \{
238     bytesParsed = parseIngress(buf);
239   \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} SPDYSessionFailed& ex) \{
240     failSession(ex.statusCode);
241     bytesParsed = buf.computeChainDataLength();
242   \}
243   \textcolor{keywordflow}{return} bytesParsed;
244 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!on\+Ping@{on\+Ping}}
\index{on\+Ping@{on\+Ping}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{on\+Ping(uint32\+\_\+t unique\+I\+D) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+S\+P\+D\+Y\+Codec\+::on\+Ping (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{unique\+ID}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1SPDYCodec_a76d2e2f40f8ac0663b1e72405f9fce21}


Definition at line 1393 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::callback\+\_\+, proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, next\+Egress\+Ping\+I\+D\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Ping\+Reply(), proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Ping\+Request(), and proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::transport\+Direction\+\_\+.



Referenced by on\+Control\+Frame().


\begin{DoxyCode}
1393                                                  \{
1394   \textcolor{keywordtype}{bool} odd = uniqueID & 0x1;
1395   \textcolor{keywordtype}{bool} isReply = \textcolor{keyword}{true};
1396   \textcolor{keywordflow}{if} (transportDirection_ == TransportDirection::DOWNSTREAM) \{
1397     \textcolor{keywordflow}{if} (odd) \{
1398       isReply = \textcolor{keyword}{false};
1399     \}
1400   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!odd) \{
1401     isReply = \textcolor{keyword}{false};
1402   \}
1403 
1404   \textcolor{keywordflow}{if} (isReply) \{
1405     \textcolor{keywordflow}{if} (uniqueID >= nextEgressPingID_) \{
1406       LOG(INFO) << \textcolor{stringliteral}{"Received reply for pingID="} << uniqueID
1407                 << \textcolor{stringliteral}{" that was never sent"};
1408       \textcolor{keywordflow}{return};
1409     \}
1410     callback_->onPingReply(uniqueID);
1411   \} \textcolor{keywordflow}{else} \{
1412     callback_->onPingRequest(uniqueID);
1413   \}
1414 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!on\+Rst\+Stream@{on\+Rst\+Stream}}
\index{on\+Rst\+Stream@{on\+Rst\+Stream}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{on\+Rst\+Stream(uint32\+\_\+t status\+Code) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+S\+P\+D\+Y\+Codec\+::on\+Rst\+Stream (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{status\+Code}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1SPDYCodec_aafa713888a5fc204b50da485e97f93b5}
Handle an ingress R\+S\+T\+\_\+\+S\+T\+R\+E\+AM control frame. 

Definition at line 1337 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::deliver\+Callback\+If\+Allowed(), proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Abort(), proxygen\+::spdy\+::rst\+To\+Error\+Code(), status\+Code, stream\+ID, and stream\+Id\+\_\+.



Referenced by on\+Control\+Frame().


\begin{DoxyCode}
1337                                                         \{
1338   VLOG(4) << \textcolor{stringliteral}{"Got RST\_STREAM, stream="} << streamId_
1339           << \textcolor{stringliteral}{", status="} << statusCode;
1340   StreamID streamID(streamId_);
1341   deliverCallbackIfAllowed(&HTTPCodec::Callback::onAbort, \textcolor{stringliteral}{"onAbort"}, streamID,
1342                        spdy::rstToErrorCode(spdy::ResetStatusCode(statusCode)));
1343 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!on\+Settings@{on\+Settings}}
\index{on\+Settings@{on\+Settings}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{on\+Settings(const Setting\+List \&settings)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+S\+P\+D\+Y\+Codec\+::on\+Settings (
\begin{DoxyParamCaption}
\item[{const {\bf Setting\+List} \&}]{settings}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a0a1e7660cf2613d0fbd224ede1d508eb}
Handle a S\+E\+T\+T\+I\+N\+GS message that changes/updates settings for the entire S\+P\+DY connection (across all transactions) 

Definition at line 1345 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::callback\+\_\+, proxygen\+::\+E\+R\+R\+OR, flags\+\_\+, proxygen\+::\+H\+T\+T\+P\+Settings\+::get\+Setting(), proxygen\+::spdy\+::\+G\+O\+A\+W\+A\+Y\+\_\+\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, proxygen\+::spdy\+::\+I\+D\+\_\+\+F\+L\+A\+G\+\_\+\+S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+P\+E\+R\+S\+I\+S\+T\+ED, ingress\+Settings\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Settings(), proxygen\+::\+H\+T\+T\+P\+Settings\+::set\+Setting(), proxygen\+::spdy\+::\+S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+C\+L\+I\+E\+N\+T\+\_\+\+C\+E\+R\+T\+I\+F\+I\+C\+A\+T\+E\+\_\+\+V\+E\+C\+T\+O\+R\+\_\+\+S\+I\+ZE, proxygen\+::spdy\+::\+S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+C\+U\+R\+R\+E\+N\+T\+\_\+\+C\+W\+ND, proxygen\+::spdy\+::\+S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+D\+O\+W\+N\+L\+O\+A\+D\+\_\+\+B\+A\+N\+D\+W\+I\+D\+TH, proxygen\+::spdy\+::\+S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+D\+O\+W\+N\+L\+O\+A\+D\+\_\+\+R\+E\+T\+R\+A\+N\+S\+\_\+\+R\+A\+TE, proxygen\+::spdy\+::\+S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+I\+N\+I\+T\+I\+A\+L\+\_\+\+W\+I\+N\+D\+O\+W\+\_\+\+S\+I\+ZE, proxygen\+::spdy\+::\+S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+M\+A\+X\+\_\+\+C\+O\+N\+C\+U\+R\+R\+E\+N\+T\+\_\+\+S\+T\+R\+E\+A\+MS, proxygen\+::spdy\+::\+S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+R\+O\+U\+N\+D\+\_\+\+T\+R\+I\+P\+\_\+\+T\+I\+ME, proxygen\+::spdy\+::\+S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+U\+P\+L\+O\+A\+D\+\_\+\+B\+A\+N\+D\+W\+I\+D\+TH, proxygen\+::spdy\+::spdy\+To\+Http\+Settings\+Id(), and version\+\_\+.



Referenced by on\+Control\+Frame().


\begin{DoxyCode}
1345                                                       \{
1346   VLOG(4) << \textcolor{stringliteral}{"Got "} << settings.size() << \textcolor{stringliteral}{" settings with "}
1347           << \textcolor{stringliteral}{"version="} << version_ << \textcolor{stringliteral}{" and flags="}
1348           << std::hex << folly::to<unsigned int>(flags_) << std::dec;
1349   SettingsList settingsList;
1350   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} SettingData& cur: settings) \{
1351     \textcolor{comment}{// For now, we never ask for anything to be persisted, so ignore anything}
1352     \textcolor{comment}{// coming back}
1353     \textcolor{keywordflow}{if} (cur.flags & spdy::ID_FLAG_SETTINGS_PERSISTED) \{
1354       VLOG(2) << \textcolor{stringliteral}{"Ignoring bogus persisted setting: "} << cur.id;
1355       \textcolor{keywordflow}{continue};
1356     \}
1357 
1358     \textcolor{keywordflow}{switch} (cur.id) \{
1359       \textcolor{keywordflow}{case} spdy::SETTINGS_UPLOAD_BANDWIDTH:
1360       \textcolor{keywordflow}{case} spdy::SETTINGS_DOWNLOAD_BANDWIDTH:
1361       \textcolor{keywordflow}{case} spdy::SETTINGS_ROUND_TRIP_TIME:
1362       \textcolor{keywordflow}{case} spdy::SETTINGS_CURRENT_CWND:
1363       \textcolor{keywordflow}{case} spdy::SETTINGS_DOWNLOAD_RETRANS_RATE:
1364       \textcolor{keywordflow}{case} spdy::SETTINGS_CLIENT_CERTIFICATE_VECTOR_SIZE:
1365         \textcolor{comment}{// These will be stored in ingressSettings\_ and passed to the callback}
1366         \textcolor{comment}{// but we currently ignore the PERSIST flag}
1367         \textcolor{keywordflow}{break};
1368       \textcolor{keywordflow}{case} spdy::SETTINGS_MAX_CONCURRENT_STREAMS:
1369         \textcolor{keywordflow}{break};
1370       \textcolor{keywordflow}{case} spdy::SETTINGS_INITIAL_WINDOW_SIZE:
1371         \textcolor{keywordflow}{if} (cur.value > std::numeric\_limits<int32\_t>::max()) \{
1372           \textcolor{keywordflow}{throw} SPDYSessionFailed(spdy::GOAWAY_PROTOCOL_ERROR);
1373         \}
1374         \textcolor{keywordflow}{break};
1375       \textcolor{keywordflow}{default}:
1376         LOG(ERROR) << \textcolor{stringliteral}{"Received unknown setting with ID="} << cur.id
1377                    << \textcolor{stringliteral}{", value="} << cur.value
1378                    << \textcolor{stringliteral}{", and flags="} << std::hex << cur.flags << std::dec;
1379     \}
1380     \textcolor{keywordflow}{if} (cur.id >= spdy::SettingsId::SETTINGS_UPLOAD_BANDWIDTH &&
1381         cur.id <= spdy::SettingsId::SETTINGS_CLIENT_CERTIFICATE_VECTOR_SIZE) \{
1382       \textcolor{keyword}{auto} \textcolor{keywordtype}{id} = spdy::spdyToHttpSettingsId((spdy::SettingsId)cur.id);
1383       \textcolor{keywordflow}{if} (\textcolor{keywordtype}{id}) \{
1384         ingressSettings_.setSetting(*\textcolor{keywordtype}{id}, cur.value);
1385         \textcolor{keyword}{auto} s = ingressSettings_.getSetting(*\textcolor{keywordtype}{id});
1386         settingsList.push\_back(*s);
1387       \}
1388     \}
1389   \}
1390   callback_->onSettings(settingsList);
1391 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!on\+Syn\+Common@{on\+Syn\+Common}}
\index{on\+Syn\+Common@{on\+Syn\+Common}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{on\+Syn\+Common(\+Stream\+I\+D stream\+I\+D, Stream\+I\+D assoc\+Stream\+I\+D, const compress\+::\+Header\+Piece\+List \&headers, int8\+\_\+t pri, const H\+T\+T\+P\+Header\+Size \&size)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+S\+P\+D\+Y\+Codec\+::on\+Syn\+Common (
\begin{DoxyParamCaption}
\item[{{\bf Stream\+ID}}]{stream\+ID, }
\item[{{\bf Stream\+ID}}]{assoc\+Stream\+ID, }
\item[{const {\bf compress\+::\+Header\+Piece\+List} \&}]{headers, }
\item[{int8\+\_\+t}]{pri, }
\item[{const {\bf H\+T\+T\+P\+Header\+Size} \&}]{size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a1bd1295af6a5a4f12a9d7863ae52e4bf}
Helper function that contains the common implementation details of calling the same callbacks for \doxyref{on\+Syn\+Stream()}{p.}{classproxygen_1_1SPDYCodec_a48e30378f48cf93b922f8e491814ea8e} and \doxyref{on\+Syn\+Reply()}{p.}{classproxygen_1_1SPDYCodec_ada7a1914e492a90e8b5f837137d2ae3d}

Negative values of pri are interpreted much like negative array indexes in python, so -\/1 will be the largest numerical priority value for this S\+P\+DY version (i.\+e., 3 for S\+P\+D\+Y/2 or 7 for S\+P\+D\+Y/3), -\/2 the second largest (i.\+e., 2 for S\+P\+D\+Y/2 or 6 for S\+P\+D\+Y/3). 

Definition at line 1238 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::spdy\+::\+C\+T\+R\+L\+\_\+\+F\+L\+A\+G\+\_\+\+F\+IN, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::deliver\+Callback\+If\+Allowed(), deliver\+On\+Message\+Begin(), proxygen\+::\+E\+R\+R\+OR, flags\+\_\+, proxygen\+::spdy\+::\+G\+O\+A\+W\+A\+Y\+\_\+\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::major\+Version, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+M\+A\+X\+\_\+\+S\+T\+R\+E\+A\+M\+\_\+\+ID, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Headers\+Complete(), parse\+Headers(), proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::protocol\+Version\+String, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::transport\+Direction\+\_\+, user\+Agent\+\_\+, version\+\_\+, and version\+Settings\+\_\+.



Referenced by on\+Syn\+Reply(), and on\+Syn\+Stream().


\begin{DoxyCode}
1242                                                         \{
1243   \textcolor{keywordflow}{if} (version_ != versionSettings_.majorVersion) \{
1244     LOG(ERROR) << \textcolor{stringliteral}{"Invalid version="} << version_;
1245     \textcolor{keywordflow}{throw} SPDYSessionFailed(spdy::GOAWAY_PROTOCOL_ERROR);
1246   \}
1247 
1248   unique\_ptr<HTTPMessage> msg = parseHeaders(transportDirection_,
1249                                              streamID, assocStreamID, headers);
1250   msg->setIngressHeaderSize(size);
1251 
1252   msg->setAdvancedProtocolString(versionSettings_.protocolVersionString);
1253   \textcolor{comment}{// Normalize priority to 3 bits in HTTPMessage.}
1254   pri <<= (3 - versionSettings_.majorVersion);
1255   msg->setPriority(pri);
1256   msg->setHTTP2Priority(std::make\_tuple(HTTPCodec::MAX_STREAM_ID + pri,
1257                                         \textcolor{keyword}{false}, 255));
1258   deliverOnMessageBegin(streamID, assocStreamID, msg.get());
1259 
1260   \textcolor{keywordflow}{if} ((flags_ & spdy::CTRL_FLAG_FIN) == 0) \{
1261     \textcolor{comment}{// If it there are DATA frames coming, consider it chunked}
1262     msg->setIsChunked(\textcolor{keyword}{true});
1263   \}
1264   \textcolor{keywordflow}{if} (userAgent_.empty()) \{
1265     userAgent_ = msg->getHeaders().getSingleOrEmpty(HTTP\_HEADER\_USER\_AGENT);
1266   \}
1267   deliverCallbackIfAllowed(&HTTPCodec::Callback::onHeadersComplete,
1268                            \textcolor{stringliteral}{"onHeadersComplete"}, streamID, std::move(msg));
1269 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!on\+Syn\+Reply@{on\+Syn\+Reply}}
\index{on\+Syn\+Reply@{on\+Syn\+Reply}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{on\+Syn\+Reply(const compress\+::\+Header\+Piece\+List \&headers, const H\+T\+T\+P\+Header\+Size \&size)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+S\+P\+D\+Y\+Codec\+::on\+Syn\+Reply (
\begin{DoxyParamCaption}
\item[{const {\bf compress\+::\+Header\+Piece\+List} \&}]{headers, }
\item[{const {\bf H\+T\+T\+P\+Header\+Size} \&}]{size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_ada7a1914e492a90e8b5f837137d2ae3d}
Handle an ingress S\+Y\+N\+\_\+\+R\+E\+P\+LY control frame. For an upstream-\/facing S\+P\+DY session, this frame is the equivalent of an H\+T\+TP response header. 

Definition at line 1323 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, No\+Stream, on\+Syn\+Common(), proxygen\+::spdy\+::\+R\+S\+T\+\_\+\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, stream\+Id\+\_\+, and proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::transport\+Direction\+\_\+.



Referenced by on\+Control\+Frame().


\begin{DoxyCode}
1324                                                        \{
1325   VLOG(4) << \textcolor{stringliteral}{"Got SYN\_REPLY, stream="} << streamId_;
1326   \textcolor{keywordflow}{if} (transportDirection_ == TransportDirection::DOWNSTREAM ||
1327       (streamId_ & 0x1) == 0) \{
1328     \textcolor{keywordflow}{throw} SPDYStreamFailed(\textcolor{keyword}{true}, streamId_, spdy::RST_PROTOCOL_ERROR);
1329   \}
1330   \textcolor{comment}{// Server push transactions, short of any better heuristics,}
1331   \textcolor{comment}{// should have a background priority. Thus, we pick the largest}
1332   \textcolor{comment}{// numerical value for the SPDY priority, which no matter what}
1333   \textcolor{comment}{// protocol version this is can be conveyed to onSynCommon by -1.}
1334   onSynCommon(StreamID(streamId_), NoStream, headers, -1, size);
1335 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!on\+Syn\+Stream@{on\+Syn\+Stream}}
\index{on\+Syn\+Stream@{on\+Syn\+Stream}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{on\+Syn\+Stream(uint32\+\_\+t assoc\+Stream, uint8\+\_\+t pri, uint8\+\_\+t slot, const compress\+::\+Header\+Piece\+List \&headers, const H\+T\+T\+P\+Header\+Size \&size)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+S\+P\+D\+Y\+Codec\+::on\+Syn\+Stream (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{assoc\+Stream, }
\item[{uint8\+\_\+t}]{pri, }
\item[{uint8\+\_\+t}]{slot, }
\item[{const {\bf compress\+::\+Header\+Piece\+List} \&}]{headers, }
\item[{const {\bf H\+T\+T\+P\+Header\+Size} \&}]{size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a48e30378f48cf93b922f8e491814ea8e}
Handle an ingress S\+Y\+N\+\_\+\+S\+T\+R\+E\+AM control frame. For a downstream-\/facing S\+P\+DY session, this frame is the equivalent of an H\+T\+TP request header. 

Definition at line 1283 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::callback\+\_\+, proxygen\+::spdy\+::\+C\+T\+R\+L\+\_\+\+F\+L\+A\+G\+\_\+\+U\+N\+I\+D\+I\+R\+E\+C\+T\+I\+O\+N\+AL, proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, egress\+Settings\+\_\+, proxygen\+::\+E\+R\+R\+OR, flags\+\_\+, proxygen\+::\+H\+T\+T\+P\+Settings\+::get\+Setting(), proxygen\+::spdy\+::\+G\+O\+A\+W\+A\+Y\+\_\+\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, proxygen\+::spdy\+::k\+Max\+Concurrent\+Streams, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::last\+Stream\+I\+D\+\_\+, proxygen\+::\+M\+A\+X\+\_\+\+C\+O\+N\+C\+U\+R\+R\+E\+N\+T\+\_\+\+S\+T\+R\+E\+A\+MS, No\+Stream, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::num\+Incoming\+Streams(), on\+Syn\+Common(), proxygen\+::spdy\+::\+R\+S\+T\+\_\+\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, proxygen\+::spdy\+::\+R\+S\+T\+\_\+\+R\+E\+F\+U\+S\+E\+D\+\_\+\+S\+T\+R\+E\+AM, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::session\+Closing\+\_\+, stream\+Id\+\_\+, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::transport\+Direction\+\_\+, and proxygen\+::\+U\+P\+S\+T\+R\+E\+AM.



Referenced by on\+Control\+Frame().


\begin{DoxyCode}
1287                                                         \{
1288   VLOG(4) << \textcolor{stringliteral}{"Got SYN\_STREAM, stream="} << streamId_
1289           << \textcolor{stringliteral}{" pri="} << folly::to<int>(pri);
1290   \textcolor{keywordflow}{if} (streamId_ == NoStream ||
1291       streamId_ < lastStreamID_ ||
1292       (transportDirection_ == TransportDirection::UPSTREAM &&
1293        (streamId_ & 0x01) == 1) ||
1294       (transportDirection_ == TransportDirection::DOWNSTREAM &&
1295        ((streamId_ & 0x1) == 0)) ||
1296       (transportDirection_ == TransportDirection::UPSTREAM &&
1297        assocStream == NoStream)) \{
1298     LOG(ERROR) << \textcolor{stringliteral}{" invalid syn stream stream\_id="} << streamId_
1299                << \textcolor{stringliteral}{" lastStreamID\_="} << lastStreamID_
1300                << \textcolor{stringliteral}{" assocStreamID="} << assocStream
1301                << \textcolor{stringliteral}{" direction="} << transportDirection_;
1302     \textcolor{keywordflow}{throw} SPDYSessionFailed(spdy::GOAWAY_PROTOCOL_ERROR);
1303   \}
1304 
1305   \textcolor{keywordflow}{if} (streamId_ == lastStreamID_) \{
1306     \textcolor{keywordflow}{throw} SPDYStreamFailed(\textcolor{keyword}{true}, streamId_, spdy::RST_PROTOCOL_ERROR);
1307   \}
1308   \textcolor{keywordflow}{if} (callback_->numIncomingStreams() >=
1309       egressSettings_.getSetting(SettingsId::MAX_CONCURRENT_STREAMS,
1310                                  spdy::kMaxConcurrentStreams)) \{
1311     \textcolor{keywordflow}{throw} SPDYStreamFailed(\textcolor{keyword}{true}, streamId_, spdy::RST_REFUSED_STREAM);
1312   \}
1313   \textcolor{keywordflow}{if} (assocStream != NoStream && !(flags_ & spdy::CTRL_FLAG_UNIDIRECTIONAL)) \{
1314     \textcolor{keywordflow}{throw} SPDYStreamFailed(\textcolor{keyword}{true}, streamId_, spdy::RST_PROTOCOL_ERROR);
1315   \}
1316   \textcolor{keywordflow}{if} (sessionClosing_ != ClosingState::CLOSING) \{
1317     lastStreamID_ = streamId_;
1318   \}
1319   onSynCommon(StreamID(streamId_),
1320               StreamID(assocStream), headers, pri, size);
1321 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!on\+Window\+Update@{on\+Window\+Update}}
\index{on\+Window\+Update@{on\+Window\+Update}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{on\+Window\+Update(uint32\+\_\+t delta) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+S\+P\+D\+Y\+Codec\+::on\+Window\+Update (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{delta}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1SPDYCodec_a5b72cbeecacd2b3368b12d943617f5a1}


Definition at line 1439 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::deliver\+Callback\+If\+Allowed(), proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Window\+Update(), and stream\+Id\+\_\+.



Referenced by on\+Control\+Frame().


\begin{DoxyCode}
1439                                                       \{
1440   deliverCallbackIfAllowed(&HTTPCodec::Callback::onWindowUpdate,
1441                            \textcolor{stringliteral}{"onWindowUpdate"}, streamId_, delta);
1442 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!parse\+Headers@{parse\+Headers}}
\index{parse\+Headers@{parse\+Headers}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{parse\+Headers(\+Transport\+Direction direction, Stream\+I\+D stream\+I\+D, Stream\+I\+D assoc\+Stream\+I\+D, const compress\+::\+Header\+Piece\+List \&headers)}]{\setlength{\rightskip}{0pt plus 5cm}unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Message} $>$ proxygen\+::\+S\+P\+D\+Y\+Codec\+::parse\+Headers (
\begin{DoxyParamCaption}
\item[{{\bf Transport\+Direction}}]{direction, }
\item[{{\bf Stream\+ID}}]{stream\+ID, }
\item[{{\bf Stream\+ID}}]{assoc\+Stream\+ID, }
\item[{const {\bf compress\+::\+Header\+Piece\+List} \&}]{headers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a3c04cf2988ce0ea5ceebfd48e34a1211}
Parses the headers in the name\+Values array and creates an \doxyref{H\+T\+T\+P\+Message}{p.}{classproxygen_1_1HTTPMessage} object initialized for this transaction. 

Definition at line 1059 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Headers\+::add(), proxygen\+::case\+Insensitive\+Equal(), deliver\+On\+Message\+Begin(), proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, proxygen\+::\+H\+T\+T\+P\+Headers\+::exists(), proxygen\+::\+H\+T\+T\+P\+Headers\+::get\+Single\+Or\+Empty(), proxygen\+::\+Codec\+Util\+::has\+Gzip\+And\+Deflate(), proxygen\+::spdy\+::\+H\+E\+A\+D\+E\+RS, name, partial\+Msg\+\_\+, proxygen\+::spdy\+::\+R\+S\+T\+\_\+\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Headers\+::set(), proxygen\+::\+Codec\+Util\+::\+S\+T\+R\+I\+CT, type\+\_\+, proxygen\+::\+U\+P\+S\+T\+R\+E\+AM, proxygen\+::\+Codec\+Util\+::validate\+Header\+Name(), proxygen\+::\+Codec\+Util\+::validate\+Header\+Value(), proxygen\+::\+Codec\+Util\+::validate\+Method(), proxygen\+::\+Codec\+Util\+::validate\+U\+R\+L(), and version\+\_\+.



Referenced by on\+Syn\+Common().


\begin{DoxyCode}
1061                                                           \{
1062   unique\_ptr<HTTPMessage> msg(\textcolor{keyword}{new} HTTPMessage());
1063   HTTPHeaders& headers = msg->getHeaders();
1064   \textcolor{keywordtype}{bool} newStream = (type_ != spdy::HEADERS);
1065 
1066   \textcolor{keywordtype}{bool} hasScheme = \textcolor{keyword}{false};
1067   \textcolor{keywordtype}{bool} hasPath = \textcolor{keyword}{false};
1068   \textcolor{keywordtype}{bool} hasContentLength = \textcolor{keyword}{false};
1069 
1070   \textcolor{comment}{// Number of fields must be even}
1071   CHECK\_EQ((inHeaders.size() & 1), 0);
1072   \textcolor{keywordflow}{for} (\textcolor{keywordtype}{unsigned} i = 0; i < inHeaders.size(); i += 2) \{
1073     uint8\_t off = 0;
1074     uint32\_t len = inHeaders[i].str.size();
1075     \textcolor{keywordflow}{if} (len > 1 && inHeaders[i].str[0] == \textcolor{charliteral}{':'}) \{
1076       off = 1;  \textcolor{comment}{// also signals control header}
1077       len--;
1078     \}
1079     folly::StringPiece name(inHeaders[i].str, off, len);
1080     folly::StringPiece value = inHeaders[i + 1].str;
1081     VLOG(5) << \textcolor{stringliteral}{"Header "} << name << \textcolor{stringliteral}{": "} << value;
1082     \textcolor{keywordtype}{bool} nameOk = CodecUtil::validateHeaderName(name);
1083     \textcolor{keywordtype}{bool} valueOk = \textcolor{keyword}{false};
1084     \textcolor{keywordtype}{bool} isPath = \textcolor{keyword}{false};
1085     \textcolor{keywordtype}{bool} isMethod = \textcolor{keyword}{false};
1086     \textcolor{keywordflow}{if} (nameOk) \{
1087       \textcolor{keywordflow}{if} (name == \textcolor{stringliteral}{"content-length"}) \{
1088         \textcolor{keywordflow}{if} (hasContentLength) \{
1089           \textcolor{keywordflow}{throw} SPDYStreamFailed(\textcolor{keyword}{false}, streamID, 400,
1090              \textcolor{stringliteral}{"Multiple content-length headers"});
1091         \}
1092         hasContentLength = \textcolor{keyword}{true};
1093       \}
1094       \textcolor{keywordflow}{if} ((version_ == 2 && name == \textcolor{stringliteral}{"url"}) ||
1095           (version_ == 3 && off && name == \textcolor{stringliteral}{"path"})) \{
1096         valueOk = CodecUtil::validateURL(value);
1097         isPath = \textcolor{keyword}{true};
1098         \textcolor{keywordflow}{if} (hasPath) \{
1099           \textcolor{keywordflow}{throw} SPDYStreamFailed(\textcolor{keyword}{false}, streamID, 400,
1100              \textcolor{stringliteral}{"Multiple paths in header"});
1101         \}
1102         hasPath = \textcolor{keyword}{true};
1103       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} ((version_ == 2 || off) && name == \textcolor{stringliteral}{"method"}) \{
1104         valueOk = CodecUtil::validateMethod(value);
1105         isMethod = \textcolor{keyword}{true};
1106         \textcolor{keywordflow}{if} (value == \textcolor{stringliteral}{"CONNECT"}) \{
1107           \textcolor{comment}{// We don't support CONNECT request for SPDY}
1108           valueOk = \textcolor{keyword}{false};
1109         \}
1110       \} \textcolor{keywordflow}{else} \{
1111         valueOk = CodecUtil::validateHeaderValue(value, CodecUtil::STRICT);
1112       \}
1113     \}
1114     \textcolor{keywordflow}{if} (!nameOk || !valueOk) \{
1115       \textcolor{keywordflow}{if} (newStream) \{
1116         deliverOnMessageBegin(streamID, assocStreamID, \textcolor{keyword}{nullptr});
1117       \}
1118       partialMsg_ = std::move(msg);
1119       \textcolor{keywordflow}{throw} SPDYStreamFailed(\textcolor{keyword}{false}, streamID, 400, \textcolor{stringliteral}{"Bad header value"});
1120     \}
1121     \textcolor{keywordtype}{bool} add = \textcolor{keyword}{false};
1122     \textcolor{keywordflow}{if} (off || version_ == 2) \{
1123       \textcolor{keywordflow}{if} (isMethod) \{
1124         msg->setMethod(value);
1125       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (isPath) \{
1126         msg->setURL(value.str());
1127       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (name == \textcolor{stringliteral}{"version"}) \{
1128         \textcolor{keywordflow}{if} (caseInsensitiveEqual(value, \textcolor{stringliteral}{"http/1.0"})) \{
1129           msg->setHTTPVersion(1, 0);
1130         \} \textcolor{keywordflow}{else} \{
1131           msg->setHTTPVersion(1, 1);
1132         \}
1133       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (version_ == 3 && name == \textcolor{stringliteral}{"host"}) \{
1134         headers.add(HTTP\_HEADER\_HOST, value.str());
1135       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (name == \textcolor{stringliteral}{"scheme"}) \{
1136         hasScheme = \textcolor{keyword}{true};
1137         \textcolor{keywordflow}{if} (value == \textcolor{stringliteral}{"https"}) \{
1138           msg->setSecure(\textcolor{keyword}{true});
1139         \}
1140       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (name == \textcolor{stringliteral}{"status"}) \{
1141         \textcolor{keywordflow}{if} (direction == TransportDirection::UPSTREAM && !assocStreamID) \{
1142           folly::StringPiece codePiece;
1143           folly::StringPiece reasonPiece;
1144           \textcolor{keywordflow}{if} (value.contains(\textcolor{charliteral}{' '})) \{
1145             folly::split<false>(\textcolor{charliteral}{' '}, value, codePiece, reasonPiece);
1146           \} \textcolor{keywordflow}{else} \{
1147             codePiece = value;
1148           \}
1149           int32\_t code = -1;
1150           \textcolor{keywordflow}{try} \{
1151             code = folly::to<unsigned int>(codePiece);
1152           \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} std::range\_error& ex) \{
1153             \textcolor{comment}{// Toss out the range error cause the exception will get it}
1154           \}
1155           \textcolor{keywordflow}{if} (code >= 100 && code <= 999) \{
1156             msg->setStatusCode(code);
1157             msg->setStatusMessage(reasonPiece.str());
1158           \} \textcolor{keywordflow}{else} \{
1159             msg->setStatusCode(0);
1160             headers.add(name, value);
1161             partialMsg_ = std::move(msg);
1162             \textcolor{keywordflow}{throw} SPDYStreamFailed(newStream, streamID,
1163                                    spdy::RST_PROTOCOL_ERROR,
1164                                   \textcolor{stringliteral}{"Invalid status code"});
1165           \}
1166         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!assocStreamID) \{
1167           \textcolor{keywordflow}{if} (version_ == 2) \{
1168             headers.add(\textcolor{stringliteral}{"Status"}, value);
1169           \}
1170         \} \textcolor{keywordflow}{else} \{ \textcolor{comment}{// is a push status since there is an assocStreamID?}
1171           \textcolor{comment}{// If there exists a push status, save it.}
1172           \textcolor{comment}{// If there does not, for now, we *eat* the push status.}
1173           \textcolor{keywordflow}{if} (value.size() > 0) \{
1174             int16\_t code = -1;
1175             \textcolor{keywordflow}{try} \{
1176               code = folly::to<uint16\_t>(value);
1177             \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} std::range\_error& ex) \{
1178               \textcolor{comment}{// eat the push status}
1179             \}
1180             \textcolor{keywordflow}{if} (code >= 100 && code <= 999) \{
1181               msg->setPushStatusCode(code);
1182             \} \textcolor{keywordflow}{else} \{
1183               \textcolor{comment}{// eat the push status.}
1184             \}
1185           \}
1186         \}
1187       \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (version_ == 2) \{
1188         add = \textcolor{keyword}{true};
1189       \}
1190     \} \textcolor{keywordflow}{else} \{
1191       add = \textcolor{keyword}{true};
1192     \}
1193     \textcolor{keywordflow}{if} (add) \{
1194       \textcolor{keywordflow}{if} (!inHeaders[i].isMultiValued() && headers.exists(name)) \{
1195         headers.add(name, value);
1196         partialMsg_ = std::move(msg);
1197         \textcolor{keywordflow}{throw} SPDYStreamFailed(newStream, streamID, spdy::RST_PROTOCOL_ERROR,
1198                                \textcolor{stringliteral}{"Duplicate header value"});
1199       \}
1200       headers.add(name, value);
1201     \}
1202   \}
1203   \textcolor{keywordflow}{if} (assocStreamID &&
1204       (!headers.exists(HTTP\_HEADER\_HOST) || !hasScheme || !hasPath)) \{
1205     \textcolor{comment}{// Fail a server push without host, scheme or path headers}
1206     \textcolor{keywordflow}{throw} SPDYStreamFailed(newStream, streamID, 400, \textcolor{stringliteral}{"Bad Request"});
1207   \}
1208   \textcolor{keywordflow}{if} (direction == TransportDirection::DOWNSTREAM) \{
1209     \textcolor{keywordflow}{if} (version_ == 2 && !headers.exists(HTTP\_HEADER\_HOST)) \{
1210       ParseURL url(msg->getURL());
1211       \textcolor{keywordflow}{if} (url.valid()) \{
1212         headers.add(HTTP\_HEADER\_HOST, url.hostAndPort());
1213       \}
1214     \}
1215 
1216     \textcolor{keyword}{const} \textcolor{keywordtype}{string}& accept\_encoding =
1217       headers.getSingleOrEmpty(HTTP\_HEADER\_ACCEPT\_ENCODING);
1218     \textcolor{keywordflow}{if} (accept\_encoding.empty()) \{
1219       headers.add(HTTP\_HEADER\_ACCEPT\_ENCODING, \textcolor{stringliteral}{"gzip, deflate"});
1220     \} \textcolor{keywordflow}{else} \{
1221       \textcolor{keywordtype}{bool} hasGzip = \textcolor{keyword}{false};
1222       \textcolor{keywordtype}{bool} hasDeflate = \textcolor{keyword}{false};
1223       \textcolor{keywordflow}{if} (!CodecUtil::hasGzipAndDeflate(accept\_encoding, hasGzip, hasDeflate)) \{
1224         \textcolor{keywordtype}{string} new\_encoding = accept\_encoding;
1225         \textcolor{keywordflow}{if} (!hasGzip) \{
1226           new\_encoding.append(\textcolor{stringliteral}{", gzip"});
1227         \}
1228         \textcolor{keywordflow}{if} (!hasDeflate) \{
1229           new\_encoding.append(\textcolor{stringliteral}{", deflate"});
1230         \}
1231         headers.set(HTTP\_HEADER\_ACCEPT\_ENCODING, new\_encoding);
1232       \}
1233     \}
1234   \}
1235   \textcolor{keywordflow}{return} msg;
1236 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!parse\+Ingress@{parse\+Ingress}}
\index{parse\+Ingress@{parse\+Ingress}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{parse\+Ingress(const folly\+::\+I\+O\+Buf \&buf)}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::parse\+Ingress (
\begin{DoxyParamCaption}
\item[{const folly\+::\+I\+O\+Buf \&}]{buf}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a0c4d9d93885454886e93444f3eb6b3da}
Ingress parser, can throw exceptions 

Definition at line 246 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::callback\+\_\+, ctrl\+\_\+, proxygen\+::spdy\+::\+C\+T\+R\+L\+\_\+\+F\+L\+A\+G\+\_\+\+F\+IN, C\+T\+R\+L\+\_\+\+M\+A\+SK, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::deliver\+Callback\+If\+Allowed(), proxygen\+::\+E\+R\+R\+OR, fail\+Stream(), flags\+\_\+, F\+L\+A\+G\+S\+\_\+\+M\+A\+SK, F\+R\+A\+M\+E\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+L\+EN, frame\+State\+\_\+, proxygen\+::spdy\+::\+G\+O\+A\+W\+A\+Y\+\_\+\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, proxygen\+::spdy\+::\+H\+E\+A\+D\+E\+RS, length\+\_\+, proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::major\+Version, max\+Frame\+Length\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Body(), on\+Control\+Frame(), proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Frame\+Header(), proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Message\+Complete(), proxygen\+::spdy\+::\+R\+S\+T\+\_\+\+F\+R\+A\+M\+E\+\_\+\+T\+O\+O\+\_\+\+L\+A\+R\+GE, S\+T\+R\+E\+A\+M\+\_\+\+I\+D\+\_\+\+M\+A\+SK, stream\+Id\+\_\+, proxygen\+::spdy\+::\+S\+Y\+N\+\_\+\+R\+E\+P\+LY, proxygen\+::spdy\+::\+S\+Y\+N\+\_\+\+S\+T\+R\+E\+AM, type\+\_\+, version\+\_\+, V\+E\+R\+S\+I\+O\+N\+\_\+\+M\+A\+SK, and version\+Settings\+\_\+.



Referenced by on\+Ingress().


\begin{DoxyCode}
246                                                     \{
247   \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} chainLength = buf.computeChainDataLength();
248   Cursor cursor(&buf);
249   \textcolor{keywordtype}{size\_t} avail = cursor.totalLength();
250 
251   \textcolor{comment}{// This can parse beyond the current IOBuf}
252   \textcolor{keywordflow}{for} (; avail > 0; avail = cursor.totalLength()) \{
253     \textcolor{keywordflow}{if} (frameState_ == FrameState::FRAME\_HEADER) \{
254       \textcolor{keywordflow}{if} (avail < FRAME_HEADER_LEN) \{
255         \textcolor{comment}{// Make the caller buffer until we get a full frame header}
256         \textcolor{keywordflow}{break};
257       \}
258       \textcolor{keyword}{auto} data = cursor.peek();
259       ctrl_ = (data.first[0] & CTRL_MASK);
260       \textcolor{keywordflow}{if} (ctrl_) \{
261         version_ = cursor.readBE<uint16\_t>() & VERSION_MASK;
262         type_  = cursor.readBE<uint16\_t>();
263         \textcolor{keywordflow}{if} (version_ != versionSettings_.majorVersion) \{
264           LOG(ERROR) << \textcolor{stringliteral}{"Invalid version="} << version_;
265           \textcolor{keywordflow}{throw} SPDYSessionFailed(spdy::GOAWAY_PROTOCOL_ERROR);
266         \}
267       \} \textcolor{keywordflow}{else} \{
268         streamId_ = cursor.readBE<uint32\_t>() & STREAM_ID_MASK;
269       \}
270       length_ = cursor.readBE<uint32\_t>();
271       flags_ = (length\_ & FLAGS_MASK) >> 24;
272       length\_ &= ~FLAGS_MASK;
273       \textcolor{keywordflow}{if} (ctrl_) \{
274         \textcolor{keywordflow}{if} (length\_ > maxFrameLength_) \{
275           \textcolor{keywordflow}{if} (type\_ == spdy::SYN_STREAM || type\_ == spdy::SYN_REPLY ||
276               type\_ == spdy::HEADERS) \{
277             uint32\_t stream\_id = cursor.readBE<uint32\_t>() & STREAM_ID_MASK;
278             failStream(\textcolor{keyword}{true}, stream\_id, spdy::RST_FRAME_TOO_LARGE);
279             \textcolor{comment}{// Compression/stream state is out of sync now}
280           \}
281           \textcolor{comment}{// Since maxFrameLength\_ must be at least 8kb and most control frames}
282           \textcolor{comment}{// have fixed size, only an invalid settings or credential frame can}
283           \textcolor{comment}{// land here. For invalid credential frames we must send a goaway,}
284           \textcolor{comment}{// and a settings frame would have > 1023 pairs, of which none are}
285           \textcolor{comment}{// allowed to be duplicates. Just fail everything.}
286           LOG(ERROR) << \textcolor{stringliteral}{"excessive frame size length\_="} << length_;
287           \textcolor{keywordflow}{throw} SPDYSessionFailed(spdy::GOAWAY_PROTOCOL_ERROR);
288         \}
289         frameState_ = FrameState::CTRL\_FRAME\_DATA;
290         callback_->onFrameHeader(0, flags\_, length\_, type\_, version_);
291       \} \textcolor{keywordflow}{else} \{
292         frameState_ = FrameState::DATA\_FRAME\_DATA;
293         callback_->onFrameHeader(streamId_, flags\_, length\_, type\_);
294       \}
295     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (frameState_ == FrameState::CTRL\_FRAME\_DATA) \{
296       \textcolor{keywordflow}{if} (avail < length\_) \{
297         \textcolor{comment}{// Make the caller buffer the rest of the control frame.}
298         \textcolor{comment}{// We could attempt to decompress incomplete name/value blocks,}
299         \textcolor{comment}{// but for now we're favoring simplicity.}
300         VLOG(6) << \textcolor{stringliteral}{"Need more data: length\_="} << length\_ << \textcolor{stringliteral}{" avail="} << avail;
301         \textcolor{keywordflow}{break};
302       \}
303       \textcolor{keywordflow}{try} \{
304         onControlFrame(cursor);
305       \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} SPDYStreamFailed& ex) \{
306         failStream(ex.isNew, ex.streamID, ex.statusCode, ex.what());
307       \}
308       frameState_ = FrameState::FRAME\_HEADER;
309     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (avail > 0 || length\_ == 0) \{
310       \textcolor{comment}{// Data frame data.  Pass everything we have up to the frame boundary}
311       DCHECK(FrameState::DATA\_FRAME\_DATA == frameState_);
312 
313       uint32\_t toClone = (avail > std::numeric\_limits<uint32\_t>::max()) ?
314         std::numeric\_limits<uint32\_t>::max() : \textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(avail);
315       toClone = std::min(toClone, length\_);
316       std::unique\_ptr<IOBuf> chunk;
317       cursor.clone(chunk, toClone);
318       deliverCallbackIfAllowed(&HTTPCodec::Callback::onBody, \textcolor{stringliteral}{"onBody"},
319                                streamId_, std::move(chunk), 0);
320       length\_ -= toClone;
321     \}
322 
323     \textcolor{comment}{// Fin handling}
324     \textcolor{keywordflow}{if} (length\_ == 0) \{
325       \textcolor{keywordflow}{if} (flags\_ & spdy::CTRL_FLAG_FIN) \{
326         deliverCallbackIfAllowed(&HTTPCodec::Callback::onMessageComplete,
327                                  \textcolor{stringliteral}{"onMessageComplete"}, streamId_, \textcolor{keyword}{false});
328       \}
329       frameState_ = FrameState::FRAME\_HEADER;
330     \}
331   \}
332   \textcolor{keywordflow}{return} chainLength - avail;
333 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!rst\+Status\+Supported@{rst\+Status\+Supported}}
\index{rst\+Status\+Supported@{rst\+Status\+Supported}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{rst\+Status\+Supported(int status\+Code) const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+S\+P\+D\+Y\+Codec\+::rst\+Status\+Supported (
\begin{DoxyParamCaption}
\item[{int}]{status\+Code}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a885b57e16a5dbabbe26940312be7bafa}
Helper function to check if the status code is supported by the S\+P\+DY version being used 

Definition at line 1489 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::major\+Version, proxygen\+::spdy\+::\+R\+S\+T\+\_\+\+F\+L\+O\+W\+\_\+\+C\+O\+N\+T\+R\+O\+L\+\_\+\+E\+R\+R\+OR, and version\+Settings\+\_\+.



Referenced by generate\+Rst\+Stream().


\begin{DoxyCode}
1489                                                        \{
1490   \textcolor{keywordflow}{if} (statusCode == 0) \{
1491     \textcolor{comment}{// 0 is not a valid status code for RST\_STREAM}
1492     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1493   \}
1494   \textcolor{comment}{// SPDY/3 supports more status codes for RST\_STREAM. For SPDY/2,}
1495   \textcolor{comment}{// we just use PROTOCOL\_ERROR for these new higher numbered error codes.}
1496   \textcolor{keywordflow}{return} (versionSettings_.majorVersion != 2 ||
1497           statusCode <= spdy::RST_FLOW_CONTROL_ERROR);
1498 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!serialize\+Request\+Headers@{serialize\+Request\+Headers}}
\index{serialize\+Request\+Headers@{serialize\+Request\+Headers}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{serialize\+Request\+Headers(const H\+T\+T\+P\+Message \&msg, bool is\+Pushed, uint32\+\_\+t headroom=0, H\+T\+T\+P\+Header\+Size $\ast$size=nullptr)}]{\setlength{\rightskip}{0pt plus 5cm}unique\+\_\+ptr$<$ I\+O\+Buf $>$ proxygen\+::\+S\+P\+D\+Y\+Codec\+::serialize\+Request\+Headers (
\begin{DoxyParamCaption}
\item[{const {\bf H\+T\+T\+P\+Message} \&}]{msg, }
\item[{bool}]{is\+Pushed, }
\item[{uint32\+\_\+t}]{headroom = {\ttfamily 0}, }
\item[{{\bf H\+T\+T\+P\+Header\+Size} $\ast$}]{size = {\ttfamily {\bf nullptr}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_affaee9e6868b1117d364c92224404222}
Serializes headers for requests (aka S\+Y\+N\+\_\+\+S\+T\+R\+E\+AM) 
\begin{DoxyParams}{Parameters}
{\em msg} & The message to serialize. \\
\hline
{\em is\+Pushed} & true if this is a push message \\
\hline
{\em size} & Size of the serialized headers before and after compression \\
\hline
{\em headroom} & Optional amount of headroom to reserve at the front of the returned I\+O\+Buf, in case the caller wants to put some other data there. \\
\hline
\end{DoxyParams}


Definition at line 587 of file S\+P\+D\+Y\+Codec.\+cpp.



References encode\+Headers(), proxygen\+::\+H\+T\+T\+P\+Headers\+::exists(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Method\+String(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Push\+Status\+Str(), proxygen\+::\+H\+T\+T\+P\+Headers\+::get\+Single\+Or\+Empty(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+U\+R\+L(), proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::host\+Str, proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER, proxygen\+::\+H\+T\+T\+P\+Message\+::is\+Secure(), proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::major\+Version, proxygen\+::\+H\+T\+T\+P\+Headers\+::size(), and version\+Settings\+\_\+.



Referenced by generate\+Syn\+Stream().


\begin{DoxyCode}
591                         \{
592 
593   \textcolor{keyword}{const} HTTPHeaders& headers = msg.getHeaders();
594   vector<Header> allHeaders;
595   allHeaders.reserve(headers.size() + 6);
596 
597   \textcolor{keyword}{const} \textcolor{keywordtype}{string}& method = msg.getMethodString();
598   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{string} https(\textcolor{stringliteral}{"https"});
599   \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{string} http(\textcolor{stringliteral}{"http"});
600   \textcolor{keyword}{const} \textcolor{keywordtype}{string}& scheme = msg.isSecure() ? https : http;
601   \textcolor{keywordtype}{string} path = msg.getURL();
602 
603   CHECK\_GT(versionSettings_.majorVersion, 2) << \textcolor{stringliteral}{"SPDY/2 no longer supported"};
604 
605   \textcolor{keywordflow}{if} (isPushed) \{
606     \textcolor{keyword}{const} \textcolor{keywordtype}{string}& pushString = msg.getPushStatusStr();
607     allHeaders.emplace\_back(HTTP\_HEADER\_COLON\_STATUS, pushString);
608   \} \textcolor{keywordflow}{else} \{
609     allHeaders.emplace\_back(HTTP\_HEADER\_COLON\_METHOD, method);
610   \}
611   allHeaders.emplace\_back(HTTP\_HEADER\_COLON\_SCHEME, scheme);
612   allHeaders.emplace\_back(HTTP\_HEADER\_COLON\_PATH, path);
613   \textcolor{keywordflow}{if} (versionSettings_.majorVersion == 3) \{
614     DCHECK(headers.exists(HTTP\_HEADER\_HOST));
615     \textcolor{keyword}{const} \textcolor{keywordtype}{string}& host = headers.getSingleOrEmpty(HTTP\_HEADER\_HOST);
616     \textcolor{comment}{// We explicitly provide both the code and header name here}
617     \textcolor{comment}{// as HTTP\_HEADER\_OTHER does not map to kNameHostv3 and we don't want a}
618     \textcolor{comment}{// perf penalty hash kNameHostv3 to HTTP\_HEADER\_OTHER}
619     allHeaders.emplace\_back(HTTP_HEADER_OTHER, versionSettings_.hostStr, host);
620 \}
621 
622   \textcolor{keywordflow}{return} encodeHeaders(msg, allHeaders, headroom, size);
623 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!serialize\+Response\+Headers@{serialize\+Response\+Headers}}
\index{serialize\+Response\+Headers@{serialize\+Response\+Headers}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{serialize\+Response\+Headers(const H\+T\+T\+P\+Message \&msg, uint32\+\_\+t headroom=0, H\+T\+T\+P\+Header\+Size $\ast$size=nullptr)}]{\setlength{\rightskip}{0pt plus 5cm}unique\+\_\+ptr$<$ I\+O\+Buf $>$ proxygen\+::\+S\+P\+D\+Y\+Codec\+::serialize\+Response\+Headers (
\begin{DoxyParamCaption}
\item[{const {\bf H\+T\+T\+P\+Message} \&}]{msg, }
\item[{uint32\+\_\+t}]{headroom = {\ttfamily 0}, }
\item[{{\bf H\+T\+T\+P\+Header\+Size} $\ast$}]{size = {\ttfamily {\bf nullptr}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_ae28feed90a373122fb3f3854dca4e17f}
Serializes headers for responses (aka S\+Y\+N\+\_\+\+R\+E\+P\+LY) 
\begin{DoxyParams}{Parameters}
{\em msg} & The message to serialize. \\
\hline
{\em size} & Size of the serialized headers before and after compression \\
\hline
{\em headroom} & Optional amount of headroom to reserve at the front of the returned I\+O\+Buf, in case the caller wants to put some other data there. \\
\hline
\end{DoxyParams}


Definition at line 557 of file S\+P\+D\+Y\+Codec.\+cpp.



References date, encode\+Headers(), proxygen\+::\+H\+T\+T\+P\+Headers\+::exists(), proxygen\+::\+H\+T\+T\+P\+Message\+::format\+Date\+Header(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Status\+Code(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Status\+Message(), and proxygen\+::\+H\+T\+T\+P\+Headers\+::size().



Referenced by generate\+Syn\+Reply().


\begin{DoxyCode}
558                                                                    \{
559 
560   \textcolor{comment}{// Note: the header-sorting code works with pointers to strings.}
561   \textcolor{comment}{// The role of this local status string is to hold the generated}
562   \textcolor{comment}{// status code long enough for the sort (done later within the}
563   \textcolor{comment}{// same scope) to be able to access it.}
564   \textcolor{keywordtype}{string} status;
565 
566   \textcolor{keyword}{const} HTTPHeaders& headers = msg.getHeaders();
567   vector<Header> allHeaders;
568   allHeaders.reserve(headers.size() + 4);
569 
570   \textcolor{keywordflow}{if} (msg.getStatusMessage().empty()) \{
571     status = folly::to<string>(msg.getStatusCode());
572   \} \textcolor{keywordflow}{else} \{
573     status = folly::to<string>(msg.getStatusCode(), \textcolor{stringliteral}{" "},
574                                msg.getStatusMessage());
575   \}
576   allHeaders.emplace\_back(HTTP\_HEADER\_COLON\_STATUS, status);
577   \textcolor{comment}{// See comment above regarding status}
578   \textcolor{keywordtype}{string} date;
579   \textcolor{keywordflow}{if} (!headers.exists(HTTP\_HEADER\_DATE)) \{
580     date = HTTPMessage::formatDateHeader();
581     allHeaders.emplace\_back(HTTP\_HEADER\_DATE, date);
582   \}
583 
584   \textcolor{keywordflow}{return} encodeHeaders(msg, allHeaders, headroom, size);
585 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!set\+Header\+Codec\+Stats@{set\+Header\+Codec\+Stats}}
\index{set\+Header\+Codec\+Stats@{set\+Header\+Codec\+Stats}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{set\+Header\+Codec\+Stats(\+Header\+Codec\+::\+Stats $\ast$stats) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+S\+P\+D\+Y\+Codec\+::set\+Header\+Codec\+Stats (
\begin{DoxyParamCaption}
\item[{{\bf Header\+Codec\+::\+Stats} $\ast$}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_a55d5716fd7e07b19816e09f9de0cac1d}
set stats for the header codec, if the protocol supports header compression 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a0177b39d7554a85c702a2e20ebce2db0}.



Definition at line 123 of file S\+P\+D\+Y\+Codec.\+h.


\begin{DoxyCode}
123                                                              \{
124     headerCodec_.setStats(stats);
125   \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!set\+Max\+Frame\+Length@{set\+Max\+Frame\+Length}}
\index{set\+Max\+Frame\+Length@{set\+Max\+Frame\+Length}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{set\+Max\+Frame\+Length(uint32\+\_\+t max\+Frame\+Length)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+S\+P\+D\+Y\+Codec\+::set\+Max\+Frame\+Length (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{max\+Frame\+Length}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1SPDYCodec_a10077f35c99f608a374c2b243403093a}


Definition at line 189 of file S\+P\+D\+Y\+Codec.\+cpp.



References max\+Frame\+Length\+\_\+.



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
189                                                          \{
190   maxFrameLength_ = maxFrameLength;
191 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!set\+Max\+Uncompressed\+Headers@{set\+Max\+Uncompressed\+Headers}}
\index{set\+Max\+Uncompressed\+Headers@{set\+Max\+Uncompressed\+Headers}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{set\+Max\+Uncompressed\+Headers(uint32\+\_\+t max\+Uncompressed)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+S\+P\+D\+Y\+Codec\+::set\+Max\+Uncompressed\+Headers (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{max\+Uncompressed}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1SPDYCodec_a68bdff54e8ed6e1da8a311d4cfdde1bb}
Set the maximum size of the uncompressed headers 

Definition at line 193 of file S\+P\+D\+Y\+Codec.\+cpp.



References header\+Codec\+\_\+, and proxygen\+::\+Header\+Codec\+::set\+Max\+Uncompressed().



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
193                                                                   \{
194   headerCodec_.setMaxUncompressed(maxUncompressed);
195 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!supports\+Push\+Transactions@{supports\+Push\+Transactions}}
\index{supports\+Push\+Transactions@{supports\+Push\+Transactions}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{supports\+Push\+Transactions() const override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+S\+P\+D\+Y\+Codec\+::supports\+Push\+Transactions (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_ab1cabfd42530643f1262885934daebb1}
Check whether the codec supports pushing resources from server to client. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_aa43f8d4ffd6e30bf9e2c176fa5b9188c}.



Definition at line 53 of file S\+P\+D\+Y\+Codec.\+h.



References status\+Code.


\begin{DoxyCode}
53 \{ \textcolor{keywordflow}{return} \textcolor{keyword}{true}; \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!supports\+Session\+Flow\+Control@{supports\+Session\+Flow\+Control}}
\index{supports\+Session\+Flow\+Control@{supports\+Session\+Flow\+Control}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{supports\+Session\+Flow\+Control() const override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+S\+P\+D\+Y\+Codec\+::supports\+Session\+Flow\+Control (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_a08497a5bb231a6394bf92d6e1b677852}
Returns true iff this codec supports session level flow control 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPParallelCodec_a2c2e5591e9331db3a9d740f64ab62b1d}.



Definition at line 214 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::major\+Version, proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::minor\+Version, and version\+Settings\+\_\+.



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
214                                                  \{
215   \textcolor{keywordflow}{return} versionSettings_.majorVersion > 3 ||
216     (versionSettings_.majorVersion == 3 && versionSettings_.minorVersion > 0);
217 \}
\end{DoxyCode}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!supports\+Stream\+Flow\+Control@{supports\+Stream\+Flow\+Control}}
\index{supports\+Stream\+Flow\+Control@{supports\+Stream\+Flow\+Control}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{supports\+Stream\+Flow\+Control() const override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+S\+P\+D\+Y\+Codec\+::supports\+Stream\+Flow\+Control (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1SPDYCodec_a7a102816218c440fa61057abfb4ddaa5}
Returns true iff this codec supports per stream flow control 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPParallelCodec_a2f8dd0d3baba658c5abc81f2258bdc13}.



Definition at line 210 of file S\+P\+D\+Y\+Codec.\+cpp.



References proxygen\+::\+S\+P\+D\+Y\+Version\+Settings\+::major\+Version, and version\+Settings\+\_\+.


\begin{DoxyCode}
210                                                 \{
211   \textcolor{keywordflow}{return} versionSettings_.majorVersion > 2;
212 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!closed\+Streams\+\_\+@{closed\+Streams\+\_\+}}
\index{closed\+Streams\+\_\+@{closed\+Streams\+\_\+}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{closed\+Streams\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::fbvector$<${\bf Stream\+ID}$>$ proxygen\+::\+S\+P\+D\+Y\+Codec\+::closed\+Streams\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a830ce3d98e202416b78a585d4da48c8f}


Definition at line 341 of file S\+P\+D\+Y\+Codec.\+h.

\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!ctrl\+\_\+@{ctrl\+\_\+}}
\index{ctrl\+\_\+@{ctrl\+\_\+}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{ctrl\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+S\+P\+D\+Y\+Codec\+::ctrl\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a661d4dddc5348c5605430dfe9840cf9e}


Definition at line 375 of file S\+P\+D\+Y\+Codec.\+h.



Referenced by parse\+Ingress().

\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!current\+Ingress\+Buf\+\_\+@{current\+Ingress\+Buf\+\_\+}}
\index{current\+Ingress\+Buf\+\_\+@{current\+Ingress\+Buf\+\_\+}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{current\+Ingress\+Buf\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}const folly\+::\+I\+O\+Buf$\ast$ proxygen\+::\+S\+P\+D\+Y\+Codec\+::current\+Ingress\+Buf\+\_\+ \{{\bf nullptr}\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_ad7e976ad0c7e90871a5540ed34b8e7fb}


Definition at line 355 of file S\+P\+D\+Y\+Codec.\+h.



Referenced by fail\+Session(), fail\+Stream(), and on\+Ingress().

\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!egress\+Settings\+\_\+@{egress\+Settings\+\_\+}}
\index{egress\+Settings\+\_\+@{egress\+Settings\+\_\+}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{egress\+Settings\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Settings} proxygen\+::\+S\+P\+D\+Y\+Codec\+::egress\+Settings\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_ab691eec86e65d17ece0f0a528ebbda82}
{\bfseries Initial value\+:}
\begin{DoxyCode}
\{
    \{SettingsId::MAX_CONCURRENT_STREAMS, spdy::kMaxConcurrentStreams\},
    \{SettingsId::INITIAL_WINDOW_SIZE, spdy::kInitialWindow\}
  \}
\end{DoxyCode}


Definition at line 348 of file S\+P\+D\+Y\+Codec.\+h.



Referenced by generate\+Settings(), and on\+Syn\+Stream().

\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!flags\+\_\+@{flags\+\_\+}}
\index{flags\+\_\+@{flags\+\_\+}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{flags\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint8\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::flags\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a33f62482a4dd47c06bb09243f568344c}


Definition at line 366 of file S\+P\+D\+Y\+Codec.\+h.



Referenced by fail\+Stream(), generate\+Rst\+Stream(), on\+Settings(), on\+Syn\+Common(), on\+Syn\+Stream(), and parse\+Ingress().

\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!frame\+State\+\_\+@{frame\+State\+\_\+}}
\index{frame\+State\+\_\+@{frame\+State\+\_\+}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{frame\+State\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+S\+P\+D\+Y\+Codec\+::\+Frame\+State}  proxygen\+::\+S\+P\+D\+Y\+Codec\+::frame\+State\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a2ddf5582d1dbf9bfd0e575b09050767f}


Referenced by parse\+Ingress().

\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!header\+Codec\+\_\+@{header\+Codec\+\_\+}}
\index{header\+Codec\+\_\+@{header\+Codec\+\_\+}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{header\+Codec\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Gzip\+Header\+Codec} proxygen\+::\+S\+P\+D\+Y\+Codec\+::header\+Codec\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a3cca50b1d99dc148980916e7639fcd0f}


Definition at line 377 of file S\+P\+D\+Y\+Codec.\+h.



Referenced by decode\+Headers(), encode\+Headers(), on\+Control\+Frame(), set\+Max\+Uncompressed\+Headers(), and S\+P\+D\+Y\+Codec().

\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!ingress\+Settings\+\_\+@{ingress\+Settings\+\_\+}}
\index{ingress\+Settings\+\_\+@{ingress\+Settings\+\_\+}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{ingress\+Settings\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Settings} proxygen\+::\+S\+P\+D\+Y\+Codec\+::ingress\+Settings\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a9ac36ef69173b739e424df496c819055}
{\bfseries Initial value\+:}
\begin{DoxyCode}
\{
    \{SettingsId::MAX_CONCURRENT_STREAMS, spdy::kMaxConcurrentStreams\},
    \{SettingsId::INITIAL_WINDOW_SIZE, spdy::kInitialWindow\}
  \}
\end{DoxyCode}


Definition at line 344 of file S\+P\+D\+Y\+Codec.\+h.



Referenced by on\+Settings().

\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!length\+\_\+@{length\+\_\+}}
\index{length\+\_\+@{length\+\_\+}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{length\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::length\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a08cd9faf0858a56af850cbdec74e79ab}


Definition at line 363 of file S\+P\+D\+Y\+Codec.\+h.



Referenced by check\+Length(), check\+Min\+Length(), decode\+Headers(), on\+Control\+Frame(), and parse\+Ingress().

\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!max\+Frame\+Length\+\_\+@{max\+Frame\+Length\+\_\+}}
\index{max\+Frame\+Length\+\_\+@{max\+Frame\+Length\+\_\+}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{max\+Frame\+Length\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::max\+Frame\+Length\+\_\+ \{{\bf spdy\+::k\+Max\+Frame\+Length}\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a4ceee91c05a7874ce935a77b01ce1d7a}


Definition at line 361 of file S\+P\+D\+Y\+Codec.\+h.



Referenced by parse\+Ingress(), and set\+Max\+Frame\+Length().

\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!next\+Egress\+Ping\+I\+D\+\_\+@{next\+Egress\+Ping\+I\+D\+\_\+}}
\index{next\+Egress\+Ping\+I\+D\+\_\+@{next\+Egress\+Ping\+I\+D\+\_\+}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{next\+Egress\+Ping\+I\+D\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stream\+ID} proxygen\+::\+S\+P\+D\+Y\+Codec\+::next\+Egress\+Ping\+I\+D\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_aac6e758aaa6737e395964efb542c0ef9}


Definition at line 357 of file S\+P\+D\+Y\+Codec.\+h.



Referenced by generate\+Ping\+Request(), on\+Ping(), and S\+P\+D\+Y\+Codec().

\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!No\+Stream@{No\+Stream}}
\index{No\+Stream@{No\+Stream}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{No\+Stream}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Stream\+ID} proxygen\+::\+S\+P\+D\+Y\+Codec\+::\+No\+Stream = 0\hspace{0.3cm}{\ttfamily [static]}}\label{classproxygen_1_1SPDYCodec_ad03c1313f9adfa488514dd54a223a9b6}


Definition at line 38 of file S\+P\+D\+Y\+Codec.\+h.



Referenced by generate\+Push\+Promise(), generate\+Syn\+Stream(), generate\+Window\+Update(), on\+Syn\+Reply(), and on\+Syn\+Stream().

\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!partial\+Msg\+\_\+@{partial\+Msg\+\_\+}}
\index{partial\+Msg\+\_\+@{partial\+Msg\+\_\+}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{partial\+Msg\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<${\bf H\+T\+T\+P\+Message}$>$ proxygen\+::\+S\+P\+D\+Y\+Codec\+::partial\+Msg\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a8c667f80418597bb7e3e73e6afd6cf88}


Definition at line 353 of file S\+P\+D\+Y\+Codec.\+h.



Referenced by fail\+Stream(), and parse\+Headers().

\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!stream\+Id\+\_\+@{stream\+Id\+\_\+}}
\index{stream\+Id\+\_\+@{stream\+Id\+\_\+}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{stream\+Id\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::stream\+Id\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_afe7de6dfa246591eb6d256650416ada1}


Definition at line 362 of file S\+P\+D\+Y\+Codec.\+h.



Referenced by decode\+Headers(), fail\+Stream(), generate\+Rst\+Stream(), on\+Control\+Frame(), on\+Rst\+Stream(), on\+Syn\+Reply(), on\+Syn\+Stream(), on\+Window\+Update(), and parse\+Ingress().

\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!type\+\_\+@{type\+\_\+}}
\index{type\+\_\+@{type\+\_\+}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{type\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::type\+\_\+ \{0xffff\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a3df8bdfa4992bc649d266b850d7fd0f6}


Definition at line 365 of file S\+P\+D\+Y\+Codec.\+h.



Referenced by decode\+Headers(), on\+Control\+Frame(), parse\+Headers(), and parse\+Ingress().

\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!user\+Agent\+\_\+@{user\+Agent\+\_\+}}
\index{user\+Agent\+\_\+@{user\+Agent\+\_\+}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{user\+Agent\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string proxygen\+::\+S\+P\+D\+Y\+Codec\+::user\+Agent\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a20e94fd781c20221c0437a3b664a7fe8}


Definition at line 354 of file S\+P\+D\+Y\+Codec.\+h.



Referenced by get\+User\+Agent(), and on\+Syn\+Common().

\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!version\+\_\+@{version\+\_\+}}
\index{version\+\_\+@{version\+\_\+}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{version\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t proxygen\+::\+S\+P\+D\+Y\+Codec\+::version\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_a2375402db89ec236dc93cc35a0454748}


Definition at line 364 of file S\+P\+D\+Y\+Codec.\+h.



Referenced by on\+Control\+Frame(), on\+Settings(), on\+Syn\+Common(), parse\+Headers(), and parse\+Ingress().

\index{proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}!version\+Settings\+\_\+@{version\+Settings\+\_\+}}
\index{version\+Settings\+\_\+@{version\+Settings\+\_\+}!proxygen\+::\+S\+P\+D\+Y\+Codec@{proxygen\+::\+S\+P\+D\+Y\+Codec}}
\subsubsection[{version\+Settings\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf S\+P\+D\+Y\+Version\+Settings}\& proxygen\+::\+S\+P\+D\+Y\+Codec\+::version\+Settings\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1SPDYCodec_ad996062e6528a6cd8d5438fdf4f2e8b9}


Definition at line 342 of file S\+P\+D\+Y\+Codec.\+h.



Referenced by encode\+Headers(), generate\+Goaway(), generate\+Ping\+Common(), generate\+Rst\+Stream(), generate\+Settings(), generate\+Syn\+Reply(), generate\+Syn\+Stream(), generate\+Window\+Update(), get\+Minor\+Version(), get\+Protocol(), get\+Version(), is\+S\+P\+D\+Y\+Reserved(), on\+Control\+Frame(), on\+Syn\+Common(), parse\+Ingress(), rst\+Status\+Supported(), serialize\+Request\+Headers(), S\+P\+D\+Y\+Codec(), supports\+Session\+Flow\+Control(), and supports\+Stream\+Flow\+Control().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
proxygen/lib/http/codec/{\bf S\+P\+D\+Y\+Codec.\+h}\item 
proxygen/lib/http/codec/{\bf S\+P\+D\+Y\+Codec.\+cpp}\end{DoxyCompactItemize}
