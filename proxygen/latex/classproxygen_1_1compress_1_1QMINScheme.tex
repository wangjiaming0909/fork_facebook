\section{proxygen\+:\+:compress\+:\+:Q\+M\+I\+N\+Scheme Class Reference}
\label{classproxygen_1_1compress_1_1QMINScheme}\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}


{\ttfamily \#include $<$Q\+M\+I\+N\+Scheme.\+h$>$}

Inheritance diagram for proxygen\+:\+:compress\+:\+:Q\+M\+I\+N\+Scheme\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{classproxygen_1_1compress_1_1QMINScheme}
\end{center}
\end{figure}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct {\bf Q\+M\+I\+N\+Ack}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Q\+M\+I\+N\+Scheme} ({\bf Compression\+Simulator} $\ast$sim, uint32\+\_\+t)
\item 
{\bf $\sim$\+Q\+M\+I\+N\+Scheme} ()
\item 
std\+::unique\+\_\+ptr$<$ {\bf Ack} $>$ {\bf get\+Ack} (uint16\+\_\+t) override
\item 
void {\bf recv\+Ack} (std\+::unique\+\_\+ptr$<$ {\bf Ack} $>$ generic\+\_\+ack) override
\item 
std\+::pair$<$ {\bf Frame\+Flags}, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ $>$ {\bf encode} (bool, std\+::vector$<$ {\bf compress\+::\+Header} $>$ all\+Headers, {\bf Sim\+Stats} \&stats) override
\item 
void {\bf decode} ({\bf Frame\+Flags}, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ encoded\+Req, {\bf Sim\+Stats} \&, {\bf Sim\+Streaming\+Callback} \&callback) override
\item 
uint32\+\_\+t {\bf get\+Hol\+Block\+Count} () const override
\item 
void {\bf run\+Loop\+Callback} () noexceptoverride
\item 
void {\bf write\+\_\+ctl\+\_\+msg} (const void $\ast${\bf buf}, size\+\_\+t {\bf sz}, unsigned idx)
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static struct {\bf stream\+\_\+chunk} $\ast$ {\bf stream\+\_\+chunk\+\_\+new} (size\+\_\+t off, const void $\ast${\bf buf}, size\+\_\+t bufsz)
\item 
static void {\bf insert\+\_\+chunk} (struct {\bf stream} $\ast${\bf stream}, struct {\bf stream\+\_\+chunk} $\ast$new\+\_\+chunk)
\item 
static struct {\bf stream\+\_\+chunk} $\ast$ {\bf maybe\+\_\+pop\+\_\+chunk} (struct {\bf stream} $\ast${\bf stream})
\item 
static void {\bf write\+\_\+enc2dec} (void $\ast$ctx, const void $\ast${\bf buf}, size\+\_\+t {\bf sz})
\item 
static void {\bf write\+\_\+dec2enc} (void $\ast$ctx, const void $\ast${\bf buf}, size\+\_\+t {\bf sz})
\end{DoxyCompactItemize}
\subsection*{Public Attributes}
\begin{DoxyCompactItemize}
\item 
char $\ast$ {\bf qms\+\_\+idstr}
\item 
struct qmin\+\_\+enc $\ast$ {\bf qms\+\_\+enc}
\item 
struct qmin\+\_\+dec $\ast$ {\bf qms\+\_\+dec}
\item 
unsigned {\bf qms\+\_\+next\+\_\+stream\+\_\+id\+\_\+to\+\_\+encode}
\item 
struct {\bf stream} $\ast$ {\bf qms\+\_\+streams}
\item 
\begin{tabbing}
xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=xx\=\kill
struct \{\\
\>struct {\bf qmin\_ctl\_out} {\bf out}\\
\>size\_t {\bf write\_off}\\
\>size\_t {\bf sz}\\
\>unsigned char {\bf buf} [0x1000]\\
\} {\bf qms\_ctl} [2]\\

\end{tabbing}\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}


Definition at line 124 of file Q\+M\+I\+N\+Scheme.\+h.



\subsection{Constructor \& Destructor Documentation}
\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}!Q\+M\+I\+N\+Scheme@{Q\+M\+I\+N\+Scheme}}
\index{Q\+M\+I\+N\+Scheme@{Q\+M\+I\+N\+Scheme}!proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}
\subsubsection[{Q\+M\+I\+N\+Scheme(\+Compression\+Simulator $\ast$sim, uint32\+\_\+t)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme\+::\+Q\+M\+I\+N\+Scheme (
\begin{DoxyParamCaption}
\item[{{\bf Compression\+Simulator} $\ast$}]{sim, }
\item[{uint32\+\_\+t}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [explicit]}}\label{classproxygen_1_1compress_1_1QMINScheme_afb675988f649762134ed02e71f2489bb}


Definition at line 159 of file Q\+M\+I\+N\+Scheme.\+h.



References qmin\+\_\+dec\+\_\+new(), qmin\+\_\+enc\+\_\+new(), Q\+S\+I\+D\+E\+\_\+\+C\+L\+I\+E\+NT, Q\+S\+I\+D\+E\+\_\+\+S\+E\+R\+V\+ER, s\+\_\+seq, and stream\+::sm\+\_\+chunks.


\begin{DoxyCode}
160       : CompressionScheme(sim) \{
161     \textcolor{comment}{// TODO: set table size?}
162     qms_ctl[0].out.qco\_write = write_enc2dec;
163     qms_ctl[0].write\_off = 0;
164     qms_ctl[0].sz = 0;
165     qms_ctl[1].out.qco\_write = write_dec2enc;
166     qms_ctl[1].write\_off = 0;
167     qms_ctl[1].sz = 0;
168 
169     qms_idstr = (\textcolor{keywordtype}{char} *)malloc(8);
170     sprintf(qms_idstr, \textcolor{stringliteral}{"%u"}, s_seq++);
171 
172     qms_enc = qmin_enc_new(QSIDE_CLIENT, 4 * 1024, &qms_ctl[0].out, qms_idstr);
173     qms_dec = qmin_dec_new(QSIDE_SERVER, 4 * 1024, &qms_ctl[1].out, qms_idstr);
174 
175     qms_streams = (\textcolor{keyword}{struct }stream *)calloc(2, \textcolor{keyword}{sizeof}(qms_streams[0]));
176     TAILQ\_INIT(&qms_streams[0].sm_chunks);
177     TAILQ\_INIT(&qms_streams[1].sm_chunks);
178 
179     qms_next_stream_id_to_encode = 1;
180   \}
\end{DoxyCode}
\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}!````~Q\+M\+I\+N\+Scheme@{$\sim$\+Q\+M\+I\+N\+Scheme}}
\index{````~Q\+M\+I\+N\+Scheme@{$\sim$\+Q\+M\+I\+N\+Scheme}!proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}
\subsubsection[{$\sim$\+Q\+M\+I\+N\+Scheme()}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme\+::$\sim$\+Q\+M\+I\+N\+Scheme (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1compress_1_1QMINScheme_a92c7217431e8eda94abd9331a544f46f}


Definition at line 182 of file Q\+M\+I\+N\+Scheme.\+h.



References qmin\+\_\+dec\+\_\+destroy(), and qmin\+\_\+enc\+\_\+destroy().


\begin{DoxyCode}
182                 \{
183     free(qms_streams);
184     qmin_enc_destroy(qms_enc);
185     qmin_dec_destroy(qms_dec);
186     free(qms_idstr);
187   \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}!decode@{decode}}
\index{decode@{decode}!proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}
\subsubsection[{decode(\+Frame\+Flags, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ encoded\+Req, Sim\+Stats \&, Sim\+Streaming\+Callback \&callback) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme\+::decode (
\begin{DoxyParamCaption}
\item[{{\bf Frame\+Flags}}]{, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{encoded\+Req, }
\item[{{\bf Sim\+Stats} \&}]{, }
\item[{{\bf Sim\+Streaming\+Callback} \&}]{callback}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1compress_1_1QMINScheme_a427f948be8edc3c3fbd784e1e4e36c7a}


Implements {\bf proxygen\+::compress\+::\+Compression\+Scheme} \doxyref{}{p.}{classproxygen_1_1compress_1_1CompressionScheme_ac5ddabc82889df4797e1e869dc32e4e2}.



Definition at line 338 of file Q\+M\+I\+N\+Scheme.\+h.



References name, proxygen\+::compress\+::\+Sim\+Streaming\+Callback\+::on\+Header(), proxygen\+::compress\+::\+Sim\+Streaming\+Callback\+::on\+Headers\+Complete(), qmin\+\_\+dec\+\_\+cmds\+\_\+in(), qmin\+\_\+dec\+\_\+decode(), qmin\+\_\+dec\+\_\+stream\+\_\+done(), stream\+\_\+chunk\+::sc\+\_\+buf, and stream\+\_\+chunk\+::sc\+\_\+sz.


\begin{DoxyCode}
341                                                        \{
342     folly::io::Cursor cursor(encodedReq.get());
343     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *buf;
344     ssize\_t nread;
345     \textcolor{keywordtype}{size\_t} ctl\_sz, stream\_off;
346     \textcolor{keywordtype}{char} outbuf[0x1000];
347     \textcolor{keywordtype}{unsigned} name\_len, val\_len;
348     \textcolor{keywordtype}{unsigned} decoded\_size = 0;
349     uint32\_t stream\_id;
350 
351     qms_ctl[1].out.qco\_ctx = \textcolor{keyword}{this};
352 
353     \textcolor{comment}{/* Read Stream ID: */}
354     buf = cursor.data();
355     memcpy(&stream\_id, buf, \textcolor{keyword}{sizeof}(uint32\_t));
356     encodedReq->trimStart(\textcolor{keyword}{sizeof}(uint32\_t));
357 
358     \textcolor{comment}{/* Read size of control messages */}
359     buf = cursor.data();
360     memcpy(&ctl\_sz, buf, \textcolor{keyword}{sizeof}(ctl\_sz));
361     encodedReq->trimStart(\textcolor{keyword}{sizeof}(ctl\_sz));
362 
363     \textcolor{comment}{/* Feed control messages to the decoder: */}
364     \textcolor{keywordflow}{if} (ctl\_sz) \{
365       \textcolor{keyword}{struct }stream_chunk *chunk;
366 
367       \textcolor{comment}{/* Read stream offset: */}
368       buf = cursor.data();
369       memcpy(&stream\_off, buf, \textcolor{keyword}{sizeof}(stream\_off));
370       encodedReq->trimStart(\textcolor{keyword}{sizeof}(stream\_off));
371 
372       buf = cursor.data();
373       chunk = stream_chunk_new(stream\_off, buf, ctl\_sz);
374       encodedReq->trimStart(ctl\_sz);
375 
376       insert_chunk(&qms_streams[1], chunk);
377 
378       \textcolor{keywordflow}{while} ((chunk = maybe_pop_chunk(&qms_streams[1]))) \{
379         nread = qmin_dec_cmds_in(qms_dec, chunk->sc_buf, chunk->sc_sz);
380         \textcolor{keywordflow}{if} (nread < 0 || (\textcolor{keywordtype}{size\_t})nread != chunk->sc_sz) \{
381           VLOG(1) << \textcolor{stringliteral}{"error: qmin\_dec\_cmds\_in failed"};
382           assert(0);
383         \}
384         free(chunk);
385       \}
386     \}
387 
388     buf = cursor.data();
389     \textcolor{keyword}{const} \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} end = buf + cursor.length();
390 
391     \textcolor{keywordflow}{while} (buf < end) \{
392       nread = qmin_dec_decode(
393           qms_dec, buf, end - buf, outbuf, \textcolor{keyword}{sizeof}(outbuf), &name\_len, &val\_len);
394       \textcolor{keywordflow}{if} (nread < 0) \{
395         VLOG(1) << \textcolor{stringliteral}{"error: decoder failed!"};
396         assert(0);
397         \textcolor{keywordflow}{return};
398       \}
399       assert(nread);
400       buf += nread;
401       decoded\_size += name\_len + val\_len;
402       std::string name\{outbuf, name\_len\};
403       std::string value\{outbuf + name\_len, val\_len\};
404       callback.onHeader(name, value);
405     \}
406 
407     \textcolor{keywordflow}{if} (0 != qmin_dec_stream_done(qms_dec, stream\_id)) \{
408       assert(0);
409       VLOG(1) << \textcolor{stringliteral}{"error: qmin\_dec\_stream\_done failed"};
410     \}
411 
412     proxygen::HTTPHeaderSize sz;
413     sz.compressed = encodedReq->computeChainDataLength();
414     sz.uncompressed = decoded\_size;
415     callback.onHeadersComplete(sz, \textcolor{keyword}{true});
416   \}
\end{DoxyCode}
\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}!encode@{encode}}
\index{encode@{encode}!proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}
\subsubsection[{encode(bool, std\+::vector$<$ compress\+::\+Header $>$ all\+Headers, Sim\+Stats \&stats) override}]{\setlength{\rightskip}{0pt plus 5cm}std\+::pair$<${\bf Frame\+Flags}, std\+::unique\+\_\+ptr$<$folly\+::\+I\+O\+Buf$>$ $>$ proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme\+::encode (
\begin{DoxyParamCaption}
\item[{bool}]{, }
\item[{std\+::vector$<$ {\bf compress\+::\+Header} $>$}]{all\+Headers, }
\item[{{\bf Sim\+Stats} \&}]{stats}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1compress_1_1QMINScheme_a389ec2fa53acd698ef9648408a163e90}


Implements {\bf proxygen\+::compress\+::\+Compression\+Scheme} \doxyref{}{p.}{classproxygen_1_1compress_1_1CompressionScheme_a4e013945112c438374a2cb99eb753d67}.



Definition at line 243 of file Q\+M\+I\+N\+Scheme.\+h.



References proxygen\+::compress\+::\+Frame\+Flags\+::allow\+O\+OO, proxygen\+::compress\+::\+Sim\+Stats\+::compressed, name, Q\+E\+S\+\_\+\+E\+RR, Q\+E\+S\+\_\+\+N\+O\+B\+U\+FS, Q\+E\+S\+\_\+\+OK, Q\+I\+T\+\_\+\+Y\+ES, qmin\+\_\+enc\+\_\+encode(), qmin\+\_\+enc\+\_\+end\+\_\+stream\+\_\+headers(), qmin\+\_\+enc\+\_\+to\+\_\+str(), and proxygen\+::compress\+::\+Sim\+Stats\+::uncompressed.


\begin{DoxyCode}
246                                 \{
247     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} max\_ctl = 0x1000;
248     \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} max\_comp = 0x1000;
249     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} outbuf[max\_ctl + max\_comp];
250     \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{char} *\textcolor{keyword}{const} comp = outbuf + max\_ctl;
251     \textcolor{keywordtype}{size\_t} nw, comp\_sz;
252     \textcolor{keyword}{enum} qmin_encode_status qes;
253     FrameFlags flags;
254 
255     qms_ctl[0].out.qco\_ctx = \textcolor{keyword}{this};
256     comp\_sz = 0;
257 
258     \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto} header : allHeaders) \{
259       std::string name\{header.name->c\_str()\};
260       std::transform(name.begin(), name.end(), name.begin(), ::tolower);
261       qes = qmin_enc_encode(qms_enc,
262                             qms_next_stream_id_to_encode,
263                             name.c\_str(),
264                             name.length(),
265                             header.value->c\_str(),
266                             header.value->length(),
267                             QIT_YES,
268                             comp + comp\_sz,
269                             max\_comp - comp\_sz,
270                             &nw);
271       \textcolor{keywordflow}{switch} (qes) \{
272         \textcolor{keywordflow}{case} QES_OK:
273           \textcolor{comment}{/* 2 is a magic number added to the uncompressed size by the other}
274 \textcolor{comment}{           * encoder.  We follow suit to make the numbers match.}
275 \textcolor{comment}{           */}
276           stats.uncompressed += name.length() + header.value->length() + 2;
277           stats.compressed += nw;
278           comp\_sz += nw;
279           \textcolor{keywordflow}{break};
280         \textcolor{keywordflow}{case} QES_NOBUFS:
281           VLOG(1) << \textcolor{stringliteral}{"compressed header does not fit into temporary "}
282                      \textcolor{stringliteral}{"output buffer"};
283           \textcolor{keywordflow}{return} \{flags, \textcolor{keyword}{nullptr}\};
284         \textcolor{keywordflow}{case} QES_ERR:
285           VLOG(1) << \textcolor{stringliteral}{"error: "} << strerror(errno);
286           assert(0);
287           \textcolor{keywordflow}{return} \{flags, \textcolor{keyword}{nullptr}\};
288       \}
289     \}
290 
291     \{
292       \textcolor{keywordtype}{size\_t} sz;
293       \textcolor{keywordtype}{char} *state = qmin_enc_to_str(qms_enc, &sz);
294       VLOG(4) << \textcolor{stringliteral}{"encoder state: "} << state;
295       free(state);
296     \}
297 
298     \textcolor{keywordflow}{if} (0 != qmin_enc_end_stream_headers(qms_enc)) \{
299       VLOG(1) << \textcolor{stringliteral}{"error: qmin\_enc\_end\_stream\_headers failed"};
300       assert(0);
301     \}
302 
303     \textcolor{comment}{/* Prepend control message and its size: */}
304     \textcolor{keywordtype}{size\_t} ctl\_msg\_sz = qms_ctl[0].sz;
305     qms_ctl[0].sz = 0;
306     \textcolor{keywordtype}{size\_t} ctl\_msg\_sz\_with\_off;
307     \textcolor{keywordflow}{if} (ctl\_msg\_sz) \{
308       memcpy(outbuf + max\_ctl - ctl\_msg\_sz, qms_ctl[0].buf, ctl\_msg\_sz);
309       memcpy(outbuf + max\_ctl - ctl\_msg\_sz - \textcolor{keyword}{sizeof}(qms_ctl[0].write_off),
310              &qms_ctl[0].write\_off,
311              \textcolor{keyword}{sizeof}(qms_ctl[0].write\_off));
312       qms_ctl[0].write\_off += ctl\_msg\_sz;
313       ctl\_msg\_sz\_with\_off = ctl\_msg\_sz + \textcolor{keyword}{sizeof}(qms_ctl[0].write\_off);
314     \} \textcolor{keywordflow}{else}
315       ctl\_msg\_sz\_with\_off = 0;
316     memcpy(outbuf + max\_ctl - ctl\_msg\_sz\_with\_off - \textcolor{keyword}{sizeof}(ctl\_msg\_sz),
317            &ctl\_msg\_sz,
318            \textcolor{keyword}{sizeof}(ctl\_msg\_sz));
319 
320     stats.compressed += ctl\_msg\_sz;
321 
322     \textcolor{comment}{/* Prepend Stream ID: */}
323     memcpy(outbuf + max\_ctl - ctl\_msg\_sz\_with\_off - \textcolor{keyword}{sizeof}(ctl\_msg\_sz) -
324                \textcolor{keyword}{sizeof}(uint32\_t),
325            &qms_next_stream_id_to_encode,
326            \textcolor{keyword}{sizeof}(qms_next_stream_id_to_encode));
327 
328     qms_next_stream_id_to_encode += 2;
329     flags.allowOOO = \textcolor{keyword}{true};
330     \textcolor{keywordflow}{return} \{
331         flags,
332         folly::IOBuf::copyBuffer(outbuf + max\_ctl - ctl\_msg\_sz\_with\_off -
333                                      \textcolor{keyword}{sizeof}(ctl\_msg\_sz) - \textcolor{keyword}{sizeof}(uint32\_t),
334                                  comp\_sz + ctl\_msg\_sz\_with\_off +
335                                      \textcolor{keyword}{sizeof}(ctl\_msg\_sz) + \textcolor{keyword}{sizeof}(uint32\_t))\};
336   \}
\end{DoxyCode}
\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}!get\+Ack@{get\+Ack}}
\index{get\+Ack@{get\+Ack}!proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}
\subsubsection[{get\+Ack(uint16\+\_\+t) override}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<${\bf Ack}$>$ proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme\+::get\+Ack (
\begin{DoxyParamCaption}
\item[{uint16\+\_\+t}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1compress_1_1QMINScheme_ac06a5811f950530ea4ea011cfeb45985}


Implements {\bf proxygen\+::compress\+::\+Compression\+Scheme} \doxyref{}{p.}{classproxygen_1_1compress_1_1CompressionScheme_af8a906f3f6600f903a3f8249478f9ea6}.



Definition at line 204 of file Q\+M\+I\+N\+Scheme.\+h.


\begin{DoxyCode}
204                                                  \{
205     \textcolor{keywordflow}{if} (qms_ctl[1].sz) \{
206       \textcolor{keyword}{auto} ack = std::make\_unique<QMINAck>(
207           qms_ctl[1].write\_off, qms_ctl[1].buf, qms_ctl[1].sz);
208       VLOG(4) << \textcolor{stringliteral}{"sent ACK for instance "} << qms_idstr
209               << \textcolor{stringliteral}{" off: "} << qms_ctl[1].write\_off << \textcolor{stringliteral}{"; sz: "} << qms_ctl[1].sz;
210       qms_ctl[1].write\_off += qms_ctl[1].sz;
211       qms_ctl[1].sz = 0;
212       \textcolor{keywordflow}{return} std::move(ack);
213     \} \textcolor{keywordflow}{else} \{
214       assert(0);
215       \textcolor{keywordflow}{return} \textcolor{keyword}{nullptr};
216     \}
217   \}
\end{DoxyCode}
\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}!get\+Hol\+Block\+Count@{get\+Hol\+Block\+Count}}
\index{get\+Hol\+Block\+Count@{get\+Hol\+Block\+Count}!proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}
\subsubsection[{get\+Hol\+Block\+Count() const override}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme\+::get\+Hol\+Block\+Count (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1compress_1_1QMINScheme_a9746dc6ffa6552250e6eadd2dda71742}


Implements {\bf proxygen\+::compress\+::\+Compression\+Scheme} \doxyref{}{p.}{classproxygen_1_1compress_1_1CompressionScheme_a08043930336620a278f3763256384a38}.



Definition at line 418 of file Q\+M\+I\+N\+Scheme.\+h.


\begin{DoxyCode}
418                                              \{
419     \textcolor{keywordflow}{return} 0;
420   \}
\end{DoxyCode}
\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}!insert\+\_\+chunk@{insert\+\_\+chunk}}
\index{insert\+\_\+chunk@{insert\+\_\+chunk}!proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}
\subsubsection[{insert\+\_\+chunk(struct stream $\ast$stream, struct stream\+\_\+chunk $\ast$new\+\_\+chunk)}]{\setlength{\rightskip}{0pt plus 5cm}static void proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme\+::insert\+\_\+chunk (
\begin{DoxyParamCaption}
\item[{struct {\bf stream} $\ast$}]{stream, }
\item[{struct {\bf stream\+\_\+chunk} $\ast$}]{new\+\_\+chunk}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classproxygen_1_1compress_1_1QMINScheme_a02a4f4cd8b318acf1510129f4f80e4f9}


Definition at line 138 of file Q\+M\+I\+N\+Scheme.\+h.



References stream\+\_\+chunk\+::sc\+\_\+off, and stream\+::sm\+\_\+chunks.


\begin{DoxyCode}
139                                                            \{
140     \textcolor{keyword}{struct }stream_chunk *chunk;
141     TAILQ\_FOREACH(chunk, &stream->sm_chunks, sc\_next)
142     if (chunk->sc_off > new\_chunk->sc_off) \{
143       TAILQ\_INSERT\_BEFORE(chunk, new\_chunk, sc\_next);
144       \textcolor{keywordflow}{return};
145     \}
146     TAILQ\_INSERT\_TAIL(&stream->sm_chunks, new\_chunk, sc\_next);
147   \}
\end{DoxyCode}
\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}!maybe\+\_\+pop\+\_\+chunk@{maybe\+\_\+pop\+\_\+chunk}}
\index{maybe\+\_\+pop\+\_\+chunk@{maybe\+\_\+pop\+\_\+chunk}!proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}
\subsubsection[{maybe\+\_\+pop\+\_\+chunk(struct stream $\ast$stream)}]{\setlength{\rightskip}{0pt plus 5cm}static struct {\bf stream\+\_\+chunk}$\ast$ proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme\+::maybe\+\_\+pop\+\_\+chunk (
\begin{DoxyParamCaption}
\item[{struct {\bf stream} $\ast$}]{stream}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classproxygen_1_1compress_1_1QMINScheme_ac31af7f76f5f526cedf82f01324dc243}


Definition at line 149 of file Q\+M\+I\+N\+Scheme.\+h.



References stream\+\_\+chunk\+::sc\+\_\+off, stream\+\_\+chunk\+::sc\+\_\+sz, stream\+::sm\+\_\+chunks, and stream\+::sm\+\_\+read\+\_\+off.


\begin{DoxyCode}
149                                                                      \{
150     \textcolor{keyword}{struct }stream_chunk *chunk = TAILQ\_FIRST(&stream->sm_chunks);
151     \textcolor{keywordflow}{if} (chunk && chunk->sc_off == stream->sm_read_off) \{
152       TAILQ\_REMOVE(&stream->sm_chunks, chunk, sc\_next);
153       stream->sm_read_off += chunk->sc_sz;
154       \textcolor{keywordflow}{return} chunk;
155     \} \textcolor{keywordflow}{else}
156       \textcolor{keywordflow}{return} NULL;
157   \}
\end{DoxyCode}
\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}!recv\+Ack@{recv\+Ack}}
\index{recv\+Ack@{recv\+Ack}!proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}
\subsubsection[{recv\+Ack(std\+::unique\+\_\+ptr$<$ Ack $>$ generic\+\_\+ack) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme\+::recv\+Ack (
\begin{DoxyParamCaption}
\item[{std\+::unique\+\_\+ptr$<$ {\bf Ack} $>$}]{generic\+\_\+ack}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1compress_1_1QMINScheme_afbc48109af89a406c0e4108a3b897aa3}


Implements {\bf proxygen\+::compress\+::\+Compression\+Scheme} \doxyref{}{p.}{classproxygen_1_1compress_1_1CompressionScheme_a8b5b9dbfd8f08e0dfdc6415e7432ddbf}.



Definition at line 219 of file Q\+M\+I\+N\+Scheme.\+h.



References qmin\+\_\+enc\+\_\+cmds\+\_\+in(), stream\+\_\+chunk\+::sc\+\_\+buf, and stream\+\_\+chunk\+::sc\+\_\+sz.


\begin{DoxyCode}
219                                                         \{
220     \textcolor{keyword}{struct }stream_chunk *chunk;
221 
222     CHECK(generic\_ack);
223     \textcolor{keyword}{auto} ack = \textcolor{keyword}{dynamic\_cast<}QMINAck *\textcolor{keyword}{>}(generic\_ack.get());
224     CHECK\_NOTNULL(ack);
225 
226     VLOG(4) << \textcolor{stringliteral}{"received ACK for instance "} << qms_idstr
227             << \textcolor{stringliteral}{" off: "} << ack->qma\_off << \textcolor{stringliteral}{"; sz: "} << ack->qma\_sz;
228 
229     chunk = stream_chunk_new(ack->qma\_off, ack->qma\_buf, ack->qma\_sz);
230     insert_chunk(&qms_streams[0], chunk);
231 
232     \textcolor{keywordflow}{while} ((chunk = maybe_pop_chunk(&qms_streams[0]))) \{
233       ssize\_t nread;
234       nread = qmin_enc_cmds_in(qms_enc, chunk->sc_buf, chunk->sc_sz);
235       \textcolor{keywordflow}{if} (nread < 0 || (\textcolor{keywordtype}{size\_t})nread != chunk->sc_sz) \{
236         VLOG(1) << \textcolor{stringliteral}{"error: qmin\_enc\_cmds\_in failed"};
237         assert(0);
238       \}
239       free(chunk);
240     \}
241   \}
\end{DoxyCode}
\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}!run\+Loop\+Callback@{run\+Loop\+Callback}}
\index{run\+Loop\+Callback@{run\+Loop\+Callback}!proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}
\subsubsection[{run\+Loop\+Callback() noexceptoverride}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme\+::run\+Loop\+Callback (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [noexcept]}}\label{classproxygen_1_1compress_1_1QMINScheme_a2e275da16b1e1d51be27e769bdb230d2}


Definition at line 422 of file Q\+M\+I\+N\+Scheme.\+h.


\begin{DoxyCode}
422                                            \{
423     CompressionScheme::runLoopCallback();
424   \}
\end{DoxyCode}
\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}!stream\+\_\+chunk\+\_\+new@{stream\+\_\+chunk\+\_\+new}}
\index{stream\+\_\+chunk\+\_\+new@{stream\+\_\+chunk\+\_\+new}!proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}
\subsubsection[{stream\+\_\+chunk\+\_\+new(size\+\_\+t off, const void $\ast$buf, size\+\_\+t bufsz)}]{\setlength{\rightskip}{0pt plus 5cm}static struct {\bf stream\+\_\+chunk}$\ast$ proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme\+::stream\+\_\+chunk\+\_\+new (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{off, }
\item[{const void $\ast$}]{buf, }
\item[{size\+\_\+t}]{bufsz}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classproxygen_1_1compress_1_1QMINScheme_a5e2230bffb2f103eba6bfbde9a0c3b82}


Definition at line 126 of file Q\+M\+I\+N\+Scheme.\+h.



References stream\+\_\+chunk\+::sc\+\_\+buf, stream\+\_\+chunk\+::sc\+\_\+off, and stream\+\_\+chunk\+::sc\+\_\+sz.


\begin{DoxyCode}
128                                                              \{
129     \textcolor{keyword}{struct }stream_chunk *chunk =
130         (\textcolor{keyword}{struct }stream_chunk *)malloc(\textcolor{keyword}{sizeof}(*chunk) + bufsz);
131     assert(chunk);
132     chunk->sc_off = off;
133     chunk->sc_sz = bufsz;
134     memcpy(chunk->sc_buf, buf, bufsz);
135     \textcolor{keywordflow}{return} chunk;
136   \}
\end{DoxyCode}
\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}!write\+\_\+ctl\+\_\+msg@{write\+\_\+ctl\+\_\+msg}}
\index{write\+\_\+ctl\+\_\+msg@{write\+\_\+ctl\+\_\+msg}!proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}
\subsubsection[{write\+\_\+ctl\+\_\+msg(const void $\ast$buf, size\+\_\+t sz, unsigned idx)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme\+::write\+\_\+ctl\+\_\+msg (
\begin{DoxyParamCaption}
\item[{const void $\ast$}]{buf, }
\item[{size\+\_\+t}]{sz, }
\item[{unsigned}]{idx}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1compress_1_1QMINScheme_a1ad0ff1923e9eb9d4921e69a4e1ca323}


Definition at line 426 of file Q\+M\+I\+N\+Scheme.\+h.



Referenced by write\+\_\+dec2enc(), and write\+\_\+enc2dec().


\begin{DoxyCode}
426                                                                \{
427     \textcolor{keywordtype}{size\_t} avail = \textcolor{keyword}{sizeof}(qms_ctl[idx].buf) - qms_ctl[idx].sz;
428     assert(avail >= sz);
429     \textcolor{keywordflow}{if} (avail < sz) \{
430       VLOG(1) << \textcolor{stringliteral}{"Truncating control message from "} << sz << \textcolor{stringliteral}{" to "} << avail
431               << \textcolor{stringliteral}{"bytes"};
432       sz = avail;
433     \}
434     memcpy(qms_ctl[idx].buf + qms_ctl[idx].sz, buf, sz);
435     qms_ctl[idx].sz += sz;
436     VLOG(4) << \textcolor{stringliteral}{"Wrote "} << sz << \textcolor{stringliteral}{" bytes to control channel"};
437   \}
\end{DoxyCode}
\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}!write\+\_\+dec2enc@{write\+\_\+dec2enc}}
\index{write\+\_\+dec2enc@{write\+\_\+dec2enc}!proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}
\subsubsection[{write\+\_\+dec2enc(void $\ast$ctx, const void $\ast$buf, size\+\_\+t sz)}]{\setlength{\rightskip}{0pt plus 5cm}static void proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme\+::write\+\_\+dec2enc (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{ctx, }
\item[{const void $\ast$}]{buf, }
\item[{size\+\_\+t}]{sz}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classproxygen_1_1compress_1_1QMINScheme_a146dd2f692d55591db4d737cbf4d80f8}


Definition at line 444 of file Q\+M\+I\+N\+Scheme.\+h.



References write\+\_\+ctl\+\_\+msg().


\begin{DoxyCode}
444                                                                    \{
445     QMINScheme *\textcolor{keyword}{const} qms = (QMINScheme *)ctx;
446     qms->write\_ctl\_msg(buf, sz, 1);
447   \}
\end{DoxyCode}
\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}!write\+\_\+enc2dec@{write\+\_\+enc2dec}}
\index{write\+\_\+enc2dec@{write\+\_\+enc2dec}!proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}
\subsubsection[{write\+\_\+enc2dec(void $\ast$ctx, const void $\ast$buf, size\+\_\+t sz)}]{\setlength{\rightskip}{0pt plus 5cm}static void proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme\+::write\+\_\+enc2dec (
\begin{DoxyParamCaption}
\item[{void $\ast$}]{ctx, }
\item[{const void $\ast$}]{buf, }
\item[{size\+\_\+t}]{sz}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classproxygen_1_1compress_1_1QMINScheme_ad6df600627c3558560d0c0aa86efd624}


Definition at line 439 of file Q\+M\+I\+N\+Scheme.\+h.



References write\+\_\+ctl\+\_\+msg().


\begin{DoxyCode}
439                                                                    \{
440     QMINScheme *\textcolor{keyword}{const} qms = (QMINScheme *)ctx;
441     qms->write\_ctl\_msg(buf, sz, 0);
442   \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}!buf@{buf}}
\index{buf@{buf}!proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}
\subsubsection[{buf}]{\setlength{\rightskip}{0pt plus 5cm}unsigned char proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme\+::buf[0x1000]}\label{classproxygen_1_1compress_1_1QMINScheme_ac7e153ecf7903fb0ea5dbdb5800259cc}


Definition at line 466 of file Q\+M\+I\+N\+Scheme.\+h.

\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}!out@{out}}
\index{out@{out}!proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}
\subsubsection[{out}]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf qmin\+\_\+ctl\+\_\+out} proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme\+::out}\label{classproxygen_1_1compress_1_1QMINScheme_a0c61bc0c15b544e56eb8fc7e5ce40077}


Definition at line 463 of file Q\+M\+I\+N\+Scheme.\+h.

\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}!qms\+\_\+ctl@{qms\+\_\+ctl}}
\index{qms\+\_\+ctl@{qms\+\_\+ctl}!proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}
\subsubsection[{qms\+\_\+ctl}]{\setlength{\rightskip}{0pt plus 5cm}struct \{ ... \}   proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme\+::qms\+\_\+ctl[2]}\label{classproxygen_1_1compress_1_1QMINScheme_ae6635e7d43e3f28b0844d5f3c6d238f5}
\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}!qms\+\_\+dec@{qms\+\_\+dec}}
\index{qms\+\_\+dec@{qms\+\_\+dec}!proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}
\subsubsection[{qms\+\_\+dec}]{\setlength{\rightskip}{0pt plus 5cm}struct qmin\+\_\+dec$\ast$ proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme\+::qms\+\_\+dec}\label{classproxygen_1_1compress_1_1QMINScheme_ab90cdb8949d48398c15fbc14ea26535a}


Definition at line 452 of file Q\+M\+I\+N\+Scheme.\+h.

\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}!qms\+\_\+enc@{qms\+\_\+enc}}
\index{qms\+\_\+enc@{qms\+\_\+enc}!proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}
\subsubsection[{qms\+\_\+enc}]{\setlength{\rightskip}{0pt plus 5cm}struct qmin\+\_\+enc$\ast$ proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme\+::qms\+\_\+enc}\label{classproxygen_1_1compress_1_1QMINScheme_a0c4602e01b2ed832e8d8d38ea274441e}


Definition at line 451 of file Q\+M\+I\+N\+Scheme.\+h.

\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}!qms\+\_\+idstr@{qms\+\_\+idstr}}
\index{qms\+\_\+idstr@{qms\+\_\+idstr}!proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}
\subsubsection[{qms\+\_\+idstr}]{\setlength{\rightskip}{0pt plus 5cm}char$\ast$ proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme\+::qms\+\_\+idstr}\label{classproxygen_1_1compress_1_1QMINScheme_ad9c9c0b3e30ba90ca1bd533765aba711}


Definition at line 449 of file Q\+M\+I\+N\+Scheme.\+h.

\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}!qms\+\_\+next\+\_\+stream\+\_\+id\+\_\+to\+\_\+encode@{qms\+\_\+next\+\_\+stream\+\_\+id\+\_\+to\+\_\+encode}}
\index{qms\+\_\+next\+\_\+stream\+\_\+id\+\_\+to\+\_\+encode@{qms\+\_\+next\+\_\+stream\+\_\+id\+\_\+to\+\_\+encode}!proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}
\subsubsection[{qms\+\_\+next\+\_\+stream\+\_\+id\+\_\+to\+\_\+encode}]{\setlength{\rightskip}{0pt plus 5cm}unsigned proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme\+::qms\+\_\+next\+\_\+stream\+\_\+id\+\_\+to\+\_\+encode}\label{classproxygen_1_1compress_1_1QMINScheme_a8de1fe87d2762eee02c0573443174bd0}


Definition at line 457 of file Q\+M\+I\+N\+Scheme.\+h.

\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}!qms\+\_\+streams@{qms\+\_\+streams}}
\index{qms\+\_\+streams@{qms\+\_\+streams}!proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}
\subsubsection[{qms\+\_\+streams}]{\setlength{\rightskip}{0pt plus 5cm}struct {\bf stream}$\ast$ proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme\+::qms\+\_\+streams}\label{classproxygen_1_1compress_1_1QMINScheme_a00e4cc5e2114786fbe432d9114b1eb33}


Definition at line 460 of file Q\+M\+I\+N\+Scheme.\+h.

\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}!sz@{sz}}
\index{sz@{sz}!proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}
\subsubsection[{sz}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme\+::sz}\label{classproxygen_1_1compress_1_1QMINScheme_af014ef74d74c3ad9521a8dcfca9570b1}


Definition at line 465 of file Q\+M\+I\+N\+Scheme.\+h.

\index{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}!write\+\_\+off@{write\+\_\+off}}
\index{write\+\_\+off@{write\+\_\+off}!proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme@{proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme}}
\subsubsection[{write\+\_\+off}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::compress\+::\+Q\+M\+I\+N\+Scheme\+::write\+\_\+off}\label{classproxygen_1_1compress_1_1QMINScheme_a5dcda510c19eadcd62e27f1f01d4753b}


Definition at line 464 of file Q\+M\+I\+N\+Scheme.\+h.



The documentation for this class was generated from the following file\+:\begin{DoxyCompactItemize}
\item 
proxygen/lib/http/codec/compress/experimental/simulator/{\bf Q\+M\+I\+N\+Scheme.\+h}\end{DoxyCompactItemize}
