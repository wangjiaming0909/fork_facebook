\section{proxygen/lib/http/test/\+H\+T\+T\+P\+Common\+Headers\+Tests.cpp File Reference}
\label{HTTPCommonHeadersTests_8cpp}\index{proxygen/lib/http/test/\+H\+T\+T\+P\+Common\+Headers\+Tests.\+cpp@{proxygen/lib/http/test/\+H\+T\+T\+P\+Common\+Headers\+Tests.\+cpp}}
{\ttfamily \#include $<$folly/portability/\+G\+Test.\+h$>$}\\*
{\ttfamily \#include $<$proxygen/lib/http/\+H\+T\+T\+P\+Common\+Headers.\+h$>$}\\*
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
class {\bf H\+T\+T\+P\+Common\+Headers\+Tests}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Common\+Headers\+Tests}, Test\+Hashing)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Common\+Headers\+Tests}, Test\+Two\+Tables\+Initialized)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Common\+Headers\+Tests}, Test\+Is\+Common\+Header\+Name\+From\+Table)
\item 
{\bf T\+E\+S\+T\+\_\+F} ({\bf H\+T\+T\+P\+Common\+Headers\+Tests}, Test\+Get\+Header\+Code\+From\+Table\+Common\+Header\+Name)
\end{DoxyCompactItemize}


\subsection{Function Documentation}
\index{H\+T\+T\+P\+Common\+Headers\+Tests.\+cpp@{H\+T\+T\+P\+Common\+Headers\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Common\+Headers\+Tests.\+cpp@{H\+T\+T\+P\+Common\+Headers\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Common\+Headers\+Tests, Test\+Hashing)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Common\+Headers\+Tests}}]{, }
\item[{Test\+Hashing}]{}
\end{DoxyParamCaption}
)}\label{HTTPCommonHeadersTests_8cpp_a21a1849dbf1191f3e8b52efc900377bc}


Definition at line 18 of file H\+T\+T\+P\+Common\+Headers\+Tests.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Common\+Headers\+::hash(), and proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER.


\begin{DoxyCode}
18                                             \{
19   std::string common1(\textcolor{stringliteral}{"Content-Length"});
20   std::string common2(\textcolor{stringliteral}{"content-length"});
21   std::string uncommon(\textcolor{stringliteral}{"Uncommon"});
22 
23   HTTPHeaderCode commonCode1 = HTTPCommonHeaders::hash(common1);
24   HTTPHeaderCode commonCode2 = HTTPCommonHeaders::hash(common2);
25   HTTPHeaderCode uncommonCode = HTTPCommonHeaders::hash(uncommon);
26 
27   EXPECT\_EQ(uncommonCode, HTTPHeaderCode::HTTP_HEADER_OTHER);
28   EXPECT\_NE(commonCode1, HTTPHeaderCode::HTTP_HEADER_OTHER);
29 
30   EXPECT\_EQ(commonCode1, commonCode2);
31 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Common\+Headers\+Tests.\+cpp@{H\+T\+T\+P\+Common\+Headers\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Common\+Headers\+Tests.\+cpp@{H\+T\+T\+P\+Common\+Headers\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Common\+Headers\+Tests, Test\+Two\+Tables\+Initialized)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Common\+Headers\+Tests}}]{, }
\item[{Test\+Two\+Tables\+Initialized}]{}
\end{DoxyParamCaption}
)}\label{HTTPCommonHeadersTests_8cpp_aa1822b897cc124adca109441fabb7452}


Definition at line 33 of file H\+T\+T\+P\+Common\+Headers\+Tests.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Common\+Headers\+::get\+Pointer\+To\+Header\+Name(), proxygen\+::\+H\+T\+T\+P\+Common\+Headers\+::hash(), and proxygen\+::\+T\+A\+B\+L\+E\+\_\+\+L\+O\+W\+E\+R\+C\+A\+SE.


\begin{DoxyCode}
33                                                          \{
34   std::string common(\textcolor{stringliteral}{"Content-Length"});
35   HTTPHeaderCode code = HTTPCommonHeaders::hash(common);
36 
37   EXPECT\_EQ(*HTTPCommonHeaders::getPointerToHeaderName(code), \textcolor{stringliteral}{"Content-Length"});
38   EXPECT\_EQ(
39     *HTTPCommonHeaders::getPointerToHeaderName(
40       code, HTTPCommonHeaderTableType::TABLE_LOWERCASE), \textcolor{stringliteral}{"content-length"});
41 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Common\+Headers\+Tests.\+cpp@{H\+T\+T\+P\+Common\+Headers\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Common\+Headers\+Tests.\+cpp@{H\+T\+T\+P\+Common\+Headers\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Common\+Headers\+Tests, Test\+Is\+Common\+Header\+Name\+From\+Table)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Common\+Headers\+Tests}}]{, }
\item[{Test\+Is\+Common\+Header\+Name\+From\+Table}]{}
\end{DoxyParamCaption}
)}\label{HTTPCommonHeadersTests_8cpp_af7418594544d91b0798ba6cae2461ceb}


Definition at line 43 of file H\+T\+T\+P\+Common\+Headers\+Tests.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Common\+Headers\+::get\+Pointer\+To\+Header\+Name(), proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+N\+O\+NE, proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER, proxygen\+::\+H\+T\+T\+P\+Header\+Code\+Common\+Offset, proxygen\+::\+H\+T\+T\+P\+Common\+Headers\+::is\+Header\+Name\+From\+Table(), and proxygen\+::\+T\+A\+B\+L\+E\+\_\+\+C\+A\+M\+E\+L\+C\+A\+SE.


\begin{DoxyCode}
43                                                                 \{
44   \textcolor{comment}{// The first two hardcoded headers are not considered actual common headers}
45   EXPECT\_FALSE(
46     HTTPCommonHeaders::isHeaderNameFromTable(
47       HTTPCommonHeaders::getPointerToHeaderName(HTTP_HEADER_NONE),
48       TABLE_CAMELCASE));
49   EXPECT\_FALSE(
50     HTTPCommonHeaders::isHeaderNameFromTable(
51       HTTPCommonHeaders::getPointerToHeaderName(HTTP_HEADER_OTHER),
52       TABLE_CAMELCASE));
53 
54   \textcolor{comment}{// Verify that the first actual common header in the address table checks out}
55   \textcolor{comment}{// Assuming there is at least one common header in the table (first two}
56   \textcolor{comment}{// entries are HTTP\_HEADER\_NONE and HTTP\_HEADER\_OTHER)}
57   \textcolor{keywordflow}{if} (HTTPCommonHeaders::num\_header\_codes > HTTPHeaderCodeCommonOffset) \{
58     EXPECT\_TRUE(
59       HTTPCommonHeaders::isHeaderNameFromTable(
60         HTTPCommonHeaders::getPointerToHeaderName(
61           static\_cast<HTTPHeaderCode>(HTTPHeaderCodeCommonOffset + 1)),
62         TABLE_CAMELCASE));
63 
64     \textcolor{comment}{// Verify that the last header in the common address table checks out}
65     EXPECT\_TRUE(
66       HTTPCommonHeaders::isHeaderNameFromTable(
67         HTTPCommonHeaders::getPointerToHeaderName(
68           static\_cast<HTTPHeaderCode>(
69             HTTPCommonHeaders::num\_header\_codes - 1)), TABLE_CAMELCASE));
70   \}
71 
72   \textcolor{comment}{// Verify that a random header is not identified as being part of the common}
73   \textcolor{comment}{// address table}
74   std::string externalHeader = \textcolor{stringliteral}{"externalHeader"};
75   EXPECT\_FALSE(HTTPCommonHeaders::isHeaderNameFromTable(
76     &externalHeader, TABLE_CAMELCASE));
77 \}
\end{DoxyCode}
\index{H\+T\+T\+P\+Common\+Headers\+Tests.\+cpp@{H\+T\+T\+P\+Common\+Headers\+Tests.\+cpp}!T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}}
\index{T\+E\+S\+T\+\_\+F@{T\+E\+S\+T\+\_\+F}!H\+T\+T\+P\+Common\+Headers\+Tests.\+cpp@{H\+T\+T\+P\+Common\+Headers\+Tests.\+cpp}}
\subsubsection[{T\+E\+S\+T\+\_\+\+F(\+H\+T\+T\+P\+Common\+Headers\+Tests, Test\+Get\+Header\+Code\+From\+Table\+Common\+Header\+Name)}]{\setlength{\rightskip}{0pt plus 5cm}T\+E\+S\+T\+\_\+F (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Common\+Headers\+Tests}}]{, }
\item[{Test\+Get\+Header\+Code\+From\+Table\+Common\+Header\+Name}]{}
\end{DoxyParamCaption}
)}\label{HTTPCommonHeadersTests_8cpp_a5bbfd50904e0d0b41d642ce42cfc940d}


Definition at line 79 of file H\+T\+T\+P\+Common\+Headers\+Tests.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Common\+Headers\+::get\+Header\+Code\+From\+Table\+Common\+Header\+Name(), proxygen\+::\+H\+T\+T\+P\+Common\+Headers\+::get\+Pointer\+To\+Header\+Name(), proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+T\+H\+ER, proxygen\+::\+H\+T\+T\+P\+Header\+Code\+Common\+Offset, and proxygen\+::\+T\+A\+B\+L\+E\+\_\+\+C\+A\+M\+E\+L\+C\+A\+SE.


\begin{DoxyCode}
79                                                                            \{
80   \textcolor{keywordflow}{for} (uint64\_t j = HTTPHeaderCodeCommonOffset;
81        j < HTTPCommonHeaders::num\_header\_codes; ++j) \{
82     HTTPHeaderCode code = \textcolor{keyword}{static\_cast<}HTTPHeaderCode\textcolor{keyword}{>}(j);
83     EXPECT\_TRUE(
84       code ==
85       HTTPCommonHeaders::getHeaderCodeFromTableCommonHeaderName(
86         HTTPCommonHeaders::getPointerToHeaderName(code), TABLE_CAMELCASE));
87   \}
88   std::string externalHeader = \textcolor{stringliteral}{"externalHeader"};
89   EXPECT\_TRUE(HTTP_HEADER_OTHER ==
90     HTTPCommonHeaders::getHeaderCodeFromTableCommonHeaderName(
91       &externalHeader, TABLE_CAMELCASE));
92 \}
\end{DoxyCode}
