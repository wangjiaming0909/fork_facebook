\section{proxygen\+:\+:H\+T\+T\+P2\+Codec Class Reference}
\label{classproxygen_1_1HTTP2Codec}\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}


{\ttfamily \#include $<$H\+T\+T\+P2\+Codec.\+h$>$}

Inheritance diagram for proxygen\+:\+:H\+T\+T\+P2\+Codec\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=3.000000cm]{classproxygen_1_1HTTP2Codec}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
void {\bf on\+Header} (const folly\+::fbstring \&{\bf name}, const folly\+::fbstring \&value) override
\item 
void {\bf on\+Headers\+Complete} ({\bf H\+T\+T\+P\+Header\+Size} decoded\+Size, bool acknowledge) override
\item 
void {\bf on\+Decode\+Error} ({\bf H\+P\+A\+C\+K\+::\+Decode\+Error} decode\+Error) override
\item 
{\bf H\+T\+T\+P2\+Codec} ({\bf Transport\+Direction} direction)
\item 
{\bf $\sim$\+H\+T\+T\+P2\+Codec} () override
\item 
{\bf Codec\+Protocol} {\bf get\+Protocol} () const override
\item 
const std\+::string \& {\bf get\+User\+Agent} () const override
\item 
size\+\_\+t {\bf on\+Ingress} (const folly\+::\+I\+O\+Buf \&buf) override
\item 
bool {\bf on\+Ingress\+Upgrade\+Message} (const {\bf H\+T\+T\+P\+Message} \&msg) override
\item 
size\+\_\+t {\bf generate\+Connection\+Preface} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf) override
\item 
void {\bf generate\+Header} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} {\bf stream}, const {\bf H\+T\+T\+P\+Message} \&msg, bool eom=false, {\bf H\+T\+T\+P\+Header\+Size} $\ast$size={\bf nullptr}) override
\item 
void {\bf generate\+Continuation} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, folly\+::\+I\+O\+Buf\+Queue \&queue, {\bf Stream\+ID} {\bf stream}, size\+\_\+t max\+Frame\+Size)
\item 
void {\bf generate\+Push\+Promise} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} {\bf stream}, const {\bf H\+T\+T\+P\+Message} \&msg, {\bf Stream\+ID} assoc\+Stream, bool eom=false, {\bf H\+T\+T\+P\+Header\+Size} $\ast$size={\bf nullptr}) override
\item 
void {\bf generate\+Ex\+Header} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} {\bf stream}, const {\bf H\+T\+T\+P\+Message} \&msg, const {\bf H\+T\+T\+P\+Codec\+::\+Ex\+Attributes} \&ex\+Attributes, bool eom=false, {\bf H\+T\+T\+P\+Header\+Size} $\ast$size={\bf nullptr}) override
\item 
size\+\_\+t {\bf generate\+Body} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} {\bf stream}, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ chain, folly\+::\+Optional$<$ uint8\+\_\+t $>$ padding, bool eom) override
\item 
size\+\_\+t {\bf generate\+Chunk\+Header} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} {\bf stream}, size\+\_\+t length) override
\item 
size\+\_\+t {\bf generate\+Chunk\+Terminator} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} {\bf stream}) override
\item 
size\+\_\+t {\bf generate\+Trailers} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} {\bf stream}, const {\bf H\+T\+T\+P\+Headers} \&trailers) override
\item 
size\+\_\+t {\bf generate\+E\+OM} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} {\bf stream}) override
\item 
size\+\_\+t {\bf generate\+Rst\+Stream} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} {\bf stream}, {\bf Error\+Code} {\bf status\+Code}) override
\item 
size\+\_\+t {\bf generate\+Goaway} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} last\+Stream, {\bf Error\+Code} {\bf status\+Code}, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ debug\+Data={\bf nullptr}) override
\item 
size\+\_\+t {\bf generate\+Ping\+Request} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf) override
\item 
size\+\_\+t {\bf generate\+Ping\+Reply} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint64\+\_\+t unique\+ID) override
\item 
size\+\_\+t {\bf generate\+Settings} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf) override
\item 
size\+\_\+t {\bf generate\+Settings\+Ack} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf) override
\item 
size\+\_\+t {\bf generate\+Window\+Update} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} {\bf stream}, uint32\+\_\+t delta) override
\item 
size\+\_\+t {\bf generate\+Priority} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} {\bf stream}, const {\bf H\+T\+T\+P\+Message\+::\+H\+T\+T\+P\+Priority} \&pri) override
\item 
size\+\_\+t {\bf generate\+Certificate\+Request} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint16\+\_\+t request\+Id, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ certificate\+Request\+Data) override
\item 
size\+\_\+t {\bf generate\+Certificate} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint16\+\_\+t cert\+Id, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ cert\+Data) override
\item 
const {\bf H\+T\+T\+P\+Settings} $\ast$ {\bf get\+Ingress\+Settings} () const override
\item 
{\bf H\+T\+T\+P\+Settings} $\ast$ {\bf get\+Egress\+Settings} () override
\item 
uint32\+\_\+t {\bf get\+Default\+Window\+Size} () const override
\item 
bool {\bf supports\+Push\+Transactions} () const override
\item 
bool {\bf peer\+Has\+Websockets} () const 
\item 
bool {\bf supports\+Ex\+Transactions} () const override
\item 
void {\bf set\+Header\+Codec\+Stats} ({\bf Header\+Codec\+::\+Stats} $\ast$hc\+Stats) override
\item 
bool {\bf is\+Request} ({\bf Stream\+ID} id) const 
\item 
size\+\_\+t {\bf add\+Priority\+Nodes} ({\bf Priority\+Queue} \&queue, folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint8\+\_\+t max\+Level) override
\item 
{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} {\bf map\+Priority\+To\+Dependency} (uint8\+\_\+t priority) const override
\item 
{\bf Compression\+Info} {\bf get\+Compression\+Info} () const override
\item 
uint64\+\_\+t {\bf get\+Received\+Frame\+Count} () const 
\item 
void {\bf set\+Reuse\+I\+O\+Buf\+Headroom\+For\+Data} (bool enabled)
\item 
void {\bf set\+Header\+Indexing\+Strategy} (const {\bf Header\+Indexing\+Strategy} $\ast$indexing\+Strat)
\item 
const {\bf Header\+Indexing\+Strategy} $\ast$ {\bf get\+Header\+Indexing\+Strategy} () const 
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static void {\bf request\+Upgrade} ({\bf H\+T\+T\+P\+Message} \&request)
\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
enum {\bf Frame\+State} \{ \\*
{\bf U\+P\+S\+T\+R\+E\+A\+M\+\_\+\+C\+O\+N\+N\+E\+C\+T\+I\+O\+N\+\_\+\+P\+R\+E\+F\+A\+CE} = 0, 
{\bf D\+O\+W\+N\+S\+T\+R\+E\+A\+M\+\_\+\+C\+O\+N\+N\+E\+C\+T\+I\+O\+N\+\_\+\+P\+R\+E\+F\+A\+CE} = 1, 
{\bf F\+R\+A\+M\+E\+\_\+\+H\+E\+A\+D\+ER} = 2, 
{\bf F\+R\+A\+M\+E\+\_\+\+D\+A\+TA} = 3, 
\\*
{\bf D\+A\+T\+A\+\_\+\+F\+R\+A\+M\+E\+\_\+\+D\+A\+TA} = 4
 \}
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
void {\bf generate\+Header\+Impl} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} {\bf stream}, const {\bf H\+T\+T\+P\+Message} \&msg, const folly\+::\+Optional$<$ {\bf Stream\+ID} $>$ \&assoc\+Stream, const folly\+::\+Optional$<$ {\bf Ex\+Attributes} $>$ \&ex\+Attributes, bool eom, {\bf H\+T\+T\+P\+Header\+Size} $\ast$size)
\item 
std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ {\bf encode\+Headers} (const {\bf H\+T\+T\+P\+Headers} \&headers, std\+::vector$<$ {\bf compress\+::\+Header} $>$ \&all\+Headers, {\bf H\+T\+T\+P\+Header\+Size} $\ast$size)
\item 
size\+\_\+t {\bf generate\+Header\+Callback\+Wrapper} ({\bf Stream\+ID} {\bf stream}, {\bf http2\+::\+Frame\+Type} type, size\+\_\+t length)
\item 
{\bf Error\+Code} {\bf parse\+Frame} (folly\+::io\+::\+Cursor \&cursor)
\item 
{\bf Error\+Code} {\bf parse\+All\+Data} (folly\+::io\+::\+Cursor \&cursor)
\item 
{\bf Error\+Code} {\bf parse\+Data\+Frame\+Data} (folly\+::io\+::\+Cursor \&cursor, size\+\_\+t buf\+Len, size\+\_\+t \&parsed)
\item 
{\bf Error\+Code} {\bf parse\+Headers} (folly\+::io\+::\+Cursor \&cursor)
\item 
{\bf Error\+Code} {\bf parse\+Ex\+Headers} (folly\+::io\+::\+Cursor \&cursor)
\item 
{\bf Error\+Code} {\bf parse\+Priority} (folly\+::io\+::\+Cursor \&cursor)
\item 
{\bf Error\+Code} {\bf parse\+Rst\+Stream} (folly\+::io\+::\+Cursor \&cursor)
\item 
{\bf Error\+Code} {\bf parse\+Settings} (folly\+::io\+::\+Cursor \&cursor)
\item 
{\bf Error\+Code} {\bf parse\+Push\+Promise} (folly\+::io\+::\+Cursor \&cursor)
\item 
{\bf Error\+Code} {\bf parse\+Ping} (folly\+::io\+::\+Cursor \&cursor)
\item 
{\bf Error\+Code} {\bf parse\+Goaway} (folly\+::io\+::\+Cursor \&cursor)
\item 
{\bf Error\+Code} {\bf parse\+Continuation} (folly\+::io\+::\+Cursor \&cursor)
\item 
{\bf Error\+Code} {\bf parse\+Window\+Update} (folly\+::io\+::\+Cursor \&cursor)
\item 
{\bf Error\+Code} {\bf parse\+Certificate\+Request} (folly\+::io\+::\+Cursor \&cursor)
\item 
{\bf Error\+Code} {\bf parse\+Certificate} (folly\+::io\+::\+Cursor \&cursor)
\item 
{\bf Error\+Code} {\bf parse\+Headers\+Impl} (folly\+::io\+::\+Cursor \&cursor, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ header\+Buf, const folly\+::\+Optional$<$ {\bf http2\+::\+Priority\+Update} $>$ \&priority, const folly\+::\+Optional$<$ uint32\+\_\+t $>$ \&promised\+Stream, const folly\+::\+Optional$<$ {\bf Ex\+Attributes} $>$ \&ex\+Attributes)
\item 
folly\+::\+Optional$<$ {\bf Error\+Code} $>$ {\bf parse\+Headers\+Decode\+Frames} (const folly\+::\+Optional$<$ {\bf http2\+::\+Priority\+Update} $>$ \&priority, const folly\+::\+Optional$<$ uint32\+\_\+t $>$ \&promised\+Stream, const folly\+::\+Optional$<$ {\bf Ex\+Attributes} $>$ \&ex\+Attributes, std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Message} $>$ \&msg)
\item 
folly\+::\+Optional$<$ {\bf Error\+Code} $>$ {\bf parse\+Headers\+Check\+Concurrent\+Streams} (const folly\+::\+Optional$<$ {\bf http2\+::\+Priority\+Update} $>$ \&priority)
\item 
{\bf Error\+Code} {\bf handle\+End\+Stream} ()
\item 
{\bf Error\+Code} {\bf check\+New\+Stream} (uint32\+\_\+t {\bf stream}, bool trailers\+Allowed)
\item 
bool {\bf check\+Connection\+Error} ({\bf Error\+Code}, const folly\+::\+I\+O\+Buf $\ast$buf)
\item 
{\bf Error\+Code} {\bf handle\+Settings} (const std\+::deque$<$ {\bf Setting\+Pair} $>$ \&{\bf settings})
\item 
void {\bf handle\+Settings\+Ack} ()
\item 
size\+\_\+t {\bf max\+Send\+Frame\+Size} () const 
\item 
uint32\+\_\+t {\bf max\+Recv\+Frame\+Size} () const 
\item 
void {\bf stream\+Error} (const std\+::string \&msg, {\bf Error\+Code} error, bool new\+Txn=false)
\item 
bool {\bf parsing\+Trailers} () const 
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
{\bf H\+P\+A\+C\+K\+Codec} {\bf header\+Codec\+\_\+}
\item 
{\bf http2\+::\+Frame\+Header} {\bf cur\+Header\+\_\+}
\item 
{\bf Stream\+ID} {\bf expected\+Continuation\+Stream\+\_\+} \{0\}
\item 
bool {\bf pending\+End\+Stream\+Handling\+\_\+} \{false\}
\item 
bool {\bf ingress\+Websocket\+Upgrade\+\_\+} \{false\}
\item 
std\+::unordered\+\_\+set$<$ {\bf Stream\+ID} $>$ {\bf upgraded\+Streams\+\_\+}
\item 
uint16\+\_\+t {\bf cur\+Cert\+Id\+\_\+} \{0\}
\item 
folly\+::\+I\+O\+Buf\+Queue {\bf cur\+Authenticator\+Block\+\_\+}
\item 
folly\+::\+I\+O\+Buf\+Queue {\bf cur\+Header\+Block\+\_\+} \{folly\+::\+I\+O\+Buf\+Queue\+::cache\+Chain\+Length()\}
\item 
{\bf H\+T\+T\+P\+Settings} {\bf ingress\+Settings\+\_\+}
\item 
{\bf H\+T\+T\+P\+Settings} {\bf egress\+Settings\+\_\+}
\item 
uint64\+\_\+t {\bf received\+Frame\+Count\+\_\+} \{0\}
\item 
{\bf Frame\+State} {\bf frame\+State\+\_\+}\+:3
\item 
std\+::string {\bf user\+Agent\+\_\+}
\item 
size\+\_\+t {\bf pending\+Data\+Frame\+Bytes\+\_\+} \{0\}
\item 
size\+\_\+t {\bf pending\+Data\+Frame\+Padding\+Bytes\+\_\+} \{0\}
\item 
{\bf Header\+Decode\+Info} {\bf decode\+Info\+\_\+}
\item 
std\+::vector$<$ {\bf Stream\+ID} $>$ {\bf virtual\+Priority\+Nodes\+\_\+}
\item 
folly\+::\+Optional$<$ uint32\+\_\+t $>$ {\bf pending\+Table\+Max\+Size\+\_\+}
\item 
bool {\bf reuse\+I\+O\+Buf\+Headroom\+For\+Data\+\_\+} \{true\}
\item 
bool {\bf parsing\+Downstream\+Trailers\+\_\+} \{false\}
\item 
{\bf http2\+::\+Frame\+Type} {\bf header\+Block\+Frame\+Type\+\_\+} \{{\bf http2\+::\+Frame\+Type\+::\+D\+A\+TA}\}
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}
An implementation of the framing layer for H\+T\+T\+P/2. Instances of this class must not be used from multiple threads concurrently. 

Definition at line 29 of file H\+T\+T\+P2\+Codec.\+h.



\subsection{Member Enumeration Documentation}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!Frame\+State@{Frame\+State}}
\index{Frame\+State@{Frame\+State}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{Frame\+State}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+H\+T\+T\+P2\+Codec\+::\+Frame\+State}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a59c0ca628f83852a7de8a023327a1ff4}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{U\+P\+S\+T\+R\+E\+A\+M\+\_\+\+C\+O\+N\+N\+E\+C\+T\+I\+O\+N\+\_\+\+P\+R\+E\+F\+A\+CE@{U\+P\+S\+T\+R\+E\+A\+M\+\_\+\+C\+O\+N\+N\+E\+C\+T\+I\+O\+N\+\_\+\+P\+R\+E\+F\+A\+CE}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!U\+P\+S\+T\+R\+E\+A\+M\+\_\+\+C\+O\+N\+N\+E\+C\+T\+I\+O\+N\+\_\+\+P\+R\+E\+F\+A\+CE@{U\+P\+S\+T\+R\+E\+A\+M\+\_\+\+C\+O\+N\+N\+E\+C\+T\+I\+O\+N\+\_\+\+P\+R\+E\+F\+A\+CE}}\item[{\em 
U\+P\+S\+T\+R\+E\+A\+M\+\_\+\+C\+O\+N\+N\+E\+C\+T\+I\+O\+N\+\_\+\+P\+R\+E\+F\+A\+CE\label{classproxygen_1_1HTTP2Codec_a59c0ca628f83852a7de8a023327a1ff4a4a0729c8fd9839b0c7c384583ea14d2f}
}]\index{D\+O\+W\+N\+S\+T\+R\+E\+A\+M\+\_\+\+C\+O\+N\+N\+E\+C\+T\+I\+O\+N\+\_\+\+P\+R\+E\+F\+A\+CE@{D\+O\+W\+N\+S\+T\+R\+E\+A\+M\+\_\+\+C\+O\+N\+N\+E\+C\+T\+I\+O\+N\+\_\+\+P\+R\+E\+F\+A\+CE}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!D\+O\+W\+N\+S\+T\+R\+E\+A\+M\+\_\+\+C\+O\+N\+N\+E\+C\+T\+I\+O\+N\+\_\+\+P\+R\+E\+F\+A\+CE@{D\+O\+W\+N\+S\+T\+R\+E\+A\+M\+\_\+\+C\+O\+N\+N\+E\+C\+T\+I\+O\+N\+\_\+\+P\+R\+E\+F\+A\+CE}}\item[{\em 
D\+O\+W\+N\+S\+T\+R\+E\+A\+M\+\_\+\+C\+O\+N\+N\+E\+C\+T\+I\+O\+N\+\_\+\+P\+R\+E\+F\+A\+CE\label{classproxygen_1_1HTTP2Codec_a59c0ca628f83852a7de8a023327a1ff4a75a806aefba029c423a53496c10f86fc}
}]\index{F\+R\+A\+M\+E\+\_\+\+H\+E\+A\+D\+ER@{F\+R\+A\+M\+E\+\_\+\+H\+E\+A\+D\+ER}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!F\+R\+A\+M\+E\+\_\+\+H\+E\+A\+D\+ER@{F\+R\+A\+M\+E\+\_\+\+H\+E\+A\+D\+ER}}\item[{\em 
F\+R\+A\+M\+E\+\_\+\+H\+E\+A\+D\+ER\label{classproxygen_1_1HTTP2Codec_a59c0ca628f83852a7de8a023327a1ff4a5591b4d1979debac72e4bb3e36d95922}
}]\index{F\+R\+A\+M\+E\+\_\+\+D\+A\+TA@{F\+R\+A\+M\+E\+\_\+\+D\+A\+TA}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!F\+R\+A\+M\+E\+\_\+\+D\+A\+TA@{F\+R\+A\+M\+E\+\_\+\+D\+A\+TA}}\item[{\em 
F\+R\+A\+M\+E\+\_\+\+D\+A\+TA\label{classproxygen_1_1HTTP2Codec_a59c0ca628f83852a7de8a023327a1ff4a382f1b09e7bc39c451955be7e8080b7e}
}]\index{D\+A\+T\+A\+\_\+\+F\+R\+A\+M\+E\+\_\+\+D\+A\+TA@{D\+A\+T\+A\+\_\+\+F\+R\+A\+M\+E\+\_\+\+D\+A\+TA}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!D\+A\+T\+A\+\_\+\+F\+R\+A\+M\+E\+\_\+\+D\+A\+TA@{D\+A\+T\+A\+\_\+\+F\+R\+A\+M\+E\+\_\+\+D\+A\+TA}}\item[{\em 
D\+A\+T\+A\+\_\+\+F\+R\+A\+M\+E\+\_\+\+D\+A\+TA\label{classproxygen_1_1HTTP2Codec_a59c0ca628f83852a7de8a023327a1ff4a355bc2fd0cf71575448a3e45d96f9f1e}
}]\end{description}
\end{Desc}


Definition at line 270 of file H\+T\+T\+P2\+Codec.\+h.


\begin{DoxyCode}
270                   \{
271     UPSTREAM_CONNECTION_PREFACE = 0,
272     DOWNSTREAM_CONNECTION_PREFACE = 1,
273     FRAME_HEADER = 2,
274     FRAME_DATA = 3,
275     DATA_FRAME_DATA = 4,
276   \};
\end{DoxyCode}


\subsection{Constructor \& Destructor Documentation}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!H\+T\+T\+P2\+Codec@{H\+T\+T\+P2\+Codec}}
\index{H\+T\+T\+P2\+Codec@{H\+T\+T\+P2\+Codec}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{H\+T\+T\+P2\+Codec(\+Transport\+Direction direction)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+H\+T\+T\+P2\+Codec\+::\+H\+T\+T\+P2\+Codec (
\begin{DoxyParamCaption}
\item[{{\bf Transport\+Direction}}]{direction}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [explicit]}}\label{classproxygen_1_1HTTP2Codec_a9fce583096ab928db8aafb5b9c970579}


Definition at line 43 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, egress\+Settings\+\_\+, proxygen\+::\+H\+T\+T\+P\+Settings\+::get\+Setting(), proxygen\+::get\+Transport\+Direction\+String(), header\+Codec\+\_\+, proxygen\+::\+M\+A\+X\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+L\+I\+S\+T\+\_\+\+S\+I\+ZE, and proxygen\+::\+H\+P\+A\+C\+K\+Codec\+::set\+Max\+Uncompressed().



Referenced by request\+Upgrade().


\begin{DoxyCode}
44     : HTTPParallelCodec(direction),
45       headerCodec_(direction),
46       frameState_(direction == TransportDirection::DOWNSTREAM
47                   ? FrameState::UPSTREAM\_CONNECTION\_PREFACE
48                   : FrameState::DOWNSTREAM\_CONNECTION\_PREFACE) \{
49 
50   \textcolor{keyword}{const} \textcolor{keyword}{auto} maxHeaderListSize = egressSettings_.getSetting(
51     SettingsId::MAX_HEADER_LIST_SIZE);
52   \textcolor{keywordflow}{if} (maxHeaderListSize) \{
53     headerCodec_.setMaxUncompressed(maxHeaderListSize->value);
54   \}
55 
56   VLOG(4) << \textcolor{stringliteral}{"creating "} << getTransportDirectionString(direction)
57           << \textcolor{stringliteral}{" HTTP/2 codec"};
58 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!````~H\+T\+T\+P2\+Codec@{$\sim$\+H\+T\+T\+P2\+Codec}}
\index{````~H\+T\+T\+P2\+Codec@{$\sim$\+H\+T\+T\+P2\+Codec}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{$\sim$\+H\+T\+T\+P2\+Codec() override}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+H\+T\+T\+P2\+Codec\+::$\sim$\+H\+T\+T\+P2\+Codec (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}}\label{classproxygen_1_1HTTP2Codec_a916eed1f924cdf1dd55f5a54e72a59ec}


Definition at line 60 of file H\+T\+T\+P2\+Codec.\+cpp.


\begin{DoxyCode}
60 \{\}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!add\+Priority\+Nodes@{add\+Priority\+Nodes}}
\index{add\+Priority\+Nodes@{add\+Priority\+Nodes}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{add\+Priority\+Nodes(\+Priority\+Queue \&queue, folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint8\+\_\+t max\+Level) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::add\+Priority\+Nodes (
\begin{DoxyParamCaption}
\item[{{\bf Priority\+Queue} \&}]{, }
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{, }
\item[{uint8\+\_\+t}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_af826e3b58baaa1e267adf09495b71a0d}
Create virtual nodes in H\+T\+T\+P/2 priority tree. Some protocols (S\+P\+DY) have a linear priority structure which must be simulated in the H\+T\+T\+P/2 tree structure with \char`\"{}virtual\char`\"{} nodes representing different priority bands. There are other cases we simply want a \char`\"{}plain\char`\"{} linear priority structure even with H\+T\+T\+P/2. In that case a Priority frame will also be sent out for each virtual node created so that peer will have the same linear structure.


\begin{DoxyParams}{Parameters}
{\em queue} & the priority queue to add nodes \\
\hline
{\em write\+Buf} & I\+O\+Buf\+Queue to append priority frames to send. For S\+P\+DY, the write\+Buf will be ignored. \\
\hline
{\em max\+Lavel} & the max level of virtual priority nodes to create. For S\+P\+DY, this value will be ignored. \\
\hline
\end{DoxyParams}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a5735debb82295d27f6d8491ab07e9b4f}.



Definition at line 667 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Priority\+Queue\+::add\+Priority\+Node(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::create\+Stream(), generate\+Priority(), and virtual\+Priority\+Nodes\+\_\+.



Referenced by is\+Request().


\begin{DoxyCode}
670                       \{
671   HTTPCodec::StreamID parent = 0;
672   \textcolor{keywordtype}{size\_t} bytes = 0;
673   \textcolor{keywordflow}{while} (maxLevel--) \{
674     \textcolor{keyword}{auto} \textcolor{keywordtype}{id} = createStream();
675     virtualPriorityNodes_.push\_back(\textcolor{keywordtype}{id});
676     queue.addPriorityNode(\textcolor{keywordtype}{id}, parent);
677     bytes += generatePriority(writeBuf, \textcolor{keywordtype}{id}, std::make\_tuple(parent, \textcolor{keyword}{false}, 0));
678     parent = id;
679   \}
680   \textcolor{keywordflow}{return} bytes;
681 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!check\+Connection\+Error@{check\+Connection\+Error}}
\index{check\+Connection\+Error@{check\+Connection\+Error}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{check\+Connection\+Error(\+Error\+Code, const folly\+::\+I\+O\+Buf $\ast$buf)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P2\+Codec\+::check\+Connection\+Error (
\begin{DoxyParamCaption}
\item[{{\bf Error\+Code}}]{err, }
\item[{const folly\+::\+I\+O\+Buf $\ast$}]{buf}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a25d4c42889b243cdf223c77996fccae4}


Definition at line 1614 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::callback\+\_\+, proxygen\+::\+E\+R\+R\+OR, proxygen\+::get\+Error\+Code\+String(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::goaway\+Error\+Message\+\_\+, proxygen\+::\+H\+T\+T\+P\+Exception\+::\+I\+N\+G\+R\+E\+S\+S\+\_\+\+A\+N\+D\+\_\+\+E\+G\+R\+E\+SS, proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Error(), proxygen\+::\+I\+O\+Buf\+Printer\+::print\+Hex\+Folly(), and proxygen\+::\+H\+T\+T\+P\+Exception\+::set\+Codec\+Status\+Code().



Referenced by get\+Header\+Indexing\+Strategy(), and on\+Ingress().


\begin{DoxyCode}
1614                                                                           \{
1615   \textcolor{keywordflow}{if} (err != ErrorCode::NO_ERROR) \{
1616     LOG(ERROR) << \textcolor{stringliteral}{"Connection error "} << getErrorCodeString(err)
1617                << \textcolor{stringliteral}{" with ingress="};
1618     VLOG(3) << IOBufPrinter::printHexFolly(buf, \textcolor{keyword}{true});
1619     \textcolor{keywordflow}{if} (callback_) \{
1620       std::string errorDescription = goawayErrorMessage_.empty() ?
1621         \textcolor{stringliteral}{"Connection error"} : goawayErrorMessage_;
1622       HTTPException ex(HTTPException::Direction::INGRESS_AND_EGRESS,
1623                        errorDescription);
1624       ex.setCodecStatusCode(err);
1625       callback_->onError(0, ex, \textcolor{keyword}{false});
1626     \}
1627     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1628   \}
1629   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1630 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!check\+New\+Stream@{check\+New\+Stream}}
\index{check\+New\+Stream@{check\+New\+Stream}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{check\+New\+Stream(uint32\+\_\+t stream, bool trailers\+Allowed)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::\+H\+T\+T\+P2\+Codec\+::check\+New\+Stream (
\begin{DoxyParamCaption}
\item[{uint32\+\_\+t}]{stream, }
\item[{bool}]{trailers\+Allowed}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_ae4a7e306771675a8e7cad071254be83b}


Definition at line 977 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::goaway\+Error\+Message\+\_\+, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::is\+Initiated\+Stream(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::last\+Stream\+I\+D\+\_\+, proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, parsing\+Downstream\+Trailers\+\_\+, proxygen\+::\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, and proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::session\+Closing\+\_\+.



Referenced by get\+Header\+Indexing\+Strategy(), parse\+Ex\+Headers(), parse\+Headers(), and parse\+Push\+Promise().


\begin{DoxyCode}
977                                                                             \{
978   \textcolor{keywordtype}{bool} existingStream = (streamId <= lastStreamID_);
979   \textcolor{keywordflow}{if} (streamId == 0 || (!trailersAllowed && existingStream)) \{
980     goawayErrorMessage_ = folly::to<string>(
981         \textcolor{stringliteral}{"GOAWAY error: received streamID="}, streamId,
982         \textcolor{stringliteral}{" as invalid new stream for lastStreamID\_="}, lastStreamID_);
983     VLOG(4) << goawayErrorMessage_;
984     \textcolor{keywordflow}{return} ErrorCode::PROTOCOL_ERROR;
985   \}
986   parsingDownstreamTrailers_ = trailersAllowed && existingStream;
987   \textcolor{keywordflow}{if} (parsingDownstreamTrailers_) \{
988     VLOG(4) << \textcolor{stringliteral}{"Parsing downstream trailers streamId="} << streamId;
989   \}
990 
991   \textcolor{keywordflow}{if} (sessionClosing_ != ClosingState::CLOSED && !existingStream) \{
992     lastStreamID_ = streamId;
993   \}
994 
995   \textcolor{keywordflow}{if} (isInitiatedStream(streamId)) \{
996     \textcolor{comment}{// this stream should be initiated by us, not by peer}
997     goawayErrorMessage_ = folly::to<string>(
998         \textcolor{stringliteral}{"GOAWAY error: invalid new stream received with streamID="}, streamId);
999     VLOG(4) << goawayErrorMessage_;
1000     \textcolor{keywordflow}{return} ErrorCode::PROTOCOL_ERROR;
1001   \} \textcolor{keywordflow}{else} \{
1002     \textcolor{keywordflow}{return} ErrorCode::NO_ERROR;
1003   \}
1004 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!encode\+Headers@{encode\+Headers}}
\index{encode\+Headers@{encode\+Headers}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{encode\+Headers(const H\+T\+T\+P\+Headers \&headers, std\+::vector$<$ compress\+::\+Header $>$ \&all\+Headers, H\+T\+T\+P\+Header\+Size $\ast$size)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ proxygen\+::\+H\+T\+T\+P2\+Codec\+::encode\+Headers (
\begin{DoxyParamCaption}
\item[{const {\bf H\+T\+T\+P\+Headers} \&}]{headers, }
\item[{std\+::vector$<$ {\bf compress\+::\+Header} $>$ \&}]{all\+Headers, }
\item[{{\bf H\+T\+T\+P\+Header\+Size} $\ast$}]{size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a4938347e7283b53ce7a82e771943a067}


Definition at line 1222 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+H\+P\+A\+C\+K\+Codec\+::encode(), proxygen\+::\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Headers\+::for\+Each(), proxygen\+::\+Header\+Codec\+::get\+Encoded\+Size(), proxygen\+::\+H\+T\+T\+P\+Settings\+::get\+Setting(), header\+Codec\+\_\+, ingress\+Settings\+\_\+, proxygen\+::http2\+::k\+Frame\+Headers\+Base\+Max\+Size, proxygen\+::http2\+::k\+Frame\+Header\+Size, proxygen\+::\+M\+A\+X\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+L\+I\+S\+T\+\_\+\+S\+I\+ZE, name, proxygen\+::\+Header\+Codec\+::set\+Encode\+Headroom(), and proxygen\+::\+H\+T\+T\+P\+Headers\+::size().



Referenced by generate\+Header\+Impl(), generate\+Trailers(), and get\+Header\+Indexing\+Strategy().


\begin{DoxyCode}
1225                           \{
1226   headerCodec_.setEncodeHeadroom(http2::kFrameHeaderSize +
1227                                  http2::kFrameHeadersBaseMaxSize);
1228   \textcolor{keyword}{auto} out = headerCodec_.encode(allHeaders);
1229   \textcolor{keywordflow}{if} (size) \{
1230     *size = headerCodec_.getEncodedSize();
1231   \}
1232 
1233   \textcolor{keywordflow}{if} (headerCodec_.getEncodedSize().uncompressed >
1234       ingressSettings_.getSetting(SettingsId::MAX_HEADER_LIST_SIZE,
1235                                   std::numeric\_limits<uint32\_t>::max())) \{
1236     \textcolor{comment}{// The remote side told us they don't want headers this large...}
1237     \textcolor{comment}{// but this function has no mechanism to fail}
1238     \textcolor{keywordtype}{string} serializedHeaders;
1239     headers.forEach(
1240       [&serializedHeaders] (\textcolor{keyword}{const} \textcolor{keywordtype}{string}& name, \textcolor{keyword}{const} \textcolor{keywordtype}{string}& value) \{
1241         serializedHeaders = folly::to<string>(serializedHeaders, \textcolor{stringliteral}{"\(\backslash\)\(\backslash\)n"}, name,
1242                                               \textcolor{stringliteral}{":"}, value);
1243       \});
1244     LOG(ERROR) << \textcolor{stringliteral}{"generating HEADERS frame larger than peer maximum nHeaders="}
1245                << headers.size() << \textcolor{stringliteral}{" all headers="}
1246                << serializedHeaders;
1247   \}
1248   \textcolor{keywordflow}{return} out;
1249 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!generate\+Body@{generate\+Body}}
\index{generate\+Body@{generate\+Body}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{generate\+Body(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D stream, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ chain, folly\+::\+Optional$<$ uint8\+\_\+t $>$ padding, bool eom) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Body (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{chain, }
\item[{folly\+::\+Optional$<$ uint8\+\_\+t $>$}]{padding, }
\item[{bool}]{eom}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_a0aab7de59125bb9d5c65bd28fa24cc87}
Write part of an egress message body.

This will automatically generate a chunk header and footer around the data if necessary (e.\+g. you haven\textquotesingle{}t manually sent a chunk header and the message should be chunked).


\begin{DoxyParams}{Parameters}
{\em padding} & Optionally add padding bytes to the body if possible \\
\hline
{\em eom} & implicitly generate the E\+OM marker with this body frame\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of bytes written 
\end{DoxyReturn}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_ad914e07a10cf00dc93e9cb9e0c0205b3}.



Definition at line 1262 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::http2\+::\+D\+A\+TA, generate\+Header\+Callback\+Wrapper(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::ingress\+Goaway\+Ack\+\_\+, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::is\+Stream\+Ingress\+Egress\+Allowed(), max\+Send\+Frame\+Size(), reuse\+I\+O\+Buf\+Headroom\+For\+Data\+\_\+, and proxygen\+::http2\+::write\+Data().



Referenced by get\+User\+Agent().


\begin{DoxyCode}
1266                                           \{
1267   \textcolor{comment}{// todo: generate random padding for everything?}
1268   \textcolor{keywordtype}{size\_t} written = 0;
1269   \textcolor{keywordflow}{if} (!isStreamIngressEgressAllowed(stream)) \{
1270     VLOG(2) << \textcolor{stringliteral}{"Suppressing DATA for stream="} << stream << \textcolor{stringliteral}{" ingressGoawayAck\_="}
1271             << ingressGoawayAck_;
1272     \textcolor{keywordflow}{return} 0;
1273   \}
1274   IOBufQueue queue(IOBufQueue::cacheChainLength());
1275   queue.append(std::move(chain));
1276   \textcolor{keywordtype}{size\_t} maxFrameSize = maxSendFrameSize();
1277   \textcolor{keywordflow}{while} (queue.chainLength() > maxFrameSize) \{
1278     \textcolor{keyword}{auto} chunk = queue.split(maxFrameSize);
1279     written += generateHeaderCallbackWrapper(
1280                   stream,
1281                   http2::FrameType::DATA,
1282                   http2::writeData(writeBuf,
1283                                    std::move(chunk),
1284                                    stream,
1285                                    padding,
1286                                    \textcolor{keyword}{false},
1287                                    reuseIOBufHeadroomForData_));
1288   \}
1289 
1290   \textcolor{keywordflow}{return} written + generateHeaderCallbackWrapper(
1291                       stream,
1292                       http2::FrameType::DATA,
1293                       http2::writeData(writeBuf,
1294                                        queue.move(),
1295                                        stream,
1296                                        padding,
1297                                        eom,
1298                                        reuseIOBufHeadroomForData_));
1299 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!generate\+Certificate@{generate\+Certificate}}
\index{generate\+Certificate@{generate\+Certificate}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{generate\+Certificate(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint16\+\_\+t cert\+Id, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ cert\+Data) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Certificate (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{uint16\+\_\+t}]{cert\+Id, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{cert\+Data}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_a6ac031f1cfff574c1651bc519ac8c3c3}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a42e1829f46f87baab24becc3ec93b0c8}.



Definition at line 1595 of file H\+T\+T\+P2\+Codec.\+cpp.



References max\+Send\+Frame\+Size(), and proxygen\+::http2\+::write\+Certificate().



Referenced by get\+User\+Agent().


\begin{DoxyCode}
1597                                                                            \{
1598   \textcolor{keywordtype}{size\_t} written = 0;
1599   VLOG(4) << \textcolor{stringliteral}{"sending CERTIFICATE with Cert-ID="} << certId << \textcolor{stringliteral}{"for stream=0"};
1600   IOBufQueue queue(IOBufQueue::cacheChainLength());
1601   queue.append(std::move(certData));
1602   \textcolor{comment}{// The maximum size of an autenticator fragment, combined with the Cert-ID can}
1603   \textcolor{comment}{// not exceed the maximal allowable size of a sent frame.}
1604   \textcolor{keywordtype}{size\_t} maxChunkSize = maxSendFrameSize() - \textcolor{keyword}{sizeof}(certId);
1605   \textcolor{keywordflow}{while} (queue.chainLength() > maxChunkSize) \{
1606     \textcolor{keyword}{auto} chunk = queue.splitAtMost(maxChunkSize);
1607     written +=
1608         http2::writeCertificate(writeBuf, certId, std::move(chunk), \textcolor{keyword}{true});
1609   \}
1610   \textcolor{keywordflow}{return} written +
1611          http2::writeCertificate(writeBuf, certId, queue.move(), \textcolor{keyword}{false});
1612 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!generate\+Certificate\+Request@{generate\+Certificate\+Request}}
\index{generate\+Certificate\+Request@{generate\+Certificate\+Request}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{generate\+Certificate\+Request(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint16\+\_\+t request\+Id, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ certificate\+Request\+Data) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Certificate\+Request (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{uint16\+\_\+t}]{request\+Id, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{certificate\+Request\+Data}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_aefb364c906dcc3bd2f5a8a4b7be47d57}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a8a77434d064a55376acef338e068ef86}.



Definition at line 1586 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::http2\+::write\+Certificate\+Request().



Referenced by get\+User\+Agent().


\begin{DoxyCode}
1589                                                       \{
1590   VLOG(4) << \textcolor{stringliteral}{"generating CERTIFICATE\_REQUEST with Request-ID="} << requestId;
1591   \textcolor{keywordflow}{return} http2::writeCertificateRequest(
1592       writeBuf, requestId, std::move(certificateRequestData));
1593 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!generate\+Chunk\+Header@{generate\+Chunk\+Header}}
\index{generate\+Chunk\+Header@{generate\+Chunk\+Header}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{generate\+Chunk\+Header(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D stream, size\+\_\+t length) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Chunk\+Header (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream, }
\item[{size\+\_\+t}]{length}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_a90ba68990b14c2c31c2d6b99c29c9861}
Write a body chunk header, if relevant. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a10a3cf44e3748bddd22d260a028c152c}.



Definition at line 1301 of file H\+T\+T\+P2\+Codec.\+cpp.



Referenced by get\+User\+Agent().


\begin{DoxyCode}
1303                                                  \{
1304   \textcolor{comment}{// HTTP/2 has no chunk headers}
1305   \textcolor{keywordflow}{return} 0;
1306 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!generate\+Chunk\+Terminator@{generate\+Chunk\+Terminator}}
\index{generate\+Chunk\+Terminator@{generate\+Chunk\+Terminator}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{generate\+Chunk\+Terminator(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D stream) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Chunk\+Terminator (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_ae2e22718e225a1a5398f9eb79001da26}
Write a body chunk terminator, if relevant. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a6e20271ad023252b6fa877d95b413f26}.



Definition at line 1308 of file H\+T\+T\+P2\+Codec.\+cpp.



Referenced by get\+User\+Agent().


\begin{DoxyCode}
1309                                                        \{
1310   \textcolor{comment}{// HTTP/2 has no chunk terminators}
1311   \textcolor{keywordflow}{return} 0;
1312 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!generate\+Connection\+Preface@{generate\+Connection\+Preface}}
\index{generate\+Connection\+Preface@{generate\+Connection\+Preface}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{generate\+Connection\+Preface(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Connection\+Preface (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_ae2d0802691534045f105980dc27553c1}
Generate a connection preface, if there is any for this protocol.

\begin{DoxyReturn}{Returns}
size of the generated message 
\end{DoxyReturn}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a6ae912c73dd75b2d3fb992c458809096}.



Definition at line 1006 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::http2\+::k\+Connection\+Preface, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::transport\+Direction\+\_\+, and proxygen\+::\+U\+P\+S\+T\+R\+E\+AM.



Referenced by get\+User\+Agent().


\begin{DoxyCode}
1006                                                                       \{
1007   \textcolor{keywordflow}{if} (transportDirection_ == TransportDirection::UPSTREAM) \{
1008     VLOG(4) << \textcolor{stringliteral}{"generating connection preface"};
1009     writeBuf.append(http2::kConnectionPreface);
1010     \textcolor{keywordflow}{return} http2::kConnectionPreface.length();
1011   \}
1012   \textcolor{keywordflow}{return} 0;
1013 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!generate\+Continuation@{generate\+Continuation}}
\index{generate\+Continuation@{generate\+Continuation}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{generate\+Continuation(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, folly\+::\+I\+O\+Buf\+Queue \&queue, Stream\+I\+D stream, size\+\_\+t max\+Frame\+Size)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Continuation (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{queue, }
\item[{{\bf Stream\+ID}}]{stream, }
\item[{size\+\_\+t}]{max\+Frame\+Size}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTP2Codec_a9790eaed5113c521aa5f56b48ab56838}


Definition at line 1205 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::http2\+::\+C\+O\+N\+T\+I\+N\+U\+A\+T\+I\+ON, generate\+Header\+Callback\+Wrapper(), and proxygen\+::http2\+::write\+Continuation().



Referenced by generate\+Header\+Impl(), generate\+Trailers(), and get\+User\+Agent().


\begin{DoxyCode}
1208                                                            \{
1209   \textcolor{keywordtype}{bool} endHeaders = \textcolor{keyword}{false};
1210   \textcolor{keywordflow}{while} (!endHeaders) \{
1211     \textcolor{keyword}{auto} chunk = queue.split(std::min(maxFrameSize, queue.chainLength()));
1212     endHeaders = (queue.chainLength() == 0);
1213     VLOG(4) << \textcolor{stringliteral}{"generating CONTINUATION for stream="} << stream;
1214     generateHeaderCallbackWrapper(
1215         stream,
1216         http2::FrameType::CONTINUATION,
1217         http2::writeContinuation(
1218             writeBuf, stream, endHeaders, std::move(chunk)));
1219   \}
1220 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!generate\+E\+OM@{generate\+E\+OM}}
\index{generate\+E\+OM@{generate\+E\+OM}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{generate\+E\+O\+M(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D stream) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+E\+OM (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_a88e055d63bcc12dd31d0b82042a2e5bc}
Generate any protocol framing needed to finalize an egress message. This method must be called to complete a stream.

\begin{DoxyReturn}{Returns}
number of bytes written 
\end{DoxyReturn}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_aefa134de8aff8e9000092a9996546bd5}.



Definition at line 1350 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::http2\+::\+D\+A\+TA, generate\+Header\+Callback\+Wrapper(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::ingress\+Goaway\+Ack\+\_\+, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::is\+Stream\+Ingress\+Egress\+Allowed(), proxygen\+::http2\+::k\+No\+Padding, reuse\+I\+O\+Buf\+Headroom\+For\+Data\+\_\+, upgraded\+Streams\+\_\+, and proxygen\+::http2\+::write\+Data().



Referenced by get\+User\+Agent().


\begin{DoxyCode}
1351                                                 \{
1352   VLOG(4) << \textcolor{stringliteral}{"sending EOM for stream="} << stream;
1353   upgradedStreams_.erase(stream);
1354   \textcolor{keywordflow}{if} (!isStreamIngressEgressAllowed(stream)) \{
1355     VLOG(2) << \textcolor{stringliteral}{"suppressed EOM for stream="} << stream << \textcolor{stringliteral}{" ingressGoawayAck\_="}
1356             << ingressGoawayAck_;
1357     \textcolor{keywordflow}{return} 0;
1358   \}
1359   \textcolor{keywordflow}{return} generateHeaderCallbackWrapper(
1360             stream,
1361             http2::FrameType::DATA,
1362             http2::writeData(writeBuf,
1363                              \textcolor{keyword}{nullptr},
1364                              stream,
1365                              http2::kNoPadding,
1366                              \textcolor{keyword}{true},
1367                              reuseIOBufHeadroomForData_));
1368 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!generate\+Ex\+Header@{generate\+Ex\+Header}}
\index{generate\+Ex\+Header@{generate\+Ex\+Header}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{generate\+Ex\+Header(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D stream, const H\+T\+T\+P\+Message \&msg, const H\+T\+T\+P\+Codec\+::\+Ex\+Attributes \&ex\+Attributes, bool eom=false, H\+T\+T\+P\+Header\+Size $\ast$size=nullptr) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Ex\+Header (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream, }
\item[{const {\bf H\+T\+T\+P\+Message} \&}]{msg, }
\item[{const {\bf H\+T\+T\+P\+Codec\+::\+Ex\+Attributes} \&}]{ex\+Attributes, }
\item[{bool}]{eom = {\ttfamily false}, }
\item[{{\bf H\+T\+T\+P\+Header\+Size} $\ast$}]{size = {\ttfamily {\bf nullptr}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_af1a4edfd68b99b4efb875af6bc423f8c}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_af7c397a651c7e848fdef4015f6d166d3}.



Definition at line 1089 of file H\+T\+T\+P2\+Codec.\+cpp.



References generate\+Header\+Impl().



Referenced by get\+User\+Agent().


\begin{DoxyCode}
1094                                                         \{
1095   generateHeaderImpl(writeBuf,
1096                      stream,
1097                      msg,
1098                      folly::none, \textcolor{comment}{/* assocStream */}
1099                      exAttributes,
1100                      eom,
1101                      size);
1102 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!generate\+Goaway@{generate\+Goaway}}
\index{generate\+Goaway@{generate\+Goaway}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{generate\+Goaway(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D last\+Stream, Error\+Code status\+Code, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ debug\+Data=nullptr) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Goaway (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{last\+Stream, }
\item[{{\bf Error\+Code}}]{code, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{debug\+Data = {\ttfamily {\bf nullptr}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_a18fe5580e3cc76ecd054eac770b56eea}
Generate any protocol framing needed to abort a connection. \begin{DoxyReturn}{Returns}
number of bytes written 
\end{DoxyReturn}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a22dec1b6d4dde73ea7380a28b937e545}.



Definition at line 1397 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::egress\+Goaway\+Ack\+\_\+, proxygen\+::http2\+::error\+Code\+To\+Goaway(), generate\+Header\+Callback\+Wrapper(), proxygen\+::get\+Error\+Code\+String(), proxygen\+::http2\+::\+G\+O\+A\+W\+AY, proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, proxygen\+::\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::session\+Closing\+\_\+, user\+Agent\+\_\+, and proxygen\+::http2\+::write\+Goaway().



Referenced by get\+User\+Agent().


\begin{DoxyCode}
1400                                                                        \{
1401   DCHECK\_LE(lastStream, egressGoawayAck_) << \textcolor{stringliteral}{"Cannot increase last good stream"};
1402   egressGoawayAck_ = lastStream;
1403   \textcolor{keywordflow}{if} (sessionClosing_ == ClosingState::CLOSED) \{
1404     VLOG(4) << \textcolor{stringliteral}{"Not sending GOAWAY for closed session"};
1405     \textcolor{keywordflow}{return} 0;
1406   \}
1407   \textcolor{keywordflow}{switch} (sessionClosing_) \{
1408     \textcolor{keywordflow}{case} ClosingState::OPEN:
1409     \textcolor{keywordflow}{case} ClosingState::OPEN\_WITH\_GRACEFUL\_DRAIN\_ENABLED:
1410       \textcolor{keywordflow}{if} (lastStream == std::numeric\_limits<int32\_t>::max() &&
1411           statusCode == ErrorCode::NO_ERROR) \{
1412         sessionClosing_ = ClosingState::FIRST\_GOAWAY\_SENT;
1413       \} \textcolor{keywordflow}{else} \{
1414         \textcolor{comment}{// The user of this codec decided not to do the double goaway}
1415         \textcolor{comment}{// drain, or this is not a graceful shutdown}
1416         sessionClosing_ = ClosingState::CLOSED;
1417       \}
1418       \textcolor{keywordflow}{break};
1419     \textcolor{keywordflow}{case} ClosingState::FIRST\_GOAWAY\_SENT:
1420       sessionClosing_ = ClosingState::CLOSED;
1421       \textcolor{keywordflow}{break};
1422     \textcolor{keywordflow}{case} ClosingState::CLOSING:
1423     \textcolor{keywordflow}{case} ClosingState::CLOSED:
1424       LOG(FATAL) << \textcolor{stringliteral}{"unreachable"};
1425   \}
1426 
1427   VLOG(4) << \textcolor{stringliteral}{"Sending GOAWAY with last acknowledged stream="}
1428           << lastStream << \textcolor{stringliteral}{" with code="} << getErrorCodeString(statusCode);
1429   \textcolor{keywordflow}{if} (statusCode == ErrorCode::PROTOCOL_ERROR) \{
1430     VLOG(2) << \textcolor{stringliteral}{"sending GOAWAY with last acknowledged stream="} << lastStream
1431             << \textcolor{stringliteral}{" with code="} << getErrorCodeString(statusCode)
1432             << \textcolor{stringliteral}{" user-agent="} << userAgent_;
1433   \}
1434 
1435   \textcolor{keyword}{auto} code = http2::errorCodeToGoaway(statusCode);
1436   \textcolor{keywordflow}{return} generateHeaderCallbackWrapper(
1437             0,
1438             http2::FrameType::GOAWAY,
1439             http2::writeGoaway(writeBuf,
1440                               lastStream,
1441                               code,
1442                               std::move(debugData)));
1443 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!generate\+Header@{generate\+Header}}
\index{generate\+Header@{generate\+Header}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{generate\+Header(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D stream, const H\+T\+T\+P\+Message \&msg, bool eom=false, H\+T\+T\+P\+Header\+Size $\ast$size=nullptr) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Header (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream, }
\item[{const {\bf H\+T\+T\+P\+Message} \&}]{msg, }
\item[{bool}]{eom = {\ttfamily false}, }
\item[{{\bf H\+T\+T\+P\+Header\+Size} $\ast$}]{size = {\ttfamily {\bf nullptr}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_a75debbfbc334f645dd4ce097d00141cc}
Write an egress message header. For pushed streams, you must specify the assoc\+Stream. 
\begin{DoxyRetVals}{Return values}
{\em size} & the size of the generated message, both the actual size and the size of the uncompressed data. \\
\hline
\end{DoxyRetVals}
\begin{DoxyReturn}{Returns}
None 
\end{DoxyReturn}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a572e25a01e0d36bb527db2dc39ca26b3}.



Definition at line 1060 of file H\+T\+T\+P2\+Codec.\+cpp.



References generate\+Header\+Impl().



Referenced by get\+User\+Agent().


\begin{DoxyCode}
1064                                                       \{
1065   generateHeaderImpl(writeBuf,
1066                      stream,
1067                      msg,
1068                      folly::none, \textcolor{comment}{/* assocStream */}
1069                      folly::none, \textcolor{comment}{/* controlStream */}
1070                      eom,
1071                      size);
1072 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!generate\+Header\+Callback\+Wrapper@{generate\+Header\+Callback\+Wrapper}}
\index{generate\+Header\+Callback\+Wrapper@{generate\+Header\+Callback\+Wrapper}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{generate\+Header\+Callback\+Wrapper(\+Stream\+I\+D stream, http2\+::\+Frame\+Type type, size\+\_\+t length)}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Header\+Callback\+Wrapper (
\begin{DoxyParamCaption}
\item[{{\bf Stream\+ID}}]{stream, }
\item[{{\bf http2\+::\+Frame\+Type}}]{type, }
\item[{size\+\_\+t}]{length}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a8d6949b25189df0a4075e412617b5b18}


Definition at line 1251 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::callback\+\_\+, and proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Generate\+Frame\+Header().



Referenced by generate\+Body(), generate\+Continuation(), generate\+E\+O\+M(), generate\+Goaway(), generate\+Header\+Impl(), generate\+Ping\+Reply(), generate\+Ping\+Request(), generate\+Priority(), generate\+Rst\+Stream(), generate\+Settings(), generate\+Settings\+Ack(), generate\+Trailers(), generate\+Window\+Update(), and get\+Header\+Indexing\+Strategy().


\begin{DoxyCode}
1253                                                                 \{
1254   \textcolor{keywordflow}{if} (callback_) \{
1255     callback_->onGenerateFrameHeader(stream,
1256                                      static\_cast<uint8\_t>(type),
1257                                      length);
1258   \}
1259   \textcolor{keywordflow}{return} length;
1260 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!generate\+Header\+Impl@{generate\+Header\+Impl}}
\index{generate\+Header\+Impl@{generate\+Header\+Impl}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{generate\+Header\+Impl(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D stream, const H\+T\+T\+P\+Message \&msg, const folly\+::\+Optional$<$ Stream\+I\+D $>$ \&assoc\+Stream, const folly\+::\+Optional$<$ Ex\+Attributes $>$ \&ex\+Attributes, bool eom, H\+T\+T\+P\+Header\+Size $\ast$size)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Header\+Impl (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream, }
\item[{const {\bf H\+T\+T\+P\+Message} \&}]{msg, }
\item[{const folly\+::\+Optional$<$ {\bf Stream\+ID} $>$ \&}]{assoc\+Stream, }
\item[{const folly\+::\+Optional$<$ {\bf Ex\+Attributes} $>$ \&}]{ex\+Attributes, }
\item[{bool}]{eom, }
\item[{{\bf H\+T\+T\+P\+Header\+Size} $\ast$}]{size}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a5226a24726b4c7d89fc3bd4aa800ccbb}


Definition at line 1104 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, encode\+Headers(), proxygen\+::http2\+::\+E\+X\+\_\+\+H\+E\+A\+D\+E\+RS, generate\+Continuation(), generate\+Header\+Callback\+Wrapper(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+H\+T\+T\+P2\+Priority(), proxygen\+::http2\+::\+H\+E\+A\+D\+E\+RS, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::ingress\+Goaway\+Ack\+\_\+, proxygen\+::\+H\+T\+T\+P\+Message\+::is\+Egress\+Websocket\+Upgrade(), proxygen\+::\+H\+T\+T\+P\+Message\+::is\+Request(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::is\+Stream\+Ingress\+Egress\+Allowed(), proxygen\+::http2\+::k\+Frame\+Priority\+Size, proxygen\+::http2\+::k\+No\+Padding, max\+Send\+Frame\+Size(), proxygen\+::\+Codec\+Util\+::prepare\+Message\+For\+Compression(), proxygen\+::http2\+::\+P\+U\+S\+H\+\_\+\+P\+R\+O\+M\+I\+SE, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::transport\+Direction\+\_\+, upgraded\+Streams\+\_\+, proxygen\+::\+U\+P\+S\+T\+R\+E\+AM, proxygen\+::http2\+::write\+Ex\+Headers(), proxygen\+::http2\+::write\+Headers(), and proxygen\+::http2\+::write\+Push\+Promise().



Referenced by generate\+Ex\+Header(), generate\+Header(), generate\+Push\+Promise(), and get\+Header\+Indexing\+Strategy().


\begin{DoxyCode}
1111                           \{
1112   \textcolor{keywordflow}{if} (assocStream) \{
1113     CHECK(!exAttributes);
1114     VLOG(4) << \textcolor{stringliteral}{"generating PUSH\_PROMISE for stream="} << stream;
1115   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (exAttributes) \{
1116     CHECK(!assocStream);
1117     VLOG(4) << \textcolor{stringliteral}{"generating ExHEADERS for stream="} << stream
1118             << \textcolor{stringliteral}{" with control stream="} << exAttributes->controlStream
1119             << \textcolor{stringliteral}{" unidirectional="} << exAttributes->unidirectional;
1120   \} \textcolor{keywordflow}{else} \{
1121     VLOG(4) << \textcolor{stringliteral}{"generating HEADERS for stream="} << stream;
1122   \}
1123 
1124   \textcolor{keywordflow}{if} (!isStreamIngressEgressAllowed(stream)) \{
1125     VLOG(2) << \textcolor{stringliteral}{"Suppressing HEADERS/PROMISE for stream="} << stream <<
1126       \textcolor{stringliteral}{" ingressGoawayAck\_="} << ingressGoawayAck_;
1127     \textcolor{keywordflow}{if} (size) \{
1128       size->uncompressed = 0;
1129       size->compressed = 0;
1130     \}
1131     \textcolor{keywordflow}{return};
1132   \}
1133 
1134   \textcolor{keywordflow}{if} (msg.isRequest()) \{
1135     DCHECK(transportDirection_ == TransportDirection::UPSTREAM ||
1136            assocStream || exAttributes);
1137     \textcolor{keywordflow}{if} (msg.isEgressWebsocketUpgrade()) \{
1138       upgradedStreams_.insert(stream);
1139     \}
1140   \} \textcolor{keywordflow}{else} \{
1141     DCHECK(transportDirection_ == TransportDirection::DOWNSTREAM ||
1142            exAttributes);
1143   \}
1144 
1145   std::vector<std::string> temps;
1146   \textcolor{keyword}{auto} allHeaders = CodecUtil::prepareMessageForCompression(msg, temps);
1147   \textcolor{keyword}{auto} out = encodeHeaders(msg.getHeaders(), allHeaders, size);
1148   IOBufQueue queue(IOBufQueue::cacheChainLength());
1149   queue.append(std::move(out));
1150   \textcolor{keyword}{auto} maxFrameSize = maxSendFrameSize();
1151   \textcolor{keywordflow}{if} (queue.chainLength() > 0) \{
1152     folly::Optional<http2::PriorityUpdate> pri;
1153     \textcolor{keyword}{auto} res = msg.getHTTP2Priority();
1154     \textcolor{keyword}{auto} remainingFrameSize = maxFrameSize;
1155     \textcolor{keywordflow}{if} (res) \{
1156       pri = http2::PriorityUpdate\{std::get<0>(*res), std::get<1>(*res),
1157                                   std::get<2>(*res)\};
1158       DCHECK\_GE(remainingFrameSize, http2::kFramePrioritySize)
1159         << \textcolor{stringliteral}{"no enough space for priority? frameHeadroom="} << remainingFrameSize;
1160       remainingFrameSize -= http2::kFramePrioritySize;
1161     \}
1162     \textcolor{keyword}{auto} chunk = queue.split(std::min(remainingFrameSize, queue.chainLength()));
1163 
1164     \textcolor{keywordtype}{bool} endHeaders = queue.chainLength() == 0;
1165 
1166     \textcolor{keywordflow}{if} (assocStream) \{
1167       DCHECK\_EQ(transportDirection_, TransportDirection::DOWNSTREAM);
1168       DCHECK(!eom);
1169       generateHeaderCallbackWrapper(stream, http2::FrameType::PUSH_PROMISE,
1170                                     http2::writePushPromise(writeBuf,
1171                                                             *assocStream,
1172                                                             stream,
1173                                                             std::move(chunk),
1174                                                             http2::kNoPadding,
1175                                                             endHeaders));
1176     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (exAttributes) \{
1177       generateHeaderCallbackWrapper(
1178         stream,
1179         http2::FrameType::EX_HEADERS,
1180         http2::writeExHeaders(writeBuf,
1181                               std::move(chunk),
1182                               stream,
1183                               *exAttributes,
1184                               pri,
1185                               http2::kNoPadding,
1186                               eom,
1187                               endHeaders));
1188     \} \textcolor{keywordflow}{else} \{
1189       generateHeaderCallbackWrapper(stream, http2::FrameType::HEADERS,
1190                                     http2::writeHeaders(writeBuf,
1191                                                         std::move(chunk),
1192                                                         stream,
1193                                                         pri,
1194                                                         http2::kNoPadding,
1195                                                         eom,
1196                                                         endHeaders));
1197     \}
1198 
1199     \textcolor{keywordflow}{if} (!endHeaders) \{
1200       generateContinuation(writeBuf, queue, stream, maxFrameSize);
1201     \}
1202   \}
1203 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!generate\+Ping\+Reply@{generate\+Ping\+Reply}}
\index{generate\+Ping\+Reply@{generate\+Ping\+Reply}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{generate\+Ping\+Reply(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint64\+\_\+t unique\+I\+D) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Ping\+Reply (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{, }
\item[{uint64\+\_\+t}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_aac48605b87c60aabc13765e80e06dea7}
Generate a reply to a ping message, if supported in the protocol implemented by the codec. 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_aeb8c597c8604bc7159e58b74c1874de3}.



Definition at line 1454 of file H\+T\+T\+P2\+Codec.\+cpp.



References generate\+Header\+Callback\+Wrapper(), proxygen\+::http2\+::\+P\+I\+NG, and proxygen\+::http2\+::write\+Ping().



Referenced by get\+User\+Agent().


\begin{DoxyCode}
1455                                                         \{
1456   VLOG(4) << \textcolor{stringliteral}{"Generating ping reply with opaqueData="} << uniqueID;
1457   \textcolor{keywordflow}{return} generateHeaderCallbackWrapper(0, http2::FrameType::PING,
1458                                        http2::writePing(writeBuf, uniqueID, \textcolor{keyword}{true} \textcolor{comment}{/* ack */}));
1459 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!generate\+Ping\+Request@{generate\+Ping\+Request}}
\index{generate\+Ping\+Request@{generate\+Ping\+Request}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{generate\+Ping\+Request(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Ping\+Request (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_a21692ad7b31050cf677378df46db3a54}
If the protocol supports it, generate a ping message that the other side should respond to. 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a70731ca9f30fe9890817034be4e78c28}.



Definition at line 1445 of file H\+T\+T\+P2\+Codec.\+cpp.



References generate\+Header\+Callback\+Wrapper(), proxygen\+::http2\+::\+P\+I\+NG, and proxygen\+::http2\+::write\+Ping().



Referenced by get\+User\+Agent().


\begin{DoxyCode}
1445                                                                 \{
1446   \textcolor{comment}{// should probably let the caller specify when integrating with session}
1447   \textcolor{comment}{// we know HTTPSession sets up events to track ping latency}
1448   uint64\_t opaqueData = folly::Random::rand64();
1449   VLOG(4) << \textcolor{stringliteral}{"Generating ping request with opaqueData="} << opaqueData;
1450   \textcolor{keywordflow}{return} generateHeaderCallbackWrapper(0, http2::FrameType::PING,
1451                                        http2::writePing(writeBuf, opaqueData, \textcolor{keyword}{false} \textcolor{comment}{/* no ack */}));
1452 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!generate\+Priority@{generate\+Priority}}
\index{generate\+Priority@{generate\+Priority}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{generate\+Priority(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D stream, const H\+T\+T\+P\+Message\+::\+H\+T\+T\+P\+Priority \&pri) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Priority (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream, }
\item[{const {\bf H\+T\+T\+P\+Message\+::\+H\+T\+T\+P\+Priority} \&}]{pri}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_ae217d3987537c27897e818312e6b7ff9}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a6315ba48314ddbe30a9b5aeb231f4c37}.



Definition at line 1568 of file H\+T\+T\+P2\+Codec.\+cpp.



References generate\+Header\+Callback\+Wrapper(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::ingress\+Goaway\+Ack\+\_\+, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::is\+Stream\+Ingress\+Egress\+Allowed(), proxygen\+::http2\+::\+P\+R\+I\+O\+R\+I\+TY, and proxygen\+::http2\+::write\+Priority().



Referenced by add\+Priority\+Nodes(), and get\+User\+Agent().


\begin{DoxyCode}
1570                                                                         \{
1571   VLOG(4) << \textcolor{stringliteral}{"generating priority for stream="} << stream;
1572   \textcolor{keywordflow}{if} (!isStreamIngressEgressAllowed(stream)) \{
1573     VLOG(2) << \textcolor{stringliteral}{"suppressed PRIORITY for stream="} << stream
1574             << \textcolor{stringliteral}{" ingressGoawayAck\_="} << ingressGoawayAck_;
1575     \textcolor{keywordflow}{return} 0;
1576   \}
1577   \textcolor{keywordflow}{return} generateHeaderCallbackWrapper(
1578             stream,
1579             http2::FrameType::PRIORITY,
1580             http2::writePriority(writeBuf, stream,
1581                                  \{std::get<0>(pri),
1582                                    std::get<1>(pri),
1583                                    std::get<2>(pri)\}));
1584 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!generate\+Push\+Promise@{generate\+Push\+Promise}}
\index{generate\+Push\+Promise@{generate\+Push\+Promise}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{generate\+Push\+Promise(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D stream, const H\+T\+T\+P\+Message \&msg, Stream\+I\+D assoc\+Stream, bool eom=false, H\+T\+T\+P\+Header\+Size $\ast$size=nullptr) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Push\+Promise (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream, }
\item[{const {\bf H\+T\+T\+P\+Message} \&}]{msg, }
\item[{{\bf Stream\+ID}}]{assoc\+Stream, }
\item[{bool}]{eom = {\ttfamily false}, }
\item[{{\bf H\+T\+T\+P\+Header\+Size} $\ast$}]{size = {\ttfamily {\bf nullptr}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_a116fef7e31e949f40ac445903622cfab}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a087b49a9fb21bf2219125ce63a96ea11}.



Definition at line 1074 of file H\+T\+T\+P2\+Codec.\+cpp.



References generate\+Header\+Impl().



Referenced by get\+User\+Agent().


\begin{DoxyCode}
1079                                                            \{
1080   generateHeaderImpl(writeBuf,
1081                      stream,
1082                      msg,
1083                      assocStream,
1084                      folly::none, \textcolor{comment}{/* controlStream */}
1085                      eom,
1086                      size);
1087 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!generate\+Rst\+Stream@{generate\+Rst\+Stream}}
\index{generate\+Rst\+Stream@{generate\+Rst\+Stream}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{generate\+Rst\+Stream(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D stream, Error\+Code status\+Code) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Rst\+Stream (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream, }
\item[{{\bf Error\+Code}}]{code}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_adbb95912a72ac71915e0066539c242ee}
Generate any protocol framing needed to abort a stream. \begin{DoxyReturn}{Returns}
number of bytes written 
\end{DoxyReturn}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_adfb41670b50d0608a8beb934494109be}.



Definition at line 1370 of file H\+T\+T\+P2\+Codec.\+cpp.



References cur\+Header\+\_\+, proxygen\+::http2\+::\+E\+N\+D\+\_\+\+S\+T\+R\+E\+AM, proxygen\+::http2\+::error\+Code\+To\+Reset(), proxygen\+::http2\+::\+Frame\+Header\+::flags, generate\+Header\+Callback\+Wrapper(), proxygen\+::get\+Error\+Code\+String(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::ingress\+Goaway\+Ack\+\_\+, ingress\+Websocket\+Upgrade\+\_\+, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::is\+Stream\+Ingress\+Egress\+Allowed(), pending\+End\+Stream\+Handling\+\_\+, proxygen\+::\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, proxygen\+::http2\+::\+R\+S\+T\+\_\+\+S\+T\+R\+E\+AM, proxygen\+::http2\+::\+Frame\+Header\+::stream, upgraded\+Streams\+\_\+, user\+Agent\+\_\+, and proxygen\+::http2\+::write\+Rst\+Stream().



Referenced by get\+User\+Agent().


\begin{DoxyCode}
1372                                                            \{
1373   VLOG(4) << \textcolor{stringliteral}{"sending RST\_STREAM for stream="} << stream
1374           << \textcolor{stringliteral}{" with code="} << getErrorCodeString(statusCode);
1375   \textcolor{keywordflow}{if} (!isStreamIngressEgressAllowed(stream)) \{
1376     VLOG(2) << \textcolor{stringliteral}{"suppressed RST\_STREAM for stream="} << stream
1377             << \textcolor{stringliteral}{" ingressGoawayAck\_="} << ingressGoawayAck_;
1378     \textcolor{keywordflow}{return} 0;
1379   \}
1380   \textcolor{comment}{// Suppress any EOM callback for the current frame.}
1381   \textcolor{keywordflow}{if} (stream == curHeader_.stream) \{
1382     curHeader_.flags &= ~http2::END_STREAM;
1383     pendingEndStreamHandling_ = \textcolor{keyword}{false};
1384     ingressWebsocketUpgrade_ = \textcolor{keyword}{false};
1385   \}
1386   upgradedStreams_.erase(stream);
1387 
1388   \textcolor{keywordflow}{if} (statusCode == ErrorCode::PROTOCOL_ERROR) \{
1389     VLOG(2) << \textcolor{stringliteral}{"sending RST\_STREAM with code="} << getErrorCodeString(statusCode)
1390             << \textcolor{stringliteral}{" for stream="} << stream << \textcolor{stringliteral}{" user-agent="} << userAgent_;
1391   \}
1392   \textcolor{keyword}{auto} code = http2::errorCodeToReset(statusCode);
1393   \textcolor{keywordflow}{return} generateHeaderCallbackWrapper(stream, http2::FrameType::RST_STREAM,
1394                                        http2::writeRstStream(writeBuf, stream, code));
1395 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!generate\+Settings@{generate\+Settings}}
\index{generate\+Settings@{generate\+Settings}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{generate\+Settings(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Settings (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_a29dde5869e70cfbf1b9638d4dd024079}
Generate a settings message, if supported in the protocol implemented by the codec. 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_ab55cd5f8412d9d930ff6a28e0aa711b6}.



Definition at line 1461 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, egress\+Settings\+\_\+, proxygen\+::\+E\+N\+A\+B\+L\+E\+\_\+\+C\+O\+N\+N\+E\+C\+T\+\_\+\+P\+R\+O\+T\+O\+C\+OL, proxygen\+::\+E\+N\+A\+B\+L\+E\+\_\+\+E\+X\+\_\+\+H\+E\+A\+D\+E\+RS, proxygen\+::\+E\+N\+A\+B\+L\+E\+\_\+\+P\+U\+SH, proxygen\+::\+E\+R\+R\+OR, generate\+Header\+Callback\+Wrapper(), proxygen\+::\+H\+T\+T\+P\+Settings\+::get\+All\+Settings(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::get\+Transport\+Direction(), proxygen\+::get\+Transport\+Direction\+String(), proxygen\+::\+H\+E\+A\+D\+E\+R\+\_\+\+T\+A\+B\+L\+E\+\_\+\+S\+I\+ZE, header\+Codec\+\_\+, proxygen\+::\+I\+N\+I\+T\+I\+A\+L\+\_\+\+W\+I\+N\+D\+O\+W\+\_\+\+S\+I\+ZE, proxygen\+::\+M\+A\+X\+\_\+\+C\+O\+N\+C\+U\+R\+R\+E\+N\+T\+\_\+\+S\+T\+R\+E\+A\+MS, proxygen\+::\+M\+A\+X\+\_\+\+F\+R\+A\+M\+E\+\_\+\+S\+I\+ZE, proxygen\+::\+M\+A\+X\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+L\+I\+S\+T\+\_\+\+S\+I\+ZE, pending\+Table\+Max\+Size\+\_\+, proxygen\+::\+H\+P\+A\+C\+K\+Codec\+::set\+Max\+Uncompressed(), proxygen\+::http2\+::\+S\+E\+T\+T\+I\+N\+GS, settings, proxygen\+::\+T\+H\+R\+I\+F\+T\+\_\+\+C\+H\+A\+N\+N\+E\+L\+\_\+\+ID, proxygen\+::\+T\+H\+R\+I\+F\+T\+\_\+\+C\+H\+A\+N\+N\+E\+L\+\_\+\+I\+D\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+ED, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::transport\+Direction\+\_\+, and proxygen\+::http2\+::write\+Settings().



Referenced by get\+User\+Agent().


\begin{DoxyCode}
1461                                                              \{
1462   std::deque<SettingPair> settings;
1463   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}& setting: egressSettings_.getAllSettings()) \{
1464     \textcolor{keywordflow}{switch} (setting.id) \{
1465       \textcolor{keywordflow}{case} SettingsId::HEADER_TABLE_SIZE:
1466         \textcolor{keywordflow}{if} (pendingTableMaxSize_) \{
1467           LOG(ERROR) << \textcolor{stringliteral}{"Can't have more than one settings in flight, skipping"};
1468           \textcolor{keywordflow}{continue};
1469         \} \textcolor{keywordflow}{else} \{
1470           pendingTableMaxSize_ = setting.value;
1471         \}
1472         \textcolor{keywordflow}{break};
1473       \textcolor{keywordflow}{case} SettingsId::ENABLE_PUSH:
1474         \textcolor{keywordflow}{if} (transportDirection_ == TransportDirection::DOWNSTREAM) \{
1475           \textcolor{comment}{// HTTP/2 spec says downstream must not send this flag}
1476           \textcolor{comment}{// HTTP2Codec uses it to determine if push features are enabled}
1477           \textcolor{keywordflow}{continue};
1478         \} \textcolor{keywordflow}{else} \{
1479           CHECK(setting.value == 0 || setting.value == 1);
1480         \}
1481         \textcolor{keywordflow}{break};
1482       \textcolor{keywordflow}{case} SettingsId::MAX_CONCURRENT_STREAMS:
1483       \textcolor{keywordflow}{case} SettingsId::INITIAL_WINDOW_SIZE:
1484       \textcolor{keywordflow}{case} SettingsId::MAX_FRAME_SIZE:
1485         \textcolor{keywordflow}{break};
1486       \textcolor{keywordflow}{case} SettingsId::MAX_HEADER_LIST_SIZE:
1487         headerCodec_.setMaxUncompressed(setting.value);
1488         \textcolor{keywordflow}{break};
1489       \textcolor{keywordflow}{case} SettingsId::ENABLE_EX_HEADERS:
1490         CHECK(setting.value == 0 || setting.value == 1);
1491         \textcolor{keywordflow}{if} (setting.value == 0) \{
1492           \textcolor{keywordflow}{continue}; \textcolor{comment}{// just skip the experimental setting if disabled}
1493         \} \textcolor{keywordflow}{else} \{
1494           VLOG(4) << \textcolor{stringliteral}{"generating ENABLE\_EX\_HEADERS="} << setting.value;
1495         \}
1496         \textcolor{keywordflow}{break};
1497       \textcolor{keywordflow}{case} SettingsId::ENABLE_CONNECT_PROTOCOL:
1498         \textcolor{keywordflow}{if} (setting.value == 0) \{
1499           \textcolor{keywordflow}{continue};
1500         \}
1501         \textcolor{keywordflow}{break};
1502       \textcolor{keywordflow}{case} SettingsId::THRIFT_CHANNEL_ID:
1503       \textcolor{keywordflow}{case} SettingsId::THRIFT_CHANNEL_ID_DEPRECATED:
1504         \textcolor{keywordflow}{break};
1505       \textcolor{keywordflow}{default}:
1506         LOG(ERROR) << \textcolor{stringliteral}{"ignore unknown settingsId="}
1507                    << std::underlying\_type<SettingsId>::type(setting.id)
1508                    << \textcolor{stringliteral}{" value="} << setting.value;
1509         \textcolor{keywordflow}{continue};
1510     \}
1511 
1512     settings.push\_back(SettingPair(setting.id, setting.value));
1513   \}
1514   VLOG(4) << getTransportDirectionString(getTransportDirection())
1515           << \textcolor{stringliteral}{" generating "} << (unsigned)settings.size() << \textcolor{stringliteral}{" settings"};
1516   \textcolor{keywordflow}{return} generateHeaderCallbackWrapper(0, http2::FrameType::SETTINGS,
1517                                        http2::writeSettings(writeBuf, settings));
1518 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!generate\+Settings\+Ack@{generate\+Settings\+Ack}}
\index{generate\+Settings\+Ack@{generate\+Settings\+Ack}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{generate\+Settings\+Ack(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Settings\+Ack (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_ab4e699331a6c702fc5c1c56d1eecca74}
Generate a settings ack message, if supported in the protocol implemented by the codec. 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a7773a5b8b6902a5bc6211e4d2b1961b7}.



Definition at line 1547 of file H\+T\+T\+P2\+Codec.\+cpp.



References generate\+Header\+Callback\+Wrapper(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::get\+Transport\+Direction(), proxygen\+::get\+Transport\+Direction\+String(), proxygen\+::http2\+::\+S\+E\+T\+T\+I\+N\+GS, and proxygen\+::http2\+::write\+Settings\+Ack().



Referenced by get\+User\+Agent().


\begin{DoxyCode}
1547                                                                 \{
1548   VLOG(4) << getTransportDirectionString(getTransportDirection())
1549           << \textcolor{stringliteral}{" generating settings ack"};
1550   \textcolor{keywordflow}{return} generateHeaderCallbackWrapper(0, http2::FrameType::SETTINGS,
1551                                        http2::writeSettingsAck(writeBuf));
1552 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!generate\+Trailers@{generate\+Trailers}}
\index{generate\+Trailers@{generate\+Trailers}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{generate\+Trailers(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D stream, const H\+T\+T\+P\+Headers \&trailers) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Trailers (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream, }
\item[{const {\bf H\+T\+T\+P\+Headers} \&}]{trailers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_a0f004009717e09a865f871dc5e3a82cd}
Write the message trailers \begin{DoxyReturn}{Returns}
number of bytes written 
\end{DoxyReturn}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a097d1fa44f042101b2eeeb775de65289}.



Definition at line 1314 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+Codec\+Util\+::append\+Headers(), encode\+Headers(), generate\+Continuation(), generate\+Header\+Callback\+Wrapper(), proxygen\+::http2\+::\+H\+E\+A\+D\+E\+RS, proxygen\+::\+H\+T\+T\+P\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+N\+O\+NE, proxygen\+::http2\+::k\+No\+Padding, max\+Send\+Frame\+Size(), and proxygen\+::http2\+::write\+Headers().



Referenced by get\+User\+Agent().


\begin{DoxyCode}
1316                                                                  \{
1317   VLOG(4) << \textcolor{stringliteral}{"generating TRAILERS for stream="} << stream;
1318   std::vector<compress::Header> allHeaders;
1319   CodecUtil::appendHeaders(trailers, allHeaders, HTTP_HEADER_NONE);
1320 
1321   HTTPHeaderSize size;
1322   \textcolor{keyword}{auto} out = encodeHeaders(trailers, allHeaders, &size);
1323 
1324   IOBufQueue queue(IOBufQueue::cacheChainLength());
1325   queue.append(std::move(out));
1326   \textcolor{keyword}{auto} maxFrameSize = maxSendFrameSize();
1327   \textcolor{keywordflow}{if} (queue.chainLength() > 0) \{
1328     folly::Optional<http2::PriorityUpdate> pri;
1329     \textcolor{keyword}{auto} remainingFrameSize = maxFrameSize;
1330     \textcolor{keyword}{auto} chunk = queue.split(std::min(remainingFrameSize, queue.chainLength()));
1331     \textcolor{keywordtype}{bool} endHeaders = queue.chainLength() == 0;
1332     generateHeaderCallbackWrapper(stream,
1333                                   http2::FrameType::HEADERS,
1334                                   http2::writeHeaders(writeBuf,
1335                                                       std::move(chunk),
1336                                                       stream,
1337                                                       pri,
1338                                                       http2::kNoPadding,
1339                                                       \textcolor{keyword}{true} \textcolor{comment}{/*eom*/},
1340                                                       endHeaders));
1341 
1342     \textcolor{keywordflow}{if} (!endHeaders) \{
1343       generateContinuation(writeBuf, queue, stream, maxFrameSize);
1344     \}
1345   \}
1346 
1347   \textcolor{keywordflow}{return} size.compressed;
1348 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!generate\+Window\+Update@{generate\+Window\+Update}}
\index{generate\+Window\+Update@{generate\+Window\+Update}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{generate\+Window\+Update(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D stream, uint32\+\_\+t delta) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Window\+Update (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream, }
\item[{uint32\+\_\+t}]{delta}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_a229a3b8ecb28e13ed68672a999f03373}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a8b80a75b703ace1377f76bd574d81b00}.



Definition at line 1554 of file H\+T\+T\+P2\+Codec.\+cpp.



References generate\+Header\+Callback\+Wrapper(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::ingress\+Goaway\+Ack\+\_\+, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::is\+Stream\+Ingress\+Egress\+Allowed(), proxygen\+::http2\+::\+W\+I\+N\+D\+O\+W\+\_\+\+U\+P\+D\+A\+TE, and proxygen\+::http2\+::write\+Window\+Update().



Referenced by get\+User\+Agent().


\begin{DoxyCode}
1556                                                         \{
1557   VLOG(4) << \textcolor{stringliteral}{"generating window update for stream="} << stream
1558           << \textcolor{stringliteral}{": Processed "} << delta << \textcolor{stringliteral}{" bytes"};
1559   \textcolor{keywordflow}{if} (!isStreamIngressEgressAllowed(stream)) \{
1560     VLOG(2) << \textcolor{stringliteral}{"suppressed WINDOW\_UPDATE for stream="} << stream
1561             << \textcolor{stringliteral}{" ingressGoawayAck\_="} << ingressGoawayAck_;
1562     \textcolor{keywordflow}{return} 0;
1563   \}
1564   \textcolor{keywordflow}{return} generateHeaderCallbackWrapper(stream, http2::FrameType::WINDOW_UPDATE,
1565                                        http2::writeWindowUpdate(writeBuf, stream, delta));
1566 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!get\+Compression\+Info@{get\+Compression\+Info}}
\index{get\+Compression\+Info@{get\+Compression\+Info}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{get\+Compression\+Info() const override}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Compression\+Info} proxygen\+::\+H\+T\+T\+P2\+Codec\+::get\+Compression\+Info (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_a61f3f2a2a5f0ff3110b8f2306b143568}
Gets both the egress and ingress header table size, bytes stored in header table, and the number of headers stored in the header table 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a4e0b7580b74da507c77553ef7891bc0e}.



Definition at line 151 of file H\+T\+T\+P2\+Codec.\+h.



References proxygen\+::\+H\+P\+A\+C\+K\+Codec\+::get\+Compression\+Info(), header\+Codec\+\_\+, and request\+Upgrade().


\begin{DoxyCode}
151                                                       \{
152     \textcolor{keywordflow}{return} headerCodec_.getCompressionInfo();
153   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!get\+Default\+Window\+Size@{get\+Default\+Window\+Size}}
\index{get\+Default\+Window\+Size@{get\+Default\+Window\+Size}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{get\+Default\+Window\+Size() const override}]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::get\+Default\+Window\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_aaf2c778a7df6b9677b3755a2a1cecceb}
Get the default size of flow control windows for this protocol 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_af4516328c1b427f975f86909cd3ed01e}.



Definition at line 117 of file H\+T\+T\+P2\+Codec.\+h.



References proxygen\+::http2\+::k\+Initial\+Window.



Referenced by T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
117                                                  \{
118     \textcolor{keywordflow}{return} http2::kInitialWindow;
119   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!get\+Egress\+Settings@{get\+Egress\+Settings}}
\index{get\+Egress\+Settings@{get\+Egress\+Settings}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{get\+Egress\+Settings() override}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Settings}$\ast$ proxygen\+::\+H\+T\+T\+P2\+Codec\+::get\+Egress\+Settings (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_abeba44c52208477693c7b187acc5bc00}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a13245f4e4f749a752c87275396cf9879}.



Definition at line 116 of file H\+T\+T\+P2\+Codec.\+h.



References egress\+Settings\+\_\+.



Referenced by H\+T\+T\+P\+Downstream\+Test$<$ S\+P\+D\+Y3\+\_\+1\+Codec\+Pair $>$\+::\+H\+T\+T\+P\+Downstream\+Test().


\begin{DoxyCode}
116 \{ \textcolor{keywordflow}{return} &egressSettings_; \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!get\+Header\+Indexing\+Strategy@{get\+Header\+Indexing\+Strategy}}
\index{get\+Header\+Indexing\+Strategy@{get\+Header\+Indexing\+Strategy}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{get\+Header\+Indexing\+Strategy() const }]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Header\+Indexing\+Strategy}$\ast$ proxygen\+::\+H\+T\+T\+P2\+Codec\+::get\+Header\+Indexing\+Strategy (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HTTP2Codec_a18540e4ea97aace01b07ae1e0c1e2129}


Definition at line 174 of file H\+T\+T\+P2\+Codec.\+h.



References check\+Connection\+Error(), check\+New\+Stream(), encode\+Headers(), generate\+Header\+Callback\+Wrapper(), generate\+Header\+Impl(), proxygen\+::\+H\+P\+A\+C\+K\+Codec\+::get\+Header\+Indexing\+Strategy(), handle\+End\+Stream(), handle\+Settings(), handle\+Settings\+Ack(), header\+Codec\+\_\+, parse\+All\+Data(), parse\+Certificate(), parse\+Certificate\+Request(), parse\+Continuation(), parse\+Data\+Frame\+Data(), parse\+Ex\+Headers(), parse\+Frame(), parse\+Goaway(), parse\+Headers(), parse\+Headers\+Check\+Concurrent\+Streams(), parse\+Headers\+Decode\+Frames(), parse\+Headers\+Impl(), parse\+Ping(), parse\+Priority(), parse\+Push\+Promise(), parse\+Rst\+Stream(), parse\+Settings(), parse\+Window\+Update(), and settings.



Referenced by H\+T\+T\+P\+Downstream\+Test$<$ S\+P\+D\+Y3\+\_\+1\+Codec\+Pair $>$\+::\+H\+T\+T\+P\+Downstream\+Test(), T\+E\+S\+T\+\_\+\+F(), H\+T\+T\+P\+Downstream\+Test$<$ C $>$\+::test\+Simple\+Upgrade(), and H\+T\+T\+P\+Upstream\+Test$<$ C $>$\+::test\+Simple\+Upgrade().


\begin{DoxyCode}
174                                                                   \{
175     \textcolor{keywordflow}{return} headerCodec_.getHeaderIndexingStrategy();
176   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!get\+Ingress\+Settings@{get\+Ingress\+Settings}}
\index{get\+Ingress\+Settings@{get\+Ingress\+Settings}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{get\+Ingress\+Settings() const override}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf H\+T\+T\+P\+Settings}$\ast$ proxygen\+::\+H\+T\+T\+P2\+Codec\+::get\+Ingress\+Settings (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_a5ea659ad33ecfad31089acd434f3bef1}


Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_aedbff2455d784b58ee452d648858cc9a}.



Definition at line 113 of file H\+T\+T\+P2\+Codec.\+h.



References ingress\+Settings\+\_\+.


\begin{DoxyCode}
113                                                           \{
114     \textcolor{keywordflow}{return} &ingressSettings_;
115   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!get\+Protocol@{get\+Protocol}}
\index{get\+Protocol@{get\+Protocol}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{get\+Protocol() const override}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Codec\+Protocol} proxygen\+::\+H\+T\+T\+P2\+Codec\+::get\+Protocol (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_a535dc616454e4d2e6d41d997bffc3371}
Gets the session protocol currently used by the codec. This can be mapped to a string for logging and diagnostic use. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a3818f5333dbb3c19312984ac5f069969}.



Definition at line 40 of file H\+T\+T\+P2\+Codec.\+h.



References proxygen\+::\+H\+T\+T\+P\+\_\+2.



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
40                                              \{
41     \textcolor{keywordflow}{return} CodecProtocol::HTTP_2;
42   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!get\+Received\+Frame\+Count@{get\+Received\+Frame\+Count}}
\index{get\+Received\+Frame\+Count@{get\+Received\+Frame\+Count}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{get\+Received\+Frame\+Count() const }]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::get\+Received\+Frame\+Count (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HTTP2Codec_a0c227182b0fbe351fe5c159798a9afa0}


Definition at line 160 of file H\+T\+T\+P2\+Codec.\+h.



References received\+Frame\+Count\+\_\+.


\begin{DoxyCode}
160                                          \{
161     \textcolor{keywordflow}{return} receivedFrameCount_;
162   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!get\+User\+Agent@{get\+User\+Agent}}
\index{get\+User\+Agent@{get\+User\+Agent}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{get\+User\+Agent() const override}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string\& proxygen\+::\+H\+T\+T\+P2\+Codec\+::get\+User\+Agent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_a10a99e9cd9555da3cb0ee4bff637482b}
Gets the user agent string of the client. Thus, it is only meaningful for a D\+O\+W\+N\+S\+T\+R\+E\+AM session. Note that the value is available after \doxyref{on\+Headers\+Complete()}{p.}{classproxygen_1_1HTTP2Codec_af156831a61f0c48cc4678100694a7b47}. It can help in diagnosing the interactions between different codec implementation. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a0fc1b54808088c79076892d0d0d53275}.



Definition at line 44 of file H\+T\+T\+P2\+Codec.\+h.



References generate\+Body(), generate\+Certificate(), generate\+Certificate\+Request(), generate\+Chunk\+Header(), generate\+Chunk\+Terminator(), generate\+Connection\+Preface(), generate\+Continuation(), generate\+E\+O\+M(), generate\+Ex\+Header(), generate\+Goaway(), generate\+Header(), generate\+Ping\+Reply(), generate\+Ping\+Request(), generate\+Priority(), generate\+Push\+Promise(), generate\+Rst\+Stream(), generate\+Settings(), generate\+Settings\+Ack(), generate\+Trailers(), generate\+Window\+Update(), on\+Ingress(), on\+Ingress\+Upgrade\+Message(), status\+Code, and user\+Agent\+\_\+.


\begin{DoxyCode}
44                                                  \{
45     \textcolor{keywordflow}{return} userAgent_;
46   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!handle\+End\+Stream@{handle\+End\+Stream}}
\index{handle\+End\+Stream@{handle\+End\+Stream}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{handle\+End\+Stream()}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::\+H\+T\+T\+P2\+Codec\+::handle\+End\+Stream (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_ab64d540f45ec9b86794f09a87f698271}


Definition at line 246 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::http2\+::\+C\+O\+N\+T\+I\+N\+U\+A\+T\+I\+ON, cur\+Header\+\_\+, proxygen\+::http2\+::\+D\+A\+TA, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::deliver\+Callback\+If\+Allowed(), proxygen\+::http2\+::\+E\+N\+D\+\_\+\+S\+T\+R\+E\+AM, proxygen\+::http2\+::\+E\+X\+\_\+\+H\+E\+A\+D\+E\+RS, expected\+Continuation\+Stream\+\_\+, proxygen\+::http2\+::\+Frame\+Header\+::flags, proxygen\+::http2\+::\+H\+E\+A\+D\+E\+RS, ingress\+Websocket\+Upgrade\+\_\+, proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Message\+Complete(), pending\+End\+Stream\+Handling\+\_\+, proxygen\+::http2\+::\+Frame\+Header\+::stream, and proxygen\+::http2\+::\+Frame\+Header\+::type.



Referenced by get\+Header\+Indexing\+Strategy(), parse\+All\+Data(), parse\+Data\+Frame\+Data(), and parse\+Headers\+Impl().


\begin{DoxyCode}
246                                       \{
247   \textcolor{keywordflow}{if} (curHeader_.type != http2::FrameType::HEADERS &&
248       curHeader_.type != http2::FrameType::EX_HEADERS &&
249       curHeader_.type != http2::FrameType::CONTINUATION &&
250       curHeader_.type != http2::FrameType::DATA) \{
251     \textcolor{keywordflow}{return} ErrorCode::NO_ERROR;
252   \}
253 
254   \textcolor{comment}{// do we need to handle case where this stream has already aborted via}
255   \textcolor{comment}{// another callback (onHeadersComplete/onBody)?}
256   pendingEndStreamHandling_ |= (curHeader_.flags & http2::END_STREAM);
257 
258   \textcolor{comment}{// with a websocket upgrade, we need to send message complete cb to}
259   \textcolor{comment}{// mirror h1x codec's behavior. when the stream closes, we need to}
260   \textcolor{comment}{// send another callback to clean up the stream's resources.}
261   \textcolor{keywordflow}{if} (ingressWebsocketUpgrade_) \{
262     ingressWebsocketUpgrade_ = \textcolor{keyword}{false};
263     deliverCallbackIfAllowed(&HTTPCodec::Callback::onMessageComplete,
264                              \textcolor{stringliteral}{"onMessageComplete"}, curHeader_.stream, \textcolor{keyword}{true});
265   \}
266 
267   \textcolor{keywordflow}{if} (pendingEndStreamHandling_ && expectedContinuationStream_ == 0) \{
268     pendingEndStreamHandling_ = \textcolor{keyword}{false};
269     deliverCallbackIfAllowed(&HTTPCodec::Callback::onMessageComplete,
270                              \textcolor{stringliteral}{"onMessageComplete"}, curHeader_.stream, \textcolor{keyword}{false});
271   \}
272   \textcolor{keywordflow}{return} ErrorCode::NO_ERROR;
273 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!handle\+Settings@{handle\+Settings}}
\index{handle\+Settings@{handle\+Settings}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{handle\+Settings(const std\+::deque$<$ Setting\+Pair $>$ \&settings)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::\+H\+T\+T\+P2\+Codec\+::handle\+Settings (
\begin{DoxyParamCaption}
\item[{const std\+::deque$<$ {\bf Setting\+Pair} $>$ \&}]{settings}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a41a22d5a0fa6b3872ea318fb1d434a08}


Definition at line 725 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::callback\+\_\+, cur\+Header\+\_\+, egress\+Settings\+\_\+, proxygen\+::\+E\+N\+A\+B\+L\+E\+\_\+\+C\+O\+N\+N\+E\+C\+T\+\_\+\+P\+R\+O\+T\+O\+C\+OL, proxygen\+::\+E\+N\+A\+B\+L\+E\+\_\+\+E\+X\+\_\+\+H\+E\+A\+D\+E\+RS, proxygen\+::\+E\+N\+A\+B\+L\+E\+\_\+\+P\+U\+SH, proxygen\+::\+H\+T\+T\+P\+Settings\+::get\+Setting(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::get\+Transport\+Direction(), proxygen\+::get\+Transport\+Direction\+String(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::goaway\+Error\+Message\+\_\+, proxygen\+::\+H\+E\+A\+D\+E\+R\+\_\+\+T\+A\+B\+L\+E\+\_\+\+S\+I\+ZE, header\+Codec\+\_\+, ingress\+Settings\+\_\+, proxygen\+::\+I\+N\+I\+T\+I\+A\+L\+\_\+\+W\+I\+N\+D\+O\+W\+\_\+\+S\+I\+ZE, proxygen\+::http2\+::k\+Max\+Frame\+Payload\+Length, proxygen\+::http2\+::k\+Max\+Frame\+Payload\+Length\+Min, proxygen\+::http2\+::k\+Max\+Header\+Table\+Size, proxygen\+::http2\+::k\+Max\+Window\+Update\+Size, proxygen\+::\+M\+A\+X\+\_\+\+C\+O\+N\+C\+U\+R\+R\+E\+N\+T\+\_\+\+S\+T\+R\+E\+A\+MS, proxygen\+::\+M\+A\+X\+\_\+\+F\+R\+A\+M\+E\+\_\+\+S\+I\+ZE, proxygen\+::\+M\+A\+X\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+L\+I\+S\+T\+\_\+\+S\+I\+ZE, proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Settings(), proxygen\+::\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+P\+A\+C\+K\+Codec\+::set\+Encoder\+Header\+Table\+Size(), proxygen\+::\+H\+T\+T\+P\+Settings\+::set\+Setting(), proxygen\+::\+S\+E\+T\+T\+I\+N\+G\+S\+\_\+\+H\+T\+T\+P\+\_\+\+C\+E\+R\+T\+\_\+\+A\+U\+TH, proxygen\+::http2\+::\+Frame\+Header\+::stream, proxygen\+::\+T\+H\+R\+I\+F\+T\+\_\+\+C\+H\+A\+N\+N\+E\+L\+\_\+\+ID, proxygen\+::\+T\+H\+R\+I\+F\+T\+\_\+\+C\+H\+A\+N\+N\+E\+L\+\_\+\+I\+D\+\_\+\+D\+E\+P\+R\+E\+C\+A\+T\+ED, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::transport\+Direction\+\_\+, and proxygen\+::\+U\+P\+S\+T\+R\+E\+AM.



Referenced by get\+Header\+Indexing\+Strategy(), on\+Ingress\+Upgrade\+Message(), and parse\+Settings().


\begin{DoxyCode}
725                                                                           \{
726   SettingsList settingsList;
727   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}& setting: settings) \{
728     \textcolor{keywordflow}{switch} (setting.first) \{
729       \textcolor{keywordflow}{case} SettingsId::HEADER_TABLE_SIZE:
730       \{
731         uint32\_t tableSize = setting.second;
732         \textcolor{keywordflow}{if} (setting.second > http2::kMaxHeaderTableSize) \{
733           VLOG(2) << \textcolor{stringliteral}{"Limiting table size from "} << tableSize << \textcolor{stringliteral}{" to "} <<
734             http2::kMaxHeaderTableSize;
735           tableSize = http2::kMaxHeaderTableSize;
736         \}
737         headerCodec_.setEncoderHeaderTableSize(tableSize);
738       \}
739       \textcolor{keywordflow}{break};
740       \textcolor{keywordflow}{case} SettingsId::ENABLE_PUSH:
741         \textcolor{keywordflow}{if} ((setting.second != 0 && setting.second != 1) ||
742             (setting.second == 1 &&
743              transportDirection_ == TransportDirection::UPSTREAM)) \{
744           goawayErrorMessage_ = folly::to<string>(
745               \textcolor{stringliteral}{"GOAWAY error: ENABLE\_PUSH invalid setting="}, setting.second,
746               \textcolor{stringliteral}{" for streamID="}, curHeader_.stream);
747           VLOG(4) << goawayErrorMessage_;
748           \textcolor{keywordflow}{return} ErrorCode::PROTOCOL_ERROR;
749         \}
750         \textcolor{keywordflow}{break};
751       \textcolor{keywordflow}{case} SettingsId::MAX_CONCURRENT_STREAMS:
752         \textcolor{keywordflow}{break};
753       \textcolor{keywordflow}{case} SettingsId::INITIAL_WINDOW_SIZE:
754         \textcolor{keywordflow}{if} (setting.second > http2::kMaxWindowUpdateSize) \{
755           goawayErrorMessage_ = folly::to<string>(
756               \textcolor{stringliteral}{"GOAWAY error: INITIAL\_WINDOW\_SIZE invalid size="}, setting.second,
757               \textcolor{stringliteral}{" for streamID="}, curHeader_.stream);
758           VLOG(4) << goawayErrorMessage_;
759           \textcolor{keywordflow}{return} ErrorCode::PROTOCOL_ERROR;
760         \}
761         \textcolor{keywordflow}{break};
762       \textcolor{keywordflow}{case} SettingsId::MAX_FRAME_SIZE:
763         \textcolor{keywordflow}{if} (setting.second < http2::kMaxFramePayloadLengthMin ||
764             setting.second > http2::kMaxFramePayloadLength) \{
765           goawayErrorMessage_ = folly::to<string>(
766               \textcolor{stringliteral}{"GOAWAY error: MAX\_FRAME\_SIZE invalid size="}, setting.second,
767               \textcolor{stringliteral}{" for streamID="}, curHeader_.stream);
768           VLOG(4) << goawayErrorMessage_;
769           \textcolor{keywordflow}{return} ErrorCode::PROTOCOL_ERROR;
770         \}
771         ingressSettings_.setSetting(SettingsId::MAX_FRAME_SIZE, setting.second);
772         \textcolor{keywordflow}{break};
773       \textcolor{keywordflow}{case} SettingsId::MAX_HEADER_LIST_SIZE:
774         \textcolor{keywordflow}{break};
775       \textcolor{keywordflow}{case} SettingsId::ENABLE_EX_HEADERS:
776       \{
777         \textcolor{keyword}{auto} ptr = egressSettings_.getSetting(SettingsId::ENABLE_EX_HEADERS);
778         \textcolor{keywordflow}{if} (ptr && ptr->value > 0) \{
779           VLOG(4) << getTransportDirectionString(getTransportDirection())
780                   << \textcolor{stringliteral}{" got ENABLE\_EX\_HEADERS="} << setting.second;
781           \textcolor{keywordflow}{if} (setting.second != 0 && setting.second != 1) \{
782             goawayErrorMessage_ = folly::to<string>(
783               \textcolor{stringliteral}{"GOAWAY error: invalid ENABLE\_EX\_HEADERS="}, setting.second,
784               \textcolor{stringliteral}{" for streamID="}, curHeader_.stream);
785             VLOG(4) << goawayErrorMessage_;
786             \textcolor{keywordflow}{return} ErrorCode::PROTOCOL_ERROR;
787           \}
788           \textcolor{keywordflow}{break};
789         \} \textcolor{keywordflow}{else} \{
790           \textcolor{comment}{// egress ENABLE\_EX\_HEADERS is disabled, consider the ingress}
791           \textcolor{comment}{// ENABLE\_EX\_HEADERS as unknown setting, and ignore it.}
792           \textcolor{keywordflow}{continue};
793         \}
794       \}
795       \textcolor{keywordflow}{case} SettingsId::ENABLE_CONNECT_PROTOCOL:
796         \textcolor{keywordflow}{if} (setting.second > 1) \{
797           goawayErrorMessage_ = folly::to<string>(
798               \textcolor{stringliteral}{"GOAWAY error: ENABLE\_CONNECT\_PROTOCOL invalid number="},
799               setting.second, \textcolor{stringliteral}{" for streamID="}, curHeader_.stream);
800           VLOG(4) << goawayErrorMessage_;
801           \textcolor{keywordflow}{return} ErrorCode::PROTOCOL_ERROR;
802         \}
803         \textcolor{keywordflow}{break};
804       \textcolor{keywordflow}{case} SettingsId::THRIFT_CHANNEL_ID:
805       \textcolor{keywordflow}{case} SettingsId::THRIFT_CHANNEL_ID_DEPRECATED:
806         \textcolor{keywordflow}{break};
807       \textcolor{keywordflow}{case} SettingsId::SETTINGS_HTTP_CERT_AUTH:
808         \textcolor{keywordflow}{break};
809       \textcolor{keywordflow}{default}:
810         \textcolor{keywordflow}{continue}; \textcolor{comment}{// ignore unknown setting}
811     \}
812     ingressSettings_.setSetting(setting.first, setting.second);
813     settingsList.push\_back(*ingressSettings_.getSetting(setting.first));
814   \}
815   \textcolor{keywordflow}{if} (callback_) \{
816     callback_->onSettings(settingsList);
817   \}
818   \textcolor{keywordflow}{return} ErrorCode::NO_ERROR;
819 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!handle\+Settings\+Ack@{handle\+Settings\+Ack}}
\index{handle\+Settings\+Ack@{handle\+Settings\+Ack}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{handle\+Settings\+Ack()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P2\+Codec\+::handle\+Settings\+Ack (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a4e7313c1e8e94d799957bc638fde479c}


Definition at line 715 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::callback\+\_\+, header\+Codec\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Settings\+Ack(), pending\+Table\+Max\+Size\+\_\+, and proxygen\+::\+H\+P\+A\+C\+K\+Codec\+::set\+Decoder\+Header\+Table\+Max\+Size().



Referenced by get\+Header\+Indexing\+Strategy(), and parse\+Settings().


\begin{DoxyCode}
715                                    \{
716   \textcolor{keywordflow}{if} (pendingTableMaxSize_) \{
717     headerCodec_.setDecoderHeaderTableMaxSize(*pendingTableMaxSize_);
718     pendingTableMaxSize_ = folly::none;
719   \}
720   \textcolor{keywordflow}{if} (callback_) \{
721     callback_->onSettingsAck();
722   \}
723 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!is\+Request@{is\+Request}}
\index{is\+Request@{is\+Request}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{is\+Request(\+Stream\+I\+D id) const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P2\+Codec\+::is\+Request (
\begin{DoxyParamCaption}
\item[{{\bf Stream\+ID}}]{id}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HTTP2Codec_adbaa418d913d844f6bef8e14ca5894d6}


Definition at line 138 of file H\+T\+T\+P2\+Codec.\+h.



References add\+Priority\+Nodes(), proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, map\+Priority\+To\+Dependency(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::transport\+Direction\+\_\+, and proxygen\+::\+U\+P\+S\+T\+R\+E\+AM.



Referenced by parse\+Ex\+Headers(), and parse\+Headers\+Decode\+Frames().


\begin{DoxyCode}
138                                     \{
139     \textcolor{keywordflow}{return} ((transportDirection_ == TransportDirection::DOWNSTREAM &&
140              (\textcolor{keywordtype}{id} & 0x1) == 1) ||
141             (transportDirection_ == TransportDirection::UPSTREAM &&
142              (\textcolor{keywordtype}{id} & 0x1) == 0));
143   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!map\+Priority\+To\+Dependency@{map\+Priority\+To\+Dependency}}
\index{map\+Priority\+To\+Dependency@{map\+Priority\+To\+Dependency}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{map\+Priority\+To\+Dependency(uint8\+\_\+t priority) const override}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} proxygen\+::\+H\+T\+T\+P2\+Codec\+::map\+Priority\+To\+Dependency (
\begin{DoxyParamCaption}
\item[{uint8\+\_\+t}]{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_a11798c1963d0a7e4b4eb670dcc7e037d}
Map the given linear priority to the correct parent node dependency 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_ad3f2df6e146618da881c36c5bd68c7e3}.



Definition at line 1643 of file H\+T\+T\+P2\+Codec.\+cpp.



References virtual\+Priority\+Nodes\+\_\+.



Referenced by is\+Request().


\begin{DoxyCode}
1643                                                           \{
1644   \textcolor{comment}{// If the priority is out of the maximum index of virtual nodes array, we}
1645   \textcolor{comment}{// return the lowest level virtual node as a punishment of not setting}
1646   \textcolor{comment}{// priority correctly.}
1647   \textcolor{keywordflow}{return} virtualPriorityNodes_.empty()
1648     ? 0
1649     : virtualPriorityNodes_[
1650         std::min(priority, uint8\_t(virtualPriorityNodes_.size() - 1))];
1651 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!max\+Recv\+Frame\+Size@{max\+Recv\+Frame\+Size}}
\index{max\+Recv\+Frame\+Size@{max\+Recv\+Frame\+Size}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{max\+Recv\+Frame\+Size() const }]{\setlength{\rightskip}{0pt plus 5cm}uint32\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::max\+Recv\+Frame\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a3926598ce62a96b2db26f69aaf986d7e}


Definition at line 234 of file H\+T\+T\+P2\+Codec.\+h.



References egress\+Settings\+\_\+, proxygen\+::\+H\+T\+T\+P\+Settings\+::get\+Setting(), proxygen\+::http2\+::k\+Max\+Frame\+Payload\+Length\+Min, proxygen\+::\+M\+A\+X\+\_\+\+F\+R\+A\+M\+E\+\_\+\+S\+I\+ZE, parsing\+Trailers(), and stream\+Error().



Referenced by on\+Ingress().


\begin{DoxyCode}
234                                     \{
235     \textcolor{keywordflow}{return} (uint32\_t)egressSettings_.getSetting(SettingsId::MAX_FRAME_SIZE,
236                                       http2::kMaxFramePayloadLengthMin);
237   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!max\+Send\+Frame\+Size@{max\+Send\+Frame\+Size}}
\index{max\+Send\+Frame\+Size@{max\+Send\+Frame\+Size}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{max\+Send\+Frame\+Size() const }]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::max\+Send\+Frame\+Size (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_ac36011bbbfe9faced640ac98d637bc76}


Definition at line 230 of file H\+T\+T\+P2\+Codec.\+h.



References proxygen\+::\+H\+T\+T\+P\+Settings\+::get\+Setting(), ingress\+Settings\+\_\+, proxygen\+::http2\+::k\+Max\+Frame\+Payload\+Length\+Min, and proxygen\+::\+M\+A\+X\+\_\+\+F\+R\+A\+M\+E\+\_\+\+S\+I\+ZE.



Referenced by generate\+Body(), generate\+Certificate(), generate\+Header\+Impl(), and generate\+Trailers().


\begin{DoxyCode}
230                                   \{
231     \textcolor{keywordflow}{return} (uint32\_t)ingressSettings_.getSetting(SettingsId::MAX_FRAME_SIZE,
232                                        http2::kMaxFramePayloadLengthMin);
233   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!on\+Decode\+Error@{on\+Decode\+Error}}
\index{on\+Decode\+Error@{on\+Decode\+Error}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{on\+Decode\+Error(\+H\+P\+A\+C\+K\+::\+Decode\+Error decode\+Error) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P2\+Codec\+::on\+Decode\+Error (
\begin{DoxyParamCaption}
\item[{{\bf H\+P\+A\+C\+K\+::\+Decode\+Error}}]{decode\+Error}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_a4a88a40aa078ed14676fb88e855beee2}


Implements {\bf proxygen\+::\+H\+P\+A\+C\+K\+::\+Streaming\+Callback} \doxyref{}{p.}{classproxygen_1_1HPACK_1_1StreamingCallback_a4ae06a3524ba64174bc6b9fb5dc4f09f}.



Definition at line 643 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+Header\+Decode\+Info\+::decode\+Error, and decode\+Info\+\_\+.


\begin{DoxyCode}
643                                                            \{
644   decodeInfo_.decodeError = decodeError;
645 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!on\+Header@{on\+Header}}
\index{on\+Header@{on\+Header}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{on\+Header(const folly\+::fbstring \&name, const folly\+::fbstring \&value) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P2\+Codec\+::on\+Header (
\begin{DoxyParamCaption}
\item[{const folly\+::fbstring \&}]{name, }
\item[{const folly\+::fbstring \&}]{value}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_aa9c0130a08f0a30fcd8bc6061d1b396b}


Implements {\bf proxygen\+::\+H\+P\+A\+C\+K\+::\+Streaming\+Callback} \doxyref{}{p.}{classproxygen_1_1HPACK_1_1StreamingCallback_a4e98f0e581dbb03435a818b92350da89}.



Definition at line 602 of file H\+T\+T\+P2\+Codec.\+cpp.



References decode\+Info\+\_\+, header\+Codec\+\_\+, proxygen\+::\+Header\+Decode\+Info\+::on\+Header(), proxygen\+::\+Header\+Decode\+Info\+::parsing\+Error, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::transport\+Direction\+\_\+, and user\+Agent\+\_\+.


\begin{DoxyCode}
603                                                       \{
604   \textcolor{keywordflow}{if} (decodeInfo_.onHeader(name, value)) \{
605     \textcolor{keywordflow}{if} (name == \textcolor{stringliteral}{"user-agent"} && userAgent_.empty()) \{
606       userAgent_ = value.toStdString();
607     \}
608   \} \textcolor{keywordflow}{else} \{
609     VLOG(4) << \textcolor{stringliteral}{"dir="} << uint32\_t(transportDirection_) <<
610       decodeInfo_.parsingError << \textcolor{stringliteral}{" codec="} << headerCodec_;
611   \}
612 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!on\+Headers\+Complete@{on\+Headers\+Complete}}
\index{on\+Headers\+Complete@{on\+Headers\+Complete}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{on\+Headers\+Complete(\+H\+T\+T\+P\+Header\+Size decoded\+Size, bool acknowledge) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P2\+Codec\+::on\+Headers\+Complete (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Header\+Size}}]{decoded\+Size, }
\item[{bool}]{acknowledge}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_af156831a61f0c48cc4678100694a7b47}


Implements {\bf proxygen\+::\+H\+P\+A\+C\+K\+::\+Streaming\+Callback} \doxyref{}{p.}{classproxygen_1_1HPACK_1_1StreamingCallback_a597eeb4d7fbe2013339317459f2520ed}.



Definition at line 614 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+C\+O\+N\+N\+E\+CT, cur\+Header\+\_\+, decode\+Info\+\_\+, proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Method(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Status\+Code(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Upgrade\+Protocol(), proxygen\+::\+H\+T\+T\+P\+Request\+Verifier\+::has\+Upgrade\+Protocol(), ingress\+Websocket\+Upgrade\+\_\+, proxygen\+::http2\+::k\+Protocol\+String, proxygen\+::headers\+::k\+Websocket\+String, proxygen\+::\+Header\+Decode\+Info\+::msg, proxygen\+::\+Header\+Decode\+Info\+::on\+Headers\+Complete(), proxygen\+::\+Header\+Decode\+Info\+::parsing\+Error, proxygen\+::\+H\+T\+T\+P\+Message\+::set\+Ingress\+Websocket\+Upgrade(), proxygen\+::http2\+::\+Frame\+Header\+::stream, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::transport\+Direction\+\_\+, upgraded\+Streams\+\_\+, and proxygen\+::\+Header\+Decode\+Info\+::verifier.


\begin{DoxyCode}
615                                            \{
616   decodeInfo_.onHeadersComplete(decodedSize);
617   decodeInfo_.msg->setAdvancedProtocolString(http2::kProtocolString);
618 
619   HTTPMessage* msg = decodeInfo_.msg.get();
620   HTTPRequestVerifier& verifier = decodeInfo_.verifier;
621   \textcolor{keywordflow}{if} ((transportDirection_ == TransportDirection::DOWNSTREAM) &&
622       verifier.hasUpgradeProtocol() &&
623       (*msg->getUpgradeProtocol() == headers::kWebsocketString) &&
624       msg->getMethod() == HTTPMethod::CONNECT) \{
625     msg->setIngressWebsocketUpgrade();
626     ingressWebsocketUpgrade_ = \textcolor{keyword}{true};
627   \} \textcolor{keywordflow}{else} \{
628     \textcolor{keyword}{auto} it = upgradedStreams_.find(curHeader_.stream);
629     \textcolor{keywordflow}{if} (it != upgradedStreams_.end()) \{
630       upgradedStreams_.erase(curHeader_.stream);
631       \textcolor{comment}{// a websocket upgrade was sent on this stream.}
632       \textcolor{keywordflow}{if} (msg->getStatusCode() != 200) \{
633         decodeInfo_.parsingError =
634           folly::to<string>(\textcolor{stringliteral}{"Invalid response code to a websocket upgrade: "},
635                             msg->getStatusCode());
636         \textcolor{keywordflow}{return};
637       \}
638       msg->setIngressWebsocketUpgrade();
639     \}
640   \}
641 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!on\+Ingress@{on\+Ingress}}
\index{on\+Ingress@{on\+Ingress}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{on\+Ingress(const folly\+::\+I\+O\+Buf \&buf) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::on\+Ingress (
\begin{DoxyParamCaption}
\item[{const folly\+::\+I\+O\+Buf \&}]{buf}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_a3611c7bd4f23c055ee31d983e4f9aefa}
Parse ingress data. 
\begin{DoxyParams}{Parameters}
{\em buf} & A single I\+O\+Buf of data to parse \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of bytes consumed. 
\end{DoxyReturn}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a44a623c547735db83ae472ba7f1af6df}.



Definition at line 64 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::callback\+\_\+, check\+Connection\+Error(), cur\+Header\+\_\+, proxygen\+::http2\+::\+D\+A\+TA, proxygen\+::http2\+::\+Frame\+Header\+::flags, proxygen\+::\+F\+R\+A\+M\+E\+\_\+\+S\+I\+Z\+E\+\_\+\+E\+R\+R\+OR, frame\+State\+\_\+, proxygen\+::http2\+::get\+Frame\+Type\+String(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::goaway\+Error\+Message\+\_\+, proxygen\+::http2\+::k\+Connection\+Preface, proxygen\+::http2\+::k\+Frame\+Header\+Size, proxygen\+::http2\+::\+Frame\+Header\+::length, max\+Recv\+Frame\+Size(), proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Frame\+Header(), parse\+Data\+Frame\+Data(), parse\+Frame(), proxygen\+::http2\+::parse\+Frame\+Header(), pending\+Data\+Frame\+Bytes\+\_\+, pending\+Data\+Frame\+Padding\+Bytes\+\_\+, proxygen\+::\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, received\+Frame\+Count\+\_\+, proxygen\+::http2\+::\+S\+E\+T\+T\+I\+N\+GS, proxygen\+::http2\+::\+Frame\+Header\+::stream, and proxygen\+::http2\+::\+Frame\+Header\+::type.



Referenced by get\+User\+Agent().


\begin{DoxyCode}
64                                                   \{
65   \textcolor{comment}{// TODO: ensure only 1 parse at a time on stack.}
66   FOLLY\_SCOPED\_TRACE\_SECTION(\textcolor{stringliteral}{"HTTP2Codec - onIngress"});
67 
68   Cursor cursor(&buf);
69   \textcolor{keywordtype}{size\_t} parsed = 0;
70   ErrorCode connError = ErrorCode::NO_ERROR;
71   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} bufLen = cursor.totalLength();
72        connError == ErrorCode::NO_ERROR;
73        bufLen = cursor.totalLength()) \{
74     \textcolor{keywordflow}{if} (frameState_ == FrameState::UPSTREAM\_CONNECTION\_PREFACE) \{
75       \textcolor{keywordflow}{if} (bufLen >= http2::kConnectionPreface.length()) \{
76         \textcolor{keyword}{auto} test = cursor.readFixedString(http2::kConnectionPreface.length());
77         parsed += http2::kConnectionPreface.length();
78         \textcolor{keywordflow}{if} (test != http2::kConnectionPreface) \{
79           goawayErrorMessage_ = \textcolor{stringliteral}{"missing connection preface"};
80           VLOG(4) << goawayErrorMessage_;
81           connError = ErrorCode::PROTOCOL_ERROR;
82         \}
83         frameState_ = FrameState::FRAME\_HEADER;
84       \} \textcolor{keywordflow}{else} \{
85         \textcolor{keywordflow}{break};
86       \}
87     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (frameState_ == FrameState::FRAME\_HEADER ||
88                frameState_ == FrameState::DOWNSTREAM\_CONNECTION\_PREFACE) \{
89       \textcolor{comment}{// Waiting to parse the common frame header}
90       \textcolor{keywordflow}{if} (bufLen >= http2::kFrameHeaderSize) \{
91         connError = parseFrameHeader(cursor, curHeader_);
92         parsed += http2::kFrameHeaderSize;
93         \textcolor{keywordflow}{if} (frameState_ == FrameState::DOWNSTREAM\_CONNECTION\_PREFACE &&
94             curHeader_.type != http2::FrameType::SETTINGS) \{
95           goawayErrorMessage_ = folly::to<string>(
96               \textcolor{stringliteral}{"GOAWAY error: got invalid connection preface frame type="},
97               getFrameTypeString(curHeader_.type), \textcolor{stringliteral}{"("}, curHeader_.type, \textcolor{stringliteral}{")"},
98               \textcolor{stringliteral}{" for streamID="}, curHeader_.stream);
99           VLOG(4) << goawayErrorMessage_;
100           connError = ErrorCode::PROTOCOL_ERROR;
101         \}
102         \textcolor{keywordflow}{if} (curHeader_.length > maxRecvFrameSize()) \{
103           VLOG(4) << \textcolor{stringliteral}{"Excessively large frame len="} << curHeader_.length;
104           connError = ErrorCode::FRAME_SIZE_ERROR;
105         \}
106 
107         \textcolor{keywordflow}{if} (callback_) \{
108           callback_->onFrameHeader(
109             curHeader_.stream,
110             curHeader_.flags,
111             curHeader_.length,
112             static\_cast<uint8\_t>(curHeader_.type));
113         \}
114 
115         frameState_ = (curHeader_.type == http2::FrameType::DATA) ?
116           FrameState::DATA\_FRAME\_DATA : FrameState::FRAME\_DATA;
117         pendingDataFrameBytes_ = curHeader_.length;
118         pendingDataFramePaddingBytes_ = 0;
119 \textcolor{preprocessor}{#ifndef NDEBUG}
120         receivedFrameCount_++;
121 \textcolor{preprocessor}{#endif}
122       \} \textcolor{keywordflow}{else} \{
123         \textcolor{keywordflow}{break};
124       \}
125     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (frameState_ == FrameState::DATA\_FRAME\_DATA && bufLen > 0 &&
126                (bufLen < curHeader_.length ||
127                 pendingDataFrameBytes_ < curHeader_.length)) \{
128       \textcolor{comment}{// FrameState::DATA\_FRAME\_DATA with partial data only}
129       \textcolor{keywordtype}{size\_t} dataParsed = 0;
130       connError = parseDataFrameData(cursor, bufLen, dataParsed);
131       \textcolor{keywordflow}{if} (dataParsed == 0 && pendingDataFrameBytes_ > 0) \{
132         \textcolor{comment}{// We received only the padding byte, we will wait for more}
133         \textcolor{keywordflow}{break};
134       \} \textcolor{keywordflow}{else} \{
135         parsed += dataParsed;
136         \textcolor{keywordflow}{if} (pendingDataFrameBytes_ == 0) \{
137           frameState_ = FrameState::FRAME\_HEADER;
138         \}
139       \}
140     \} \textcolor{keywordflow}{else} \{ \textcolor{comment}{// FrameState::FRAME\_DATA}
141              \textcolor{comment}{// or FrameState::DATA\_FRAME\_DATA with all data available}
142       \textcolor{comment}{// Already parsed the common frame header}
143       \textcolor{keyword}{const} \textcolor{keyword}{auto} frameLen = curHeader_.length;
144       \textcolor{keywordflow}{if} (bufLen >= frameLen) \{
145         connError = parseFrame(cursor);
146         parsed += curHeader_.length;
147         frameState_ = FrameState::FRAME\_HEADER;
148       \} \textcolor{keywordflow}{else} \{
149         \textcolor{keywordflow}{break};
150       \}
151     \}
152   \}
153   checkConnectionError(connError, &buf);
154   \textcolor{keywordflow}{return} parsed;
155 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!on\+Ingress\+Upgrade\+Message@{on\+Ingress\+Upgrade\+Message}}
\index{on\+Ingress\+Upgrade\+Message@{on\+Ingress\+Upgrade\+Message}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{on\+Ingress\+Upgrade\+Message(const H\+T\+T\+P\+Message \&msg) override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P2\+Codec\+::on\+Ingress\+Upgrade\+Message (
\begin{DoxyParamCaption}
\item[{const {\bf H\+T\+T\+P\+Message} \&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_a01c0d94750190f9cf0fb2cacc56cf065}
Invoked on a codec that has been upgraded to via an \doxyref{H\+T\+T\+P\+Message}{p.}{classproxygen_1_1HTTPMessage} on a different codec. The codec may return false to halt the upgrade. 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a1118801488cb642470f5a21c1ffb371d}.



Definition at line 1015 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), proxygen\+::\+H\+T\+T\+P\+Headers\+::get\+Number\+Of\+Values(), proxygen\+::\+H\+T\+T\+P\+Headers\+::get\+Single\+Or\+Empty(), handle\+Settings(), proxygen\+::http2\+::k\+Max\+Frame\+Payload\+Length, proxygen\+::http2\+::k\+Protocol\+Settings\+Header, proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::on\+Ingress\+Upgrade\+Message(), proxygen\+::http2\+::parse\+Settings(), proxygen\+::http2\+::\+S\+E\+T\+T\+I\+N\+GS, and settings.



Referenced by get\+User\+Agent().


\begin{DoxyCode}
1015                                                                \{
1016   \textcolor{keywordflow}{if} (!HTTPParallelCodec::onIngressUpgradeMessage(msg)) \{
1017     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1018   \}
1019   \textcolor{keywordflow}{if} (msg.getHeaders().getNumberOfValues(http2::kProtocolSettingsHeader) != 1) \{
1020     VLOG(4) << \_\_func\_\_ << \textcolor{stringliteral}{" with no HTTP2-Settings"};
1021     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1022   \}
1023 
1024   \textcolor{keyword}{const} \textcolor{keyword}{auto}& settingsHeader = msg.getHeaders().getSingleOrEmpty(
1025     http2::kProtocolSettingsHeader);
1026   \textcolor{keywordflow}{if} (settingsHeader.empty()) \{
1027     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1028   \}
1029 
1030   \textcolor{keyword}{auto} decoded = base64url\_decode(settingsHeader);
1031 
1032   \textcolor{comment}{// Must be well formed Base64Url and not too large}
1033   \textcolor{keywordflow}{if} (decoded.empty() || decoded.length() > http2::kMaxFramePayloadLength) \{
1034     VLOG(4) << \_\_func\_\_ << \textcolor{stringliteral}{" failed to decode HTTP2-Settings"};
1035     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1036   \}
1037   std::unique\_ptr<IOBuf> decodedBuf = IOBuf::wrapBuffer(decoded.data(),
1038                                                         decoded.length());
1039   IOBufQueue settingsQueue\{IOBufQueue::cacheChainLength()\};
1040   settingsQueue.append(std::move(decodedBuf));
1041   Cursor c(settingsQueue.front());
1042   std::deque<SettingPair> settings;
1043   \textcolor{comment}{// downcast is ok because of above length check}
1044   http2::FrameHeader frameHeader\{
1045     (uint32\_t)settingsQueue.chainLength(), 0, http2::FrameType::SETTINGS, 0, 0\};
1046   \textcolor{keyword}{auto} err = http2::parseSettings(c, frameHeader, settings);
1047   \textcolor{keywordflow}{if} (err != ErrorCode::NO_ERROR) \{
1048     VLOG(4) << \_\_func\_\_ << \textcolor{stringliteral}{" bad settings frame"};
1049     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1050   \}
1051 
1052   \textcolor{keywordflow}{if} (handleSettings(settings) != ErrorCode::NO_ERROR) \{
1053     VLOG(4) << \_\_func\_\_ << \textcolor{stringliteral}{" handleSettings failed"};
1054     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1055   \}
1056 
1057   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
1058 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!parse\+All\+Data@{parse\+All\+Data}}
\index{parse\+All\+Data@{parse\+All\+Data}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{parse\+All\+Data(folly\+::io\+::\+Cursor \&cursor)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+All\+Data (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a13a5477d00ba1bb2dbbd1920b559d6ce}


Definition at line 275 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::callback\+\_\+, cur\+Header\+\_\+, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::deliver\+Callback\+If\+Allowed(), handle\+End\+Stream(), proxygen\+::http2\+::\+Frame\+Header\+::length, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Body(), proxygen\+::http2\+::parse\+Data(), R\+E\+T\+U\+R\+N\+\_\+\+I\+F\+\_\+\+E\+R\+R\+OR, and proxygen\+::http2\+::\+Frame\+Header\+::stream.



Referenced by get\+Header\+Indexing\+Strategy(), and parse\+Frame().


\begin{DoxyCode}
275                                                  \{
276   std::unique\_ptr<IOBuf> outData;
277   uint16\_t padding = 0;
278   VLOG(10) << \textcolor{stringliteral}{"parsing all frame DATA bytes for stream="} << curHeader_.stream <<
279     \textcolor{stringliteral}{" length="} << curHeader_.length;
280   \textcolor{keyword}{auto} ret = http2::parseData(cursor, curHeader_, outData, padding);
281   RETURN_IF_ERROR(ret);
282 
283   \textcolor{keywordflow}{if} (callback_ && (padding > 0 || (outData && !outData->empty()))) \{
284     \textcolor{keywordflow}{if} (!outData) \{
285       outData = std::make\_unique<IOBuf>();
286     \}
287     deliverCallbackIfAllowed(&HTTPCodec::Callback::onBody, \textcolor{stringliteral}{"onBody"},
288                              curHeader_.stream, std::move(outData), padding);
289   \}
290   \textcolor{keywordflow}{return} handleEndStream();
291 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!parse\+Certificate@{parse\+Certificate}}
\index{parse\+Certificate@{parse\+Certificate}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{parse\+Certificate(folly\+::io\+::\+Cursor \&cursor)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Certificate (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_ac595f3a54e0c69c7c6e919d00f5257b3}


Definition at line 949 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::callback\+\_\+, cur\+Authenticator\+Block\+\_\+, cur\+Cert\+Id\+\_\+, cur\+Header\+\_\+, proxygen\+::http2\+::\+Frame\+Header\+::flags, proxygen\+::http2\+::k\+Max\+Authenticator\+Buf\+Size, proxygen\+::http2\+::\+Frame\+Header\+::length, proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Certificate(), proxygen\+::http2\+::parse\+Certificate(), proxygen\+::\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, R\+E\+T\+U\+R\+N\+\_\+\+I\+F\+\_\+\+E\+R\+R\+OR, and proxygen\+::http2\+::\+T\+O\+\_\+\+B\+E\+\_\+\+C\+O\+N\+T\+I\+N\+U\+ED.



Referenced by get\+Header\+Indexing\+Strategy(), and parse\+Frame().


\begin{DoxyCode}
949                                                      \{
950   VLOG(4) << \textcolor{stringliteral}{"parsing CERTIFICATE frame length="} << curHeader_.length;
951   uint16\_t certId = 0;
952   std::unique\_ptr<IOBuf> authData;
953   \textcolor{keyword}{auto} err = http2::parseCertificate(cursor, curHeader_, certId, authData);
954   RETURN_IF_ERROR(err);
955   \textcolor{keywordflow}{if} (curAuthenticatorBlock_.empty()) \{
956     curCertId_ = certId;
957   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (certId != curCertId_) \{
958     \textcolor{comment}{// Received CERTIFICATE frame with different Cert-ID.}
959     \textcolor{keywordflow}{return} ErrorCode::PROTOCOL_ERROR;
960   \}
961   curAuthenticatorBlock_.append(std::move(authData));
962   \textcolor{keywordflow}{if} (curAuthenticatorBlock_.chainLength() > http2::kMaxAuthenticatorBufSize) \{
963     \textcolor{comment}{// Received excessively long authenticator.}
964     \textcolor{keywordflow}{return} ErrorCode::PROTOCOL_ERROR;
965   \}
966   \textcolor{keywordflow}{if} (!(curHeader_.flags & http2::TO_BE_CONTINUED)) \{
967     \textcolor{keyword}{auto} authenticator = curAuthenticatorBlock_.move();
968     \textcolor{keywordflow}{if} (callback_) \{
969       callback_->onCertificate(certId, std::move(authenticator));
970     \} \textcolor{keywordflow}{else} \{
971       curAuthenticatorBlock_.clear();
972     \}
973   \}
974   \textcolor{keywordflow}{return} ErrorCode::NO_ERROR;
975 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!parse\+Certificate\+Request@{parse\+Certificate\+Request}}
\index{parse\+Certificate\+Request@{parse\+Certificate\+Request}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{parse\+Certificate\+Request(folly\+::io\+::\+Cursor \&cursor)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Certificate\+Request (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_ad63fdccefa25930e3ff2a83ff86064f4}


Definition at line 935 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::callback\+\_\+, cur\+Header\+\_\+, proxygen\+::http2\+::\+Frame\+Header\+::length, proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Certificate\+Request(), proxygen\+::http2\+::parse\+Certificate\+Request(), and R\+E\+T\+U\+R\+N\+\_\+\+I\+F\+\_\+\+E\+R\+R\+OR.



Referenced by get\+Header\+Indexing\+Strategy(), and parse\+Frame().


\begin{DoxyCode}
935                                                             \{
936   VLOG(4) << \textcolor{stringliteral}{"parsing CERTIFICATE\_REQUEST frame length="} << curHeader_.length;
937   uint16\_t requestId = 0;
938   std::unique\_ptr<IOBuf> authRequest;
939 
940   \textcolor{keyword}{auto} err = http2::parseCertificateRequest(
941       cursor, curHeader_, requestId, authRequest);
942   RETURN_IF_ERROR(err);
943   \textcolor{keywordflow}{if} (callback_) \{
944     callback_->onCertificateRequest(requestId, std::move(authRequest));
945   \}
946   \textcolor{keywordflow}{return} ErrorCode::NO_ERROR;
947 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!parse\+Continuation@{parse\+Continuation}}
\index{parse\+Continuation@{parse\+Continuation}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{parse\+Continuation(folly\+::io\+::\+Cursor \&cursor)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Continuation (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_ab4a28add1ab8a46c95ffbbf218eed230}


Definition at line 407 of file H\+T\+T\+P2\+Codec.\+cpp.



References cur\+Header\+\_\+, proxygen\+::http2\+::\+Frame\+Header\+::length, proxygen\+::http2\+::parse\+Continuation(), parse\+Headers\+Impl(), R\+E\+T\+U\+R\+N\+\_\+\+I\+F\+\_\+\+E\+R\+R\+OR, and proxygen\+::http2\+::\+Frame\+Header\+::stream.



Referenced by get\+Header\+Indexing\+Strategy(), and parse\+Frame().


\begin{DoxyCode}
407                                                       \{
408   std::unique\_ptr<IOBuf> headerBuf;
409   VLOG(4) << \textcolor{stringliteral}{"parsing CONTINUATION frame for stream="} << curHeader_.stream <<
410     \textcolor{stringliteral}{" length="} << curHeader_.length;
411   \textcolor{keyword}{auto} err = http2::parseContinuation(cursor, curHeader_, headerBuf);
412   RETURN_IF_ERROR(err);
413   err = parseHeadersImpl(cursor, std::move(headerBuf),
414                          folly::none, folly::none, folly::none);
415   \textcolor{keywordflow}{return} err;
416 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!parse\+Data\+Frame\+Data@{parse\+Data\+Frame\+Data}}
\index{parse\+Data\+Frame\+Data@{parse\+Data\+Frame\+Data}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{parse\+Data\+Frame\+Data(folly\+::io\+::\+Cursor \&cursor, size\+\_\+t buf\+Len, size\+\_\+t \&parsed)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Data\+Frame\+Data (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor, }
\item[{size\+\_\+t}]{buf\+Len, }
\item[{size\+\_\+t \&}]{parsed}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_aabc86d54be7229ef61dfad546d57fedc}


Definition at line 293 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::callback\+\_\+, cur\+Header\+\_\+, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::deliver\+Callback\+If\+Allowed(), proxygen\+::http2\+::frame\+Has\+Padding(), handle\+End\+Stream(), proxygen\+::http2\+::\+Frame\+Header\+::length, proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Body(), proxygen\+::http2\+::parse\+Data\+Begin(), proxygen\+::http2\+::parse\+Data\+End(), pending\+Data\+Frame\+Bytes\+\_\+, pending\+Data\+Frame\+Padding\+Bytes\+\_\+, R\+E\+T\+U\+R\+N\+\_\+\+I\+F\+\_\+\+E\+R\+R\+OR, and proxygen\+::http2\+::\+Frame\+Header\+::stream.



Referenced by get\+Header\+Indexing\+Strategy(), and on\+Ingress().


\begin{DoxyCode}
295                                                          \{
296   FOLLY\_SCOPED\_TRACE\_SECTION(\textcolor{stringliteral}{"HTTP2Codec - parseDataFrameData"});
297   \textcolor{keywordflow}{if} (bufLen == 0) \{
298     VLOG(10) << \textcolor{stringliteral}{"No data to parse"};
299     \textcolor{keywordflow}{return} ErrorCode::NO_ERROR;
300   \}
301 
302   std::unique\_ptr<IOBuf> outData;
303   uint16\_t padding = 0;
304   VLOG(10) << \textcolor{stringliteral}{"parsing DATA frame data for stream="} << curHeader_.stream <<
305     \textcolor{stringliteral}{" frame data length="} << curHeader_.length << \textcolor{stringliteral}{" pendingDataFrameBytes\_="} <<
306     pendingDataFrameBytes_ << \textcolor{stringliteral}{" pendingDataFramePaddingBytes\_="} <<
307     pendingDataFramePaddingBytes_ << \textcolor{stringliteral}{" bufLen="} << bufLen <<
308     \textcolor{stringliteral}{" parsed="} << parsed;
309   \textcolor{comment}{// Parse the padding information only the first time}
310   \textcolor{keywordflow}{if} (pendingDataFrameBytes_ == curHeader_.length &&
311     pendingDataFramePaddingBytes_ == 0) \{
312     \textcolor{keywordflow}{if} (frameHasPadding(curHeader_) && bufLen == 1) \{
313       \textcolor{comment}{// We need to wait for more bytes otherwise we won't be able to pass}
314       \textcolor{comment}{// the correct padding to the first onBody call}
315       \textcolor{keywordflow}{return} ErrorCode::NO_ERROR;
316     \}
317     \textcolor{keyword}{const} \textcolor{keyword}{auto} ret = http2::parseDataBegin(cursor, curHeader_, parsed, padding);
318     RETURN_IF_ERROR(ret);
319     \textcolor{keywordflow}{if} (padding > 0) \{
320       pendingDataFramePaddingBytes_ = padding - 1;
321       pendingDataFrameBytes_--;
322       bufLen--;
323       parsed++;
324     \}
325     VLOG(10) << \textcolor{stringliteral}{"out padding="} << padding << \textcolor{stringliteral}{" pendingDataFrameBytes\_="} <<
326       pendingDataFrameBytes_ << \textcolor{stringliteral}{" pendingDataFramePaddingBytes\_="} <<
327       pendingDataFramePaddingBytes_ << \textcolor{stringliteral}{" bufLen="} << bufLen <<
328       \textcolor{stringliteral}{" parsed="} << parsed;
329   \}
330   \textcolor{keywordflow}{if} (bufLen > 0) \{
331     \textcolor{comment}{// Check if we have application data to parse}
332     \textcolor{keywordflow}{if} (pendingDataFrameBytes_ > pendingDataFramePaddingBytes_) \{
333       \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} pendingAppData =
334         pendingDataFrameBytes_ - pendingDataFramePaddingBytes_;
335       \textcolor{keyword}{const} \textcolor{keywordtype}{size\_t} toClone = std::min(pendingAppData, bufLen);
336       cursor.clone(outData, toClone);
337       bufLen -= toClone;
338       pendingDataFrameBytes_ -= toClone;
339       parsed += toClone;
340       VLOG(10) << \textcolor{stringliteral}{"parsed some app data, pendingDataFrameBytes\_="} <<
341         pendingDataFrameBytes_ << \textcolor{stringliteral}{" pendingDataFramePaddingBytes\_="} <<
342         pendingDataFramePaddingBytes\_ << \textcolor{stringliteral}{" bufLen="} << bufLen <<
343         \textcolor{stringliteral}{" parsed="} << parsed;
344     \}
345     \textcolor{comment}{// Check if we have padding bytes to parse}
346     \textcolor{keywordflow}{if} (bufLen > 0 && pendingDataFramePaddingBytes\_ > 0) \{
347       \textcolor{keywordtype}{size\_t} toSkip = 0;
348       \textcolor{keyword}{auto} ret = http2::parseDataEnd(cursor, bufLen,
349                                      pendingDataFramePaddingBytes\_, toSkip);
350       RETURN_IF_ERROR(ret);
351       pendingDataFrameBytes_ -= toSkip;
352       pendingDataFramePaddingBytes\_ -= toSkip;
353       parsed += toSkip;
354       VLOG(10) << \textcolor{stringliteral}{"parsed some padding, pendingDataFrameBytes\_="} <<
355         pendingDataFrameBytes_ << \textcolor{stringliteral}{" pendingDataFramePaddingBytes\_="} <<
356         pendingDataFramePaddingBytes\_ << \textcolor{stringliteral}{" bufLen="} << bufLen <<
357         \textcolor{stringliteral}{" parsed="} << parsed;
358     \}
359   \}
360 
361   \textcolor{keywordflow}{if} (callback_ && (padding > 0 || (outData && !outData->empty()))) \{
362     \textcolor{keywordflow}{if} (!outData) \{
363       outData = std::make\_unique<IOBuf>();
364     \}
365     deliverCallbackIfAllowed(&HTTPCodec::Callback::onBody, \textcolor{stringliteral}{"onBody"},
366                              curHeader_.stream, std::move(outData), padding);
367   \}
368   \textcolor{keywordflow}{return} (pendingDataFrameBytes_ > 0) ? ErrorCode::NO_ERROR : handleEndStream();
369 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!parse\+Ex\+Headers@{parse\+Ex\+Headers}}
\index{parse\+Ex\+Headers@{parse\+Ex\+Headers}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{parse\+Ex\+Headers(folly\+::io\+::\+Cursor \&cursor)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Ex\+Headers (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a906a2e41b818b74c67e05bfe7a0bc8c9}


Definition at line 389 of file H\+T\+T\+P2\+Codec.\+cpp.



References check\+New\+Stream(), cur\+Header\+\_\+, is\+Request(), proxygen\+::http2\+::\+Frame\+Header\+::length, proxygen\+::http2\+::parse\+Ex\+Headers(), parse\+Headers\+Impl(), R\+E\+T\+U\+R\+N\+\_\+\+I\+F\+\_\+\+E\+R\+R\+OR, and proxygen\+::http2\+::\+Frame\+Header\+::stream.



Referenced by get\+Header\+Indexing\+Strategy(), and parse\+Frame().


\begin{DoxyCode}
389                                                    \{
390   FOLLY\_SCOPED\_TRACE\_SECTION(\textcolor{stringliteral}{"HTTP2Codec - parseExHeaders"});
391   HTTPCodec::ExAttributes exAttributes;
392   folly::Optional<http2::PriorityUpdate> priority;
393   std::unique\_ptr<IOBuf> headerBuf;
394   VLOG(4) << \textcolor{stringliteral}{"parsing ExHEADERS frame for stream="} << curHeader_.stream
395           << \textcolor{stringliteral}{" length="} << curHeader_.length;
396   \textcolor{keyword}{auto} err = http2::parseExHeaders(
397       cursor, curHeader_, exAttributes, priority, headerBuf);
398   RETURN_IF_ERROR(err);
399   \textcolor{keywordflow}{if} (isRequest(curHeader_.stream)) \{
400     RETURN_IF_ERROR(
401         checkNewStream(curHeader_.stream, \textcolor{keyword}{false} \textcolor{comment}{/* trailersAllowed */}));
402   \}
403   \textcolor{keywordflow}{return} parseHeadersImpl(cursor, std::move(headerBuf), priority, folly::none,
404                           exAttributes);
405 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!parse\+Frame@{parse\+Frame}}
\index{parse\+Frame@{parse\+Frame}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{parse\+Frame(folly\+::io\+::\+Cursor \&cursor)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Frame (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_ab33ca34b2fc8446817a3f466aa3c370d}


Definition at line 157 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::http2\+::\+A\+L\+T\+S\+VC, proxygen\+::http2\+::\+C\+E\+R\+T\+I\+F\+I\+C\+A\+TE, proxygen\+::http2\+::\+C\+E\+R\+T\+I\+F\+I\+C\+A\+T\+E\+\_\+\+R\+E\+Q\+U\+E\+ST, proxygen\+::http2\+::\+C\+O\+N\+T\+I\+N\+U\+A\+T\+I\+ON, cur\+Header\+\_\+, cur\+Header\+Block\+\_\+, proxygen\+::http2\+::\+D\+A\+TA, egress\+Settings\+\_\+, proxygen\+::\+E\+N\+A\+B\+L\+E\+\_\+\+E\+X\+\_\+\+H\+E\+A\+D\+E\+RS, proxygen\+::http2\+::\+E\+N\+D\+\_\+\+H\+E\+A\+D\+E\+RS, proxygen\+::\+E\+R\+R\+OR, proxygen\+::http2\+::\+E\+X\+\_\+\+H\+E\+A\+D\+E\+RS, expected\+Continuation\+Stream\+\_\+, proxygen\+::http2\+::\+Frame\+Header\+::flags, proxygen\+::http2\+::frame\+Affects\+Compression(), proxygen\+::http2\+::get\+Frame\+Type\+String(), proxygen\+::\+H\+T\+T\+P\+Settings\+::get\+Setting(), proxygen\+::http2\+::\+G\+O\+A\+W\+AY, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::goaway\+Error\+Message\+\_\+, proxygen\+::http2\+::\+H\+E\+A\+D\+E\+RS, ingress\+Settings\+\_\+, proxygen\+::http2\+::\+Frame\+Header\+::length, proxygen\+::\+M\+A\+X\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+L\+I\+S\+T\+\_\+\+S\+I\+ZE, proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, parse\+All\+Data(), parse\+Certificate(), parse\+Certificate\+Request(), parse\+Continuation(), parse\+Ex\+Headers(), parse\+Goaway(), parse\+Headers(), parse\+Ping(), parse\+Priority(), parse\+Push\+Promise(), parse\+Rst\+Stream(), parse\+Settings(), parse\+Window\+Update(), proxygen\+::http2\+::\+P\+I\+NG, proxygen\+::http2\+::\+P\+R\+I\+O\+R\+I\+TY, proxygen\+::\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, proxygen\+::http2\+::\+P\+U\+S\+H\+\_\+\+P\+R\+O\+M\+I\+SE, proxygen\+::http2\+::\+R\+S\+T\+\_\+\+S\+T\+R\+E\+AM, proxygen\+::http2\+::\+S\+E\+T\+T\+I\+N\+GS, proxygen\+::http2\+::\+Frame\+Header\+::stream, proxygen\+::http2\+::\+Frame\+Header\+::type, and proxygen\+::http2\+::\+W\+I\+N\+D\+O\+W\+\_\+\+U\+P\+D\+A\+TE.



Referenced by get\+Header\+Indexing\+Strategy(), and on\+Ingress().


\begin{DoxyCode}
157                                                       \{
158   FOLLY\_SCOPED\_TRACE\_SECTION(\textcolor{stringliteral}{"HTTP2Codec - parseFrame"});
159   \textcolor{keywordflow}{if} (expectedContinuationStream_ != 0 &&
160        (curHeader_.type != http2::FrameType::CONTINUATION ||
161         expectedContinuationStream_ != curHeader_.stream)) \{
162     goawayErrorMessage_ = folly::to<string>(
163         \textcolor{stringliteral}{"GOAWAY error: while expected CONTINUATION with stream="},
164         expectedContinuationStream_, \textcolor{stringliteral}{", received streamID="}, curHeader_.stream,
165         \textcolor{stringliteral}{" of type="}, getFrameTypeString(curHeader_.type));
166     VLOG(4) << goawayErrorMessage_;
167     \textcolor{keywordflow}{return} ErrorCode::PROTOCOL_ERROR;
168   \}
169   \textcolor{keywordflow}{if} (expectedContinuationStream_ == 0 &&
170       curHeader_.type == http2::FrameType::CONTINUATION) \{
171     goawayErrorMessage_ = folly::to<string>(
172         \textcolor{stringliteral}{"GOAWAY error: unexpected CONTINUATION received with streamID="},
173         curHeader_.stream);
174     VLOG(4) << goawayErrorMessage_;
175     \textcolor{keywordflow}{return} ErrorCode::PROTOCOL_ERROR;
176   \}
177   \textcolor{keywordflow}{if} (frameAffectsCompression(curHeader_.type) &&
178       curHeaderBlock_.chainLength() + curHeader_.length >
179       egressSettings_.getSetting(SettingsId::MAX_HEADER_LIST_SIZE, 0)) \{
180     \textcolor{comment}{// this may be off by up to the padding length (max 255), but}
181     \textcolor{comment}{// these numbers are already so generous, and we're comparing the}
182     \textcolor{comment}{// max-uncompressed to the actual compressed size.  Let's fail}
183     \textcolor{comment}{// before buffering.}
184 
185     \textcolor{comment}{// TODO(t6513634): it would be nicer to stream-process this header}
186     \textcolor{comment}{// block to keep the connection state consistent without consuming}
187     \textcolor{comment}{// memory, and fail just the request per the HTTP/2 spec (section}
188     \textcolor{comment}{// 10.3)}
189     goawayErrorMessage_ = folly::to<string>(
190       \textcolor{stringliteral}{"Failing connection due to excessively large headers"});
191     LOG(ERROR) << goawayErrorMessage_;
192     \textcolor{keywordflow}{return} ErrorCode::PROTOCOL_ERROR;
193   \}
194 
195   expectedContinuationStream_ =
196     (frameAffectsCompression(curHeader_.type) &&
197      !(curHeader_.flags & http2::END_HEADERS)) ? curHeader_.stream : 0;
198 
199   \textcolor{keywordflow}{switch} (curHeader_.type) \{
200     \textcolor{keywordflow}{case} http2::FrameType::DATA:
201       \textcolor{keywordflow}{return} parseAllData(cursor);
202     \textcolor{keywordflow}{case} http2::FrameType::HEADERS:
203       \textcolor{keywordflow}{return} parseHeaders(cursor);
204     \textcolor{keywordflow}{case} http2::FrameType::PRIORITY:
205       \textcolor{keywordflow}{return} parsePriority(cursor);
206     \textcolor{keywordflow}{case} http2::FrameType::RST_STREAM:
207       \textcolor{keywordflow}{return} parseRstStream(cursor);
208     \textcolor{keywordflow}{case} http2::FrameType::SETTINGS:
209       \textcolor{keywordflow}{return} parseSettings(cursor);
210     \textcolor{keywordflow}{case} http2::FrameType::PUSH_PROMISE:
211       \textcolor{keywordflow}{return} parsePushPromise(cursor);
212     \textcolor{keywordflow}{case} http2::FrameType::EX_HEADERS:
213       \textcolor{keywordflow}{if} (ingressSettings_.getSetting(SettingsId::ENABLE_EX_HEADERS, 0)) \{
214         \textcolor{keywordflow}{return} parseExHeaders(cursor);
215       \} \textcolor{keywordflow}{else} \{
216         VLOG(2) << \textcolor{stringliteral}{"EX\_HEADERS not enabled, ignoring the frame"};
217         \textcolor{keywordflow}{break};
218       \}
219     \textcolor{keywordflow}{case} http2::FrameType::PING:
220       \textcolor{keywordflow}{return} parsePing(cursor);
221     \textcolor{keywordflow}{case} http2::FrameType::GOAWAY:
222       \textcolor{keywordflow}{return} parseGoaway(cursor);
223     \textcolor{keywordflow}{case} http2::FrameType::WINDOW_UPDATE:
224       \textcolor{keywordflow}{return} parseWindowUpdate(cursor);
225     \textcolor{keywordflow}{case} http2::FrameType::CONTINUATION:
226       \textcolor{keywordflow}{return} parseContinuation(cursor);
227     \textcolor{keywordflow}{case} http2::FrameType::ALTSVC:
228       \textcolor{comment}{// fall through, unimplemented}
229       \textcolor{keywordflow}{break};
230     \textcolor{keywordflow}{case} http2::FrameType::CERTIFICATE_REQUEST:
231       \textcolor{keywordflow}{return} parseCertificateRequest(cursor);
232     \textcolor{keywordflow}{case} http2::FrameType::CERTIFICATE:
233       \textcolor{keywordflow}{return} parseCertificate(cursor);
234     \textcolor{keywordflow}{default}:
235       \textcolor{comment}{// Implementations MUST ignore and discard any frame that has a}
236       \textcolor{comment}{// type that is unknown}
237       \textcolor{keywordflow}{break};
238   \}
239 
240   \textcolor{comment}{// Landing here means unknown, unimplemented or ignored frame.}
241   VLOG(2) << \textcolor{stringliteral}{"Skipping frame (type="} << (uint8\_t)curHeader_.type << \textcolor{stringliteral}{")"};
242   cursor.skip(curHeader_.length);
243   \textcolor{keywordflow}{return} ErrorCode::NO_ERROR;
244 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!parse\+Goaway@{parse\+Goaway}}
\index{parse\+Goaway@{parse\+Goaway}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{parse\+Goaway(folly\+::io\+::\+Cursor \&cursor)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Goaway (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a6d06174cc0a48ff6c6cb849dce7afd24}


Definition at line 873 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::callback\+\_\+, cur\+Header\+\_\+, proxygen\+::empty\+\_\+string, proxygen\+::get\+Error\+Code\+String(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::ingress\+Goaway\+Ack\+\_\+, proxygen\+::http2\+::\+Frame\+Header\+::length, proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Goaway(), proxygen\+::http2\+::parse\+Goaway(), R\+E\+T\+U\+R\+N\+\_\+\+I\+F\+\_\+\+E\+R\+R\+OR, status\+Code, and user\+Agent\+\_\+.



Referenced by get\+Header\+Indexing\+Strategy(), and parse\+Frame().


\begin{DoxyCode}
873                                                 \{
874   VLOG(4) << \textcolor{stringliteral}{"parsing GOAWAY frame length="} << curHeader_.length;
875   uint32\_t lastGoodStream = 0;
876   ErrorCode statusCode = ErrorCode::NO_ERROR;
877   std::unique\_ptr<IOBuf> debugData;
878 
879   \textcolor{keyword}{auto} err = http2::parseGoaway(cursor, curHeader_, lastGoodStream, statusCode,
880                                 debugData);
881   \textcolor{keywordflow}{if} (statusCode != ErrorCode::NO_ERROR) \{
882     VLOG(2) << \textcolor{stringliteral}{"Goaway error statusCode="} << getErrorCodeString(statusCode)
883             << \textcolor{stringliteral}{" lastStream="} << lastGoodStream
884             << \textcolor{stringliteral}{" user-agent="} << userAgent_ <<  \textcolor{stringliteral}{" debugData="} <<
885       ((debugData) ? \textcolor{keywordtype}{string}((\textcolor{keywordtype}{char}*)debugData->data(), debugData->length()):
886        empty_string);
887   \}
888   RETURN_IF_ERROR(err);
889   if (lastGoodStream < ingressGoawayAck_) \{
890     ingressGoawayAck\_ = lastGoodStream;
891     \textcolor{comment}{// Drain all streams <= lastGoodStream}
892     \textcolor{comment}{// and abort streams > lastGoodStream}
893     \textcolor{keywordflow}{if} (callback_) \{
894       callback_->onGoaway(lastGoodStream, statusCode, std::move(debugData));
895     \}
896   \} \textcolor{keywordflow}{else} \{
897     LOG(WARNING) << \textcolor{stringliteral}{"Received multiple GOAWAY with increasing ack"};
898   \}
899   \textcolor{keywordflow}{return} ErrorCode::NO_ERROR;
900 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!parse\+Headers@{parse\+Headers}}
\index{parse\+Headers@{parse\+Headers}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{parse\+Headers(folly\+::io\+::\+Cursor \&cursor)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Headers (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a7c4e6d53ef33d23d82d2ecffff8bd547}


Definition at line 372 of file H\+T\+T\+P2\+Codec.\+cpp.



References check\+New\+Stream(), cur\+Header\+\_\+, proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, proxygen\+::http2\+::\+Frame\+Header\+::length, proxygen\+::http2\+::parse\+Headers(), parse\+Headers\+Impl(), R\+E\+T\+U\+R\+N\+\_\+\+I\+F\+\_\+\+E\+R\+R\+OR, proxygen\+::http2\+::\+Frame\+Header\+::stream, and proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::transport\+Direction\+\_\+.



Referenced by get\+Header\+Indexing\+Strategy(), and parse\+Frame().


\begin{DoxyCode}
372                                                  \{
373   FOLLY\_SCOPED\_TRACE\_SECTION(\textcolor{stringliteral}{"HTTP2Codec - parseHeaders"});
374   folly::Optional<http2::PriorityUpdate> priority;
375   std::unique\_ptr<IOBuf> headerBuf;
376   VLOG(4) << \textcolor{stringliteral}{"parsing HEADERS frame for stream="} << curHeader_.stream <<
377     \textcolor{stringliteral}{" length="} << curHeader_.length;
378   \textcolor{keyword}{auto} err = http2::parseHeaders(cursor, curHeader_, priority, headerBuf);
379   RETURN_IF_ERROR(err);
380   \textcolor{keywordflow}{if} (transportDirection_ == TransportDirection::DOWNSTREAM) \{
381     RETURN_IF_ERROR(
382         checkNewStream(curHeader_.stream, \textcolor{keyword}{true} \textcolor{comment}{/* trailersAllowed */}));
383   \}
384   err = parseHeadersImpl(cursor, std::move(headerBuf), priority, folly::none,
385                          folly::none);
386   \textcolor{keywordflow}{return} err;
387 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!parse\+Headers\+Check\+Concurrent\+Streams@{parse\+Headers\+Check\+Concurrent\+Streams}}
\index{parse\+Headers\+Check\+Concurrent\+Streams@{parse\+Headers\+Check\+Concurrent\+Streams}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{parse\+Headers\+Check\+Concurrent\+Streams(const folly\+::\+Optional$<$ http2\+::\+Priority\+Update $>$ \&priority)}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+Optional$<$ {\bf Error\+Code} $>$ proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Headers\+Check\+Concurrent\+Streams (
\begin{DoxyParamCaption}
\item[{const folly\+::\+Optional$<$ {\bf http2\+::\+Priority\+Update} $>$ \&}]{priority}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a514f1b077cd30673c80b7e4b32c768dc}


Definition at line 581 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::callback\+\_\+, cur\+Header\+\_\+, egress\+Settings\+\_\+, proxygen\+::http2\+::\+E\+X\+\_\+\+H\+E\+A\+D\+E\+RS, proxygen\+::http2\+::\+Frame\+Header\+::flags, proxygen\+::\+H\+T\+T\+P\+Settings\+::get\+Setting(), proxygen\+::http2\+::\+H\+E\+A\+D\+E\+RS, proxygen\+::\+M\+A\+X\+\_\+\+C\+O\+N\+C\+U\+R\+R\+E\+N\+T\+\_\+\+S\+T\+R\+E\+A\+MS, proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::num\+Incoming\+Streams(), proxygen\+::http2\+::\+P\+R\+I\+O\+R\+I\+TY, proxygen\+::\+R\+E\+F\+U\+S\+E\+D\+\_\+\+S\+T\+R\+E\+AM, stream\+Error(), and proxygen\+::http2\+::\+Frame\+Header\+::type.



Referenced by get\+Header\+Indexing\+Strategy(), and parse\+Headers\+Impl().


\begin{DoxyCode}
582                                                         \{
583   \textcolor{keywordflow}{if} (curHeader_.type == http2::FrameType::HEADERS ||
584       curHeader_.type == http2::FrameType::EX_HEADERS) \{
585     \textcolor{keywordflow}{if} (curHeader_.flags & http2::PRIORITY) \{
586       DCHECK(priority);
587       \textcolor{comment}{// callback\_->onPriority(priority.get());}
588     \}
589 
590     \textcolor{comment}{// callback checks total number of streams is smaller than settings max}
591     \textcolor{keywordflow}{if} (callback_->numIncomingStreams() >=
592         egressSettings_.getSetting(SettingsId::MAX_CONCURRENT_STREAMS,
593                                    std::numeric\_limits<int32\_t>::max())) \{
594       streamError(folly::to<string>(\textcolor{stringliteral}{"Exceeded max\_concurrent\_streams"}),
595                   ErrorCode::REFUSED_STREAM, \textcolor{keyword}{true});
596       \textcolor{keywordflow}{return} ErrorCode::NO_ERROR;
597     \}
598   \}
599   \textcolor{keywordflow}{return} folly::Optional<ErrorCode>();
600 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!parse\+Headers\+Decode\+Frames@{parse\+Headers\+Decode\+Frames}}
\index{parse\+Headers\+Decode\+Frames@{parse\+Headers\+Decode\+Frames}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{parse\+Headers\+Decode\+Frames(const folly\+::\+Optional$<$ http2\+::\+Priority\+Update $>$ \&priority, const folly\+::\+Optional$<$ uint32\+\_\+t $>$ \&promised\+Stream, const folly\+::\+Optional$<$ Ex\+Attributes $>$ \&ex\+Attributes, std\+::unique\+\_\+ptr$<$ H\+T\+T\+P\+Message $>$ \&msg)}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+Optional$<$ {\bf Error\+Code} $>$ proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Headers\+Decode\+Frames (
\begin{DoxyParamCaption}
\item[{const folly\+::\+Optional$<$ {\bf http2\+::\+Priority\+Update} $>$ \&}]{priority, }
\item[{const folly\+::\+Optional$<$ uint32\+\_\+t $>$ \&}]{promised\+Stream, }
\item[{const folly\+::\+Optional$<$ {\bf Ex\+Attributes} $>$ \&}]{ex\+Attributes, }
\item[{std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Message} $>$ \&}]{msg}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a0e8c1be27a4ce8b0b87a07cf79bf6144}


Definition at line 501 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::callback\+\_\+, proxygen\+::\+C\+O\+M\+P\+R\+E\+S\+S\+I\+O\+N\+\_\+\+E\+R\+R\+OR, cur\+Header\+\_\+, cur\+Header\+Block\+\_\+, proxygen\+::\+Header\+Decode\+Info\+::decode\+Error, decode\+Info\+\_\+, proxygen\+::\+H\+P\+A\+C\+K\+Codec\+::decode\+Streaming(), proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, proxygen\+::\+E\+R\+R\+OR, header\+Codec\+\_\+, proxygen\+::http2\+::\+H\+E\+A\+D\+E\+RS, proxygen\+::\+H\+P\+A\+C\+K\+::\+H\+E\+A\+D\+E\+R\+S\+\_\+\+T\+O\+O\+\_\+\+L\+A\+R\+GE, proxygen\+::\+H\+T\+T\+P\+Exception\+::\+I\+N\+G\+R\+E\+SS, proxygen\+::\+Header\+Decode\+Info\+::init(), is\+Request(), proxygen\+::\+Header\+Decode\+Info\+::msg, proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+P\+A\+C\+K\+::\+N\+O\+NE, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Error(), parsing\+Downstream\+Trailers\+\_\+, proxygen\+::\+Header\+Decode\+Info\+::parsing\+Error, proxygen\+::\+I\+O\+Buf\+Printer\+::print\+Hex\+Folly(), proxygen\+::\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, proxygen\+::http2\+::\+Frame\+Header\+::stream, stream\+Error(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::transport\+Direction\+\_\+, and proxygen\+::http2\+::\+Frame\+Header\+::type.



Referenced by get\+Header\+Indexing\+Strategy(), and parse\+Headers\+Impl().


\begin{DoxyCode}
505                                      \{
506   \textcolor{comment}{// decompress headers}
507   Cursor headerCursor(curHeaderBlock_.front());
508   \textcolor{keywordtype}{bool} isReq = \textcolor{keyword}{false};
509   \textcolor{keywordflow}{if} (promisedStream) \{
510     isReq = \textcolor{keyword}{true};
511   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (exAttributes) \{
512     isReq = isRequest(curHeader_.stream);
513   \} \textcolor{keywordflow}{else} \{
514     isReq = transportDirection_ == TransportDirection::DOWNSTREAM;
515   \}
516 
517   \textcolor{comment}{// Validate circular dependencies.}
518   \textcolor{keywordflow}{if} (priority && (curHeader_.stream == priority->streamDependency)) \{
519     streamError(
520         folly::to<string>(\textcolor{stringliteral}{"Circular dependency for txn="}, curHeader_.stream),
521         ErrorCode::PROTOCOL_ERROR,
522         curHeader_.type == http2::FrameType::HEADERS);
523     \textcolor{keywordflow}{return} ErrorCode::NO_ERROR;
524   \}
525 
526   decodeInfo_.init(isReq, parsingDownstreamTrailers_);
527   \textcolor{keywordflow}{if} (priority) \{
528     decodeInfo_.msg->setHTTP2Priority(
529         std::make\_tuple(priority->streamDependency,
530                         priority->exclusive,
531                         priority->weight));
532   \}
533 
534   headerCodec_.decodeStreaming(
535       headerCursor, curHeaderBlock_.chainLength(), \textcolor{keyword}{this});
536   msg = std::move(decodeInfo_.msg);
537   \textcolor{comment}{// Saving this in case we need to log it on error}
538   \textcolor{keyword}{auto} g = folly::makeGuard([\textcolor{keyword}{this}] \{ curHeaderBlock_.move(); \});
539   \textcolor{comment}{// Check decoding error}
540   \textcolor{keywordflow}{if} (decodeInfo_.decodeError != HPACK::DecodeError::NONE) \{
541     \textcolor{keyword}{static} \textcolor{keyword}{const} std::string decodeErrorMessage =
542         \textcolor{stringliteral}{"Failed decoding header block for stream="};
543     \textcolor{comment}{// Avoid logging header blocks that have failed decoding due to being}
544     \textcolor{comment}{// excessively large.}
545     \textcolor{keywordflow}{if} (decodeInfo_.decodeError != HPACK::DecodeError::HEADERS_TOO_LARGE) \{
546       LOG(ERROR) << decodeErrorMessage << curHeader_.stream
547                  << \textcolor{stringliteral}{" header block="};
548       VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), \textcolor{keyword}{true});
549     \} \textcolor{keywordflow}{else} \{
550       LOG(ERROR) << decodeErrorMessage << curHeader_.stream;
551     \}
552 
553     \textcolor{keywordflow}{if} (msg) \{
554       \textcolor{comment}{// print the partial message}
555       msg->dumpMessage(3);
556     \}
557     \textcolor{keywordflow}{return} ErrorCode::COMPRESSION_ERROR;
558   \}
559 
560   \textcolor{comment}{// Check parsing error}
561   \textcolor{keywordflow}{if} (decodeInfo_.parsingError != \textcolor{stringliteral}{""}) \{
562     LOG(ERROR) << \textcolor{stringliteral}{"Failed parsing header list for stream="} << curHeader_.stream
563                << \textcolor{stringliteral}{", error="} << decodeInfo_.parsingError << \textcolor{stringliteral}{", header block="};
564     VLOG(3) << IOBufPrinter::printHexFolly(curHeaderBlock_.front(), \textcolor{keyword}{true});
565     HTTPException err(HTTPException::Direction::INGRESS,
566                       folly::to<std::string>(\textcolor{stringliteral}{"HTTP2Codec stream error: "},
567                                              \textcolor{stringliteral}{"stream="},
568                                              curHeader_.stream,
569                                              \textcolor{stringliteral}{" status="},
570                                              400,
571                                              \textcolor{stringliteral}{" error: "},
572                                              decodeInfo_.parsingError));
573     err.setHttpStatusCode(400);
574     callback_->onError(curHeader_.stream, err, \textcolor{keyword}{true});
575     \textcolor{keywordflow}{return} ErrorCode::NO_ERROR;
576   \}
577 
578   \textcolor{keywordflow}{return} folly::Optional<ErrorCode>();
579 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!parse\+Headers\+Impl@{parse\+Headers\+Impl}}
\index{parse\+Headers\+Impl@{parse\+Headers\+Impl}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{parse\+Headers\+Impl(folly\+::io\+::\+Cursor \&cursor, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ header\+Buf, const folly\+::\+Optional$<$ http2\+::\+Priority\+Update $>$ \&priority, const folly\+::\+Optional$<$ uint32\+\_\+t $>$ \&promised\+Stream, const folly\+::\+Optional$<$ Ex\+Attributes $>$ \&ex\+Attributes)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Headers\+Impl (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{header\+Buf, }
\item[{const folly\+::\+Optional$<$ {\bf http2\+::\+Priority\+Update} $>$ \&}]{priority, }
\item[{const folly\+::\+Optional$<$ uint32\+\_\+t $>$ \&}]{promised\+Stream, }
\item[{const folly\+::\+Optional$<$ {\bf Ex\+Attributes} $>$ \&}]{ex\+Attributes}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_aba4ba6ea12397d657a221250a8564009}


Definition at line 418 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::callback\+\_\+, proxygen\+::http2\+::\+C\+O\+N\+T\+I\+N\+U\+A\+T\+I\+ON, cur\+Header\+\_\+, cur\+Header\+Block\+\_\+, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::deliver\+Callback\+If\+Allowed(), proxygen\+::http2\+::\+E\+N\+D\+\_\+\+H\+E\+A\+D\+E\+RS, proxygen\+::http2\+::\+E\+N\+D\+\_\+\+S\+T\+R\+E\+AM, proxygen\+::http2\+::\+E\+X\+\_\+\+H\+E\+A\+D\+E\+RS, proxygen\+::http2\+::\+Frame\+Header\+::flags, handle\+End\+Stream(), header\+Block\+Frame\+Type\+\_\+, proxygen\+::http2\+::\+H\+E\+A\+D\+E\+RS, proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Ex\+Message\+Begin(), proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Headers\+Complete(), proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Message\+Begin(), proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Push\+Message\+Begin(), proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Trailers\+Complete(), parse\+Headers\+Check\+Concurrent\+Streams(), parse\+Headers\+Decode\+Frames(), parsing\+Trailers(), proxygen\+::http2\+::\+P\+U\+S\+H\+\_\+\+P\+R\+O\+M\+I\+SE, proxygen\+::http2\+::\+Frame\+Header\+::stream, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::transport\+Direction\+\_\+, and proxygen\+::http2\+::\+Frame\+Header\+::type.



Referenced by get\+Header\+Indexing\+Strategy(), parse\+Continuation(), parse\+Ex\+Headers(), parse\+Headers(), and parse\+Push\+Promise().


\begin{DoxyCode}
423                                                      \{
424   curHeaderBlock_.append(std::move(headerBuf));
425   std::unique\_ptr<HTTPMessage> msg;
426   \textcolor{keywordflow}{if} (curHeader_.flags & http2::END_HEADERS) \{
427     \textcolor{keyword}{auto} errorCode =
428         parseHeadersDecodeFrames(priority, promisedStream, exAttributes, msg);
429     \textcolor{keywordflow}{if} (errorCode.hasValue()) \{
430       \textcolor{keywordflow}{return} errorCode.value();
431     \}
432   \}
433 
434   \textcolor{comment}{// if we're not parsing CONTINUATION, then it's start of new header block}
435   \textcolor{keywordflow}{if} (curHeader_.type != http2::FrameType::CONTINUATION) \{
436     headerBlockFrameType_ = curHeader_.type;
437   \}
438 
439   \textcolor{comment}{// Report back what we've parsed}
440   \textcolor{keywordflow}{if} (callback_) \{
441     \textcolor{keyword}{auto} concurError = parseHeadersCheckConcurrentStreams(priority);
442     \textcolor{keywordflow}{if} (concurError.hasValue()) \{
443       \textcolor{keywordflow}{return} concurError.value();
444     \}
445     uint32\_t headersCompleteStream = curHeader_.stream;
446     \textcolor{keywordtype}{bool} trailers = parsingTrailers();
447     \textcolor{keywordtype}{bool} allHeaderFramesReceived =
448         (curHeader_.flags & http2::END_HEADERS) &&
449         (headerBlockFrameType_ == http2::FrameType::HEADERS);
450     \textcolor{keywordflow}{if} (allHeaderFramesReceived && !trailers) \{
451       \textcolor{comment}{// Only deliver onMessageBegin once per stream.}
452       \textcolor{comment}{// For responses with CONTINUATION, this will be delayed until}
453       \textcolor{comment}{// the frame with the END\_HEADERS flag set.}
454       \textcolor{keywordflow}{if} (!deliverCallbackIfAllowed(&HTTPCodec::Callback::onMessageBegin,
455                                     \textcolor{stringliteral}{"onMessageBegin"},
456                                     curHeader_.stream,
457                                     msg.get())) \{
458         \textcolor{keywordflow}{return} handleEndStream();
459       \}
460    \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (curHeader_.type == http2::FrameType::EX_HEADERS) \{
461       \textcolor{keywordflow}{if} (!deliverCallbackIfAllowed(&HTTPCodec::Callback::onExMessageBegin,
462                                     \textcolor{stringliteral}{"onExMessageBegin"},
463                                     curHeader_.stream,
464                                     exAttributes->controlStream,
465                                     exAttributes->unidirectional,
466                                     msg.get())) \{
467         \textcolor{keywordflow}{return} handleEndStream();
468       \}
469     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (curHeader_.type == http2::FrameType::PUSH_PROMISE) \{
470       DCHECK(promisedStream);
471       \textcolor{keywordflow}{if} (!deliverCallbackIfAllowed(&HTTPCodec::Callback::onPushMessageBegin,
472                                     \textcolor{stringliteral}{"onPushMessageBegin"}, *promisedStream,
473                                     curHeader_.stream, msg.get())) \{
474         \textcolor{keywordflow}{return} handleEndStream();
475       \}
476       headersCompleteStream = *promisedStream;
477     \}
478 
479     \textcolor{keywordflow}{if} (curHeader_.flags & http2::END_HEADERS && msg) \{
480       \textcolor{keywordflow}{if} (!(curHeader_.flags & http2::END_STREAM)) \{
481         \textcolor{comment}{// If it there are DATA frames coming, consider it chunked}
482         msg->setIsChunked(\textcolor{keyword}{true});
483       \}
484       \textcolor{keywordflow}{if} (trailers) \{
485         VLOG(4) << \textcolor{stringliteral}{"Trailers complete for streamId="} << headersCompleteStream
486                 << \textcolor{stringliteral}{" direction="} << transportDirection_;
487         \textcolor{keyword}{auto} trailerHeaders =
488             std::make\_unique<HTTPHeaders>(msg->extractHeaders());
489         msg.reset();
490         callback_->onTrailersComplete(headersCompleteStream,
491                                       std::move(trailerHeaders));
492       \} \textcolor{keywordflow}{else} \{
493         callback_->onHeadersComplete(headersCompleteStream, std::move(msg));
494       \}
495     \}
496     \textcolor{keywordflow}{return} handleEndStream();
497   \}
498   \textcolor{keywordflow}{return} ErrorCode::NO_ERROR;
499 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!parse\+Ping@{parse\+Ping}}
\index{parse\+Ping@{parse\+Ping}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{parse\+Ping(folly\+::io\+::\+Cursor \&cursor)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Ping (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a83ef4704995222d5921bf40f9fb02209}


Definition at line 858 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::http2\+::\+A\+CK, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::callback\+\_\+, cur\+Header\+\_\+, proxygen\+::http2\+::\+Frame\+Header\+::flags, proxygen\+::http2\+::\+Frame\+Header\+::length, proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Ping\+Reply(), proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Ping\+Request(), proxygen\+::http2\+::parse\+Ping(), and R\+E\+T\+U\+R\+N\+\_\+\+I\+F\+\_\+\+E\+R\+R\+OR.



Referenced by get\+Header\+Indexing\+Strategy(), and parse\+Frame().


\begin{DoxyCode}
858                                               \{
859   VLOG(4) << \textcolor{stringliteral}{"parsing PING frame length="} << curHeader_.length;
860   uint64\_t opaqueData = 0;
861   \textcolor{keyword}{auto} err = http2::parsePing(cursor, curHeader_, opaqueData);
862   RETURN_IF_ERROR(err);
863   \textcolor{keywordflow}{if} (callback_) \{
864     \textcolor{keywordflow}{if} (curHeader_.flags & http2::ACK) \{
865       callback_->onPingReply(opaqueData);
866     \} \textcolor{keywordflow}{else} \{
867       callback_->onPingRequest(opaqueData);
868     \}
869   \}
870   \textcolor{keywordflow}{return} ErrorCode::NO_ERROR;
871 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!parse\+Priority@{parse\+Priority}}
\index{parse\+Priority@{parse\+Priority}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{parse\+Priority(folly\+::io\+::\+Cursor \&cursor)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Priority (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a315a6cc71bff9d053e45799cc1129491}


Definition at line 647 of file H\+T\+T\+P2\+Codec.\+cpp.



References cur\+Header\+\_\+, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::deliver\+Callback\+If\+Allowed(), proxygen\+::http2\+::\+Priority\+Update\+::exclusive, proxygen\+::http2\+::\+Frame\+Header\+::length, proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Priority(), proxygen\+::http2\+::parse\+Priority(), proxygen\+::\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, R\+E\+T\+U\+R\+N\+\_\+\+I\+F\+\_\+\+E\+R\+R\+OR, proxygen\+::http2\+::\+Frame\+Header\+::stream, proxygen\+::http2\+::\+Priority\+Update\+::stream\+Dependency, stream\+Error(), and proxygen\+::http2\+::\+Priority\+Update\+::weight.



Referenced by get\+Header\+Indexing\+Strategy(), and parse\+Frame().


\begin{DoxyCode}
647                                                   \{
648   VLOG(4) << \textcolor{stringliteral}{"parsing PRIORITY frame for stream="} << curHeader_.stream <<
649     \textcolor{stringliteral}{" length="} << curHeader_.length;
650   http2::PriorityUpdate pri;
651   \textcolor{keyword}{auto} err = http2::parsePriority(cursor, curHeader_, pri);
652   RETURN_IF_ERROR(err);
653   \textcolor{keywordflow}{if} (curHeader_.stream == pri.streamDependency) \{
654     streamError(folly::to<string>(\textcolor{stringliteral}{"Circular dependency for txn="},
655                                   curHeader_.stream),
656                 ErrorCode::PROTOCOL_ERROR, \textcolor{keyword}{false});
657     \textcolor{keywordflow}{return} ErrorCode::NO_ERROR;
658   \}
659   deliverCallbackIfAllowed(&HTTPCodec::Callback::onPriority, \textcolor{stringliteral}{"onPriority"},
660                            curHeader_.stream,
661                            std::make\_tuple(pri.streamDependency,
662                                            pri.exclusive,
663                                            pri.weight));
664   \textcolor{keywordflow}{return} ErrorCode::NO_ERROR;
665 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!parse\+Push\+Promise@{parse\+Push\+Promise}}
\index{parse\+Push\+Promise@{parse\+Push\+Promise}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{parse\+Push\+Promise(folly\+::io\+::\+Cursor \&cursor)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Push\+Promise (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a7a26d5c41349c591584d5f056d23a4e5}


Definition at line 821 of file H\+T\+T\+P2\+Codec.\+cpp.



References check\+New\+Stream(), cur\+Header\+\_\+, egress\+Settings\+\_\+, proxygen\+::\+E\+N\+A\+B\+L\+E\+\_\+\+P\+U\+SH, proxygen\+::\+H\+T\+T\+P\+Settings\+::get\+Setting(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::goaway\+Error\+Message\+\_\+, proxygen\+::http2\+::\+Frame\+Header\+::length, parse\+Headers\+Impl(), proxygen\+::http2\+::parse\+Push\+Promise(), proxygen\+::\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, R\+E\+T\+U\+R\+N\+\_\+\+I\+F\+\_\+\+E\+R\+R\+OR, proxygen\+::http2\+::\+Frame\+Header\+::stream, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::transport\+Direction\+\_\+, and proxygen\+::\+U\+P\+S\+T\+R\+E\+AM.



Referenced by get\+Header\+Indexing\+Strategy(), and parse\+Frame().


\begin{DoxyCode}
821                                                      \{
822   \textcolor{comment}{// stream id must be idle - protocol error}
823   \textcolor{comment}{// assoc-stream-id=closed/unknown - protocol error, unless rst\_stream sent}
824 
825   \textcolor{comment}{/*}
826 \textcolor{comment}{   * What does "must handle" mean in the following context?  I have to}
827 \textcolor{comment}{   * accept this as a valid pushed resource?}
828 \textcolor{comment}{}
829 \textcolor{comment}{    However, an endpoint that has sent RST\_STREAM on the associated}
830 \textcolor{comment}{    stream MUST handle PUSH\_PROMISE frames that might have been}
831 \textcolor{comment}{    created before the RST\_STREAM frame is received and processed.}
832 \textcolor{comment}{  */}
833   \textcolor{keywordflow}{if} (transportDirection_ != TransportDirection::UPSTREAM) \{
834     goawayErrorMessage_ = folly::to<string>(
835       \textcolor{stringliteral}{"Received PUSH\_PROMISE on DOWNSTREAM codec"});
836     VLOG(2) << goawayErrorMessage_;
837     \textcolor{keywordflow}{return} ErrorCode::PROTOCOL_ERROR;
838   \}
839   \textcolor{keywordflow}{if} (egressSettings_.getSetting(SettingsId::ENABLE_PUSH, -1) != 1) \{
840     goawayErrorMessage_ = folly::to<string>(
841       \textcolor{stringliteral}{"Received PUSH\_PROMISE on codec with push disabled"});
842     VLOG(2) << goawayErrorMessage_;
843     \textcolor{keywordflow}{return} ErrorCode::PROTOCOL_ERROR;
844   \}
845   VLOG(4) << \textcolor{stringliteral}{"parsing PUSH\_PROMISE frame for stream="} << curHeader_.stream <<
846     \textcolor{stringliteral}{" length="} << curHeader_.length;
847   uint32\_t promisedStream;
848   std::unique\_ptr<IOBuf> headerBlockFragment;
849   \textcolor{keyword}{auto} err = http2::parsePushPromise(cursor, curHeader_, promisedStream,
850                                      headerBlockFragment);
851   RETURN_IF_ERROR(err);
852   RETURN_IF_ERROR(checkNewStream(promisedStream, \textcolor{keyword}{false} \textcolor{comment}{/* trailersAllowed */}));
853   err = parseHeadersImpl(cursor, std::move(headerBlockFragment), folly::none,
854                          promisedStream, folly::none);
855   \textcolor{keywordflow}{return} err;
856 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!parse\+Rst\+Stream@{parse\+Rst\+Stream}}
\index{parse\+Rst\+Stream@{parse\+Rst\+Stream}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{parse\+Rst\+Stream(folly\+::io\+::\+Cursor \&cursor)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Rst\+Stream (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_ada840b8f16ceb59fef8903e4ad3e9506}


Definition at line 683 of file H\+T\+T\+P2\+Codec.\+cpp.



References cur\+Header\+\_\+, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::deliver\+Callback\+If\+Allowed(), proxygen\+::get\+Error\+Code\+String(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::goaway\+Error\+Message\+\_\+, proxygen\+::http2\+::\+Frame\+Header\+::length, proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Abort(), proxygen\+::http2\+::parse\+Rst\+Stream(), proxygen\+::\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, R\+E\+T\+U\+R\+N\+\_\+\+I\+F\+\_\+\+E\+R\+R\+OR, status\+Code, proxygen\+::http2\+::\+Frame\+Header\+::stream, upgraded\+Streams\+\_\+, and user\+Agent\+\_\+.



Referenced by get\+Header\+Indexing\+Strategy(), and parse\+Frame().


\begin{DoxyCode}
683                                                    \{
684   \textcolor{comment}{// rst for stream in idle state - protocol error}
685   VLOG(4) << \textcolor{stringliteral}{"parsing RST\_STREAM frame for stream="} << curHeader_.stream <<
686     \textcolor{stringliteral}{" length="} << curHeader_.length;
687   upgradedStreams_.erase(curHeader_.stream);
688   ErrorCode statusCode = ErrorCode::NO_ERROR;
689   \textcolor{keyword}{auto} err = http2::parseRstStream(cursor, curHeader_, statusCode);
690   RETURN_IF_ERROR(err);
691   \textcolor{keywordflow}{if} (statusCode == ErrorCode::PROTOCOL_ERROR) \{
692     goawayErrorMessage_ = folly::to<string>(
693         \textcolor{stringliteral}{"GOAWAY error: RST\_STREAM with code="}, getErrorCodeString(statusCode),
694         \textcolor{stringliteral}{" for streamID="}, curHeader_.stream, \textcolor{stringliteral}{" user-agent="}, userAgent_);
695     VLOG(2) << goawayErrorMessage_;
696   \}
697   deliverCallbackIfAllowed(&HTTPCodec::Callback::onAbort, \textcolor{stringliteral}{"onAbort"},
698                            curHeader_.stream, statusCode);
699   \textcolor{keywordflow}{return} ErrorCode::NO_ERROR;
700 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!parse\+Settings@{parse\+Settings}}
\index{parse\+Settings@{parse\+Settings}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{parse\+Settings(folly\+::io\+::\+Cursor \&cursor)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Settings (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a87540a29c5c7b53cb3dd9ab38277c677}


Definition at line 702 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::http2\+::\+A\+CK, cur\+Header\+\_\+, proxygen\+::http2\+::\+Frame\+Header\+::flags, handle\+Settings(), handle\+Settings\+Ack(), proxygen\+::http2\+::\+Frame\+Header\+::length, proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, proxygen\+::http2\+::parse\+Settings(), R\+E\+T\+U\+R\+N\+\_\+\+I\+F\+\_\+\+E\+R\+R\+OR, settings, and proxygen\+::http2\+::\+Frame\+Header\+::stream.



Referenced by get\+Header\+Indexing\+Strategy(), and parse\+Frame().


\begin{DoxyCode}
702                                                   \{
703   VLOG(4) << \textcolor{stringliteral}{"parsing SETTINGS frame for stream="} << curHeader_.stream <<
704     \textcolor{stringliteral}{" length="} << curHeader_.length;
705   std::deque<SettingPair> settings;
706   \textcolor{keyword}{auto} err = http2::parseSettings(cursor, curHeader_, settings);
707   RETURN_IF_ERROR(err);
708   \textcolor{keywordflow}{if} (curHeader_.flags & http2::ACK) \{
709     handleSettingsAck();
710     \textcolor{keywordflow}{return} ErrorCode::NO_ERROR;
711   \}
712   \textcolor{keywordflow}{return} handleSettings(settings);
713 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!parse\+Window\+Update@{parse\+Window\+Update}}
\index{parse\+Window\+Update@{parse\+Window\+Update}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{parse\+Window\+Update(folly\+::io\+::\+Cursor \&cursor)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Window\+Update (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_ac4ee308788952dd4535760c6e9a2bbe7}


Definition at line 902 of file H\+T\+T\+P2\+Codec.\+cpp.



References cur\+Header\+\_\+, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::deliver\+Callback\+If\+Allowed(), proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::goaway\+Error\+Message\+\_\+, proxygen\+::http2\+::\+Frame\+Header\+::length, proxygen\+::\+N\+O\+\_\+\+E\+R\+R\+OR, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Window\+Update(), proxygen\+::http2\+::parse\+Window\+Update(), proxygen\+::\+P\+R\+O\+T\+O\+C\+O\+L\+\_\+\+E\+R\+R\+OR, R\+E\+T\+U\+R\+N\+\_\+\+I\+F\+\_\+\+E\+R\+R\+OR, proxygen\+::http2\+::\+Frame\+Header\+::stream, and stream\+Error().



Referenced by get\+Header\+Indexing\+Strategy(), and parse\+Frame().


\begin{DoxyCode}
902                                                       \{
903   VLOG(4) << \textcolor{stringliteral}{"parsing WINDOW\_UPDATE frame for stream="} << curHeader_.stream <<
904     \textcolor{stringliteral}{" length="} << curHeader_.length;
905   uint32\_t delta = 0;
906   \textcolor{keyword}{auto} err = http2::parseWindowUpdate(cursor, curHeader_, delta);
907   RETURN_IF_ERROR(err);
908   \textcolor{keywordflow}{if} (delta == 0) \{
909     VLOG(4) << \textcolor{stringliteral}{"Invalid 0 length delta for stream="} << curHeader_.stream;
910     \textcolor{keywordflow}{if} (curHeader_.stream == 0) \{
911       goawayErrorMessage_ = folly::to<string>(
912         \textcolor{stringliteral}{"GOAWAY error: invalid/0 length delta for streamID="},
913         curHeader_.stream);
914       \textcolor{keywordflow}{return} ErrorCode::PROTOCOL_ERROR;
915     \} \textcolor{keywordflow}{else} \{
916       \textcolor{comment}{// Parsing a zero delta window update should cause a protocol error}
917       \textcolor{comment}{// and send a rst stream}
918       goawayErrorMessage_ = folly::to<string>(
919         \textcolor{stringliteral}{"parseWindowUpdate Invalid 0 length"});
920       VLOG(4) << goawayErrorMessage_;
921       streamError(folly::to<std::string>(\textcolor{stringliteral}{"streamID="}, curHeader_.stream,
922                                          \textcolor{stringliteral}{" with HTTP2Codec stream error: "},
923                                          \textcolor{stringliteral}{"window update delta="}, delta),
924                   ErrorCode::PROTOCOL_ERROR);
925       \textcolor{keywordflow}{return} ErrorCode::PROTOCOL_ERROR;
926     \}
927   \}
928   \textcolor{comment}{// if window exceeds 2^31-1, connection/stream error flow control error}
929   \textcolor{comment}{// must be checked in session/txn}
930   deliverCallbackIfAllowed(&HTTPCodec::Callback::onWindowUpdate,
931                            \textcolor{stringliteral}{"onWindowUpdate"}, curHeader_.stream, delta);
932   \textcolor{keywordflow}{return} ErrorCode::NO_ERROR;
933 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!parsing\+Trailers@{parsing\+Trailers}}
\index{parsing\+Trailers@{parsing\+Trailers}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{parsing\+Trailers() const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P2\+Codec\+::parsing\+Trailers (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a3046b2915acc496a5926164cb4960039}


Definition at line 1653 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::http2\+::\+C\+O\+N\+T\+I\+N\+U\+A\+T\+I\+ON, cur\+Header\+\_\+, decode\+Info\+\_\+, proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, proxygen\+::\+Header\+Decode\+Info\+::has\+Status(), proxygen\+::http2\+::\+H\+E\+A\+D\+E\+RS, parsing\+Downstream\+Trailers\+\_\+, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::transport\+Direction\+\_\+, and proxygen\+::http2\+::\+Frame\+Header\+::type.



Referenced by max\+Recv\+Frame\+Size(), and parse\+Headers\+Impl().


\begin{DoxyCode}
1653                                        \{
1654   \textcolor{comment}{// HEADERS frame is used for request/response headers and trailers.}
1655   \textcolor{comment}{// Per spec, specific role of HEADERS frame is determined by it's postion}
1656   \textcolor{comment}{// within the stream. We don't keep full stream state in this codec,}
1657   \textcolor{comment}{// thus using heuristics to distinguish between headers/trailers.}
1658   \textcolor{comment}{// For DOWNSTREAM case, request headers HEADERS frame would be creating}
1659   \textcolor{comment}{// new stream, thus HEADERS on existing stream ID are considered trailers}
1660   \textcolor{comment}{// (see checkNewStream).}
1661   \textcolor{comment}{// For UPSTREAM case, response headers are required to have status code,}
1662   \textcolor{comment}{// thus if no status code we consider that trailers.}
1663   \textcolor{keywordflow}{if} (curHeader_.type == http2::FrameType::HEADERS ||
1664       curHeader_.type == http2::FrameType::CONTINUATION) \{
1665     \textcolor{keywordflow}{if} (transportDirection_ == TransportDirection::DOWNSTREAM) \{
1666       \textcolor{keywordflow}{return} parsingDownstreamTrailers_;
1667     \} \textcolor{keywordflow}{else} \{
1668       \textcolor{keywordflow}{return} !decodeInfo_.hasStatus();
1669     \}
1670   \}
1671   \textcolor{keywordflow}{return} \textcolor{keyword}{false};
1672 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!peer\+Has\+Websockets@{peer\+Has\+Websockets}}
\index{peer\+Has\+Websockets@{peer\+Has\+Websockets}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{peer\+Has\+Websockets() const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P2\+Codec\+::peer\+Has\+Websockets (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HTTP2Codec_ade8232176f661d89532b4849d73fa4f3}


Definition at line 127 of file H\+T\+T\+P2\+Codec.\+h.



References proxygen\+::\+E\+N\+A\+B\+L\+E\+\_\+\+C\+O\+N\+N\+E\+C\+T\+\_\+\+P\+R\+O\+T\+O\+C\+OL, proxygen\+::\+H\+T\+T\+P\+Settings\+::get\+Setting(), and ingress\+Settings\+\_\+.


\begin{DoxyCode}
127                                  \{
128     \textcolor{keywordflow}{return} ingressSettings_.getSetting(SettingsId::ENABLE_CONNECT_PROTOCOL);
129   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!request\+Upgrade@{request\+Upgrade}}
\index{request\+Upgrade@{request\+Upgrade}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{request\+Upgrade(\+H\+T\+T\+P\+Message \&request)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P2\+Codec\+::request\+Upgrade (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Message} \&}]{request}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classproxygen_1_1HTTP2Codec_acfd2ca8ca915a899e80aa7addd24e0ba}


Definition at line 1520 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Message\+::check\+For\+Header\+Token(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), H\+T\+T\+P2\+Codec(), proxygen\+::http2\+::k\+Frame\+Header\+Size, proxygen\+::http2\+::k\+Protocol\+Cleartext\+String, proxygen\+::http2\+::k\+Protocol\+Settings\+Header, proxygen\+::\+H\+T\+T\+P\+Headers\+::set(), and proxygen\+::\+U\+P\+S\+T\+R\+E\+AM.



Referenced by get\+Compression\+Info(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
1520                                                     \{
1521   \textcolor{keyword}{static} folly::ThreadLocalPtr<HTTP2Codec> defaultCodec;
1522   \textcolor{keywordflow}{if} (!defaultCodec.get()) \{
1523     defaultCodec.reset(\textcolor{keyword}{new} HTTP2Codec(TransportDirection::UPSTREAM));
1524   \}
1525 
1526   \textcolor{keyword}{auto}& headers = request.getHeaders();
1527   headers.set(HTTP\_HEADER\_UPGRADE, http2::kProtocolCleartextString);
1528   \textcolor{keywordflow}{if} (!request.checkForHeaderToken(HTTP\_HEADER\_CONNECTION, \textcolor{stringliteral}{"Upgrade"}, \textcolor{keyword}{false})) \{
1529     headers.add(HTTP\_HEADER\_CONNECTION, \textcolor{stringliteral}{"Upgrade"});
1530   \}
1531   IOBufQueue writeBuf\{IOBufQueue::cacheChainLength()\};
1532   defaultCodec->generateSettings(writeBuf);
1533   \textcolor{comment}{// fake an ack since defaultCodec gets reused}
1534   defaultCodec->handleSettingsAck();
1535   writeBuf.trimStart(http2::kFrameHeaderSize);
1536   \textcolor{keyword}{auto} buf = writeBuf.move();
1537   buf->coalesce();
1538   headers.set(http2::kProtocolSettingsHeader,
1539               base64url\_encode(folly::ByteRange(buf->data(), buf->length())));
1540   \textcolor{keywordflow}{if} (!request.checkForHeaderToken(HTTP\_HEADER\_CONNECTION,
1541                                    http2::kProtocolSettingsHeader.c\_str(),
1542                                    \textcolor{keyword}{false})) \{
1543     headers.add(HTTP\_HEADER\_CONNECTION, http2::kProtocolSettingsHeader);
1544   \}
1545 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!set\+Header\+Codec\+Stats@{set\+Header\+Codec\+Stats}}
\index{set\+Header\+Codec\+Stats@{set\+Header\+Codec\+Stats}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{set\+Header\+Codec\+Stats(\+Header\+Codec\+::\+Stats $\ast$hc\+Stats) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P2\+Codec\+::set\+Header\+Codec\+Stats (
\begin{DoxyParamCaption}
\item[{{\bf Header\+Codec\+::\+Stats} $\ast$}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_a0cf655369be58321deb1fadc4cef1591}
set stats for the header codec, if the protocol supports header compression 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a0177b39d7554a85c702a2e20ebce2db0}.



Definition at line 134 of file H\+T\+T\+P2\+Codec.\+h.



References header\+Codec\+\_\+, and proxygen\+::\+Header\+Codec\+::set\+Stats().


\begin{DoxyCode}
134                                                                \{
135     headerCodec_.setStats(hcStats);
136   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!set\+Header\+Indexing\+Strategy@{set\+Header\+Indexing\+Strategy}}
\index{set\+Header\+Indexing\+Strategy@{set\+Header\+Indexing\+Strategy}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{set\+Header\+Indexing\+Strategy(const Header\+Indexing\+Strategy $\ast$indexing\+Strat)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P2\+Codec\+::set\+Header\+Indexing\+Strategy (
\begin{DoxyParamCaption}
\item[{const {\bf Header\+Indexing\+Strategy} $\ast$}]{indexing\+Strat}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HTTP2Codec_ab9004def92b456e85df95c607e5b87c8}


Definition at line 171 of file H\+T\+T\+P2\+Codec.\+h.



References header\+Codec\+\_\+, and proxygen\+::\+H\+P\+A\+C\+K\+Codec\+::set\+Header\+Indexing\+Strategy().



Referenced by proxygen\+::\+H\+T\+T\+P\+Session\+Base\+::init\+Codec\+Header\+Indexing\+Strategy().


\begin{DoxyCode}
171                                                                               \{
172     headerCodec_.setHeaderIndexingStrategy(indexingStrat);
173   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!set\+Reuse\+I\+O\+Buf\+Headroom\+For\+Data@{set\+Reuse\+I\+O\+Buf\+Headroom\+For\+Data}}
\index{set\+Reuse\+I\+O\+Buf\+Headroom\+For\+Data@{set\+Reuse\+I\+O\+Buf\+Headroom\+For\+Data}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{set\+Reuse\+I\+O\+Buf\+Headroom\+For\+Data(bool enabled)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P2\+Codec\+::set\+Reuse\+I\+O\+Buf\+Headroom\+For\+Data (
\begin{DoxyParamCaption}
\item[{bool}]{enabled}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HTTP2Codec_aa4ff2668cda111c43eb1911ec790dc1b}


Definition at line 167 of file H\+T\+T\+P2\+Codec.\+h.



References reuse\+I\+O\+Buf\+Headroom\+For\+Data\+\_\+.


\begin{DoxyCode}
167                                                   \{
168     reuseIOBufHeadroomForData_ = enabled;
169   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!stream\+Error@{stream\+Error}}
\index{stream\+Error@{stream\+Error}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{stream\+Error(const std\+::string \&msg, Error\+Code error, bool new\+Txn=false)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P2\+Codec\+::stream\+Error (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{msg, }
\item[{{\bf Error\+Code}}]{error, }
\item[{bool}]{new\+Txn = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a736aae5aa1b8bcd119d4cef0219ff51c}


Definition at line 1632 of file H\+T\+T\+P2\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::callback\+\_\+, cur\+Header\+\_\+, proxygen\+::\+H\+T\+T\+P\+Exception\+::\+I\+N\+G\+R\+E\+S\+S\+\_\+\+A\+N\+D\+\_\+\+E\+G\+R\+E\+SS, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Error(), proxygen\+::\+H\+T\+T\+P\+Exception\+::set\+Codec\+Status\+Code(), and proxygen\+::http2\+::\+Frame\+Header\+::stream.



Referenced by max\+Recv\+Frame\+Size(), parse\+Headers\+Check\+Concurrent\+Streams(), parse\+Headers\+Decode\+Frames(), parse\+Priority(), and parse\+Window\+Update().


\begin{DoxyCode}
1633                                           \{
1634   HTTPException error(HTTPException::Direction::INGRESS_AND_EGRESS,
1635                       msg);
1636   error.setCodecStatusCode(code);
1637   \textcolor{keywordflow}{if} (callback_) \{
1638     callback_->onError(curHeader_.stream, error, newTxn);
1639   \}
1640 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!supports\+Ex\+Transactions@{supports\+Ex\+Transactions}}
\index{supports\+Ex\+Transactions@{supports\+Ex\+Transactions}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{supports\+Ex\+Transactions() const override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P2\+Codec\+::supports\+Ex\+Transactions (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_a7d7539d5c41a29e8fc5fbef10d0887dc}
Check whether the codec supports bidirectional communications between server and client. 

Reimplemented from {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a0081fbb66811b106c6826c059c3c5437}.



Definition at line 130 of file H\+T\+T\+P2\+Codec.\+h.



References egress\+Settings\+\_\+, proxygen\+::\+E\+N\+A\+B\+L\+E\+\_\+\+E\+X\+\_\+\+H\+E\+A\+D\+E\+RS, proxygen\+::\+H\+T\+T\+P\+Settings\+::get\+Setting(), and ingress\+Settings\+\_\+.


\begin{DoxyCode}
130                                                \{
131     \textcolor{keywordflow}{return} ingressSettings_.getSetting(SettingsId::ENABLE_EX_HEADERS, 0) &&
132       egressSettings_.getSetting(SettingsId::ENABLE_EX_HEADERS, 0);
133   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!supports\+Push\+Transactions@{supports\+Push\+Transactions}}
\index{supports\+Push\+Transactions@{supports\+Push\+Transactions}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{supports\+Push\+Transactions() const override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P2\+Codec\+::supports\+Push\+Transactions (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP2Codec_a4e06e939c2682a21144b8c37a6fbf85c}
Check whether the codec supports pushing resources from server to client. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_aa43f8d4ffd6e30bf9e2c176fa5b9188c}.



Definition at line 120 of file H\+T\+T\+P2\+Codec.\+h.



References proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, egress\+Settings\+\_\+, proxygen\+::\+E\+N\+A\+B\+L\+E\+\_\+\+P\+U\+SH, proxygen\+::\+H\+T\+T\+P\+Settings\+::get\+Setting(), ingress\+Settings\+\_\+, proxygen\+::\+H\+T\+T\+P\+Parallel\+Codec\+::transport\+Direction\+\_\+, and proxygen\+::\+U\+P\+S\+T\+R\+E\+AM.


\begin{DoxyCode}
120                                                  \{
121     \textcolor{keywordflow}{return}
122       (transportDirection_ == TransportDirection::DOWNSTREAM &&
123        ingressSettings_.getSetting(SettingsId::ENABLE_PUSH, 1)) ||
124       (transportDirection_ == TransportDirection::UPSTREAM &&
125        egressSettings_.getSetting(SettingsId::ENABLE_PUSH, 1));
126   \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!cur\+Authenticator\+Block\+\_\+@{cur\+Authenticator\+Block\+\_\+}}
\index{cur\+Authenticator\+Block\+\_\+@{cur\+Authenticator\+Block\+\_\+}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{cur\+Authenticator\+Block\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+I\+O\+Buf\+Queue proxygen\+::\+H\+T\+T\+P2\+Codec\+::cur\+Authenticator\+Block\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a303ceb2ba8f4b6eb49fc2d2b77dd7024}
{\bfseries Initial value\+:}
\begin{DoxyCode}
\{
      folly::IOBufQueue::cacheChainLength()\}
\end{DoxyCode}


Definition at line 252 of file H\+T\+T\+P2\+Codec.\+h.



Referenced by parse\+Certificate().

\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!cur\+Cert\+Id\+\_\+@{cur\+Cert\+Id\+\_\+}}
\index{cur\+Cert\+Id\+\_\+@{cur\+Cert\+Id\+\_\+}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{cur\+Cert\+Id\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint16\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::cur\+Cert\+Id\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_ac486e718209b1fd8f9fab1239d1a03d6}


Definition at line 251 of file H\+T\+T\+P2\+Codec.\+h.



Referenced by parse\+Certificate().

\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!cur\+Header\+\_\+@{cur\+Header\+\_\+}}
\index{cur\+Header\+\_\+@{cur\+Header\+\_\+}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{cur\+Header\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf http2\+::\+Frame\+Header} proxygen\+::\+H\+T\+T\+P2\+Codec\+::cur\+Header\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a688448aa944d728427a493be7ab3482e}


Definition at line 244 of file H\+T\+T\+P2\+Codec.\+h.



Referenced by generate\+Rst\+Stream(), handle\+End\+Stream(), handle\+Settings(), on\+Headers\+Complete(), on\+Ingress(), parse\+All\+Data(), parse\+Certificate(), parse\+Certificate\+Request(), parse\+Continuation(), parse\+Data\+Frame\+Data(), parse\+Ex\+Headers(), parse\+Frame(), parse\+Goaway(), parse\+Headers(), parse\+Headers\+Check\+Concurrent\+Streams(), parse\+Headers\+Decode\+Frames(), parse\+Headers\+Impl(), parse\+Ping(), parse\+Priority(), parse\+Push\+Promise(), parse\+Rst\+Stream(), parse\+Settings(), parse\+Window\+Update(), parsing\+Trailers(), and stream\+Error().

\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!cur\+Header\+Block\+\_\+@{cur\+Header\+Block\+\_\+}}
\index{cur\+Header\+Block\+\_\+@{cur\+Header\+Block\+\_\+}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{cur\+Header\+Block\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+I\+O\+Buf\+Queue proxygen\+::\+H\+T\+T\+P2\+Codec\+::cur\+Header\+Block\+\_\+ \{folly\+::\+I\+O\+Buf\+Queue\+::cache\+Chain\+Length()\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_aaf01b9d3fabbc1bf35bb7de0676599a6}


Definition at line 255 of file H\+T\+T\+P2\+Codec.\+h.



Referenced by parse\+Frame(), parse\+Headers\+Decode\+Frames(), and parse\+Headers\+Impl().

\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!decode\+Info\+\_\+@{decode\+Info\+\_\+}}
\index{decode\+Info\+\_\+@{decode\+Info\+\_\+}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{decode\+Info\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Header\+Decode\+Info} proxygen\+::\+H\+T\+T\+P2\+Codec\+::decode\+Info\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_aef9a9b7aa814ea413206646ccc22371d}


Definition at line 283 of file H\+T\+T\+P2\+Codec.\+h.



Referenced by on\+Decode\+Error(), on\+Header(), on\+Headers\+Complete(), parse\+Headers\+Decode\+Frames(), and parsing\+Trailers().

\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!egress\+Settings\+\_\+@{egress\+Settings\+\_\+}}
\index{egress\+Settings\+\_\+@{egress\+Settings\+\_\+}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{egress\+Settings\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Settings} proxygen\+::\+H\+T\+T\+P2\+Codec\+::egress\+Settings\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a1294114a1f9b7aaac943921ea58d8c1e}
{\bfseries Initial value\+:}
\begin{DoxyCode}
\{
    \{ SettingsId::HEADER_TABLE_SIZE, 4096 \},
    \{ SettingsId::ENABLE_PUSH, 0 \},
    \{ SettingsId::MAX_FRAME_SIZE, 16384 \},
    \{ SettingsId::MAX_HEADER_LIST_SIZE, 1 << 17 \}, 
  \}
\end{DoxyCode}


Definition at line 261 of file H\+T\+T\+P2\+Codec.\+h.



Referenced by generate\+Settings(), get\+Egress\+Settings(), handle\+Settings(), H\+T\+T\+P2\+Codec(), max\+Recv\+Frame\+Size(), parse\+Frame(), parse\+Headers\+Check\+Concurrent\+Streams(), parse\+Push\+Promise(), supports\+Ex\+Transactions(), and supports\+Push\+Transactions().

\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!expected\+Continuation\+Stream\+\_\+@{expected\+Continuation\+Stream\+\_\+}}
\index{expected\+Continuation\+Stream\+\_\+@{expected\+Continuation\+Stream\+\_\+}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{expected\+Continuation\+Stream\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stream\+ID} proxygen\+::\+H\+T\+T\+P2\+Codec\+::expected\+Continuation\+Stream\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a8218e38c4b8e936fff31ef5e5419b159}


Definition at line 245 of file H\+T\+T\+P2\+Codec.\+h.



Referenced by handle\+End\+Stream(), and parse\+Frame().

\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!frame\+State\+\_\+@{frame\+State\+\_\+}}
\index{frame\+State\+\_\+@{frame\+State\+\_\+}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{frame\+State\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Frame\+State} proxygen\+::\+H\+T\+T\+P2\+Codec\+::frame\+State\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a866b702048fd151ac1c8d94c358c3b1d}


Definition at line 277 of file H\+T\+T\+P2\+Codec.\+h.



Referenced by on\+Ingress().

\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!header\+Block\+Frame\+Type\+\_\+@{header\+Block\+Frame\+Type\+\_\+}}
\index{header\+Block\+Frame\+Type\+\_\+@{header\+Block\+Frame\+Type\+\_\+}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{header\+Block\+Frame\+Type\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf http2\+::\+Frame\+Type} proxygen\+::\+H\+T\+T\+P2\+Codec\+::header\+Block\+Frame\+Type\+\_\+ \{{\bf http2\+::\+Frame\+Type\+::\+D\+A\+TA}\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_aacaa2fa8fc6582e71275ffcba59292a3}


Definition at line 298 of file H\+T\+T\+P2\+Codec.\+h.



Referenced by parse\+Headers\+Impl().

\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!header\+Codec\+\_\+@{header\+Codec\+\_\+}}
\index{header\+Codec\+\_\+@{header\+Codec\+\_\+}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{header\+Codec\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+P\+A\+C\+K\+Codec} proxygen\+::\+H\+T\+T\+P2\+Codec\+::header\+Codec\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_ac7bcfa78767ab456ff93e58574d3a464}


Definition at line 241 of file H\+T\+T\+P2\+Codec.\+h.



Referenced by encode\+Headers(), generate\+Settings(), get\+Compression\+Info(), get\+Header\+Indexing\+Strategy(), handle\+Settings(), handle\+Settings\+Ack(), H\+T\+T\+P2\+Codec(), on\+Header(), parse\+Headers\+Decode\+Frames(), set\+Header\+Codec\+Stats(), and set\+Header\+Indexing\+Strategy().

\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!ingress\+Settings\+\_\+@{ingress\+Settings\+\_\+}}
\index{ingress\+Settings\+\_\+@{ingress\+Settings\+\_\+}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{ingress\+Settings\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Settings} proxygen\+::\+H\+T\+T\+P2\+Codec\+::ingress\+Settings\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a4cc664e242d286fb8eb4359727650ef6}
{\bfseries Initial value\+:}
\begin{DoxyCode}
\{
    \{ SettingsId::HEADER_TABLE_SIZE, 4096 \},
    \{ SettingsId::ENABLE_PUSH, 1 \},
    \{ SettingsId::MAX_FRAME_SIZE, 16384 \},
  \}
\end{DoxyCode}


Definition at line 256 of file H\+T\+T\+P2\+Codec.\+h.



Referenced by encode\+Headers(), get\+Ingress\+Settings(), handle\+Settings(), max\+Send\+Frame\+Size(), parse\+Frame(), peer\+Has\+Websockets(), supports\+Ex\+Transactions(), and supports\+Push\+Transactions().

\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!ingress\+Websocket\+Upgrade\+\_\+@{ingress\+Websocket\+Upgrade\+\_\+}}
\index{ingress\+Websocket\+Upgrade\+\_\+@{ingress\+Websocket\+Upgrade\+\_\+}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{ingress\+Websocket\+Upgrade\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P2\+Codec\+::ingress\+Websocket\+Upgrade\+\_\+ \{false\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a87f918bf9d86b143090d68cb1bc49c82}


Definition at line 247 of file H\+T\+T\+P2\+Codec.\+h.



Referenced by generate\+Rst\+Stream(), handle\+End\+Stream(), and on\+Headers\+Complete().

\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!parsing\+Downstream\+Trailers\+\_\+@{parsing\+Downstream\+Trailers\+\_\+}}
\index{parsing\+Downstream\+Trailers\+\_\+@{parsing\+Downstream\+Trailers\+\_\+}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{parsing\+Downstream\+Trailers\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P2\+Codec\+::parsing\+Downstream\+Trailers\+\_\+ \{false\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a722b5a56f2be5b3339baaca36a0fa2d9}


Definition at line 294 of file H\+T\+T\+P2\+Codec.\+h.



Referenced by check\+New\+Stream(), parse\+Headers\+Decode\+Frames(), and parsing\+Trailers().

\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!pending\+Data\+Frame\+Bytes\+\_\+@{pending\+Data\+Frame\+Bytes\+\_\+}}
\index{pending\+Data\+Frame\+Bytes\+\_\+@{pending\+Data\+Frame\+Bytes\+\_\+}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{pending\+Data\+Frame\+Bytes\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::pending\+Data\+Frame\+Bytes\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_aa5db688fcc95c9364c708becaabe06fa}


Definition at line 280 of file H\+T\+T\+P2\+Codec.\+h.



Referenced by on\+Ingress(), and parse\+Data\+Frame\+Data().

\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!pending\+Data\+Frame\+Padding\+Bytes\+\_\+@{pending\+Data\+Frame\+Padding\+Bytes\+\_\+}}
\index{pending\+Data\+Frame\+Padding\+Bytes\+\_\+@{pending\+Data\+Frame\+Padding\+Bytes\+\_\+}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{pending\+Data\+Frame\+Padding\+Bytes\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::pending\+Data\+Frame\+Padding\+Bytes\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_ae38f3eafc5ee04caabba16eabfa929f8}


Definition at line 281 of file H\+T\+T\+P2\+Codec.\+h.



Referenced by on\+Ingress(), and parse\+Data\+Frame\+Data().

\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!pending\+End\+Stream\+Handling\+\_\+@{pending\+End\+Stream\+Handling\+\_\+}}
\index{pending\+End\+Stream\+Handling\+\_\+@{pending\+End\+Stream\+Handling\+\_\+}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{pending\+End\+Stream\+Handling\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P2\+Codec\+::pending\+End\+Stream\+Handling\+\_\+ \{false\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a1a7967a568fe7d2bbe930d17ec68b2cf}


Definition at line 246 of file H\+T\+T\+P2\+Codec.\+h.



Referenced by generate\+Rst\+Stream(), and handle\+End\+Stream().

\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!pending\+Table\+Max\+Size\+\_\+@{pending\+Table\+Max\+Size\+\_\+}}
\index{pending\+Table\+Max\+Size\+\_\+@{pending\+Table\+Max\+Size\+\_\+}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{pending\+Table\+Max\+Size\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+Optional$<$uint32\+\_\+t$>$ proxygen\+::\+H\+T\+T\+P2\+Codec\+::pending\+Table\+Max\+Size\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a299b42fb33daa4ed29f1bd5a660d40cf}


Definition at line 285 of file H\+T\+T\+P2\+Codec.\+h.



Referenced by generate\+Settings(), and handle\+Settings\+Ack().

\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!received\+Frame\+Count\+\_\+@{received\+Frame\+Count\+\_\+}}
\index{received\+Frame\+Count\+\_\+@{received\+Frame\+Count\+\_\+}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{received\+Frame\+Count\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}uint64\+\_\+t proxygen\+::\+H\+T\+T\+P2\+Codec\+::received\+Frame\+Count\+\_\+ \{0\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a4d0d2d4a29609511eaa3344b046ab821}


Definition at line 268 of file H\+T\+T\+P2\+Codec.\+h.



Referenced by get\+Received\+Frame\+Count(), and on\+Ingress().

\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!reuse\+I\+O\+Buf\+Headroom\+For\+Data\+\_\+@{reuse\+I\+O\+Buf\+Headroom\+For\+Data\+\_\+}}
\index{reuse\+I\+O\+Buf\+Headroom\+For\+Data\+\_\+@{reuse\+I\+O\+Buf\+Headroom\+For\+Data\+\_\+}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{reuse\+I\+O\+Buf\+Headroom\+For\+Data\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P2\+Codec\+::reuse\+I\+O\+Buf\+Headroom\+For\+Data\+\_\+ \{true\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a3c913acf656d07ceb805e6d2a27482b9}


Definition at line 286 of file H\+T\+T\+P2\+Codec.\+h.



Referenced by generate\+Body(), generate\+E\+O\+M(), and set\+Reuse\+I\+O\+Buf\+Headroom\+For\+Data().

\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!upgraded\+Streams\+\_\+@{upgraded\+Streams\+\_\+}}
\index{upgraded\+Streams\+\_\+@{upgraded\+Streams\+\_\+}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{upgraded\+Streams\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unordered\+\_\+set$<${\bf Stream\+ID}$>$ proxygen\+::\+H\+T\+T\+P2\+Codec\+::upgraded\+Streams\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a002e5cf628c1fde79ffda426913dd02b}


Definition at line 249 of file H\+T\+T\+P2\+Codec.\+h.



Referenced by generate\+E\+O\+M(), generate\+Header\+Impl(), generate\+Rst\+Stream(), on\+Headers\+Complete(), and parse\+Rst\+Stream().

\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!user\+Agent\+\_\+@{user\+Agent\+\_\+}}
\index{user\+Agent\+\_\+@{user\+Agent\+\_\+}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{user\+Agent\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string proxygen\+::\+H\+T\+T\+P2\+Codec\+::user\+Agent\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_a838563c665ae88ebd4b2efae5ec72d24}


Definition at line 278 of file H\+T\+T\+P2\+Codec.\+h.



Referenced by generate\+Goaway(), generate\+Rst\+Stream(), get\+User\+Agent(), on\+Header(), parse\+Goaway(), and parse\+Rst\+Stream().

\index{proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}!virtual\+Priority\+Nodes\+\_\+@{virtual\+Priority\+Nodes\+\_\+}}
\index{virtual\+Priority\+Nodes\+\_\+@{virtual\+Priority\+Nodes\+\_\+}!proxygen\+::\+H\+T\+T\+P2\+Codec@{proxygen\+::\+H\+T\+T\+P2\+Codec}}
\subsubsection[{virtual\+Priority\+Nodes\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<${\bf Stream\+ID}$>$ proxygen\+::\+H\+T\+T\+P2\+Codec\+::virtual\+Priority\+Nodes\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP2Codec_ace111d908b93f5d09e4e8d0f0e9a5155}


Definition at line 284 of file H\+T\+T\+P2\+Codec.\+h.



Referenced by add\+Priority\+Nodes(), and map\+Priority\+To\+Dependency().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
proxygen/lib/http/codec/{\bf H\+T\+T\+P2\+Codec.\+h}\item 
proxygen/lib/http/codec/{\bf H\+T\+T\+P2\+Codec.\+cpp}\end{DoxyCompactItemize}
