\section{proxygen\+:\+:H\+T\+T\+P\+Server Class Reference}
\label{classproxygen_1_1HTTPServer}\index{proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}}


{\ttfamily \#include $<$H\+T\+T\+P\+Server.\+h$>$}

\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct {\bf I\+P\+Config}
\end{DoxyCompactItemize}
\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum {\bf Protocol} \+: uint8\+\_\+t \{ {\bf Protocol\+::\+H\+T\+TP}, 
{\bf Protocol\+::\+S\+P\+DY}, 
{\bf Protocol\+::\+H\+T\+T\+P2}
 \}
\end{DoxyCompactItemize}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf H\+T\+T\+P\+Server} ({\bf H\+T\+T\+P\+Server\+Options} options)
\item 
{\bf $\sim$\+H\+T\+T\+P\+Server} ()
\item 
void {\bf bind} (std\+::vector$<$ {\bf I\+P\+Config} $>$ \&\&addrs)
\item 
void {\bf bind} (std\+::vector$<$ {\bf I\+P\+Config} $>$ const \&addrs)
\item 
void {\bf start} (std\+::function$<$ void()$>$ on\+Success={\bf nullptr}, std\+::function$<$ void(std\+::exception\+\_\+ptr)$>$ on\+Error={\bf nullptr})
\item 
void {\bf stop\+Listening} ()
\item 
void {\bf stop} ()
\item 
std\+::vector$<$ {\bf I\+P\+Config} $>$ {\bf addresses} () const 
\item 
const std\+::vector$<$ const folly\+::\+Async\+Socket\+Base $\ast$ $>$ {\bf get\+Sockets} () const 
\item 
void {\bf set\+Session\+Info\+Callback} ({\bf H\+T\+T\+P\+Session\+::\+Info\+Callback} $\ast$cb)
\item 
int {\bf get\+Listen\+Socket} () const 
\item 
void {\bf update\+T\+L\+S\+Credentials} ()
\item 
void {\bf update\+Ticket\+Seeds} (wangle\+::\+T\+L\+S\+Ticket\+Key\+Seeds seeds)
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::shared\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Server\+Options} $>$ {\bf options\+\_\+}
\item 
folly\+::\+Event\+Base $\ast$ {\bf main\+Event\+Base\+\_\+} \{{\bf nullptr}\}
\item 
std\+::unique\+\_\+ptr$<$ {\bf Signal\+Handler} $>$ {\bf signal\+Handler\+\_\+}
\item 
std\+::vector$<$ {\bf I\+P\+Config} $>$ {\bf addresses\+\_\+}
\item 
std\+::vector$<$ wangle\+::\+Server\+Bootstrap$<$ wangle\+::\+Default\+Pipeline $>$ $>$ {\bf bootstrap\+\_\+}
\item 
{\bf H\+T\+T\+P\+Session\+::\+Info\+Callback} $\ast$ {\bf session\+Info\+Cb\+\_\+} \{{\bf nullptr}\}
\end{DoxyCompactItemize}


\subsection{Detailed Description}
\doxyref{H\+T\+T\+P\+Server}{p.}{classproxygen_1_1HTTPServer} based on proxygen http libraries 

Definition at line 28 of file H\+T\+T\+P\+Server.\+h.



\subsection{Member Enumeration Documentation}
\index{proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}!Protocol@{Protocol}}
\index{Protocol@{Protocol}!proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}}
\subsubsection[{Protocol}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+H\+T\+T\+P\+Server\+::\+Protocol} \+: uint8\+\_\+t\hspace{0.3cm}{\ttfamily [strong]}}\label{classproxygen_1_1HTTPServer_aa27f45acacd7a57c59ddba1729b520e2}
For each IP you can specify H\+T\+TP protocol to use. You can use plain old H\+T\+T\+P/1.\+1 protocol or S\+P\+D\+Y/3.\+1 for now. \begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{H\+T\+TP@{H\+T\+TP}!proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}}\index{proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}!H\+T\+TP@{H\+T\+TP}}\item[{\em 
H\+T\+TP\label{classproxygen_1_1HTTPServer_aa27f45acacd7a57c59ddba1729b520e2a293c9ea246ff9985dc6f62a650f78986}
}]\index{S\+P\+DY@{S\+P\+DY}!proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}}\index{proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}!S\+P\+DY@{S\+P\+DY}}\item[{\em 
S\+P\+DY\label{classproxygen_1_1HTTPServer_aa27f45acacd7a57c59ddba1729b520e2adbc2b23f8602ccdf438c0f5dce917655}
}]\index{H\+T\+T\+P2@{H\+T\+T\+P2}!proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}}\index{proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}!H\+T\+T\+P2@{H\+T\+T\+P2}}\item[{\em 
H\+T\+T\+P2\label{classproxygen_1_1HTTPServer_aa27f45acacd7a57c59ddba1729b520e2ae911468ee8681ba1862cf34bc5e85a8a}
}]\end{description}
\end{Desc}


Definition at line 34 of file H\+T\+T\+P\+Server.\+h.


\begin{DoxyCode}
34                      : uint8\_t \{
35     HTTP,
36     SPDY,
37     HTTP2,
38   \};
\end{DoxyCode}


\subsection{Constructor \& Destructor Documentation}
\index{proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}!H\+T\+T\+P\+Server@{H\+T\+T\+P\+Server}}
\index{H\+T\+T\+P\+Server@{H\+T\+T\+P\+Server}!proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}}
\subsubsection[{H\+T\+T\+P\+Server(\+H\+T\+T\+P\+Server\+Options options)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+H\+T\+T\+P\+Server\+::\+H\+T\+T\+P\+Server (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Server\+Options}}]{options}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [explicit]}}\label{classproxygen_1_1HTTPServer_a95eb0589c9e61565268d6f9075491a9f}
Create a new \doxyref{H\+T\+T\+P\+Server}{p.}{classproxygen_1_1HTTPServer} 

Definition at line 59 of file H\+T\+T\+P\+Server.\+cpp.



References options\+\_\+.


\begin{DoxyCode}
59                                                :
60     options_(std::make\_shared<HTTPServerOptions>(std::move(options))) \{
61 
62   \textcolor{comment}{// Insert a filter to fail all the CONNECT request, if required}
63   \textcolor{keywordflow}{if} (!options_->supportsConnect) \{
64     options_->handlerFactories.insert(
65         options_->handlerFactories.begin(),
66         std::make\_unique<RejectConnectFilterFactory>());
67   \}
68 
69   \textcolor{comment}{// Add Content Compression filter (gzip), if needed. Should be}
70   \textcolor{comment}{// final filter}
71   \textcolor{keywordflow}{if} (options_->enableContentCompression) \{
72     options_->handlerFactories.insert(
73         options_->handlerFactories.begin(),
74         std::make\_unique<ZlibServerFilterFactory>(
75           options_->contentCompressionLevel,
76           options_->contentCompressionMinimumSize,
77           options_->contentCompressionTypes));
78   \}
79 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}!````~H\+T\+T\+P\+Server@{$\sim$\+H\+T\+T\+P\+Server}}
\index{````~H\+T\+T\+P\+Server@{$\sim$\+H\+T\+T\+P\+Server}!proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}}
\subsubsection[{$\sim$\+H\+T\+T\+P\+Server()}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+H\+T\+T\+P\+Server\+::$\sim$\+H\+T\+T\+P\+Server (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPServer_a4422f89e16391e15f2e21b503c9d91a6}


Definition at line 81 of file H\+T\+T\+P\+Server.\+cpp.



References main\+Event\+Base\+\_\+.


\begin{DoxyCode}
81                         \{
82   CHECK(!mainEventBase_) << \textcolor{stringliteral}{"Forgot to stop() server?"};
83 \}
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}!addresses@{addresses}}
\index{addresses@{addresses}!proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}}
\subsubsection[{addresses() const }]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<${\bf I\+P\+Config}$>$ proxygen\+::\+H\+T\+T\+P\+Server\+::addresses (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HTTPServer_afff93c766bccb2cc19c092754b010467}
Get the list of addresses server is listening on. Empty if sockets are not bound yet. 

Definition at line 139 of file H\+T\+T\+P\+Server.\+h.



References addresses\+\_\+, and get\+Sockets().



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
139                                         \{
140     \textcolor{keywordflow}{return} addresses_;
141   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}!bind@{bind}}
\index{bind@{bind}!proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}}
\subsubsection[{bind(std\+::vector$<$ I\+P\+Config $>$ \&\&addrs)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Server\+::bind (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ {\bf I\+P\+Config} $>$ \&\&}]{addrs}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPServer_a1a79d15c20a1634ca890b4c316f71079}
Configure server to bind to the following addresses.

Actual bind happens in {\ttfamily start} function.

Can be called from any thread. 

Definition at line 85 of file H\+T\+T\+P\+Server.\+cpp.



References addresses\+\_\+.



Referenced by main().


\begin{DoxyCode}
85                                                  \{
86   addresses_ = std::move(addrs);
87 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}!bind@{bind}}
\index{bind@{bind}!proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}}
\subsubsection[{bind(std\+::vector$<$ I\+P\+Config $>$ const \&addrs)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Server\+::bind (
\begin{DoxyParamCaption}
\item[{std\+::vector$<$ {\bf I\+P\+Config} $>$ const \&}]{addrs}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPServer_a1bbe79a5b7854312d32a5a780bfa9373}


Definition at line 89 of file H\+T\+T\+P\+Server.\+cpp.



References addresses\+\_\+.


\begin{DoxyCode}
89                                                       \{
90   addresses_ = addrs;
91 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}!get\+Listen\+Socket@{get\+Listen\+Socket}}
\index{get\+Listen\+Socket@{get\+Listen\+Socket}!proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}}
\subsubsection[{get\+Listen\+Socket() const }]{\setlength{\rightskip}{0pt plus 5cm}int proxygen\+::\+H\+T\+T\+P\+Server\+::get\+Listen\+Socket (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classproxygen_1_1HTTPServer_a797b4b17bc591954bedaaa3028a51e91}
Returns a file descriptor associated with the listening socket 

Definition at line 224 of file H\+T\+T\+P\+Server.\+cpp.



References bootstrap\+\_\+.



Referenced by set\+Session\+Info\+Callback(), and T\+E\+S\+T().


\begin{DoxyCode}
224                                       \{
225   \textcolor{keywordflow}{if} (bootstrap_.size() == 0) \{
226     \textcolor{keywordflow}{return} -1;
227   \}
228 
229   \textcolor{keyword}{auto}& bootstrapSockets = bootstrap_[0].getSockets();
230   \textcolor{keywordflow}{if} (bootstrapSockets.size() == 0) \{
231     \textcolor{keywordflow}{return} -1;
232   \}
233 
234   \textcolor{keyword}{auto} serverSocket =
235       std::dynamic\_pointer\_cast<folly::AsyncServerSocket>(bootstrapSockets[0]);
236   \textcolor{keyword}{auto} socketFds = serverSocket->getSockets();
237   \textcolor{keywordflow}{if} (socketFds.size() == 0) \{
238     \textcolor{keywordflow}{return} -1;
239   \}
240 
241   \textcolor{keywordflow}{return} socketFds[0];
242 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}!get\+Sockets@{get\+Sockets}}
\index{get\+Sockets@{get\+Sockets}!proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}}
\subsubsection[{get\+Sockets() const }]{\setlength{\rightskip}{0pt plus 5cm}const std\+::vector$<$ const folly\+::\+Async\+Socket\+Base $\ast$ $>$ proxygen\+::\+H\+T\+T\+P\+Server\+::get\+Sockets (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const}\label{classproxygen_1_1HTTPServer_a7e08a94fc022f27700ec86ee9af9f911}
Get the sockets the server is currently bound to. 

Definition at line 211 of file H\+T\+T\+P\+Server.\+cpp.



References bootstrap\+\_\+.



Referenced by addresses().


\begin{DoxyCode}
211                                \{
212 
213   std::vector<const folly::AsyncSocketBase*> sockets;
214   FOR\_EACH\_RANGE(i, 0, bootstrap_.size()) \{
215     \textcolor{keyword}{auto}& bootstrapSockets = bootstrap_[i].getSockets();
216     FOR\_EACH\_RANGE(j, 0, bootstrapSockets.size()) \{
217       sockets.push\_back(bootstrapSockets[j].\textcolor{keyword}{get}());
218     \}
219   \}
220 
221   \textcolor{keywordflow}{return} sockets;
222 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}!set\+Session\+Info\+Callback@{set\+Session\+Info\+Callback}}
\index{set\+Session\+Info\+Callback@{set\+Session\+Info\+Callback}!proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}}
\subsubsection[{set\+Session\+Info\+Callback(\+H\+T\+T\+P\+Session\+::\+Info\+Callback $\ast$cb)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Server\+::set\+Session\+Info\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Session\+::\+Info\+Callback} $\ast$}]{cb}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}}\label{classproxygen_1_1HTTPServer_a77d9eab4adcb373d3f1df182778d5619}


Definition at line 148 of file H\+T\+T\+P\+Server.\+h.



References get\+Listen\+Socket(), session\+Info\+Cb\+\_\+, update\+Ticket\+Seeds(), and update\+T\+L\+S\+Credentials().


\begin{DoxyCode}
148                                                            \{
149     sessionInfoCb_ = cb;
150   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}!start@{start}}
\index{start@{start}!proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}}
\subsubsection[{start(std\+::function$<$ void()$>$ on\+Success=nullptr, std\+::function$<$ void(std\+::exception\+\_\+ptr)$>$ on\+Error=nullptr)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Server\+::start (
\begin{DoxyParamCaption}
\item[{std\+::function$<$ void()$>$}]{on\+Success = {\ttfamily {\bf nullptr}}, }
\item[{std\+::function$<$ void(std\+::exception\+\_\+ptr)$>$}]{on\+Error = {\ttfamily {\bf nullptr}}}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPServer_a19e1851fcecf37f4e3cb3d6da11321b2}
Start \doxyref{H\+T\+T\+P\+Server}{p.}{classproxygen_1_1HTTPServer}.

Note this is a blocking call and the current thread will be used to listen for incoming connections. Throws exception if something goes wrong (say somebody else is already listening on that socket).

{\ttfamily on\+Success} callback will be invoked from the event loop which shows that all the setup was successfully done.

{\ttfamily on\+Error} callback will be invoked if some errors occurs while starting the server instead of throwing exception. 

Definition at line 119 of file H\+T\+T\+P\+Server.\+cpp.



References addresses\+\_\+, bootstrap\+\_\+, main\+Event\+Base\+\_\+, proxygen\+::\+H\+T\+T\+P\+Server\+Acceptor\+::make\+Config(), options\+\_\+, session\+Info\+Cb\+\_\+, signal\+Handler\+\_\+, and stop().



Referenced by main().


\begin{DoxyCode}
120                                                                     \{
121   mainEventBase_ = EventBaseManager::get()->getEventBase();
122 
123   \textcolor{keyword}{auto} accExe = std::make\_shared<IOThreadPoolExecutor>(1);
124   \textcolor{keyword}{auto} exe = std::make\_shared<IOThreadPoolExecutor>(options_->threads,
125     std::make\_shared<folly::NamedThreadFactory>(\textcolor{stringliteral}{"HTTPSrvExec"}));
126   \textcolor{keyword}{auto} exeObserver = std::make\_shared<HandlerCallbacks>(options_);
127   \textcolor{comment}{// Observer has to be set before bind(), so onServerStart() callbacks run}
128   exe->addObserver(exeObserver);
129 
130   \textcolor{keywordflow}{try} \{
131     FOR\_EACH\_RANGE (i, 0, addresses_.size()) \{
132       \textcolor{keyword}{auto} codecFactory = addresses_[i].codecFactory;
133       \textcolor{keyword}{auto} accConfig = HTTPServerAcceptor::makeConfig(addresses_[i], *options_);
134       \textcolor{keyword}{auto} factory = std::make\_shared<AcceptorFactory>(
135           options_,
136           codecFactory,
137           accConfig,
138           sessionInfoCb_);
139       bootstrap_.push\_back(
140           wangle::ServerBootstrap<wangle::DefaultPipeline>());
141       bootstrap_[i].childHandler(factory);
142       \textcolor{keywordflow}{if} (accConfig.enableTCPFastOpen) \{
143         \textcolor{comment}{// We need to do this because wangle's bootstrap has 2 acceptor configs}
144         \textcolor{comment}{// and the socketConfig gets passed to the SocketFactory. The number of}
145         \textcolor{comment}{// configs should really be one, and when that happens, we can remove}
146         \textcolor{comment}{// this code path.}
147         bootstrap_[i].socketConfig.enableTCPFastOpen = \textcolor{keyword}{true};
148         bootstrap_[i].socketConfig.fastOpenQueueSize =
149             accConfig.fastOpenQueueSize;
150       \}
151       bootstrap_[i].group(accExe, exe);
152       \textcolor{keywordflow}{if} (options\_->preboundSockets\_.size() > 0) \{
153         bootstrap_[i].bind(std::move(options\_->preboundSockets\_[i]));
154       \} \textcolor{keywordflow}{else} \{
155         bootstrap_[i].bind(addresses_[i].address);
156       \}
157     \}
158   \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} std::exception& ex) \{
159     stop();
160 
161     \textcolor{keywordflow}{if} (onError) \{
162       onError(std::current\_exception());
163       \textcolor{keywordflow}{return};
164     \}
165 
166     \textcolor{keywordflow}{throw};
167   \}
168 
169   \textcolor{comment}{// Install signal handler if required}
170   \textcolor{keywordflow}{if} (!options\_->shutdownOn.empty()) \{
171     signalHandler_ = std::make\_unique<SignalHandler>(\textcolor{keyword}{this});
172     signalHandler_->install(options\_->shutdownOn);
173   \}
174 
175   \textcolor{comment}{// Start the main event loop.}
176   \textcolor{keywordflow}{if} (onSuccess) \{
177     mainEventBase_->runInLoop([onSuccess(std::move(onSuccess))]() \{
178       \textcolor{comment}{// IMPORTANT: Since we may be racing with stop(), we must assume that}
179       \textcolor{comment}{// mainEventBase\_ can become null the moment that onSuccess is called,}
180       \textcolor{comment}{// so this **has** to be queued to run from inside loopForever().}
181         onSuccess();
182     \});
183   \}
184   mainEventBase_->loopForever();
185 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}!stop@{stop}}
\index{stop@{stop}!proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}}
\subsubsection[{stop()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Server\+::stop (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPServer_acdb213f592f853fb01279d01a38b3946}
Stop \doxyref{H\+T\+T\+P\+Server}{p.}{classproxygen_1_1HTTPServer}.

Can be called from any thread, but only after \doxyref{start()}{p.}{classproxygen_1_1HTTPServer_a19e1851fcecf37f4e3cb3d6da11321b2} has called on\+Success. Server will stop listening for new connections and will wait for running requests to finish.

T\+O\+DO\+: Separate method to do hard shutdown? 

Definition at line 193 of file H\+T\+T\+P\+Server.\+cpp.



References bootstrap\+\_\+, main\+Event\+Base\+\_\+, signal\+Handler\+\_\+, and stop\+Listening().



Referenced by proxygen\+::\+Signal\+Handler\+::signal\+Received(), and start().


\begin{DoxyCode}
193                       \{
194   stopListening();
195 
196   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}& bootstrap : bootstrap_) \{
197     bootstrap.join();
198   \}
199 
200   \textcolor{keywordflow}{if} (signalHandler_) \{
201     signalHandler_.reset();
202   \}
203 
204   \textcolor{keywordflow}{if} (mainEventBase_) \{
205     mainEventBase_->terminateLoopSoon();
206     mainEventBase_ = \textcolor{keyword}{nullptr};
207   \}
208 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}!stop\+Listening@{stop\+Listening}}
\index{stop\+Listening@{stop\+Listening}!proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}}
\subsubsection[{stop\+Listening()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Server\+::stop\+Listening (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPServer_a3a9be5ce511a9267631f5348ae1aa24b}
Stop listening on bound ports. (Stop accepting new work). It does not wait for pending work to complete. You must still invoke \doxyref{stop()}{p.}{classproxygen_1_1HTTPServer_acdb213f592f853fb01279d01a38b3946} before destroying the server. You do N\+OT need to invoke this before calling \doxyref{stop()}{p.}{classproxygen_1_1HTTPServer_acdb213f592f853fb01279d01a38b3946}. This can be called from any thread, and it is idempotent. However, it may only be called {\bfseries after} \doxyref{start()}{p.}{classproxygen_1_1HTTPServer_a19e1851fcecf37f4e3cb3d6da11321b2} has called on\+Success. 

Definition at line 187 of file H\+T\+T\+P\+Server.\+cpp.



References bootstrap\+\_\+.



Referenced by stop(), and T\+E\+S\+T().


\begin{DoxyCode}
187                                \{
188   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}& bootstrap : bootstrap_) \{
189     bootstrap.stop();
190   \}
191 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}!update\+Ticket\+Seeds@{update\+Ticket\+Seeds}}
\index{update\+Ticket\+Seeds@{update\+Ticket\+Seeds}!proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}}
\subsubsection[{update\+Ticket\+Seeds(wangle\+::\+T\+L\+S\+Ticket\+Key\+Seeds seeds)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Server\+::update\+Ticket\+Seeds (
\begin{DoxyParamCaption}
\item[{wangle\+::\+T\+L\+S\+Ticket\+Key\+Seeds}]{seeds}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPServer_ab755831704988d73949676d864339948}
Updates ticket seeds for the \doxyref{H\+T\+T\+P\+Server}{p.}{classproxygen_1_1HTTPServer} for all the V\+I\+Ps. 

Definition at line 262 of file H\+T\+T\+P\+Server.\+cpp.



References bootstrap\+\_\+.



Referenced by set\+Session\+Info\+Callback(), and T\+E\+S\+T().


\begin{DoxyCode}
262                                                                 \{
263   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}& bootstrap : bootstrap_) \{
264     bootstrap.forEachWorker([&](wangle::Acceptor* acceptor) \{
265       \textcolor{keywordflow}{if} (!acceptor || !acceptor->isSSL()) \{
266         \textcolor{keywordflow}{return};
267       \}
268       \textcolor{keyword}{auto} evb = acceptor->getEventBase();
269       \textcolor{keywordflow}{if} (!evb) \{
270         \textcolor{keywordflow}{return};
271       \}
272       evb->runInEventBaseThread([acceptor, seeds] \{
273         acceptor->setTLSTicketSecrets(
274             seeds.oldSeeds, seeds.currentSeeds, seeds.newSeeds);
275       \});
276     \});
277   \}
278 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}!update\+T\+L\+S\+Credentials@{update\+T\+L\+S\+Credentials}}
\index{update\+T\+L\+S\+Credentials@{update\+T\+L\+S\+Credentials}!proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}}
\subsubsection[{update\+T\+L\+S\+Credentials()}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P\+Server\+::update\+T\+L\+S\+Credentials (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTPServer_a087aaed0120183af4fa08a59926b857f}
Re-\/reads the certificate / key pair for all S\+SL vips on all acceptors 

Definition at line 245 of file H\+T\+T\+P\+Server.\+cpp.



References bootstrap\+\_\+.



Referenced by set\+Session\+Info\+Callback().


\begin{DoxyCode}
245                                       \{
246   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}& bootstrap : bootstrap_) \{
247     bootstrap.forEachWorker([&](wangle::Acceptor* acceptor) \{
248       \textcolor{keywordflow}{if} (!acceptor || !acceptor->isSSL()) \{
249         \textcolor{keywordflow}{return};
250       \}
251       \textcolor{keyword}{auto} evb = acceptor->getEventBase();
252       \textcolor{keywordflow}{if} (!evb) \{
253         \textcolor{keywordflow}{return};
254       \}
255       evb->runInEventBaseThread([acceptor] \{
256         acceptor->resetSSLContextConfigs();
257       \});
258     \});
259   \}
260 \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}!addresses\+\_\+@{addresses\+\_\+}}
\index{addresses\+\_\+@{addresses\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}}
\subsubsection[{addresses\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<${\bf I\+P\+Config}$>$ proxygen\+::\+H\+T\+T\+P\+Server\+::addresses\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPServer_ae5ba0f644861eb77c2c9e1b518a93e1a}
Addresses we are listening on 

Definition at line 183 of file H\+T\+T\+P\+Server.\+h.



Referenced by addresses(), bind(), and start().

\index{proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}!bootstrap\+\_\+@{bootstrap\+\_\+}}
\index{bootstrap\+\_\+@{bootstrap\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}}
\subsubsection[{bootstrap\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$wangle\+::\+Server\+Bootstrap$<$wangle\+::\+Default\+Pipeline$>$ $>$ proxygen\+::\+H\+T\+T\+P\+Server\+::bootstrap\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPServer_a8c27604e2f12713a0f35b9391b7fc309}


Definition at line 184 of file H\+T\+T\+P\+Server.\+h.



Referenced by get\+Listen\+Socket(), get\+Sockets(), start(), stop(), stop\+Listening(), update\+Ticket\+Seeds(), and update\+T\+L\+S\+Credentials().

\index{proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}!main\+Event\+Base\+\_\+@{main\+Event\+Base\+\_\+}}
\index{main\+Event\+Base\+\_\+@{main\+Event\+Base\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}}
\subsubsection[{main\+Event\+Base\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+Event\+Base$\ast$ proxygen\+::\+H\+T\+T\+P\+Server\+::main\+Event\+Base\+\_\+ \{{\bf nullptr}\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPServer_a43bc593fe3746f09cce6b0f36804251a}
Event base in which we binded server sockets. 

Definition at line 173 of file H\+T\+T\+P\+Server.\+h.



Referenced by start(), stop(), and $\sim$\+H\+T\+T\+P\+Server().

\index{proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}!options\+\_\+@{options\+\_\+}}
\index{options\+\_\+@{options\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}}
\subsubsection[{options\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::shared\+\_\+ptr$<${\bf H\+T\+T\+P\+Server\+Options}$>$ proxygen\+::\+H\+T\+T\+P\+Server\+::options\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPServer_a382fa6e29181838aedb51a48e1419f6e}


Definition at line 168 of file H\+T\+T\+P\+Server.\+h.



Referenced by H\+T\+T\+P\+Server(), start(), proxygen\+::\+Handler\+Callbacks\+::thread\+Started(), and proxygen\+::\+Handler\+Callbacks\+::thread\+Stopped().

\index{proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}!session\+Info\+Cb\+\_\+@{session\+Info\+Cb\+\_\+}}
\index{session\+Info\+Cb\+\_\+@{session\+Info\+Cb\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}}
\subsubsection[{session\+Info\+Cb\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Session\+::\+Info\+Callback}$\ast$ proxygen\+::\+H\+T\+T\+P\+Server\+::session\+Info\+Cb\+\_\+ \{{\bf nullptr}\}\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPServer_ac8895144d1f0c6595cedba7f24964281}
Callback for session create/destruction 

Definition at line 189 of file H\+T\+T\+P\+Server.\+h.



Referenced by set\+Session\+Info\+Callback(), and start().

\index{proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}!signal\+Handler\+\_\+@{signal\+Handler\+\_\+}}
\index{signal\+Handler\+\_\+@{signal\+Handler\+\_\+}!proxygen\+::\+H\+T\+T\+P\+Server@{proxygen\+::\+H\+T\+T\+P\+Server}}
\subsubsection[{signal\+Handler\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<${\bf Signal\+Handler}$>$ proxygen\+::\+H\+T\+T\+P\+Server\+::signal\+Handler\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTPServer_a4528e1738a7bc419154999548fbaaab5}
Optional signal handlers on which we should shutdown server 

Definition at line 178 of file H\+T\+T\+P\+Server.\+h.



Referenced by start(), and stop().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
proxygen/httpserver/{\bf H\+T\+T\+P\+Server.\+h}\item 
proxygen/httpserver/{\bf H\+T\+T\+P\+Server.\+cpp}\end{DoxyCompactItemize}
