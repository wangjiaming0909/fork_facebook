\section{proxygen\+:\+:R\+F\+C2616 Namespace Reference}
\label{namespaceproxygen_1_1RFC2616}\index{proxygen\+::\+R\+F\+C2616@{proxygen\+::\+R\+F\+C2616}}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using {\bf Token\+Q\+Pair} = std\+::pair$<$ folly\+::\+String\+Piece, double $>$
\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum {\bf Body\+Allowed} \{ {\bf Body\+Allowed\+::\+D\+E\+F\+I\+N\+ED}, 
{\bf Body\+Allowed\+::\+N\+O\+T\+\_\+\+D\+E\+F\+I\+N\+ED}, 
{\bf Body\+Allowed\+::\+N\+O\+T\+\_\+\+A\+L\+L\+O\+W\+ED}
 \}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Body\+Allowed} {\bf is\+Request\+Body\+Allowed} (folly\+::\+Optional$<$ {\bf H\+T\+T\+P\+Method} $>$ method)
\item 
bool {\bf response\+Body\+Must\+Be\+Empty} (unsigned status)
\item 
bool {\bf body\+Implied} (const {\bf H\+T\+T\+P\+Headers} \&headers)
\item 
bool {\bf parse\+Qvalues} (folly\+::\+String\+Piece value, std\+::vector$<$ {\bf Token\+Q\+Pair} $>$ \&output)
\item 
bool {\bf parse\+Byte\+Range\+Spec} (folly\+::\+String\+Piece value, unsigned long \&out\+First\+Byte, unsigned long \&out\+Last\+Byte, unsigned long \&out\+Instance\+Length)
\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\index{proxygen\+::\+R\+F\+C2616@{proxygen\+::\+R\+F\+C2616}!Token\+Q\+Pair@{Token\+Q\+Pair}}
\index{Token\+Q\+Pair@{Token\+Q\+Pair}!proxygen\+::\+R\+F\+C2616@{proxygen\+::\+R\+F\+C2616}}
\subsubsection[{Token\+Q\+Pair}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::\+R\+F\+C2616\+::\+Token\+Q\+Pair} = typedef std\+::pair$<$folly\+::\+String\+Piece, double$>$}\label{namespaceproxygen_1_1RFC2616_ab879755d2a94c65fdf500196944b3364}
Parse a string containing tokens and qvalues, such as the R\+FC strings for Accept-\/\+Charset, Accept-\/\+Encoding and Accept-\/\+Language. It won\textquotesingle{}t work for complex Accept\+: headers because it doesn\textquotesingle{}t return parameters or accept-\/extension.

See R\+FC sections 14.\+2, 14.\+3, 14.\+4 for definitions of these header values

T\+O\+DO\+: optionally sort by qvalue descending

Return true if the string was well formed according to the R\+FC. Note it can return false but still populate output with best-\/effort parsing. 

Definition at line 69 of file R\+F\+C2616.\+h.



\subsection{Enumeration Type Documentation}
\index{proxygen\+::\+R\+F\+C2616@{proxygen\+::\+R\+F\+C2616}!Body\+Allowed@{Body\+Allowed}}
\index{Body\+Allowed@{Body\+Allowed}!proxygen\+::\+R\+F\+C2616@{proxygen\+::\+R\+F\+C2616}}
\subsubsection[{Body\+Allowed}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+R\+F\+C2616\+::\+Body\+Allowed}\hspace{0.3cm}{\ttfamily [strong]}}\label{namespaceproxygen_1_1RFC2616_acb9891a80a8184a88b2ebe39c4950b5b}
This file contains functions for determining when certain tricky parts of R\+FC 2616 arise. The H\+T\+TP request as defined in R\+FC 2616 may or may not have a body. In some cases they M\+U\+ST N\+OT have a body. In other cases, the body has no semantic meaning and so is not defined. Finally, for some methods, the body is well defined. Please see Section 9 and 4.\+3 for details on this. \begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{D\+E\+F\+I\+N\+ED@{D\+E\+F\+I\+N\+ED}!proxygen\+::\+R\+F\+C2616@{proxygen\+::\+R\+F\+C2616}}\index{proxygen\+::\+R\+F\+C2616@{proxygen\+::\+R\+F\+C2616}!D\+E\+F\+I\+N\+ED@{D\+E\+F\+I\+N\+ED}}\item[{\em 
D\+E\+F\+I\+N\+ED\label{namespaceproxygen_1_1RFC2616_acb9891a80a8184a88b2ebe39c4950b5bad95be57411fe22c8d2c9e829b2a0cf85}
}]\index{N\+O\+T\+\_\+\+D\+E\+F\+I\+N\+ED@{N\+O\+T\+\_\+\+D\+E\+F\+I\+N\+ED}!proxygen\+::\+R\+F\+C2616@{proxygen\+::\+R\+F\+C2616}}\index{proxygen\+::\+R\+F\+C2616@{proxygen\+::\+R\+F\+C2616}!N\+O\+T\+\_\+\+D\+E\+F\+I\+N\+ED@{N\+O\+T\+\_\+\+D\+E\+F\+I\+N\+ED}}\item[{\em 
N\+O\+T\+\_\+\+D\+E\+F\+I\+N\+ED\label{namespaceproxygen_1_1RFC2616_acb9891a80a8184a88b2ebe39c4950b5babfd8c78fbb91fe67b9886fad146392a4}
}]\index{N\+O\+T\+\_\+\+A\+L\+L\+O\+W\+ED@{N\+O\+T\+\_\+\+A\+L\+L\+O\+W\+ED}!proxygen\+::\+R\+F\+C2616@{proxygen\+::\+R\+F\+C2616}}\index{proxygen\+::\+R\+F\+C2616@{proxygen\+::\+R\+F\+C2616}!N\+O\+T\+\_\+\+A\+L\+L\+O\+W\+ED@{N\+O\+T\+\_\+\+A\+L\+L\+O\+W\+ED}}\item[{\em 
N\+O\+T\+\_\+\+A\+L\+L\+O\+W\+ED\label{namespaceproxygen_1_1RFC2616_acb9891a80a8184a88b2ebe39c4950b5ba4596302bc1e8ce6e62188e769aac94cf}
}]\end{description}
\end{Desc}


Definition at line 34 of file R\+F\+C2616.\+h.


\begin{DoxyCode}
34                        \{
35   DEFINED,
36   NOT_DEFINED,
37   NOT_ALLOWED,
38 \};
\end{DoxyCode}


\subsection{Function Documentation}
\index{proxygen\+::\+R\+F\+C2616@{proxygen\+::\+R\+F\+C2616}!body\+Implied@{body\+Implied}}
\index{body\+Implied@{body\+Implied}!proxygen\+::\+R\+F\+C2616@{proxygen\+::\+R\+F\+C2616}}
\subsubsection[{body\+Implied(const H\+T\+T\+P\+Headers \&headers)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+R\+F\+C2616\+::body\+Implied (
\begin{DoxyParamCaption}
\item[{const {\bf H\+T\+T\+P\+Headers} \&}]{headers}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1RFC2616_a9c07048b149ad760b7deed013868fd83}
Returns true if the headers imply that a body will follow. Note that in some situations a body may come even if this function returns false (e.\+g. a 1.\+0 response body\textquotesingle{}s length can be given implicitly by closing the connection). 

Definition at line 59 of file R\+F\+C2616.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Headers\+::exists().



Referenced by proxygen\+::\+H\+T\+T\+P\+Checks\+::generate\+Header(), and proxygen\+::\+H\+T\+T\+P\+Checks\+::on\+Headers\+Complete().


\begin{DoxyCode}
59                                              \{
60   \textcolor{keywordflow}{return} headers.exists(HTTP\_HEADER\_TRANSFER\_ENCODING) ||
61     headers.exists(HTTP\_HEADER\_CONTENT\_LENGTH);
62 \}
\end{DoxyCode}
\index{proxygen\+::\+R\+F\+C2616@{proxygen\+::\+R\+F\+C2616}!is\+Request\+Body\+Allowed@{is\+Request\+Body\+Allowed}}
\index{is\+Request\+Body\+Allowed@{is\+Request\+Body\+Allowed}!proxygen\+::\+R\+F\+C2616@{proxygen\+::\+R\+F\+C2616}}
\subsubsection[{is\+Request\+Body\+Allowed(folly\+::\+Optional$<$ H\+T\+T\+P\+Method $>$ method)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Body\+Allowed} proxygen\+::\+R\+F\+C2616\+::is\+Request\+Body\+Allowed (
\begin{DoxyParamCaption}
\item[{folly\+::\+Optional$<$ {\bf H\+T\+T\+P\+Method} $>$}]{method}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1RFC2616_a67246a6541e06c21c310dcd3151b9c9e}


Definition at line 43 of file R\+F\+C2616.\+cpp.



References D\+E\+F\+I\+N\+ED, N\+O\+T\+\_\+\+A\+L\+L\+O\+W\+ED, N\+O\+T\+\_\+\+D\+E\+F\+I\+N\+ED, proxygen\+::\+O\+P\+T\+I\+O\+NS, proxygen\+::\+P\+O\+ST, proxygen\+::\+P\+UT, and proxygen\+::\+T\+R\+A\+CE.



Referenced by proxygen\+::\+H\+T\+T\+P\+Checks\+::generate\+Header(), and proxygen\+::\+H\+T\+T\+P\+Checks\+::on\+Headers\+Complete().


\begin{DoxyCode}
43                                                                    \{
44   \textcolor{keywordflow}{if} (method == HTTPMethod::TRACE) \{
45     \textcolor{keywordflow}{return} BodyAllowed::NOT\_ALLOWED;
46   \}
47   \textcolor{keywordflow}{if} (method == HTTPMethod::OPTIONS || method == HTTPMethod::POST ||
48       method == HTTPMethod::PUT) \{
49     \textcolor{keywordflow}{return} BodyAllowed::DEFINED;
50   \}
51   \textcolor{keywordflow}{return} BodyAllowed::NOT\_DEFINED;
52 \}
\end{DoxyCode}
\index{proxygen\+::\+R\+F\+C2616@{proxygen\+::\+R\+F\+C2616}!parse\+Byte\+Range\+Spec@{parse\+Byte\+Range\+Spec}}
\index{parse\+Byte\+Range\+Spec@{parse\+Byte\+Range\+Spec}!proxygen\+::\+R\+F\+C2616@{proxygen\+::\+R\+F\+C2616}}
\subsubsection[{parse\+Byte\+Range\+Spec(folly\+::\+String\+Piece value, unsigned long \&out\+First\+Byte, unsigned long \&out\+Last\+Byte, unsigned long \&out\+Instance\+Length)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+R\+F\+C2616\+::parse\+Byte\+Range\+Spec (
\begin{DoxyParamCaption}
\item[{folly\+::\+String\+Piece}]{value, }
\item[{unsigned long \&}]{first\+Byte, }
\item[{unsigned long \&}]{last\+Byte, }
\item[{unsigned long \&}]{instance\+Length}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1RFC2616_a9b23fc626e31c881c225aedbc349f624}
Parse an R\+FC 2616 section 14.\+16 \char`\"{}bytes A-\/\+B/\+C\char`\"{} string and returns them as the first and last bytes and instance length, respectively.

Wildcards are handled specially as follows\+: if the range is actually \char`\"{}$\ast$\char`\"{}, the first byte is parsed as 0 and last byte as U\+L\+O\+N\+G\+\_\+\+M\+AX; if instance length is actually \char`\"{}$\ast$\char`\"{}, it is parsed as U\+L\+O\+N\+G\+\_\+\+M\+AX.

Note that is O\+N\+LY suitable for use in parsing \char`\"{}\+Content-\/\+Range\char`\"{} response headers. The \char`\"{}\+Range\char`\"{} request header has different but similar syntax. 

Definition at line 105 of file R\+F\+C2616.\+cpp.



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
109                                       \{
110   \textcolor{comment}{// We should start with "bytes "}
111   \textcolor{keywordflow}{if} (!value.startsWith(\textcolor{stringliteral}{"bytes "})) \{
112     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
113   \}
114 
115   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* curs = value.begin() + 6 \textcolor{comment}{/* strlen("bytes ") */};
116   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* end = value.end();
117 
118   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} firstByte = ULONG\_MAX;
119   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} lastByte = ULONG\_MAX;
120   \textcolor{keywordtype}{unsigned} \textcolor{keywordtype}{long} instanceLength = ULONG\_MAX;
121 
122   \textcolor{keywordflow}{if} (!strtoulWrapper(curs, end, firstByte)) \{
123     \textcolor{keywordflow}{if} (*curs != \textcolor{charliteral}{'*'}) \{
124       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
125     \}
126 
127     firstByte = 0;
128     lastByte = ULONG\_MAX;
129     ++curs;
130   \} \textcolor{keywordflow}{else} \{
131     \textcolor{keywordflow}{if} (*curs != \textcolor{charliteral}{'-'}) \{
132       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
133     \}
134 
135     ++curs;
136 
137     \textcolor{keywordflow}{if} (!strtoulWrapper(curs, end, lastByte)) \{
138       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
139     \}
140   \}
141 
142   \textcolor{keywordflow}{if} (*curs != \textcolor{charliteral}{'/'}) \{
143     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
144   \}
145 
146   ++curs;
147   \textcolor{keywordflow}{if} (*curs != \textcolor{charliteral}{'*'}) \{
148     \textcolor{keywordflow}{if} (!strtoulWrapper(curs, end, instanceLength)) \{
149       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
150     \}
151   \} \textcolor{keywordflow}{else} \{
152     ++curs;
153   \}
154 
155   \textcolor{keywordflow}{if} (curs < end && *curs != \textcolor{charliteral}{'\(\backslash\)0'}) \{
156     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
157   \}
158 
159   \textcolor{keywordflow}{if} (lastByte < firstByte) \{
160     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
161   \}
162 
163   \textcolor{keywordflow}{if} ((lastByte - firstByte + 1) > instanceLength) \{
164     \textcolor{keywordflow}{return} \textcolor{keyword}{false};
165   \}
166 
167   outFirstByte = firstByte;
168   outLastByte = lastByte;
169   outInstanceLength = instanceLength;
170   \textcolor{keywordflow}{return} \textcolor{keyword}{true};
171 \}
\end{DoxyCode}
\index{proxygen\+::\+R\+F\+C2616@{proxygen\+::\+R\+F\+C2616}!parse\+Qvalues@{parse\+Qvalues}}
\index{parse\+Qvalues@{parse\+Qvalues}!proxygen\+::\+R\+F\+C2616@{proxygen\+::\+R\+F\+C2616}}
\subsubsection[{parse\+Qvalues(folly\+::\+String\+Piece value, std\+::vector$<$ Token\+Q\+Pair $>$ \&output)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+R\+F\+C2616\+::parse\+Qvalues (
\begin{DoxyParamCaption}
\item[{folly\+::\+String\+Piece}]{value, }
\item[{std\+::vector$<$ {\bf Token\+Q\+Pair} $>$ \&}]{output}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1RFC2616_af6bc219a760edec79d271944e55fe5c8}


Definition at line 64 of file R\+F\+C2616.\+cpp.



References tokens.



Referenced by proxygen\+::\+Zlib\+Server\+Filter\+Factory\+::accepts\+Supported\+Compression\+Type(), proxygen\+::\+Codec\+Util\+::has\+Gzip\+And\+Deflate(), and T\+E\+S\+T().


\begin{DoxyCode}
64                                                                          \{
65   \textcolor{keywordtype}{bool} result = \textcolor{keyword}{true};
66   \textcolor{keyword}{static} folly::ThreadLocal<std::vector<folly::StringPiece>> tokens;
67   tokens->clear();
68   folly::split(\textcolor{stringliteral}{","}, value, *tokens, \textcolor{keyword}{true} \textcolor{comment}{/*ignore empty*/});
69   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto}& token: *tokens) \{
70     \textcolor{keyword}{auto} pos = token.find(\textcolor{charliteral}{';'});
71     \textcolor{keywordtype}{double} qvalue = 1.0;
72     \textcolor{keywordflow}{if} (pos != std::string::npos) \{
73       \textcolor{keyword}{auto} qpos = token.find(\textcolor{stringliteral}{"q="}, pos);
74       \textcolor{keywordflow}{if} (qpos != std::string::npos) \{
75         folly::StringPiece qvalueStr(token.data() + qpos + 2,
76                                      token.size() - (qpos + 2));
77         \textcolor{keywordflow}{try} \{
78           qvalue = folly::to<double>(&qvalueStr);
79         \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} std::range\_error&) \{
80           \textcolor{comment}{// q=<some garbage>}
81           result = \textcolor{keyword}{false};
82         \}
83         \textcolor{comment}{// we could validate that the remainder of qvalueStr was all whitespace,}
84         \textcolor{comment}{// for now we just discard it}
85       \} \textcolor{keywordflow}{else} \{
86         \textcolor{comment}{// ; but no q=}
87         result = \textcolor{keyword}{false};
88       \}
89       token.reset(token.start(), pos);
90     \}
91     \textcolor{comment}{// strip leading whitespace}
92     \textcolor{keywordflow}{while} (token.size() > 0 && isspace(token[0])) \{
93       token.reset(token.start() + 1, token.size() - 1);
94     \}
95     \textcolor{keywordflow}{if} (token.size() == 0) \{
96       \textcolor{comment}{// empty token}
97       result = \textcolor{keyword}{false};
98     \} \textcolor{keywordflow}{else} \{
99       output.emplace\_back(token, qvalue);
100     \}
101   \}
102   \textcolor{keywordflow}{return} result && output.size() > 0;
103 \}
\end{DoxyCode}
\index{proxygen\+::\+R\+F\+C2616@{proxygen\+::\+R\+F\+C2616}!response\+Body\+Must\+Be\+Empty@{response\+Body\+Must\+Be\+Empty}}
\index{response\+Body\+Must\+Be\+Empty@{response\+Body\+Must\+Be\+Empty}!proxygen\+::\+R\+F\+C2616@{proxygen\+::\+R\+F\+C2616}}
\subsubsection[{response\+Body\+Must\+Be\+Empty(unsigned status)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+R\+F\+C2616\+::response\+Body\+Must\+Be\+Empty (
\begin{DoxyParamCaption}
\item[{unsigned}]{status}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1RFC2616_a190e9a54e16965094cb9d3e476eb35fb}
Some status codes imply that there M\+U\+ST N\+OT be a response body. See section 4.\+3\+: \char`\"{}\+All 1xx (informational), 204 (no content), and 304 (not modified)
responses M\+U\+S\+T N\+O\+T include a message-\/body.\char`\"{} 
\begin{DoxyParams}{Parameters}
{\em status} & The code to test (100 $<$= status $<$= 999) \\
\hline
\end{DoxyParams}


Definition at line 54 of file R\+F\+C2616.\+cpp.



Referenced by proxygen\+::\+H\+T\+T\+P1x\+Codec\+::generate\+Header(), proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Headers\+Complete(), and proxygen\+::\+H\+T\+T\+P\+Transaction\+::on\+Ingress\+Headers\+Complete().


\begin{DoxyCode}
54                                               \{
55   \textcolor{keywordflow}{return} (status == 304 || status == 204 ||
56           (100 <= status && status < 200));
57 \}
\end{DoxyCode}
