\section{proxygen\+:\+:Codec\+Util Class Reference}
\label{classproxygen_1_1CodecUtil}\index{proxygen\+::\+Codec\+Util@{proxygen\+::\+Codec\+Util}}


{\ttfamily \#include $<$Codec\+Util.\+h$>$}

\subsection*{Public Types}
\begin{DoxyCompactItemize}
\item 
enum {\bf Ctl\+Escape\+Mode} \{ {\bf C\+O\+M\+P\+L\+I\+A\+NT}, 
{\bf S\+T\+R\+I\+CT}
 \}
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static bool {\bf validate\+U\+RL} (folly\+::\+Byte\+Range url)
\item 
static bool {\bf validate\+Method} (folly\+::\+Byte\+Range method)
\item 
static bool {\bf validate\+Header\+Name} (folly\+::\+Byte\+Range {\bf name})
\item 
static bool {\bf validate\+Header\+Value} (folly\+::\+Byte\+Range value, {\bf Ctl\+Escape\+Mode} mode)
\item 
static bool {\bf has\+Gzip\+And\+Deflate} (const std\+::string \&value, bool \&has\+Gzip, bool \&has\+Deflate)
\item 
static std\+::vector$<$ {\bf compress\+::\+Header} $>$ {\bf prepare\+Message\+For\+Compression} (const {\bf H\+T\+T\+P\+Message} \&msg, std\+::vector$<$ std\+::string $>$ \&temps)
\item 
static bool {\bf append\+Headers} (const {\bf H\+T\+T\+P\+Headers} \&input\+Headers, std\+::vector$<$ {\bf compress\+::\+Header} $>$ \&headers, {\bf H\+T\+T\+P\+Header\+Code} header\+To\+Check)
\end{DoxyCompactItemize}
\subsection*{Static Public Attributes}
\begin{DoxyCompactItemize}
\item 
static const char {\bf http\+\_\+tokens} [256]
\end{DoxyCompactItemize}


\subsection{Detailed Description}


Definition at line 23 of file Codec\+Util.\+h.



\subsection{Member Enumeration Documentation}
\index{proxygen\+::\+Codec\+Util@{proxygen\+::\+Codec\+Util}!Ctl\+Escape\+Mode@{Ctl\+Escape\+Mode}}
\index{Ctl\+Escape\+Mode@{Ctl\+Escape\+Mode}!proxygen\+::\+Codec\+Util@{proxygen\+::\+Codec\+Util}}
\subsubsection[{Ctl\+Escape\+Mode}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+Codec\+Util\+::\+Ctl\+Escape\+Mode}}\label{classproxygen_1_1CodecUtil_a856a74954c175245974a2fc27c8c554b}
\doxyref{R\+F\+C2616}{p.}{namespaceproxygen_1_1RFC2616} allows certain control chars in header values if they are quoted and escaped. When mode is C\+O\+M\+P\+L\+I\+A\+NT, then this is allowed. When mode is S\+T\+R\+I\+CT, no escaped C\+T\+Ls are allowed \begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{C\+O\+M\+P\+L\+I\+A\+NT@{C\+O\+M\+P\+L\+I\+A\+NT}!proxygen\+::\+Codec\+Util@{proxygen\+::\+Codec\+Util}}\index{proxygen\+::\+Codec\+Util@{proxygen\+::\+Codec\+Util}!C\+O\+M\+P\+L\+I\+A\+NT@{C\+O\+M\+P\+L\+I\+A\+NT}}\item[{\em 
C\+O\+M\+P\+L\+I\+A\+NT\label{classproxygen_1_1CodecUtil_a856a74954c175245974a2fc27c8c554ba35ad9e7dd13b99faf2913be5a9470144}
}]\index{S\+T\+R\+I\+CT@{S\+T\+R\+I\+CT}!proxygen\+::\+Codec\+Util@{proxygen\+::\+Codec\+Util}}\index{proxygen\+::\+Codec\+Util@{proxygen\+::\+Codec\+Util}!S\+T\+R\+I\+CT@{S\+T\+R\+I\+CT}}\item[{\em 
S\+T\+R\+I\+CT\label{classproxygen_1_1CodecUtil_a856a74954c175245974a2fc27c8c554ba71a6e170eb4d3c8b755a4ace234aaf46}
}]\end{description}
\end{Desc}


Definition at line 61 of file Codec\+Util.\+h.


\begin{DoxyCode}
61                      \{
62     COMPLIANT,
63     STRICT
64   \};
\end{DoxyCode}


\subsection{Member Function Documentation}
\index{proxygen\+::\+Codec\+Util@{proxygen\+::\+Codec\+Util}!append\+Headers@{append\+Headers}}
\index{append\+Headers@{append\+Headers}!proxygen\+::\+Codec\+Util@{proxygen\+::\+Codec\+Util}}
\subsubsection[{append\+Headers(const H\+T\+T\+P\+Headers \&input\+Headers, std\+::vector$<$ compress\+::\+Header $>$ \&headers, H\+T\+T\+P\+Header\+Code header\+To\+Check)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+Codec\+Util\+::append\+Headers (
\begin{DoxyParamCaption}
\item[{const {\bf H\+T\+T\+P\+Headers} \&}]{input\+Headers, }
\item[{std\+::vector$<$ {\bf compress\+::\+Header} $>$ \&}]{headers, }
\item[{{\bf H\+T\+T\+P\+Header\+Code}}]{header\+To\+Check}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classproxygen_1_1CodecUtil_a88c268b449dc3ba5b47ed181b68234c3}


Definition at line 131 of file Codec\+Util.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Headers\+::for\+Each\+With\+Code(), and name.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Trailers(), prepare\+Message\+For\+Compression(), and validate\+Header\+Value().


\begin{DoxyCode}
133                                                             \{
134   \textcolor{keywordtype}{bool} headerToCheckExists = \textcolor{keyword}{false};
135   \textcolor{comment}{// Add the HTTP headers supplied by the caller, but skip}
136   \textcolor{comment}{// any per-hop headers that aren't supported in HTTP/2.}
137   inputHeaders.forEachWithCode([&](HTTPHeaderCode code,
138                                    \textcolor{keyword}{const} std::string& name,
139                                    \textcolor{keyword}{const} std::string& value) \{
140     \textcolor{keyword}{static} \textcolor{keyword}{const} std::bitset<256> s\_perHopHeaderCodes\{[] \{
141       std::bitset<256> bs;
142       \textcolor{comment}{// HTTP/1.x per-hop headers that have no meaning in HTTP/2}
143       bs[HTTP\_HEADER\_CONNECTION] = \textcolor{keyword}{true};
144       bs[HTTP\_HEADER\_HOST] = \textcolor{keyword}{true};
145       bs[HTTP\_HEADER\_KEEP\_ALIVE] = \textcolor{keyword}{true};
146       bs[HTTP\_HEADER\_PROXY\_CONNECTION] = \textcolor{keyword}{true};
147       bs[HTTP\_HEADER\_TRANSFER\_ENCODING] = \textcolor{keyword}{true};
148       bs[HTTP\_HEADER\_UPGRADE] = \textcolor{keyword}{true};
149       bs[HTTP\_HEADER\_SEC\_WEBSOCKET\_KEY] = \textcolor{keyword}{true};
150       bs[HTTP\_HEADER\_SEC\_WEBSOCKET\_ACCEPT] = \textcolor{keyword}{true};
151       \textcolor{keywordflow}{return} bs;
152     \}()\};
153 
154     \textcolor{keywordflow}{if} (s\_perHopHeaderCodes[code] || name.size() == 0 || name[0] == \textcolor{charliteral}{':'}) \{
155       DCHECK\_GT(name.size(), 0) << \textcolor{stringliteral}{"Empty header"};
156       DCHECK\_NE(name[0], \textcolor{charliteral}{':'}) << \textcolor{stringliteral}{"Invalid header="} << name;
157       \textcolor{keywordflow}{return};
158     \}
159     \textcolor{comment}{// Note this code will not drop headers named by Connection.  That's the}
160     \textcolor{comment}{// caller's job}
161 
162     \textcolor{comment}{// see HTTP/2 spec, 8.1.2}
163     DCHECK(name != \textcolor{stringliteral}{"TE"} || value == \textcolor{stringliteral}{"trailers"});
164     \textcolor{keywordflow}{if} ((name.size() > 0 && name[0] != \textcolor{charliteral}{':'}) && code != HTTP\_HEADER\_HOST) \{
165       headers.emplace\_back(code, name, value);
166     \}
167     \textcolor{keywordflow}{if} (code == headerToCheck) \{
168       headerToCheckExists = \textcolor{keyword}{true};
169     \}
170   \});
171 
172   \textcolor{keywordflow}{return} headerToCheckExists;
173 \}
\end{DoxyCode}
\index{proxygen\+::\+Codec\+Util@{proxygen\+::\+Codec\+Util}!has\+Gzip\+And\+Deflate@{has\+Gzip\+And\+Deflate}}
\index{has\+Gzip\+And\+Deflate@{has\+Gzip\+And\+Deflate}!proxygen\+::\+Codec\+Util@{proxygen\+::\+Codec\+Util}}
\subsubsection[{has\+Gzip\+And\+Deflate(const std\+::string \&value, bool \&has\+Gzip, bool \&has\+Deflate)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+Codec\+Util\+::has\+Gzip\+And\+Deflate (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{value, }
\item[{bool \&}]{has\+Gzip, }
\item[{bool \&}]{has\+Deflate}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classproxygen_1_1CodecUtil_ad1df12d61ffacdeeabb5eac028f75aed}


Definition at line 61 of file Codec\+Util.\+cpp.



References proxygen\+::\+R\+F\+C2616\+::parse\+Qvalues().



Referenced by proxygen\+::\+S\+P\+D\+Y\+Codec\+::parse\+Headers(), and validate\+Header\+Value().


\begin{DoxyCode}
62                                                    \{
63   \textcolor{keyword}{static} folly::ThreadLocal<std::vector<RFC2616::TokenQPair>> output;
64   output->clear();
65   hasGzip = \textcolor{keyword}{false};
66   hasDeflate = \textcolor{keyword}{false};
67   RFC2616::parseQvalues(value, *output);
68   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& encodingQ: *output) \{
69     std::string lower(encodingQ.first.str());
70     std::transform(lower.begin(), lower.end(), lower.begin(), ::tolower);
71     \textcolor{comment}{// RFC says 3 sig figs}
72     \textcolor{keywordflow}{if} (lower == \textcolor{stringliteral}{"gzip"} && encodingQ.second >= 0.001) \{
73       hasGzip = \textcolor{keyword}{true};
74     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (lower == \textcolor{stringliteral}{"deflate"} && encodingQ.second >= 0.001) \{
75       hasDeflate = \textcolor{keyword}{true};
76     \}
77   \}
78   \textcolor{keywordflow}{return} hasGzip && hasDeflate;
79 \}
\end{DoxyCode}
\index{proxygen\+::\+Codec\+Util@{proxygen\+::\+Codec\+Util}!prepare\+Message\+For\+Compression@{prepare\+Message\+For\+Compression}}
\index{prepare\+Message\+For\+Compression@{prepare\+Message\+For\+Compression}!proxygen\+::\+Codec\+Util@{proxygen\+::\+Codec\+Util}}
\subsubsection[{prepare\+Message\+For\+Compression(const H\+T\+T\+P\+Message \&msg, std\+::vector$<$ std\+::string $>$ \&temps)}]{\setlength{\rightskip}{0pt plus 5cm}std\+::vector$<$ {\bf compress\+::\+Header} $>$ proxygen\+::\+Codec\+Util\+::prepare\+Message\+For\+Compression (
\begin{DoxyParamCaption}
\item[{const {\bf H\+T\+T\+P\+Message} \&}]{msg, }
\item[{std\+::vector$<$ std\+::string $>$ \&}]{temps}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classproxygen_1_1CodecUtil_aa88e7bf99028926f11066a8e47baf672}


Definition at line 82 of file Codec\+Util.\+cpp.



References append\+Headers(), proxygen\+::\+C\+O\+N\+N\+E\+CT, proxygen\+::\+H\+T\+T\+P\+Message\+::format\+Date\+Header(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Method(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Method\+String(), proxygen\+::\+H\+T\+T\+P\+Headers\+::get\+Single\+Or\+Empty(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Status\+Code(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+U\+R\+L(), proxygen\+::\+H\+T\+T\+P\+Message\+::is\+Egress\+Websocket\+Upgrade(), proxygen\+::\+H\+T\+T\+P\+Message\+::is\+Request(), proxygen\+::\+H\+T\+T\+P\+Message\+::is\+Response(), proxygen\+::\+H\+T\+T\+P\+Message\+::is\+Secure(), proxygen\+::headers\+::k\+Http, proxygen\+::headers\+::k\+Https, proxygen\+::headers\+::k\+Status200, proxygen\+::headers\+::k\+Websocket\+String, and proxygen\+::method\+To\+String().



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Header\+Impl(), and validate\+Header\+Value().


\begin{DoxyCode}
84                                  \{
85   std::vector<compress::Header> allHeaders;
86   \textcolor{keywordflow}{if} (msg.isRequest()) \{
87     \textcolor{keywordflow}{if} (msg.isEgressWebsocketUpgrade()) \{
88       allHeaders.emplace\_back(HTTP\_HEADER\_COLON\_METHOD,
89           methodToString(HTTPMethod::CONNECT));
90       allHeaders.emplace\_back(HTTP\_HEADER\_COLON\_PROTOCOL,
91                               headers::kWebsocketString);
92     \} \textcolor{keywordflow}{else} \{
93       \textcolor{keyword}{const} std::string& method = msg.getMethodString();
94       allHeaders.emplace\_back(HTTP\_HEADER\_COLON\_METHOD, method);
95     \}
96 
97     \textcolor{keywordflow}{if} (msg.getMethod() != HTTPMethod::CONNECT ||
98         msg.isEgressWebsocketUpgrade()) \{
99       \textcolor{keyword}{const} std::string& scheme =
100         (msg.isSecure() ? headers::kHttps : headers::kHttp);
101       \textcolor{keyword}{const} std::string& path = msg.getURL();
102       allHeaders.emplace\_back(HTTP\_HEADER\_COLON\_SCHEME, scheme);
103       allHeaders.emplace\_back(HTTP\_HEADER\_COLON\_PATH, path);
104     \}
105     \textcolor{keyword}{const} HTTPHeaders& headers = msg.getHeaders();
106     \textcolor{keyword}{const} std::string& host = headers.getSingleOrEmpty(HTTP\_HEADER\_HOST);
107     \textcolor{keywordflow}{if} (!host.empty()) \{
108       allHeaders.emplace\_back(HTTP\_HEADER\_COLON\_AUTHORITY, host);
109     \}
110   \} \textcolor{keywordflow}{else} \{
111     temps.reserve(3); \textcolor{comment}{// must be large enough so that emplace does not resize}
112     \textcolor{keywordflow}{if} (msg.isEgressWebsocketUpgrade()) \{
113       temps.emplace\_back(headers::kStatus200);
114     \} \textcolor{keywordflow}{else} \{
115       temps.emplace\_back(folly::to<std::string>(msg.getStatusCode()));
116     \}
117     allHeaders.emplace\_back(HTTP\_HEADER\_COLON\_STATUS, temps.back());
118     \textcolor{comment}{// HEADERS frames do not include a version or reason string.}
119   \}
120 
121   \textcolor{keywordtype}{bool} hasDateHeader =
122       appendHeaders(msg.getHeaders(), allHeaders, HTTP\_HEADER\_DATE);
123 
124   \textcolor{keywordflow}{if} (msg.isResponse() && !hasDateHeader) \{
125     temps.emplace\_back(HTTPMessage::formatDateHeader());
126     allHeaders.emplace\_back(HTTP\_HEADER\_DATE, temps.back());
127   \}
128   \textcolor{keywordflow}{return} allHeaders;
129 \}
\end{DoxyCode}
\index{proxygen\+::\+Codec\+Util@{proxygen\+::\+Codec\+Util}!validate\+Header\+Name@{validate\+Header\+Name}}
\index{validate\+Header\+Name@{validate\+Header\+Name}!proxygen\+::\+Codec\+Util@{proxygen\+::\+Codec\+Util}}
\subsubsection[{validate\+Header\+Name(folly\+::\+Byte\+Range name)}]{\setlength{\rightskip}{0pt plus 5cm}static bool proxygen\+::\+Codec\+Util\+::validate\+Header\+Name (
\begin{DoxyParamCaption}
\item[{folly\+::\+Byte\+Range}]{name}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classproxygen_1_1CodecUtil_a82438d2f4bb2dfda705f03a750e8e7fc}


Definition at line 43 of file Codec\+Util.\+h.



Referenced by proxygen\+::\+Header\+Decode\+Info\+::on\+Header(), and proxygen\+::\+S\+P\+D\+Y\+Codec\+::parse\+Headers().


\begin{DoxyCode}
43                                                       \{
44     \textcolor{keywordflow}{if} (name.size() == 0) \{
45       \textcolor{keywordflow}{return} \textcolor{keyword}{false};
46     \}
47     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} p: name) \{
48       \textcolor{keywordflow}{if} (p < 0x80 && http_tokens[(uint8\_t)p] != p) \{
49         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
50       \}
51     \}
52     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
53   \}
\end{DoxyCode}
\index{proxygen\+::\+Codec\+Util@{proxygen\+::\+Codec\+Util}!validate\+Header\+Value@{validate\+Header\+Value}}
\index{validate\+Header\+Value@{validate\+Header\+Value}!proxygen\+::\+Codec\+Util@{proxygen\+::\+Codec\+Util}}
\subsubsection[{validate\+Header\+Value(folly\+::\+Byte\+Range value, Ctl\+Escape\+Mode mode)}]{\setlength{\rightskip}{0pt plus 5cm}static bool proxygen\+::\+Codec\+Util\+::validate\+Header\+Value (
\begin{DoxyParamCaption}
\item[{folly\+::\+Byte\+Range}]{value, }
\item[{{\bf Ctl\+Escape\+Mode}}]{mode}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classproxygen_1_1CodecUtil_ac5cc215d13e8b9bccfa35adf20c61ae8}


Definition at line 66 of file Codec\+Util.\+h.



References append\+Headers(), C\+O\+M\+P\+L\+I\+A\+NT, has\+Gzip\+And\+Deflate(), and prepare\+Message\+For\+Compression().



Referenced by proxygen\+::\+Header\+Decode\+Info\+::on\+Header(), proxygen\+::\+S\+P\+D\+Y\+Codec\+::parse\+Headers(), and proxygen\+::\+H\+T\+T\+P\+Request\+Verifier\+::set\+Authority().


\begin{DoxyCode}
67                                                       \{
68     \textcolor{keywordtype}{bool} escape = \textcolor{keyword}{false};
69     \textcolor{keywordtype}{bool} quote = \textcolor{keyword}{false};
70     \textcolor{keyword}{enum} \{ lws\_none,
71            lws\_expect\_nl,
72            lws\_expect\_ws1,
73            lws\_expect\_ws2 \} state = lws\_none;
74 
75     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} p = std::begin(value); p != std::end(value); ++p) \{
76       \textcolor{keywordflow}{if} (escape) \{
77         escape = \textcolor{keyword}{false};
78         \textcolor{keywordflow}{if} (mode == COMPLIANT) \{
79           \textcolor{comment}{// prev char escaped.  Turn off escape and go to next char}
80           \textcolor{comment}{// COMPLIANT mode only}
81           assert(quote);
82           \textcolor{keywordflow}{continue};
83         \}
84       \}
85       \textcolor{keywordflow}{switch} (state) \{
86         \textcolor{keywordflow}{case} lws\_none:
87           \textcolor{keywordflow}{switch} (*p) \{
88             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)\(\backslash\)'}:
89               \textcolor{keywordflow}{if} (quote) \{
90                 escape = \textcolor{keyword}{true};
91               \}
92               \textcolor{keywordflow}{break};
93             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)"'}:
94               quote = !quote;
95               \textcolor{keywordflow}{break};
96             \textcolor{keywordflow}{case} \textcolor{charliteral}{'\(\backslash\)r'}:
97               state = lws\_expect\_nl;
98               \textcolor{keywordflow}{break};
99             \textcolor{keywordflow}{default}:
100               \textcolor{keywordflow}{if} ((*p < 0x20 || *p == 0x7f) && *p != \textcolor{charliteral}{'\(\backslash\)t'}) \{
101                 \textcolor{comment}{// unexpected ctl per rfc2616, HT OK}
102                 \textcolor{keywordflow}{return} \textcolor{keyword}{false};
103               \}
104               \textcolor{keywordflow}{break};
105           \}
106           \textcolor{keywordflow}{break};
107         \textcolor{keywordflow}{case} lws\_expect\_nl:
108           \textcolor{keywordflow}{if} (*p != \textcolor{charliteral}{'\(\backslash\)n'}) \{
109             \textcolor{comment}{// unescaped \(\backslash\)r must be LWS}
110             \textcolor{keywordflow}{return} \textcolor{keyword}{false};
111           \}
112           state = lws\_expect\_ws1;
113           \textcolor{keywordflow}{break};
114         \textcolor{keywordflow}{case} lws\_expect\_ws1:
115           \textcolor{keywordflow}{if} (*p != \textcolor{charliteral}{' '} && *p != \textcolor{charliteral}{'\(\backslash\)t'}) \{
116             \textcolor{comment}{// unescaped \(\backslash\)r\(\backslash\)n must be LWS}
117             \textcolor{keywordflow}{return} \textcolor{keyword}{false};
118           \}
119           state = lws\_expect\_ws2;
120           \textcolor{keywordflow}{break};
121         \textcolor{keywordflow}{case} lws\_expect\_ws2:
122           \textcolor{keywordflow}{if} (*p != \textcolor{charliteral}{' '} && *p != \textcolor{charliteral}{'\(\backslash\)t'}) \{
123             \textcolor{comment}{// terminated LWS}
124             state = lws\_none;
125             \textcolor{comment}{// check this char again}
126             p--;
127           \}
128           \textcolor{keywordflow}{break};
129       \}
130     \}
131     \textcolor{comment}{// Unterminated quotes are OK, since the value can be* TEXT which treats}
132     \textcolor{comment}{// the " like any other char.}
133     \textcolor{comment}{// Unterminated escapes are bad because it will escape the next character}
134     \textcolor{comment}{// when converting to HTTP}
135     \textcolor{comment}{// Unterminated LWS (dangling \(\backslash\)r or \(\backslash\)r\(\backslash\)n) is bad because it could}
136     \textcolor{comment}{// prematurely terminate the headers when converting to HTTP}
137     \textcolor{keywordflow}{return} !escape && (state == lws\_none || state == lws\_expect\_ws2);
138   \}
\end{DoxyCode}
\index{proxygen\+::\+Codec\+Util@{proxygen\+::\+Codec\+Util}!validate\+Method@{validate\+Method}}
\index{validate\+Method@{validate\+Method}!proxygen\+::\+Codec\+Util@{proxygen\+::\+Codec\+Util}}
\subsubsection[{validate\+Method(folly\+::\+Byte\+Range method)}]{\setlength{\rightskip}{0pt plus 5cm}static bool proxygen\+::\+Codec\+Util\+::validate\+Method (
\begin{DoxyParamCaption}
\item[{folly\+::\+Byte\+Range}]{method}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classproxygen_1_1CodecUtil_aa865daca9716ad297c4771ebb6c650c5}


Definition at line 33 of file Codec\+Util.\+h.



Referenced by proxygen\+::\+S\+P\+D\+Y\+Codec\+::parse\+Headers(), proxygen\+::\+H\+T\+T\+P\+Request\+Verifier\+::set\+Method(), and proxygen\+::\+H\+T\+T\+P\+Request\+Verifier\+::set\+Scheme().


\begin{DoxyCode}
33                                                     \{
34     \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} p: method) \{
35       \textcolor{keywordflow}{if} (!isalpha(p)) \{
36         \textcolor{comment}{// methods are all characters}
37         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
38       \}
39     \}
40     \textcolor{keywordflow}{return} \textcolor{keyword}{true};
41   \}
\end{DoxyCode}
\index{proxygen\+::\+Codec\+Util@{proxygen\+::\+Codec\+Util}!validate\+U\+RL@{validate\+U\+RL}}
\index{validate\+U\+RL@{validate\+U\+RL}!proxygen\+::\+Codec\+Util@{proxygen\+::\+Codec\+Util}}
\subsubsection[{validate\+U\+R\+L(folly\+::\+Byte\+Range url)}]{\setlength{\rightskip}{0pt plus 5cm}static bool proxygen\+::\+Codec\+Util\+::validate\+U\+RL (
\begin{DoxyParamCaption}
\item[{folly\+::\+Byte\+Range}]{url}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [static]}}\label{classproxygen_1_1CodecUtil_a1cf346e49d7822f78d85fe3edbb67ef5}


Definition at line 29 of file Codec\+Util.\+h.



References proxygen\+::validate\+U\+R\+L().



Referenced by proxygen\+::\+S\+P\+D\+Y\+Codec\+::parse\+Headers(), and proxygen\+::\+H\+T\+T\+P\+Request\+Verifier\+::set\+Path().


\begin{DoxyCode}
29                                               \{
30     \textcolor{keywordflow}{return} proxygen::validateURL(url);
31   \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{proxygen\+::\+Codec\+Util@{proxygen\+::\+Codec\+Util}!http\+\_\+tokens@{http\+\_\+tokens}}
\index{http\+\_\+tokens@{http\+\_\+tokens}!proxygen\+::\+Codec\+Util@{proxygen\+::\+Codec\+Util}}
\subsubsection[{http\+\_\+tokens}]{\setlength{\rightskip}{0pt plus 5cm}const char proxygen\+::\+Codec\+Util\+::http\+\_\+tokens\hspace{0.3cm}{\ttfamily [static]}}\label{classproxygen_1_1CodecUtil_ae6e8cce92924181e499587aadedee378}
Tokens as defined by rfc 2616. Also lowercases them. token = 1$\ast$$<$any char=\char`\"{}\char`\"{} except=\char`\"{}\char`\"{} ctls=\char`\"{}\char`\"{} or=\char`\"{}\char`\"{} separators$>$=\char`\"{}\char`\"{}$>$ separators = \char`\"{}(\char`\"{} $\vert$ \char`\"{})\char`\"{} $\vert$ \char`\"{}$<$\char`\"{} $\vert$ \char`\"{}$>$\char`\"{} $\vert$ \char`\"{}@\char`\"{} $\vert$ \char`\"{},\char`\"{} $\vert$ \char`\"{};\char`\"{} $\vert$ \char`\"{}\+:\char`\"{} $\vert$ \char`\"{}\textbackslash{}\char`\"{} $\vert$ $<$\char`\"{}$>$
                  $\vert$ \char`\"{}/\char`\"{} $\vert$ \char`\"{}[\char`\"{} $\vert$ \char`\"{}]\char`\"{} $\vert$ \char`\"{}?\char`\"{} $\vert$ \char`\"{}=\char`\"{}
                  $\vert$ \char`\"{}\{\char`\"{} $\vert$ \char`\"{}\}" $\vert$ SP $\vert$ HT 

Definition at line 27 of file Codec\+Util.\+h.



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
proxygen/lib/http/codec/{\bf Codec\+Util.\+h}\item 
proxygen/lib/http/codec/{\bf Codec\+Util.\+cpp}\end{DoxyCompactItemize}
