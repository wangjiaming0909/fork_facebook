\section{proxygen\+:\+:http2 Namespace Reference}
\label{namespaceproxygen_1_1http2}\index{proxygen\+::http2@{proxygen\+::http2}}
\subsection*{Classes}
\begin{DoxyCompactItemize}
\item 
struct {\bf Frame\+Header}
\item 
struct {\bf Priority\+Update}
\end{DoxyCompactItemize}
\subsection*{Typedefs}
\begin{DoxyCompactItemize}
\item 
using {\bf Padding} = folly\+::\+Optional$<$ uint8\+\_\+t $>$
\end{DoxyCompactItemize}
\subsection*{Enumerations}
\begin{DoxyCompactItemize}
\item 
enum {\bf Frame\+Type} \+: uint8\+\_\+t \{ \\*
{\bf Frame\+Type\+::\+D\+A\+TA} = 0, 
{\bf Frame\+Type\+::\+H\+E\+A\+D\+E\+RS} = 1, 
{\bf P\+R\+I\+O\+R\+I\+TY} = 2, 
{\bf Frame\+Type\+::\+R\+S\+T\+\_\+\+S\+T\+R\+E\+AM} = 3, 
\\*
{\bf Frame\+Type\+::\+S\+E\+T\+T\+I\+N\+GS} = 4, 
{\bf Frame\+Type\+::\+P\+U\+S\+H\+\_\+\+P\+R\+O\+M\+I\+SE} = 5, 
{\bf Frame\+Type\+::\+P\+I\+NG} = 6, 
{\bf Frame\+Type\+::\+G\+O\+A\+W\+AY} = 7, 
\\*
{\bf Frame\+Type\+::\+W\+I\+N\+D\+O\+W\+\_\+\+U\+P\+D\+A\+TE} = 8, 
{\bf Frame\+Type\+::\+C\+O\+N\+T\+I\+N\+U\+A\+T\+I\+ON} = 9, 
{\bf Frame\+Type\+::\+A\+L\+T\+S\+VC} = 10, 
{\bf Frame\+Type\+::\+E\+X\+\_\+\+H\+E\+A\+D\+E\+RS} = 0xfb, 
\\*
{\bf Frame\+Type\+::\+C\+E\+R\+T\+I\+F\+I\+C\+A\+T\+E\+\_\+\+R\+E\+Q\+U\+E\+ST} = 0xf0, 
{\bf Frame\+Type\+::\+C\+E\+R\+T\+I\+F\+I\+C\+A\+TE} = 0xf1, 
{\bf Frame\+Type\+::\+C\+E\+R\+T\+I\+F\+I\+C\+A\+T\+E\+\_\+\+N\+E\+E\+D\+ED} = 0xf2, 
{\bf Frame\+Type\+::\+U\+S\+E\+\_\+\+C\+E\+R\+T\+I\+F\+I\+C\+A\+TE} = 0xf3
 \}
\item 
enum {\bf Flags} \{ \\*
{\bf A\+CK} = 0x1, 
{\bf E\+N\+D\+\_\+\+S\+T\+R\+E\+AM} = 0x1, 
{\bf E\+N\+D\+\_\+\+H\+E\+A\+D\+E\+RS} = 0x4, 
{\bf P\+A\+D\+D\+ED} = 0x8, 
\\*
{\bf P\+R\+I\+O\+R\+I\+TY} = 0x20, 
{\bf P\+R\+I\+O\+R\+I\+TY} = 2, 
{\bf U\+N\+I\+D\+I\+R\+E\+C\+T\+I\+O\+N\+AL} = 0x40, 
{\bf U\+N\+S\+O\+L\+I\+C\+I\+T\+ED} = 0x1, 
\\*
{\bf T\+O\+\_\+\+B\+E\+\_\+\+C\+O\+N\+T\+I\+N\+U\+ED} = 0x1
 \}
\end{DoxyCompactItemize}
\subsection*{Functions}
\begin{DoxyCompactItemize}
\item 
{\bf Error\+Code} {\bf filter\+Invalid\+Stream} ({\bf Error\+Code} code)
\item 
{\bf Error\+Code} {\bf error\+Code\+To\+Goaway} ({\bf Error\+Code} code)
\item 
{\bf Error\+Code} {\bf error\+Code\+To\+Reset} ({\bf Error\+Code} code)
\item 
const std\+::string {\bf k\+Connection\+Preface} (\char`\"{}P\+RI $\ast$ H\+T\+TP/2.\+0\textbackslash{}r\textbackslash{}n\textbackslash{}r\textbackslash{}n\+S\+M\textbackslash{}r\textbackslash{}n\textbackslash{}r\textbackslash{}n\char`\"{})
\item 
const std\+::string {\bf k\+Protocol\+String} (\char`\"{}h2\char`\"{})
\item 
const std\+::string {\bf k\+Protocol\+Draft\+String} (\char`\"{}h2-\/14\char`\"{})
\item 
const std\+::string {\bf k\+Protocol\+Experimental\+String} (\char`\"{}h2-\/fb\char`\"{})
\item 
const std\+::string {\bf k\+Protocol\+Cleartext\+String} (\char`\"{}h2c\char`\"{})
\item 
const std\+::string {\bf k\+Protocol\+Settings\+Header} (\char`\"{}H\+T\+T\+P2-\/Settings\char`\"{})
\item 
bool {\bf is\+Valid\+Frame\+Type} ({\bf Frame\+Type} type)
\item 
bool {\bf frame\+Affects\+Compression} ({\bf Frame\+Type} t)
\item 
bool {\bf frame\+Has\+Padding} (const {\bf Frame\+Header} \&header)
\item 
{\bf Error\+Code} {\bf parse\+Frame\+Header} (Cursor \&cursor, {\bf Frame\+Header} \&header) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Data} (Cursor \&cursor, const {\bf Frame\+Header} \&header, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ \&out\+Buf, uint16\+\_\+t \&out\+Padding) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Data\+Begin} (Cursor \&cursor, const {\bf Frame\+Header} \&header, size\+\_\+t \&, uint16\+\_\+t \&out\+Padding) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Data\+End} (Cursor \&cursor, const size\+\_\+t buf\+Len, const size\+\_\+t pending\+Data\+Frame\+Padding\+Bytes, size\+\_\+t \&to\+Skip) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Headers} (Cursor \&cursor, const {\bf Frame\+Header} \&header, folly\+::\+Optional$<$ {\bf Priority\+Update} $>$ \&out\+Priority, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ \&out\+Buf) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Ex\+Headers} (Cursor \&cursor, const {\bf Frame\+Header} \&header, {\bf H\+T\+T\+P\+Codec\+::\+Ex\+Attributes} \&out\+Ex\+Attributes, folly\+::\+Optional$<$ {\bf Priority\+Update} $>$ \&out\+Priority, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ \&out\+Buf) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Priority} (Cursor \&cursor, const {\bf Frame\+Header} \&header, {\bf Priority\+Update} \&out\+Priority) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Rst\+Stream} (Cursor \&cursor, const {\bf Frame\+Header} \&header, {\bf Error\+Code} \&out\+Code) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Settings} (Cursor \&cursor, const {\bf Frame\+Header} \&header, std\+::deque$<$ {\bf Setting\+Pair} $>$ \&{\bf settings}) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Push\+Promise} (Cursor \&cursor, const {\bf Frame\+Header} \&header, uint32\+\_\+t \&out\+Promised\+Stream, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ \&out\+Buf) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Ping} (Cursor \&cursor, const {\bf Frame\+Header} \&header, uint64\+\_\+t \&out\+Opaque\+Data) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Goaway} (Cursor \&cursor, const {\bf Frame\+Header} \&header, uint32\+\_\+t \&out\+Last\+Stream\+ID, {\bf Error\+Code} \&out\+Code, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ \&out\+Debug\+Data) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Window\+Update} (Cursor \&cursor, const {\bf Frame\+Header} \&header, uint32\+\_\+t \&out\+Amount) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Continuation} (Cursor \&cursor, const {\bf Frame\+Header} \&header, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ \&out\+Buf) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Alt\+Svc} (Cursor \&cursor, const {\bf Frame\+Header} \&header, uint32\+\_\+t \&out\+Max\+Age, uint32\+\_\+t \&out\+Port, std\+::string \&out\+Protocol, std\+::string \&out\+Host, std\+::string \&out\+Origin) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Certificate\+Request} (folly\+::io\+::\+Cursor \&cursor, const {\bf Frame\+Header} \&header, uint16\+\_\+t \&out\+Request\+Id, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ \&out\+Auth\+Request) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Certificate} (folly\+::io\+::\+Cursor \&cursor, const {\bf Frame\+Header} \&header, uint16\+\_\+t \&out\+Cert\+Id, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ \&out\+Authenticator) noexcept
\item 
size\+\_\+t {\bf write\+Data} (I\+O\+Buf\+Queue \&queue, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ data, uint32\+\_\+t {\bf stream}, folly\+::\+Optional$<$ uint8\+\_\+t $>$ padding, bool end\+Stream, bool reuse\+I\+O\+Buf\+Headroom) noexcept
\item 
size\+\_\+t {\bf write\+Headers} (I\+O\+Buf\+Queue \&queue, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ headers, uint32\+\_\+t {\bf stream}, folly\+::\+Optional$<$ {\bf Priority\+Update} $>$ priority, folly\+::\+Optional$<$ uint8\+\_\+t $>$ padding, bool end\+Stream, bool end\+Headers) noexcept
\item 
size\+\_\+t {\bf write\+Ex\+Headers} (I\+O\+Buf\+Queue \&queue, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ headers, uint32\+\_\+t {\bf stream}, const {\bf H\+T\+T\+P\+Codec\+::\+Ex\+Attributes} \&ex\+Attributes, const folly\+::\+Optional$<$ {\bf Priority\+Update} $>$ \&priority, const folly\+::\+Optional$<$ uint8\+\_\+t $>$ \&padding, bool end\+Stream, bool end\+Headers) noexcept
\item 
size\+\_\+t {\bf write\+Priority} (I\+O\+Buf\+Queue \&queue, uint32\+\_\+t {\bf stream}, {\bf Priority\+Update} priority) noexcept
\item 
size\+\_\+t {\bf write\+Rst\+Stream} (I\+O\+Buf\+Queue \&queue, uint32\+\_\+t {\bf stream}, {\bf Error\+Code} error\+Code) noexcept
\item 
size\+\_\+t {\bf write\+Settings} (I\+O\+Buf\+Queue \&queue, const std\+::deque$<$ {\bf Setting\+Pair} $>$ \&{\bf settings})
\item 
size\+\_\+t {\bf write\+Settings\+Ack} (I\+O\+Buf\+Queue \&queue)
\item 
size\+\_\+t {\bf write\+Push\+Promise} (I\+O\+Buf\+Queue \&queue, uint32\+\_\+t associated\+Stream, uint32\+\_\+t promised\+Stream, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ headers, folly\+::\+Optional$<$ uint8\+\_\+t $>$ padding, bool end\+Headers) noexcept
\item 
size\+\_\+t {\bf write\+Ping} (I\+O\+Buf\+Queue \&queue, uint64\+\_\+t opaque\+Data, bool ack) noexcept
\item 
size\+\_\+t {\bf write\+Goaway} (I\+O\+Buf\+Queue \&queue, uint32\+\_\+t last\+Stream\+ID, {\bf Error\+Code} error\+Code, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ debug\+Data) noexcept
\item 
size\+\_\+t {\bf write\+Window\+Update} (I\+O\+Buf\+Queue \&queue, uint32\+\_\+t {\bf stream}, uint32\+\_\+t amount) noexcept
\item 
size\+\_\+t {\bf write\+Continuation} (I\+O\+Buf\+Queue \&queue, uint32\+\_\+t {\bf stream}, bool end\+Headers, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ headers) noexcept
\item 
size\+\_\+t {\bf write\+Alt\+Svc} (I\+O\+Buf\+Queue \&queue, uint32\+\_\+t {\bf stream}, uint32\+\_\+t max\+Age, uint16\+\_\+t port, String\+Piece protocol, String\+Piece host, String\+Piece origin) noexcept
\item 
size\+\_\+t {\bf write\+Certificate\+Request} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint16\+\_\+t request\+Id, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ auth\+Request)
\item 
size\+\_\+t {\bf write\+Certificate} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint16\+\_\+t cert\+Id, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ authenticator, bool to\+Be\+Continued)
\item 
const char $\ast$ {\bf get\+Frame\+Type\+String} ({\bf Frame\+Type} type)
\item 
{\bf Error\+Code} {\bf parse\+Frame\+Header} (folly\+::io\+::\+Cursor \&cursor, {\bf Frame\+Header} \&header) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Data} (folly\+::io\+::\+Cursor \&cursor, const {\bf Frame\+Header} \&header, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ \&out\+Buf, uint16\+\_\+t \&padding) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Data\+Begin} (folly\+::io\+::\+Cursor \&cursor, const {\bf Frame\+Header} \&header, size\+\_\+t \&parsed, uint16\+\_\+t \&out\+Padding) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Data\+End} (folly\+::io\+::\+Cursor \&cursor, const size\+\_\+t buf\+Len, const size\+\_\+t pending\+Data\+Frame\+Padding\+Bytes, size\+\_\+t \&to\+Skip) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Headers} (folly\+::io\+::\+Cursor \&cursor, const {\bf Frame\+Header} \&header, folly\+::\+Optional$<$ {\bf Priority\+Update} $>$ \&out\+Priority, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ \&out\+Buf) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Ex\+Headers} (folly\+::io\+::\+Cursor \&cursor, const {\bf Frame\+Header} \&header, {\bf H\+T\+T\+P\+Codec\+::\+Ex\+Attributes} \&out\+Ex\+Attributes, folly\+::\+Optional$<$ {\bf Priority\+Update} $>$ \&out\+Priority, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ \&out\+Buf) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Priority} (folly\+::io\+::\+Cursor \&cursor, const {\bf Frame\+Header} \&header, {\bf Priority\+Update} \&out\+Priority) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Rst\+Stream} (folly\+::io\+::\+Cursor \&cursor, const {\bf Frame\+Header} \&header, {\bf Error\+Code} \&out\+Code) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Settings} (folly\+::io\+::\+Cursor \&cursor, const {\bf Frame\+Header} \&header, std\+::deque$<$ {\bf Setting\+Pair} $>$ \&{\bf settings}) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Push\+Promise} (folly\+::io\+::\+Cursor \&cursor, const {\bf Frame\+Header} \&header, uint32\+\_\+t \&out\+Promised\+Stream, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ \&out\+Buf) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Ping} (folly\+::io\+::\+Cursor \&cursor, const {\bf Frame\+Header} \&header, uint64\+\_\+t \&out\+Data) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Goaway} (folly\+::io\+::\+Cursor \&cursor, const {\bf Frame\+Header} \&header, uint32\+\_\+t \&out\+Last\+Stream\+ID, {\bf Error\+Code} \&out\+Code, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ \&out\+Debug\+Data) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Window\+Update} (folly\+::io\+::\+Cursor \&cursor, const {\bf Frame\+Header} \&header, uint32\+\_\+t \&out\+Amount) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Continuation} (folly\+::io\+::\+Cursor \&cursor, const {\bf Frame\+Header} \&header, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ \&out\+Buf) noexcept
\item 
{\bf Error\+Code} {\bf parse\+Alt\+Svc} (folly\+::io\+::\+Cursor \&cursor, const {\bf Frame\+Header} \&header, uint32\+\_\+t \&out\+Max\+Age, uint32\+\_\+t \&out\+Port, std\+::string \&out\+Protocol, std\+::string \&out\+Host, std\+::string \&out\+Origin) noexcept
\item 
size\+\_\+t {\bf write\+Data} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ data, uint32\+\_\+t {\bf stream}, folly\+::\+Optional$<$ uint8\+\_\+t $>$ padding, bool end\+Stream, bool reuse\+I\+O\+Buf\+Headroom) noexcept
\item 
size\+\_\+t {\bf write\+Headers} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ headers, uint32\+\_\+t {\bf stream}, folly\+::\+Optional$<$ {\bf Priority\+Update} $>$ priority, folly\+::\+Optional$<$ uint8\+\_\+t $>$ padding, bool end\+Stream, bool end\+Headers) noexcept
\item 
size\+\_\+t {\bf write\+Ex\+Headers} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ headers, uint32\+\_\+t {\bf stream}, const {\bf H\+T\+T\+P\+Codec\+::\+Ex\+Attributes} \&ex\+Attributes, const folly\+::\+Optional$<$ {\bf Priority\+Update} $>$ \&priority, const folly\+::\+Optional$<$ uint8\+\_\+t $>$ \&padding, bool end\+Stream, bool end\+Headers) noexcept
\item 
size\+\_\+t {\bf write\+Priority} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint32\+\_\+t {\bf stream}, {\bf Priority\+Update} priority) noexcept
\item 
size\+\_\+t {\bf write\+Rst\+Stream} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint32\+\_\+t {\bf stream}, {\bf Error\+Code} error\+Code) noexcept
\item 
size\+\_\+t {\bf write\+Settings} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, const std\+::deque$<$ {\bf Setting\+Pair} $>$ \&{\bf settings})
\item 
size\+\_\+t {\bf write\+Settings\+Ack} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf)
\item 
size\+\_\+t {\bf write\+Push\+Promise} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint32\+\_\+t associated\+Stream, uint32\+\_\+t promised\+Stream, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ headers, folly\+::\+Optional$<$ uint8\+\_\+t $>$ padding, bool end\+Headers) noexcept
\item 
size\+\_\+t {\bf write\+Ping} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint64\+\_\+t data, bool ack) noexcept
\item 
size\+\_\+t {\bf write\+Goaway} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint32\+\_\+t last\+Stream\+ID, {\bf Error\+Code} error\+Code, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ debug\+Data={\bf nullptr}) noexcept
\item 
size\+\_\+t {\bf write\+Window\+Update} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint32\+\_\+t {\bf stream}, uint32\+\_\+t amount) noexcept
\item 
size\+\_\+t {\bf write\+Continuation} (folly\+::\+I\+O\+Buf\+Queue \&queue, uint32\+\_\+t {\bf stream}, bool end\+Headers, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ headers) noexcept
\item 
size\+\_\+t {\bf write\+Alt\+Svc} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint32\+\_\+t {\bf stream}, uint32\+\_\+t max\+Age, uint16\+\_\+t port, folly\+::\+String\+Piece protocol, folly\+::\+String\+Piece host, folly\+::\+String\+Piece origin) noexcept
\end{DoxyCompactItemize}
\subsection*{Variables}
\begin{DoxyCompactItemize}
\item 
const uint32\+\_\+t {\bf k\+Frame\+Header\+Size} = 9
\item 
const uint32\+\_\+t {\bf k\+Frame\+Headers\+Base\+Max\+Size} = {\bf k\+Frame\+Priority\+Size} + 1
\item 
const uint32\+\_\+t {\bf k\+Frame\+Priority\+Size} = 5
\item 
const uint32\+\_\+t {\bf k\+Frame\+Stream\+I\+D\+Size} = 4
\item 
const uint32\+\_\+t {\bf k\+Frame\+Rst\+Stream\+Size} = 4
\item 
const uint32\+\_\+t {\bf k\+Frame\+Push\+Promise\+Size} = 4
\item 
const uint32\+\_\+t {\bf k\+Frame\+Ping\+Size} = 8
\item 
const uint32\+\_\+t {\bf k\+Frame\+Goaway\+Size} = 8
\item 
const uint32\+\_\+t {\bf k\+Frame\+Window\+Update\+Size} = 4
\item 
const uint32\+\_\+t {\bf k\+Frame\+Certificate\+Request\+Size\+Base} = 2
\item 
const uint32\+\_\+t {\bf k\+Frame\+Certificate\+Size\+Base} = 2
\item 
const uint32\+\_\+t {\bf k\+Frame\+Alt\+Svc\+Size\+Base} = 8
\item 
const uint32\+\_\+t {\bf k\+Max\+Frame\+Payload\+Length\+Min} = (1u $<$$<$ 14)
\item 
const uint32\+\_\+t {\bf k\+Max\+Frame\+Payload\+Length} = (1u $<$$<$ 24) -\/ 1
\item 
const uint32\+\_\+t {\bf k\+Max\+Stream\+ID} = (1u $<$$<$ 31) -\/ 1
\item 
const uint32\+\_\+t {\bf k\+Initial\+Window} = (1u $<$$<$ 16) -\/ 1
\item 
const uint32\+\_\+t {\bf k\+Max\+Window\+Update\+Size} = (1u $<$$<$ 31) -\/ 1
\item 
const uint32\+\_\+t {\bf k\+Max\+Header\+Table\+Size} = (1u $<$$<$ 16)
\item 
const uint32\+\_\+t {\bf k\+Max\+Authenticator\+Buf\+Size} = 0x20000
\item 
const std\+::string {\bf k\+Connection\+Preface}
\item 
const std\+::string {\bf k\+Protocol\+String}
\item 
const std\+::string {\bf k\+Protocol\+Draft\+String}
\item 
const std\+::string {\bf k\+Protocol\+Experimental\+String}
\item 
const std\+::string {\bf k\+Protocol\+Cleartext\+String}
\item 
const std\+::string {\bf k\+Protocol\+Settings\+Header}
\item 
const uint8\+\_\+t {\bf k\+Min\+Experimental\+Frame\+Type} = 0xf0
\item 
const {\bf Padding} {\bf k\+No\+Padding} = folly\+::none
\item 
const {\bf Priority\+Update} {\bf Default\+Priority} \{0, false, 15\}
\end{DoxyCompactItemize}


\subsection{Typedef Documentation}
\index{proxygen\+::http2@{proxygen\+::http2}!Padding@{Padding}}
\index{Padding@{Padding}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{Padding}]{\setlength{\rightskip}{0pt plus 5cm}using {\bf proxygen\+::http2\+::\+Padding} = typedef folly\+::\+Optional$<$uint8\+\_\+t$>$}\label{namespaceproxygen_1_1http2_adb27a3f88dc81d4ddede65c1b6a07ce4}


Definition at line 30 of file H\+T\+T\+P2\+Framer.\+h.



\subsection{Enumeration Type Documentation}
\index{proxygen\+::http2@{proxygen\+::http2}!Flags@{Flags}}
\index{Flags@{Flags}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{Flags}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::http2\+::\+Flags}}\label{namespaceproxygen_1_1http2_a812c0033030c8deebf5a6d908350a1c5}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{A\+CK@{A\+CK}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!A\+CK@{A\+CK}}\item[{\em 
A\+CK\label{namespaceproxygen_1_1http2_a812c0033030c8deebf5a6d908350a1c5aea83b79bc0cd291d8643401404416ac4}
}]\index{E\+N\+D\+\_\+\+S\+T\+R\+E\+AM@{E\+N\+D\+\_\+\+S\+T\+R\+E\+AM}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!E\+N\+D\+\_\+\+S\+T\+R\+E\+AM@{E\+N\+D\+\_\+\+S\+T\+R\+E\+AM}}\item[{\em 
E\+N\+D\+\_\+\+S\+T\+R\+E\+AM\label{namespaceproxygen_1_1http2_a812c0033030c8deebf5a6d908350a1c5a54ab323de73630b9a0ab103fdb790746}
}]\index{E\+N\+D\+\_\+\+H\+E\+A\+D\+E\+RS@{E\+N\+D\+\_\+\+H\+E\+A\+D\+E\+RS}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!E\+N\+D\+\_\+\+H\+E\+A\+D\+E\+RS@{E\+N\+D\+\_\+\+H\+E\+A\+D\+E\+RS}}\item[{\em 
E\+N\+D\+\_\+\+H\+E\+A\+D\+E\+RS\label{namespaceproxygen_1_1http2_a812c0033030c8deebf5a6d908350a1c5a23c99820f6e40485194fba7147878f3f}
}]\index{P\+A\+D\+D\+ED@{P\+A\+D\+D\+ED}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!P\+A\+D\+D\+ED@{P\+A\+D\+D\+ED}}\item[{\em 
P\+A\+D\+D\+ED\label{namespaceproxygen_1_1http2_a812c0033030c8deebf5a6d908350a1c5a65c0020a3ced583c8fea135d9890f1d7}
}]\index{P\+R\+I\+O\+R\+I\+TY@{P\+R\+I\+O\+R\+I\+TY}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!P\+R\+I\+O\+R\+I\+TY@{P\+R\+I\+O\+R\+I\+TY}}\item[{\em 
P\+R\+I\+O\+R\+I\+TY\label{namespaceproxygen_1_1http2_a812c0033030c8deebf5a6d908350a1c5a2c54e60666900376cdd131f8e8b1e061}
}]\index{P\+R\+I\+O\+R\+I\+TY@{P\+R\+I\+O\+R\+I\+TY}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!P\+R\+I\+O\+R\+I\+TY@{P\+R\+I\+O\+R\+I\+TY}}\item[{\em 
P\+R\+I\+O\+R\+I\+TY\label{namespaceproxygen_1_1http2_a812c0033030c8deebf5a6d908350a1c5acaf55db72c49969e2ed270adbcd0a8f5}
}]\index{U\+N\+I\+D\+I\+R\+E\+C\+T\+I\+O\+N\+AL@{U\+N\+I\+D\+I\+R\+E\+C\+T\+I\+O\+N\+AL}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!U\+N\+I\+D\+I\+R\+E\+C\+T\+I\+O\+N\+AL@{U\+N\+I\+D\+I\+R\+E\+C\+T\+I\+O\+N\+AL}}\item[{\em 
U\+N\+I\+D\+I\+R\+E\+C\+T\+I\+O\+N\+AL\label{namespaceproxygen_1_1http2_a812c0033030c8deebf5a6d908350a1c5a5484864a7ebb72bed5d223518f240e3e}
}]\index{U\+N\+S\+O\+L\+I\+C\+I\+T\+ED@{U\+N\+S\+O\+L\+I\+C\+I\+T\+ED}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!U\+N\+S\+O\+L\+I\+C\+I\+T\+ED@{U\+N\+S\+O\+L\+I\+C\+I\+T\+ED}}\item[{\em 
U\+N\+S\+O\+L\+I\+C\+I\+T\+ED\label{namespaceproxygen_1_1http2_a812c0033030c8deebf5a6d908350a1c5a0b80e6dd49b85c9148ffa3fd53d19dde}
}]\index{T\+O\+\_\+\+B\+E\+\_\+\+C\+O\+N\+T\+I\+N\+U\+ED@{T\+O\+\_\+\+B\+E\+\_\+\+C\+O\+N\+T\+I\+N\+U\+ED}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!T\+O\+\_\+\+B\+E\+\_\+\+C\+O\+N\+T\+I\+N\+U\+ED@{T\+O\+\_\+\+B\+E\+\_\+\+C\+O\+N\+T\+I\+N\+U\+ED}}\item[{\em 
T\+O\+\_\+\+B\+E\+\_\+\+C\+O\+N\+T\+I\+N\+U\+ED\label{namespaceproxygen_1_1http2_a812c0033030c8deebf5a6d908350a1c5a4b651bec334b2fa876d93a646ef74326}
}]\end{description}
\end{Desc}


Definition at line 59 of file H\+T\+T\+P2\+Framer.\+h.


\begin{DoxyCode}
59            \{
60   ACK = 0x1,
61   END_STREAM = 0x1,
62   END_HEADERS = 0x4,
63   PADDED = 0x8,
64   PRIORITY = 0x20,
65   \textcolor{comment}{// experimental flag for EX stream only}
66   UNIDIRECTIONAL = 0x40,
67 
68   \textcolor{comment}{// for secondary certificate authentication frames}
69   UNSOLICITED = 0x1,
70   TO_BE_CONTINUED = 0x1,
71 \};
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!Frame\+Type@{Frame\+Type}}
\index{Frame\+Type@{Frame\+Type}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{Frame\+Type}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::http2\+::\+Frame\+Type} \+: uint8\+\_\+t\hspace{0.3cm}{\ttfamily [strong]}}\label{namespaceproxygen_1_1http2_a60a5f26de8e64ad7cc596791738df31e}
\begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{D\+A\+TA@{D\+A\+TA}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!D\+A\+TA@{D\+A\+TA}}\item[{\em 
D\+A\+TA\label{namespaceproxygen_1_1http2_a60a5f26de8e64ad7cc596791738df31eae44f9e348e41cb272efa87387728571b}
}]\index{H\+E\+A\+D\+E\+RS@{H\+E\+A\+D\+E\+RS}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!H\+E\+A\+D\+E\+RS@{H\+E\+A\+D\+E\+RS}}\item[{\em 
H\+E\+A\+D\+E\+RS\label{namespaceproxygen_1_1http2_a60a5f26de8e64ad7cc596791738df31ea1242249ca7c09fa7634e292cf2819f85}
}]\index{P\+R\+I\+O\+R\+I\+TY@{P\+R\+I\+O\+R\+I\+TY}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!P\+R\+I\+O\+R\+I\+TY@{P\+R\+I\+O\+R\+I\+TY}}\item[{\em 
P\+R\+I\+O\+R\+I\+TY\label{namespaceproxygen_1_1http2_a812c0033030c8deebf5a6d908350a1c5acaf55db72c49969e2ed270adbcd0a8f5}
}]\index{R\+S\+T\+\_\+\+S\+T\+R\+E\+AM@{R\+S\+T\+\_\+\+S\+T\+R\+E\+AM}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!R\+S\+T\+\_\+\+S\+T\+R\+E\+AM@{R\+S\+T\+\_\+\+S\+T\+R\+E\+AM}}\item[{\em 
R\+S\+T\+\_\+\+S\+T\+R\+E\+AM\label{namespaceproxygen_1_1http2_a60a5f26de8e64ad7cc596791738df31eab1f3602a647feee25f03b754f03316c0}
}]\index{S\+E\+T\+T\+I\+N\+GS@{S\+E\+T\+T\+I\+N\+GS}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!S\+E\+T\+T\+I\+N\+GS@{S\+E\+T\+T\+I\+N\+GS}}\item[{\em 
S\+E\+T\+T\+I\+N\+GS\label{namespaceproxygen_1_1http2_a60a5f26de8e64ad7cc596791738df31eaed6f7aca7887a927b9ed3d62aa347a86}
}]\index{P\+U\+S\+H\+\_\+\+P\+R\+O\+M\+I\+SE@{P\+U\+S\+H\+\_\+\+P\+R\+O\+M\+I\+SE}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!P\+U\+S\+H\+\_\+\+P\+R\+O\+M\+I\+SE@{P\+U\+S\+H\+\_\+\+P\+R\+O\+M\+I\+SE}}\item[{\em 
P\+U\+S\+H\+\_\+\+P\+R\+O\+M\+I\+SE\label{namespaceproxygen_1_1http2_a60a5f26de8e64ad7cc596791738df31eaa2302bddf66a619a09f67beb7c446504}
}]\index{P\+I\+NG@{P\+I\+NG}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!P\+I\+NG@{P\+I\+NG}}\item[{\em 
P\+I\+NG\label{namespaceproxygen_1_1http2_a60a5f26de8e64ad7cc596791738df31eae07ff41a486c27c095a15898dcca34d1}
}]\index{G\+O\+A\+W\+AY@{G\+O\+A\+W\+AY}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!G\+O\+A\+W\+AY@{G\+O\+A\+W\+AY}}\item[{\em 
G\+O\+A\+W\+AY\label{namespaceproxygen_1_1http2_a60a5f26de8e64ad7cc596791738df31ea21c426cbdb92c2439053c570eb511c30}
}]\index{W\+I\+N\+D\+O\+W\+\_\+\+U\+P\+D\+A\+TE@{W\+I\+N\+D\+O\+W\+\_\+\+U\+P\+D\+A\+TE}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!W\+I\+N\+D\+O\+W\+\_\+\+U\+P\+D\+A\+TE@{W\+I\+N\+D\+O\+W\+\_\+\+U\+P\+D\+A\+TE}}\item[{\em 
W\+I\+N\+D\+O\+W\+\_\+\+U\+P\+D\+A\+TE\label{namespaceproxygen_1_1http2_a60a5f26de8e64ad7cc596791738df31ea8930ff86ec057f61f21407e49bf82e6d}
}]\index{C\+O\+N\+T\+I\+N\+U\+A\+T\+I\+ON@{C\+O\+N\+T\+I\+N\+U\+A\+T\+I\+ON}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!C\+O\+N\+T\+I\+N\+U\+A\+T\+I\+ON@{C\+O\+N\+T\+I\+N\+U\+A\+T\+I\+ON}}\item[{\em 
C\+O\+N\+T\+I\+N\+U\+A\+T\+I\+ON\label{namespaceproxygen_1_1http2_a60a5f26de8e64ad7cc596791738df31eaa912ad8cd8aeb3f2762b4359d4c36583}
}]\index{A\+L\+T\+S\+VC@{A\+L\+T\+S\+VC}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!A\+L\+T\+S\+VC@{A\+L\+T\+S\+VC}}\item[{\em 
A\+L\+T\+S\+VC\label{namespaceproxygen_1_1http2_a60a5f26de8e64ad7cc596791738df31ea2f632de1b4bb5109f66bd0b36c47a3f3}
}]\index{E\+X\+\_\+\+H\+E\+A\+D\+E\+RS@{E\+X\+\_\+\+H\+E\+A\+D\+E\+RS}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!E\+X\+\_\+\+H\+E\+A\+D\+E\+RS@{E\+X\+\_\+\+H\+E\+A\+D\+E\+RS}}\item[{\em 
E\+X\+\_\+\+H\+E\+A\+D\+E\+RS\label{namespaceproxygen_1_1http2_a60a5f26de8e64ad7cc596791738df31ea2645f378155cf2c9ecfe391fd17be7b0}
}]\index{C\+E\+R\+T\+I\+F\+I\+C\+A\+T\+E\+\_\+\+R\+E\+Q\+U\+E\+ST@{C\+E\+R\+T\+I\+F\+I\+C\+A\+T\+E\+\_\+\+R\+E\+Q\+U\+E\+ST}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!C\+E\+R\+T\+I\+F\+I\+C\+A\+T\+E\+\_\+\+R\+E\+Q\+U\+E\+ST@{C\+E\+R\+T\+I\+F\+I\+C\+A\+T\+E\+\_\+\+R\+E\+Q\+U\+E\+ST}}\item[{\em 
C\+E\+R\+T\+I\+F\+I\+C\+A\+T\+E\+\_\+\+R\+E\+Q\+U\+E\+ST\label{namespaceproxygen_1_1http2_a60a5f26de8e64ad7cc596791738df31ead3d3b002c0022969e52f9b0e87b8823e}
}]\index{C\+E\+R\+T\+I\+F\+I\+C\+A\+TE@{C\+E\+R\+T\+I\+F\+I\+C\+A\+TE}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!C\+E\+R\+T\+I\+F\+I\+C\+A\+TE@{C\+E\+R\+T\+I\+F\+I\+C\+A\+TE}}\item[{\em 
C\+E\+R\+T\+I\+F\+I\+C\+A\+TE\label{namespaceproxygen_1_1http2_a60a5f26de8e64ad7cc596791738df31eaad1694fa18786504d416601fa3e96d01}
}]\index{C\+E\+R\+T\+I\+F\+I\+C\+A\+T\+E\+\_\+\+N\+E\+E\+D\+ED@{C\+E\+R\+T\+I\+F\+I\+C\+A\+T\+E\+\_\+\+N\+E\+E\+D\+ED}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!C\+E\+R\+T\+I\+F\+I\+C\+A\+T\+E\+\_\+\+N\+E\+E\+D\+ED@{C\+E\+R\+T\+I\+F\+I\+C\+A\+T\+E\+\_\+\+N\+E\+E\+D\+ED}}\item[{\em 
C\+E\+R\+T\+I\+F\+I\+C\+A\+T\+E\+\_\+\+N\+E\+E\+D\+ED\label{namespaceproxygen_1_1http2_a60a5f26de8e64ad7cc596791738df31eae8c183fafade6ecd07a1f2fa4772ff36}
}]\index{U\+S\+E\+\_\+\+C\+E\+R\+T\+I\+F\+I\+C\+A\+TE@{U\+S\+E\+\_\+\+C\+E\+R\+T\+I\+F\+I\+C\+A\+TE}!proxygen\+::http2@{proxygen\+::http2}}\index{proxygen\+::http2@{proxygen\+::http2}!U\+S\+E\+\_\+\+C\+E\+R\+T\+I\+F\+I\+C\+A\+TE@{U\+S\+E\+\_\+\+C\+E\+R\+T\+I\+F\+I\+C\+A\+TE}}\item[{\em 
U\+S\+E\+\_\+\+C\+E\+R\+T\+I\+F\+I\+C\+A\+TE\label{namespaceproxygen_1_1http2_a60a5f26de8e64ad7cc596791738df31eafc95c08a1c670dd9fd29a94b13782e16}
}]\end{description}
\end{Desc}


Definition at line 35 of file H\+T\+T\+P2\+Framer.\+h.


\begin{DoxyCode}
35                      : uint8\_t \{
36   DATA = 0,
37   HEADERS = 1,
38   PRIORITY = 2,
39   RST_STREAM = 3,
40   SETTINGS = 4,
41   PUSH_PROMISE = 5,
42   PING = 6,
43   GOAWAY = 7,
44   WINDOW_UPDATE = 8,
45   CONTINUATION = 9,
46   ALTSVC = 10, \textcolor{comment}{// not in current draft so frame type has not been assigned}
47 
48   \textcolor{comment}{// experimental use}
49   EX_HEADERS = 0xfb,
50 
51   \textcolor{comment}{// For secondary certificate authentication in HTTP/2 as specified in the}
52   \textcolor{comment}{// draft-ietf-httpbis-http2-secondary-certs-02.}
53   CERTIFICATE_REQUEST = 0xf0,
54   CERTIFICATE = 0xf1,
55   CERTIFICATE_NEEDED = 0xf2,
56   USE_CERTIFICATE = 0xf3,
57 \};
\end{DoxyCode}


\subsection{Function Documentation}
\index{proxygen\+::http2@{proxygen\+::http2}!error\+Code\+To\+Goaway@{error\+Code\+To\+Goaway}}
\index{error\+Code\+To\+Goaway@{error\+Code\+To\+Goaway}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{error\+Code\+To\+Goaway(\+Error\+Code code)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::error\+Code\+To\+Goaway (
\begin{DoxyParamCaption}
\item[{{\bf Error\+Code}}]{code}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1http2_a5ac070c713074beca8be8276ccefbc82}


Definition at line 22 of file H\+T\+T\+P2\+Constants.\+cpp.



References filter\+Invalid\+Stream().



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Goaway().


\begin{DoxyCode}
22                                             \{
23   \textcolor{keywordflow}{return} filterInvalidStream(code);
24 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!error\+Code\+To\+Reset@{error\+Code\+To\+Reset}}
\index{error\+Code\+To\+Reset@{error\+Code\+To\+Reset}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{error\+Code\+To\+Reset(\+Error\+Code code)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::error\+Code\+To\+Reset (
\begin{DoxyParamCaption}
\item[{{\bf Error\+Code}}]{code}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1http2_adaeb862dac4d9842917bf5d338ea5408}


Definition at line 26 of file H\+T\+T\+P2\+Constants.\+cpp.



References filter\+Invalid\+Stream().



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Rst\+Stream().


\begin{DoxyCode}
26                                            \{
27   \textcolor{keywordflow}{return} filterInvalidStream(code);
28 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!filter\+Invalid\+Stream@{filter\+Invalid\+Stream}}
\index{filter\+Invalid\+Stream@{filter\+Invalid\+Stream}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{filter\+Invalid\+Stream(\+Error\+Code code)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::filter\+Invalid\+Stream (
\begin{DoxyParamCaption}
\item[{{\bf Error\+Code}}]{code}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1http2_ae946a43ce07b2040c405804c76ee6475}


Definition at line 14 of file H\+T\+T\+P2\+Constants.\+cpp.



References proxygen\+::\+\_\+\+S\+P\+D\+Y\+\_\+\+I\+N\+V\+A\+L\+I\+D\+\_\+\+S\+T\+R\+E\+AM, and proxygen\+::\+S\+T\+R\+E\+A\+M\+\_\+\+C\+L\+O\+S\+ED.



Referenced by error\+Code\+To\+Goaway(), and error\+Code\+To\+Reset().


\begin{DoxyCode}
14                                               \{
15   \textcolor{comment}{// \_SPDY\_INVALID\_STREAM is SPDY specific, filter it out}
16   \textcolor{keywordflow}{if} (code == ErrorCode::\_SPDY\_INVALID\_STREAM) \{
17     \textcolor{keywordflow}{return} ErrorCode::STREAM\_CLOSED;
18   \}
19   \textcolor{keywordflow}{return} code;
20 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!frame\+Affects\+Compression@{frame\+Affects\+Compression}}
\index{frame\+Affects\+Compression@{frame\+Affects\+Compression}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{frame\+Affects\+Compression(\+Frame\+Type t)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::http2\+::frame\+Affects\+Compression (
\begin{DoxyParamCaption}
\item[{{\bf Frame\+Type}}]{t}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1http2_a25070f55c2255c10605c8ed0c207ca49}


Definition at line 245 of file H\+T\+T\+P2\+Framer.\+cpp.



References proxygen\+::spdy\+::\+H\+E\+A\+D\+E\+RS.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Frame().


\begin{DoxyCode}
245                                           \{
246   \textcolor{keywordflow}{return} t == FrameType::HEADERS ||
247     t == FrameType::PUSH\_PROMISE ||
248     t == FrameType::CONTINUATION;
249 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!frame\+Has\+Padding@{frame\+Has\+Padding}}
\index{frame\+Has\+Padding@{frame\+Has\+Padding}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{frame\+Has\+Padding(const Frame\+Header \&header)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::http2\+::frame\+Has\+Padding (
\begin{DoxyParamCaption}
\item[{const {\bf Frame\+Header} \&}]{header}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1http2_ab2e2c86594e7d43c88411bb21f1988d2}
This function returns true if the padding bit is set in the header


\begin{DoxyParams}{Parameters}
{\em header} & The frame header. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
true if the padding bit is set, false otherwise. 
\end{DoxyReturn}


Definition at line 251 of file H\+T\+T\+P2\+Framer.\+cpp.



References proxygen\+::http2\+::\+Frame\+Header\+::flags, and P\+A\+D\+D\+ED.



Referenced by parse\+Data(), parse\+Data\+Begin(), and proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Data\+Frame\+Data().


\begin{DoxyCode}
251                                                   \{
252     \textcolor{keywordflow}{return} header.flags & PADDED;
253   \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!get\+Frame\+Type\+String@{get\+Frame\+Type\+String}}
\index{get\+Frame\+Type\+String@{get\+Frame\+Type\+String}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{get\+Frame\+Type\+String(\+Frame\+Type type)}]{\setlength{\rightskip}{0pt plus 5cm}const char $\ast$ proxygen\+::http2\+::get\+Frame\+Type\+String (
\begin{DoxyParamCaption}
\item[{{\bf Frame\+Type}}]{type}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1http2_a3c0291a33e7a6ce29beacc4bb0eae7af}
Get the string representation of the given Frame\+Type


\begin{DoxyParams}{Parameters}
{\em type} & frame type\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
string representation of the frame type 
\end{DoxyReturn}


Definition at line 964 of file H\+T\+T\+P2\+Framer.\+cpp.



References proxygen\+::spdy\+::\+G\+O\+A\+W\+AY, proxygen\+::spdy\+::\+H\+E\+A\+D\+E\+RS, proxygen\+::spdy\+::\+P\+I\+NG, P\+R\+I\+O\+R\+I\+TY, proxygen\+::spdy\+::\+R\+S\+T\+\_\+\+S\+T\+R\+E\+AM, proxygen\+::spdy\+::\+S\+E\+T\+T\+I\+N\+GS, and proxygen\+::spdy\+::\+W\+I\+N\+D\+O\+W\+\_\+\+U\+P\+D\+A\+TE.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::on\+Ingress(), and proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Frame().


\begin{DoxyCode}
964                                                \{
965   \textcolor{keywordflow}{switch} (type) \{
966     \textcolor{keywordflow}{case} FrameType::DATA: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"DATA"};
967     \textcolor{keywordflow}{case} FrameType::HEADERS: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"HEADERS"};
968     \textcolor{keywordflow}{case} FrameType::PRIORITY: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"PRIORITY"};
969     \textcolor{keywordflow}{case} FrameType::RST_STREAM: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"RST\_STREAM"};
970     \textcolor{keywordflow}{case} FrameType::SETTINGS: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"SETTINGS"};
971     \textcolor{keywordflow}{case} FrameType::PUSH\_PROMISE: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"PUSH\_PROMISE"};
972     \textcolor{keywordflow}{case} FrameType::PING: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"PING"};
973     \textcolor{keywordflow}{case} FrameType::GOAWAY: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"GOAWAY"};
974     \textcolor{keywordflow}{case} FrameType::WINDOW_UPDATE: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"WINDOW\_UPDATE"};
975     \textcolor{keywordflow}{case} FrameType::CONTINUATION: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"CONTINUATION"};
976     \textcolor{keywordflow}{case} FrameType::ALTSVC: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"ALTSVC"};
977     \textcolor{keywordflow}{case} FrameType::CERTIFICATE\_REQUEST: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"CERTIFICATE\_REQUEST"};
978     \textcolor{keywordflow}{case} FrameType::CERTIFICATE: \textcolor{keywordflow}{return} \textcolor{stringliteral}{"CERTIFICATE"};
979     \textcolor{keywordflow}{default}:
980       \textcolor{comment}{// can happen when type was cast from uint8\_t}
981       \textcolor{keywordflow}{return} \textcolor{stringliteral}{"Unknown"};
982   \}
983   LOG(FATAL) << \textcolor{stringliteral}{"Unreachable"};
984   \textcolor{keywordflow}{return} \textcolor{stringliteral}{""};
985 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!is\+Valid\+Frame\+Type@{is\+Valid\+Frame\+Type}}
\index{is\+Valid\+Frame\+Type@{is\+Valid\+Frame\+Type}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{is\+Valid\+Frame\+Type(\+Frame\+Type type)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::http2\+::is\+Valid\+Frame\+Type (
\begin{DoxyParamCaption}
\item[{{\bf Frame\+Type}}]{type}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1http2_aeaebeeb2d6eb9f569b6699740d3e0c4d}


Definition at line 227 of file H\+T\+T\+P2\+Framer.\+cpp.


\begin{DoxyCode}
227                                       \{
228   \textcolor{keyword}{auto} val = \textcolor{keyword}{static\_cast<}uint8\_t\textcolor{keyword}{>}(type);
229   \textcolor{keywordflow}{if} (val < kMinExperimentalFrameType) \{
230     \textcolor{keywordflow}{return} val <= static\_cast<uint8\_t>(FrameType::ALTSVC);
231   \} \textcolor{keywordflow}{else} \{
232     \textcolor{keywordflow}{switch} (type) \{
233       \textcolor{keywordflow}{case} FrameType::EX\_HEADERS:
234         \textcolor{comment}{// Include the frame types added into FrameType enum for secondary}
235         \textcolor{comment}{// authentication.}
236       \textcolor{keywordflow}{case} FrameType::CERTIFICATE\_REQUEST:
237       \textcolor{keywordflow}{case} FrameType::CERTIFICATE:
238         \textcolor{keywordflow}{return} \textcolor{keyword}{true};
239       \textcolor{keywordflow}{default}:
240         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
241     \}
242   \}
243 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!k\+Connection\+Preface@{k\+Connection\+Preface}}
\index{k\+Connection\+Preface@{k\+Connection\+Preface}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Connection\+Preface(""P\+R\+I $\ast$ H\+T\+T\+P/2.\+0\textbackslash{}r\textbackslash{}n\textbackslash{}r\textbackslash{}n\+S\+M\textbackslash{}r\textbackslash{}n\textbackslash{}r\textbackslash{}n"")}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string proxygen\+::http2\+::k\+Connection\+Preface (
\begin{DoxyParamCaption}
\item[{\char`\"{}P\+RI $\ast$ H\+T\+TP/2.\+0\textbackslash{}r\textbackslash{}n\textbackslash{}r\textbackslash{}n\+S\+M\textbackslash{}r\textbackslash{}n\textbackslash{}r\textbackslash{}n\char`\"{}}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1http2_a5a7b7395f81e3c32fd3923a2fc6a7ed2}
\index{proxygen\+::http2@{proxygen\+::http2}!k\+Protocol\+Cleartext\+String@{k\+Protocol\+Cleartext\+String}}
\index{k\+Protocol\+Cleartext\+String@{k\+Protocol\+Cleartext\+String}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Protocol\+Cleartext\+String(""h2c"")}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string proxygen\+::http2\+::k\+Protocol\+Cleartext\+String (
\begin{DoxyParamCaption}
\item[{\char`\"{}h2c\char`\"{}}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1http2_a14f27703224d0b79573a1bdd0fba7ce0}
\index{proxygen\+::http2@{proxygen\+::http2}!k\+Protocol\+Draft\+String@{k\+Protocol\+Draft\+String}}
\index{k\+Protocol\+Draft\+String@{k\+Protocol\+Draft\+String}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Protocol\+Draft\+String(""h2-\/14"")}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string proxygen\+::http2\+::k\+Protocol\+Draft\+String (
\begin{DoxyParamCaption}
\item[{\char`\"{}h2-\/14\char`\"{}}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1http2_a5192d2b96b3cef5f4f278cde53e09090}
\index{proxygen\+::http2@{proxygen\+::http2}!k\+Protocol\+Experimental\+String@{k\+Protocol\+Experimental\+String}}
\index{k\+Protocol\+Experimental\+String@{k\+Protocol\+Experimental\+String}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Protocol\+Experimental\+String(""h2-\/fb"")}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string proxygen\+::http2\+::k\+Protocol\+Experimental\+String (
\begin{DoxyParamCaption}
\item[{\char`\"{}h2-\/fb\char`\"{}}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1http2_a000dea5cf64da02e928d69163078876b}
\index{proxygen\+::http2@{proxygen\+::http2}!k\+Protocol\+Settings\+Header@{k\+Protocol\+Settings\+Header}}
\index{k\+Protocol\+Settings\+Header@{k\+Protocol\+Settings\+Header}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Protocol\+Settings\+Header(""H\+T\+T\+P2-\/\+Settings"")}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string proxygen\+::http2\+::k\+Protocol\+Settings\+Header (
\begin{DoxyParamCaption}
\item[{\char`\"{}H\+T\+T\+P2-\/Settings\char`\"{}}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1http2_a62ef2ba3aa8766aa5994813a3c07b0f5}
\index{proxygen\+::http2@{proxygen\+::http2}!k\+Protocol\+String@{k\+Protocol\+String}}
\index{k\+Protocol\+String@{k\+Protocol\+String}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Protocol\+String(""h2"")}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string proxygen\+::http2\+::k\+Protocol\+String (
\begin{DoxyParamCaption}
\item[{\char`\"{}h2\char`\"{}}]{}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1http2_a215143b57284716b269f41b7d71afe6e}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Alt\+Svc@{parse\+Alt\+Svc}}
\index{parse\+Alt\+Svc@{parse\+Alt\+Svc}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Alt\+Svc(folly\+::io\+::\+Cursor \&cursor, const Frame\+Header \&header, uint32\+\_\+t \&out\+Max\+Age, uint32\+\_\+t \&out\+Port, std\+::string \&out\+Protocol, std\+::string \&out\+Host, std\+::string \&out\+Origin) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Alt\+Svc (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{uint32\+\_\+t \&}]{out\+Max\+Age, }
\item[{uint32\+\_\+t \&}]{out\+Port, }
\item[{std\+::string \&}]{out\+Protocol, }
\item[{std\+::string \&}]{out\+Host, }
\item[{std\+::string \&}]{out\+Origin}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a8e9120d1d409445f2a93c3f36302be4d}
This function parses the section of the A\+L\+T\+S\+VC frame after the common frame header. The caller must ensure there is header.\+length bytes available in the cursor.


\begin{DoxyParams}{Parameters}
{\em cursor} & The cursor to pull data from. \\
\hline
{\em header} & The frame header for the frame being parsed. \\
\hline
{\em out\+Max\+Age} & The max age field. \\
\hline
{\em out\+Port} & The port the alternative service is on. \\
\hline
{\em out\+Protocol} & The alternative service protocol string. \\
\hline
{\em out\+Host} & The alternative service host name. \\
\hline
{\em out\+Origin} & The origin the alternative service is applicable to. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
N\+O\+\_\+\+E\+R\+R\+OR for successful parse. The connection error code to return in a G\+O\+A\+W\+AY frame if failure. 
\end{DoxyReturn}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Alt\+Svc@{parse\+Alt\+Svc}}
\index{parse\+Alt\+Svc@{parse\+Alt\+Svc}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Alt\+Svc(\+Cursor \&cursor, const Frame\+Header \&header, uint32\+\_\+t \&out\+Max\+Age, uint32\+\_\+t \&out\+Port, std\+::string \&out\+Protocol, std\+::string \&out\+Host, std\+::string \&out\+Origin) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Alt\+Svc (
\begin{DoxyParamCaption}
\item[{Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{uint32\+\_\+t \&}]{out\+Max\+Age, }
\item[{uint32\+\_\+t \&}]{out\+Port, }
\item[{std\+::string \&}]{out\+Protocol, }
\item[{std\+::string \&}]{out\+Host, }
\item[{std\+::string \&}]{out\+Origin}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_ad8628be6dd91e4ccc3dcca3010a2d844}


Definition at line 534 of file H\+T\+T\+P2\+Framer.\+cpp.



References k\+Frame\+Alt\+Svc\+Size\+Base.



Referenced by T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
540                                            \{
541   DCHECK\_LE(header.length, cursor.totalLength());
542   \textcolor{keywordflow}{if} (header.length < kFrameAltSvcSizeBase) \{
543     \textcolor{keywordflow}{return} ErrorCode::FRAME\_SIZE\_ERROR;
544   \}
545   std::unique\_ptr<IOBuf> tmpBuf;
546 
547   outMaxAge = cursor.readBE<uint32\_t>();
548   outPort = cursor.readBE<uint16\_t>();
549   \textcolor{keyword}{const} \textcolor{keyword}{auto} protoLen = cursor.readBE<uint8\_t>();
550   \textcolor{keywordflow}{if} (header.length < kFrameAltSvcSizeBase + protoLen) \{
551     \textcolor{keywordflow}{return} ErrorCode::FRAME\_SIZE\_ERROR;
552   \}
553   outProtocol = cursor.readFixedString(protoLen);
554   \textcolor{keyword}{const} \textcolor{keyword}{auto} hostLen = cursor.readBE<uint8\_t>();
555   \textcolor{keywordflow}{if} (header.length < kFrameAltSvcSizeBase + protoLen + hostLen) \{
556     \textcolor{keywordflow}{return} ErrorCode::FRAME\_SIZE\_ERROR;
557   \}
558   outHost = cursor.readFixedString(hostLen);
559   \textcolor{keyword}{const} \textcolor{keyword}{auto} originLen = (header.length - kFrameAltSvcSizeBase -
560                           protoLen - hostLen);
561   outOrigin = cursor.readFixedString(originLen);
562 
563   \textcolor{keywordflow}{return} ErrorCode::NO\_ERROR;
564 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Certificate@{parse\+Certificate}}
\index{parse\+Certificate@{parse\+Certificate}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Certificate(folly\+::io\+::\+Cursor \&cursor, const Frame\+Header \&header, uint16\+\_\+t \&out\+Cert\+Id, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ \&out\+Authenticator) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Certificate (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{uint16\+\_\+t \&}]{out\+Cert\+Id, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ \&}]{out\+Authenticator}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_aedd22d6376b51f350693d760946f5870}
This function parses the section of the C\+E\+R\+T\+I\+F\+I\+C\+A\+TE frame after the common frame header. It pulls header.\+length bytes from the cursor, so it is the caller\textquotesingle{}s responsibility to ensure there is enough data available.


\begin{DoxyParams}{Parameters}
{\em cursor} & The cursor to pull data from. \\
\hline
{\em header} & The frame header for the frame being parsed. \\
\hline
{\em out\+Cert\+Id} & The Cert-\/\+ID identifying the frame. \\
\hline
{\em out\+Authenticator} & Authenticator fragment in the frame, if any. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
N\+O\+\_\+\+E\+R\+R\+OR for successful parse. The connection error code to return in a C\+E\+R\+T\+I\+F\+I\+C\+A\+TE frame if failure. 
\end{DoxyReturn}


Definition at line 587 of file H\+T\+T\+P2\+Framer.\+cpp.



References k\+Frame\+Certificate\+Size\+Base.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Certificate(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
591                                                           \{
592   DCHECK\_LE(header.length, cursor.totalLength());
593   \textcolor{keywordflow}{if} (header.length < kFrameCertificateSizeBase) \{
594     \textcolor{keywordflow}{return} ErrorCode::FRAME\_SIZE\_ERROR;
595   \}
596   \textcolor{keywordflow}{if} (header.stream != 0) \{
597     \textcolor{keywordflow}{return} ErrorCode::PROTOCOL\_ERROR;
598   \}
599   outCertId = cursor.readBE<uint16\_t>();
600   \textcolor{keyword}{auto} length = header.length;
601   length -= kFrameCertificateSizeBase;
602   \textcolor{keywordflow}{if} (length > 0) \{
603     cursor.clone(outAuthenticator, length);
604   \}
605   \textcolor{keywordflow}{return} ErrorCode::NO\_ERROR;
606 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Certificate\+Request@{parse\+Certificate\+Request}}
\index{parse\+Certificate\+Request@{parse\+Certificate\+Request}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Certificate\+Request(folly\+::io\+::\+Cursor \&cursor, const Frame\+Header \&header, uint16\+\_\+t \&out\+Request\+Id, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ \&out\+Auth\+Request) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Certificate\+Request (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{uint16\+\_\+t \&}]{out\+Request\+Id, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ \&}]{out\+Auth\+Request}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_aca31ad616258da5295b3f009ace63135}
This function parses the section of the C\+E\+R\+T\+I\+F\+I\+C\+A\+T\+E\+\_\+\+R\+E\+Q\+U\+E\+ST frame after the common frame header. It pulls header.\+length bytes from the cursor, so it is the caller\textquotesingle{}s responsibility to ensure there is enough data available.


\begin{DoxyParams}{Parameters}
{\em cursor} & The cursor to pull data from. \\
\hline
{\em header} & The frame header for the frame being parsed. \\
\hline
{\em out\+Request\+Id} & The Request-\/\+ID identifying this certificate request. \\
\hline
{\em out\+Auth\+Request} & Authenticator request in the frame, if any. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
N\+O\+\_\+\+E\+R\+R\+OR for successful parse. The connection error code to return in a C\+E\+R\+T\+I\+F\+I\+C\+A\+T\+E\+\_\+\+R\+E\+Q\+U\+E\+ST frame if failure. 
\end{DoxyReturn}


Definition at line 566 of file H\+T\+T\+P2\+Framer.\+cpp.



References k\+Frame\+Certificate\+Request\+Size\+Base.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Certificate\+Request(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
570                                                         \{
571   DCHECK\_LE(header.length, cursor.totalLength());
572   \textcolor{keywordflow}{if} (header.length < kFrameCertificateRequestSizeBase) \{
573     \textcolor{keywordflow}{return} ErrorCode::FRAME\_SIZE\_ERROR;
574   \}
575   \textcolor{keywordflow}{if} (header.stream != 0) \{
576     \textcolor{keywordflow}{return} ErrorCode::PROTOCOL\_ERROR;
577   \}
578   outRequestId = cursor.readBE<uint16\_t>();
579   \textcolor{keyword}{auto} length = header.length;
580   length -= kFrameCertificateRequestSizeBase;
581   \textcolor{keywordflow}{if} (length > 0) \{
582     cursor.clone(outAuthRequest, length);
583   \}
584   \textcolor{keywordflow}{return} ErrorCode::NO\_ERROR;
585 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Continuation@{parse\+Continuation}}
\index{parse\+Continuation@{parse\+Continuation}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Continuation(folly\+::io\+::\+Cursor \&cursor, const Frame\+Header \&header, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ \&out\+Buf) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Continuation (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ \&}]{out\+Buf}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a2e0892e976c7fd5142f3f3c47c886b99}
This function parses the section of the C\+O\+N\+T\+I\+N\+U\+A\+T\+I\+ON frame after the common frame header. The caller must ensure there is header.\+length bytes available in the cursor.


\begin{DoxyParams}{Parameters}
{\em cursor} & The cursor to pull data from. \\
\hline
{\em header} & The frame header for the frame being parsed. \\
\hline
{\em out\+Buf} & The buffer to fill with header data. \\
\hline
{\em out\+Amount} & The amount to increment the stream\textquotesingle{}s window by. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
N\+O\+\_\+\+E\+R\+R\+OR for successful parse. The connection error code to return in a G\+O\+A\+W\+AY frame if failure. 
\end{DoxyReturn}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Continuation@{parse\+Continuation}}
\index{parse\+Continuation@{parse\+Continuation}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Continuation(\+Cursor \&cursor, const Frame\+Header \&header, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ \&out\+Buf) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Continuation (
\begin{DoxyParamCaption}
\item[{Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ \&}]{out\+Buf}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_acdec161020ad15e21ba209d4f52db294}


Definition at line 521 of file H\+T\+T\+P2\+Framer.\+cpp.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Continuation(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
523                                                          \{
524   DCHECK(header.type == FrameType::CONTINUATION);
525   DCHECK\_LE(header.length, cursor.totalLength());
526   \textcolor{keywordflow}{if} (header.stream == 0) \{
527     \textcolor{keywordflow}{return} ErrorCode::PROTOCOL\_ERROR;
528   \}
529   cursor.clone(outBuf, header.length);
530   \textcolor{keywordflow}{return} ErrorCode::NO\_ERROR;
531 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Data@{parse\+Data}}
\index{parse\+Data@{parse\+Data}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Data(folly\+::io\+::\+Cursor \&cursor, const Frame\+Header \&header, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ \&out\+Buf, uint16\+\_\+t \&padding) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Data (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ \&}]{out\+Buf, }
\item[{uint16\+\_\+t \&}]{padding}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_aa9c3783aefd2390f6a3a474186c76b04}
This function parses the section of the D\+A\+TA frame after the common frame header. It discards any padding and returns the body data in out\+Buf. It pulls header.\+length bytes from the cursor, so it is the caller\textquotesingle{}s responsibility to ensure there is enough data available.


\begin{DoxyParams}{Parameters}
{\em cursor} & The cursor to pull data from. \\
\hline
{\em header} & The frame header for the frame being parsed. \\
\hline
{\em out\+Buf} & The buf to fill with body data. \\
\hline
{\em padding} & The number of padding bytes in this data frame \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
N\+O\+\_\+\+E\+R\+R\+OR for successful parse. The connection error code to return in a G\+O\+A\+W\+AY frame if failure. 
\end{DoxyReturn}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Data@{parse\+Data}}
\index{parse\+Data@{parse\+Data}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Data(\+Cursor \&cursor, const Frame\+Header \&header, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ \&out\+Buf, uint16\+\_\+t \&out\+Padding) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Data (
\begin{DoxyParamCaption}
\item[{Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ \&}]{out\+Buf, }
\item[{uint16\+\_\+t \&}]{out\+Padding}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a59e751630f35a389b4c8efd537d0567e}


Definition at line 271 of file H\+T\+T\+P2\+Framer.\+cpp.



References frame\+Has\+Padding(), and R\+E\+T\+U\+R\+N\+\_\+\+I\+F\+\_\+\+E\+R\+R\+OR.



Referenced by H\+T\+T\+P2\+Framer\+Test\+::data\+Frame\+Test(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+All\+Data(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
274                                                      \{
275     DCHECK\_LE(header.length, cursor.totalLength());
276     \textcolor{keywordflow}{if} (header.stream == 0) \{
277       \textcolor{keywordflow}{return} ErrorCode::PROTOCOL\_ERROR;
278     \}
279 
280     uint8\_t padding;
281     uint32\_t lefttoparse;
282     \textcolor{keyword}{const} \textcolor{keyword}{auto} err = parsePadding(cursor, header, padding, lefttoparse);
283     RETURN_IF_ERROR(err);
284     \textcolor{comment}{// outPadding is the total number of flow-controlled pad bytes, which}
285     \textcolor{comment}{// includes the length byte, if present.}
286     outPadding = padding + ((frameHasPadding(header)) ? 1 : 0);
287     cursor.clone(outBuf, lefttoparse);
288     \textcolor{keywordflow}{return} skipPadding(cursor, padding, kStrictPadding);
289   \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Data\+Begin@{parse\+Data\+Begin}}
\index{parse\+Data\+Begin@{parse\+Data\+Begin}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Data\+Begin(folly\+::io\+::\+Cursor \&cursor, const Frame\+Header \&header, size\+\_\+t \&parsed, uint16\+\_\+t \&out\+Padding) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Data\+Begin (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{size\+\_\+t \&}]{parsed, }
\item[{uint16\+\_\+t \&}]{out\+Padding}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a9c83ea8de9528ce3d02395c8c9ec14cd}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Data\+Begin@{parse\+Data\+Begin}}
\index{parse\+Data\+Begin@{parse\+Data\+Begin}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Data\+Begin(\+Cursor \&cursor, const Frame\+Header \&header, size\+\_\+t \&, uint16\+\_\+t \&out\+Padding) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Data\+Begin (
\begin{DoxyParamCaption}
\item[{Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{size\+\_\+t \&}]{, }
\item[{uint16\+\_\+t \&}]{out\+Padding}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_ab126161a67af8d2b74cae811ae47477f}


Definition at line 291 of file H\+T\+T\+P2\+Framer.\+cpp.



References frame\+Has\+Padding(), and R\+E\+T\+U\+R\+N\+\_\+\+I\+F\+\_\+\+E\+R\+R\+OR.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Data\+Frame\+Data().


\begin{DoxyCode}
294                                                           \{
295     uint8\_t padding;
296     uint32\_t lefttoparse;
297     \textcolor{keyword}{const} \textcolor{keyword}{auto} err = http2::parsePadding(cursor, header, padding, lefttoparse);
298     RETURN_IF_ERROR(err);
299     \textcolor{comment}{// outPadding is the total number of flow-controlled pad bytes, which}
300     \textcolor{comment}{// includes the length byte, if present.}
301     outPadding = padding + ((frameHasPadding(header)) ? 1 : 0);
302     \textcolor{keywordflow}{return} ErrorCode::NO\_ERROR;
303   \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Data\+End@{parse\+Data\+End}}
\index{parse\+Data\+End@{parse\+Data\+End}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Data\+End(folly\+::io\+::\+Cursor \&cursor, const size\+\_\+t buf\+Len, const size\+\_\+t pending\+Data\+Frame\+Padding\+Bytes, size\+\_\+t \&to\+Skip) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Data\+End (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor, }
\item[{const size\+\_\+t}]{buf\+Len, }
\item[{const size\+\_\+t}]{pending\+Data\+Frame\+Padding\+Bytes, }
\item[{size\+\_\+t \&}]{to\+Skip}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_ad1c06d95091f608605ce8aa789f9896a}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Data\+End@{parse\+Data\+End}}
\index{parse\+Data\+End@{parse\+Data\+End}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Data\+End(\+Cursor \&cursor, const size\+\_\+t buf\+Len, const size\+\_\+t pending\+Data\+Frame\+Padding\+Bytes, size\+\_\+t \&to\+Skip) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Data\+End (
\begin{DoxyParamCaption}
\item[{Cursor \&}]{cursor, }
\item[{const size\+\_\+t}]{buf\+Len, }
\item[{const size\+\_\+t}]{pending\+Data\+Frame\+Padding\+Bytes, }
\item[{size\+\_\+t \&}]{to\+Skip}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_ad4a833f2b6d253c5fe8bbd4900bde678}


Definition at line 305 of file H\+T\+T\+P2\+Framer.\+cpp.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Data\+Frame\+Data().


\begin{DoxyCode}
308                                                   \{
309     toSkip = std::min(pendingDataFramePaddingBytes, bufLen);
310     \textcolor{keywordflow}{return} skipPadding(cursor, toSkip, kStrictPadding);
311 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Ex\+Headers@{parse\+Ex\+Headers}}
\index{parse\+Ex\+Headers@{parse\+Ex\+Headers}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Ex\+Headers(folly\+::io\+::\+Cursor \&cursor, const Frame\+Header \&header, H\+T\+T\+P\+Codec\+::\+Ex\+Attributes \&out\+Ex\+Attributes, folly\+::\+Optional$<$ Priority\+Update $>$ \&out\+Priority, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ \&out\+Buf) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Ex\+Headers (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Ex\+Attributes} \&}]{out\+Ex\+Attributes, }
\item[{folly\+::\+Optional$<$ {\bf Priority\+Update} $>$ \&}]{out\+Priority, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ \&}]{out\+Buf}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_afec2dfe427c31dc7716ba73e515eee17}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Ex\+Headers@{parse\+Ex\+Headers}}
\index{parse\+Ex\+Headers@{parse\+Ex\+Headers}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Ex\+Headers(\+Cursor \&cursor, const Frame\+Header \&header, H\+T\+T\+P\+Codec\+::\+Ex\+Attributes \&out\+Ex\+Attributes, folly\+::\+Optional$<$ Priority\+Update $>$ \&out\+Priority, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ \&out\+Buf) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Ex\+Headers (
\begin{DoxyParamCaption}
\item[{Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{{\bf H\+T\+T\+P\+Codec\+::\+Ex\+Attributes} \&}]{out\+Ex\+Attributes, }
\item[{folly\+::\+Optional$<$ {\bf Priority\+Update} $>$ \&}]{out\+Priority, }
\item[{std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ \&}]{out\+Buf}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a73139bfcf1237acc0be6e134b5fa92f5}


Definition at line 340 of file H\+T\+T\+P2\+Framer.\+cpp.



References k\+Frame\+Priority\+Size, k\+Frame\+Stream\+I\+D\+Size, P\+R\+I\+O\+R\+I\+TY, R\+E\+T\+U\+R\+N\+\_\+\+I\+F\+\_\+\+E\+R\+R\+OR, and U\+N\+I\+D\+I\+R\+E\+C\+T\+I\+O\+N\+AL.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Ex\+Headers(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
344                                                       \{
345   DCHECK\_LE(header.length, cursor.totalLength());
346   \textcolor{keywordflow}{if} (header.stream == 0) \{
347     \textcolor{keywordflow}{return} ErrorCode::PROTOCOL\_ERROR;
348   \}
349 
350   uint8\_t padding;
351   uint32\_t lefttoparse;
352   \textcolor{keyword}{auto} err = parsePadding(cursor, header, padding, lefttoparse);
353   RETURN_IF_ERROR(err);
354 
355   \textcolor{comment}{// the regular HEADERS frame starts from here}
356   \textcolor{keywordflow}{if} (header.flags & PRIORITY) \{
357     \textcolor{keywordflow}{if} (lefttoparse < kFramePrioritySize) \{
358       \textcolor{keywordflow}{return} ErrorCode::FRAME\_SIZE\_ERROR;
359     \}
360     outPriority = parsePriorityCommon(cursor);
361     lefttoparse -= kFramePrioritySize;
362   \} \textcolor{keywordflow}{else} \{
363     outPriority = folly::none;
364   \}
365   outExAttributes.unidirectional = header.flags & UNIDIRECTIONAL;
366 
367   \textcolor{keywordflow}{if} (lefttoparse < kFrameStreamIDSize) \{
368     \textcolor{keywordflow}{return} ErrorCode::FRAME\_SIZE\_ERROR;
369   \}
370   outExAttributes.controlStream = parseUint31(cursor);
371   lefttoparse -= kFrameStreamIDSize;
372   \textcolor{keywordflow}{if} (!(outExAttributes.controlStream & 0x1)) \{
373     \textcolor{comment}{// control stream ID should be odd because it is initiated by client}
374     \textcolor{keywordflow}{return} ErrorCode::PROTOCOL\_ERROR;
375   \}
376 
377   cursor.clone(outBuf, lefttoparse);
378   \textcolor{keywordflow}{return} skipPadding(cursor, padding, kStrictPadding);
379 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Frame\+Header@{parse\+Frame\+Header}}
\index{parse\+Frame\+Header@{parse\+Frame\+Header}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Frame\+Header(folly\+::io\+::\+Cursor \&cursor, Frame\+Header \&header) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Frame\+Header (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor, }
\item[{{\bf Frame\+Header} \&}]{header}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_ad787442a3a977cdb316b42a91992ba86}
This function parses the common H\+T\+T\+P/2 frame header. This function pulls k\+Frame\+Header\+Size bytes from the cursor, so the caller must check that that amount is available.


\begin{DoxyParams}{Parameters}
{\em cursor} & The cursor to pull data from. \\
\hline
{\em header} & The frame header struct to populate. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Nothing if success. The connection error code if failure. 
\end{DoxyReturn}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Frame\+Header@{parse\+Frame\+Header}}
\index{parse\+Frame\+Header@{parse\+Frame\+Header}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Frame\+Header(\+Cursor \&cursor, Frame\+Header \&header) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Frame\+Header (
\begin{DoxyParamCaption}
\item[{Cursor \&}]{cursor, }
\item[{{\bf Frame\+Header} \&}]{header}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_aca005c94391a0efef128eaba26f6590f}


Definition at line 257 of file H\+T\+T\+P2\+Framer.\+cpp.



References k\+Frame\+Header\+Size.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::on\+Ingress(), H\+T\+T\+P2\+Framer\+Test\+::parse(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
257                                                                              \{
258     FOLLY\_SCOPED\_TRACE\_SECTION(\textcolor{stringliteral}{"HTTP2Framer - parseFrameHeader"});
259     DCHECK\_LE(kFrameHeaderSize, cursor.totalLength());
260 
261     \textcolor{comment}{// MUST ignore the 2 bits before the length}
262     uint32\_t lengthAndType = cursor.readBE<uint32\_t>();
263     header.length = kLengthMask & (lengthAndType >> 8);
264     uint8\_t type = lengthAndType & 0xff;
265     header.type = FrameType(type);
266     header.flags = cursor.readBE<uint8\_t>();
267     header.stream = parseUint31(cursor);
268     \textcolor{keywordflow}{return} ErrorCode::NO\_ERROR;
269   \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Goaway@{parse\+Goaway}}
\index{parse\+Goaway@{parse\+Goaway}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Goaway(folly\+::io\+::\+Cursor \&cursor, const Frame\+Header \&header, uint32\+\_\+t \&out\+Last\+Stream\+I\+D, Error\+Code \&out\+Code, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ \&out\+Debug\+Data) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Goaway (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{uint32\+\_\+t \&}]{out\+Last\+Stream\+ID, }
\item[{{\bf Error\+Code} \&}]{out\+Code, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ \&}]{out\+Debug\+Data}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a0180d254b6f9c5805b1a63c80e4d1fc4}
This function parses the section of the G\+O\+A\+W\+AY frame after the common frame header. It pulls header.\+length bytes from the cursor, so it is the caller\textquotesingle{}s responsibility to ensure there is enough data available.


\begin{DoxyParams}{Parameters}
{\em cursor} & The cursor to pull data from. \\
\hline
{\em header} & The frame header for the frame being parsed. \\
\hline
{\em out\+Last\+Stream\+ID} & The last stream id accepted by the remote. \\
\hline
{\em out\+Code} & The error code received in the frame. \\
\hline
{\em out\+Debug\+Data} & Additional debug-\/data in the frame, if any \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
N\+O\+\_\+\+E\+R\+R\+OR for successful parse. The connection error code to return in a G\+O\+A\+W\+AY frame if failure. 
\end{DoxyReturn}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Goaway@{parse\+Goaway}}
\index{parse\+Goaway@{parse\+Goaway}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Goaway(\+Cursor \&cursor, const Frame\+Header \&header, uint32\+\_\+t \&out\+Last\+Stream\+I\+D, Error\+Code \&out\+Code, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ \&out\+Debug\+Data) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Goaway (
\begin{DoxyParamCaption}
\item[{Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{uint32\+\_\+t \&}]{out\+Last\+Stream\+ID, }
\item[{{\bf Error\+Code} \&}]{out\+Code, }
\item[{std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ \&}]{out\+Debug\+Data}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_ab0a1a83f882a03440b553ea0f395b9d7}


Definition at line 485 of file H\+T\+T\+P2\+Framer.\+cpp.



References k\+Frame\+Goaway\+Size, and R\+E\+T\+U\+R\+N\+\_\+\+I\+F\+\_\+\+E\+R\+R\+OR.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Goaway(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
489                                                          \{
490   DCHECK\_LE(header.length, cursor.totalLength());
491   \textcolor{keywordflow}{if} (header.length < kFrameGoawaySize) \{
492     \textcolor{keywordflow}{return} ErrorCode::FRAME\_SIZE\_ERROR;
493   \}
494   \textcolor{keywordflow}{if} (header.stream != 0) \{
495     \textcolor{keywordflow}{return} ErrorCode::PROTOCOL\_ERROR;
496   \}
497   outLastStreamID = parseUint31(cursor);
498   \textcolor{keyword}{auto} err = parseErrorCode(cursor, outCode);
499   RETURN_IF_ERROR(err);
500   \textcolor{keyword}{auto} length = header.length;
501   length -= kFrameGoawaySize;
502   \textcolor{keywordflow}{if} (length > 0) \{
503     cursor.clone(outDebugData, length);
504   \}
505   \textcolor{keywordflow}{return} ErrorCode::NO\_ERROR;
506 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Headers@{parse\+Headers}}
\index{parse\+Headers@{parse\+Headers}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Headers(folly\+::io\+::\+Cursor \&cursor, const Frame\+Header \&header, folly\+::\+Optional$<$ Priority\+Update $>$ \&out\+Priority, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ \&out\+Buf) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Headers (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{folly\+::\+Optional$<$ {\bf Priority\+Update} $>$ \&}]{out\+Priority, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ \&}]{out\+Buf}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_aaec5ebbf78ce9b192acc0c2a4d4b3ea2}
This function parses the section of the H\+E\+A\+D\+E\+RS frame after the common frame header. It discards any padding and returns the header data in out\+Buf. It pulls header.\+length bytes from the cursor, so it is the caller\textquotesingle{}s responsibility to ensure there is enough data available.


\begin{DoxyParams}{Parameters}
{\em cursor} & The cursor to pull data from. \\
\hline
{\em header} & The frame header for the frame being parsed. \\
\hline
{\em out\+Priority} & If P\+R\+I\+O\+R\+I\+TY flag is set, this will be filled with the priority information from this frame. \\
\hline
{\em out\+Buf} & The buf to fill with header data. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
N\+O\+\_\+\+E\+R\+R\+OR for successful parse. The connection error code to return in a G\+O\+A\+W\+AY frame if failure. 
\end{DoxyReturn}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Headers@{parse\+Headers}}
\index{parse\+Headers@{parse\+Headers}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Headers(\+Cursor \&cursor, const Frame\+Header \&header, folly\+::\+Optional$<$ Priority\+Update $>$ \&out\+Priority, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ \&out\+Buf) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Headers (
\begin{DoxyParamCaption}
\item[{Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{folly\+::\+Optional$<$ {\bf Priority\+Update} $>$ \&}]{out\+Priority, }
\item[{std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ \&}]{out\+Buf}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a5985e5bfea7b9f60af1311367a26d1db}


Definition at line 314 of file H\+T\+T\+P2\+Framer.\+cpp.



References k\+Frame\+Priority\+Size, P\+R\+I\+O\+R\+I\+TY, and R\+E\+T\+U\+R\+N\+\_\+\+I\+F\+\_\+\+E\+R\+R\+OR.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Headers(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
317                                                     \{
318   DCHECK\_LE(header.length, cursor.totalLength());
319   \textcolor{keywordflow}{if} (header.stream == 0) \{
320     \textcolor{keywordflow}{return} ErrorCode::PROTOCOL\_ERROR;
321   \}
322   uint8\_t padding;
323   uint32\_t lefttoparse;
324   \textcolor{keyword}{auto} err = parsePadding(cursor, header, padding, lefttoparse);
325   RETURN_IF_ERROR(err);
326   \textcolor{keywordflow}{if} (header.flags & PRIORITY) \{
327     \textcolor{keywordflow}{if} (lefttoparse < kFramePrioritySize) \{
328       \textcolor{keywordflow}{return} ErrorCode::FRAME\_SIZE\_ERROR;
329     \}
330     outPriority = parsePriorityCommon(cursor);
331     lefttoparse -= kFramePrioritySize;
332   \} \textcolor{keywordflow}{else} \{
333     outPriority = folly::none;
334   \}
335   cursor.clone(outBuf, lefttoparse);
336   \textcolor{keywordflow}{return} skipPadding(cursor, padding, kStrictPadding);
337 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Ping@{parse\+Ping}}
\index{parse\+Ping@{parse\+Ping}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Ping(folly\+::io\+::\+Cursor \&cursor, const Frame\+Header \&header, uint64\+\_\+t \&out\+Data) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Ping (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{uint64\+\_\+t \&}]{out\+Data}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a2d42235c0ecd0df3dac30b7d0139d86b}
This function parses the section of the P\+I\+NG frame after the common frame header. It pulls header.\+length bytes from the cursor, so it is the caller\textquotesingle{}s responsibility to ensure there is enough data available.


\begin{DoxyParams}{Parameters}
{\em cursor} & The cursor to pull data from. \\
\hline
{\em header} & The frame header for the frame being parsed. \\
\hline
{\em out\+Data} & The opaque data from the ping frame \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
N\+O\+\_\+\+E\+R\+R\+OR for successful parse. The connection error code to return in a G\+O\+A\+W\+AY frame if failure. 
\end{DoxyReturn}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Ping@{parse\+Ping}}
\index{parse\+Ping@{parse\+Ping}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Ping(\+Cursor \&cursor, const Frame\+Header \&header, uint64\+\_\+t \&out\+Opaque\+Data) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Ping (
\begin{DoxyParamCaption}
\item[{Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{uint64\+\_\+t \&}]{out\+Opaque\+Data}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a6d774c71b6bf5a3d7b24c0b0ce33510d}


Definition at line 468 of file H\+T\+T\+P2\+Framer.\+cpp.



References k\+Frame\+Ping\+Size.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Ping(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
470                                             \{
471   DCHECK\_LE(header.length, cursor.totalLength());
472 
473   \textcolor{keywordflow}{if} (header.length != kFramePingSize) \{
474     \textcolor{keywordflow}{return} ErrorCode::FRAME\_SIZE\_ERROR;
475   \}
476   \textcolor{keywordflow}{if} (header.stream != 0) \{
477     \textcolor{keywordflow}{return} ErrorCode::PROTOCOL\_ERROR;
478   \}
479 
480   cursor.pull(&outOpaqueData, \textcolor{keyword}{sizeof}(outOpaqueData));
481   \textcolor{keywordflow}{return} ErrorCode::NO\_ERROR;
482 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Priority@{parse\+Priority}}
\index{parse\+Priority@{parse\+Priority}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Priority(folly\+::io\+::\+Cursor \&cursor, const Frame\+Header \&header, Priority\+Update \&out\+Priority) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Priority (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{{\bf Priority\+Update} \&}]{out\+Priority}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a16d962526a5f0a80528ce19282813931}
This function parses the section of the P\+R\+I\+O\+R\+I\+TY frame after the common frame header. It pulls header.\+length bytes from the cursor, so it is the caller\textquotesingle{}s responsibility to ensure there is enough data available.


\begin{DoxyParams}{Parameters}
{\em cursor} & The cursor to pull data from. \\
\hline
{\em header} & The frame header for the frame being parsed. \\
\hline
{\em out\+Priority} & On success, filled with the priority information from this frame. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
N\+O\+\_\+\+E\+R\+R\+OR for successful parse. The connection error code to return in a G\+O\+A\+W\+AY frame if failure. 
\end{DoxyReturn}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Priority@{parse\+Priority}}
\index{parse\+Priority@{parse\+Priority}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Priority(\+Cursor \&cursor, const Frame\+Header \&header, Priority\+Update \&out\+Priority) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Priority (
\begin{DoxyParamCaption}
\item[{Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{{\bf Priority\+Update} \&}]{out\+Priority}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a0af6dc35aca8352da90958108460f2d7}


Definition at line 382 of file H\+T\+T\+P2\+Framer.\+cpp.



References k\+Frame\+Priority\+Size.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Priority(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
384                                                     \{
385   DCHECK\_LE(header.length, cursor.totalLength());
386   \textcolor{keywordflow}{if} (header.length != kFramePrioritySize) \{
387     \textcolor{keywordflow}{return} ErrorCode::FRAME\_SIZE\_ERROR;
388   \}
389   \textcolor{keywordflow}{if} (header.stream == 0) \{
390     \textcolor{keywordflow}{return} ErrorCode::PROTOCOL\_ERROR;
391   \}
392   outPriority = parsePriorityCommon(cursor);
393   \textcolor{keywordflow}{return} ErrorCode::NO\_ERROR;
394 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Push\+Promise@{parse\+Push\+Promise}}
\index{parse\+Push\+Promise@{parse\+Push\+Promise}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Push\+Promise(folly\+::io\+::\+Cursor \&cursor, const Frame\+Header \&header, uint32\+\_\+t \&out\+Promised\+Stream, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ \&out\+Buf) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Push\+Promise (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{uint32\+\_\+t \&}]{out\+Promised\+Stream, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ \&}]{out\+Buf}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a88939474284b4c5dd3e4f227d074283a}
This function parses the section of the P\+U\+S\+H\+\_\+\+P\+R\+O\+M\+I\+SE frame after the common frame header. It pulls header.\+length bytes from the cursor, so it is the caller\textquotesingle{}s responsibility to ensure there is enough data available.


\begin{DoxyParams}{Parameters}
{\em cursor} & The cursor to pull data from. \\
\hline
{\em header} & The frame header for the frame being parsed. \\
\hline
{\em out\+Promised\+Stream} & The id of the stream promised by the remote. \\
\hline
{\em out\+Buf} & The buffer to fill with header data. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
N\+O\+\_\+\+E\+R\+R\+OR for successful parse. The connection error code to return in a G\+O\+A\+W\+AY frame if failure. 
\end{DoxyReturn}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Push\+Promise@{parse\+Push\+Promise}}
\index{parse\+Push\+Promise@{parse\+Push\+Promise}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Push\+Promise(\+Cursor \&cursor, const Frame\+Header \&header, uint32\+\_\+t \&out\+Promised\+Stream, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ \&out\+Buf) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Push\+Promise (
\begin{DoxyParamCaption}
\item[{Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{uint32\+\_\+t \&}]{out\+Promised\+Stream, }
\item[{std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ \&}]{out\+Buf}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a6a54af4937306841fff139f75cbe7a0e}


Definition at line 437 of file H\+T\+T\+P2\+Framer.\+cpp.



References k\+Frame\+Push\+Promise\+Size, and R\+E\+T\+U\+R\+N\+\_\+\+I\+F\+\_\+\+E\+R\+R\+OR.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Push\+Promise(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
440                                                         \{
441   DCHECK\_LE(header.length, cursor.totalLength());
442   \textcolor{keywordflow}{if} (header.stream == 0) \{
443     \textcolor{keywordflow}{return} ErrorCode::PROTOCOL\_ERROR;
444   \}
445 
446   uint8\_t padding;
447   uint32\_t lefttoparse;
448   \textcolor{keyword}{auto} err = parsePadding(cursor, header, padding, lefttoparse);
449   RETURN_IF_ERROR(err);
450   \textcolor{keywordflow}{if} (lefttoparse < kFramePushPromiseSize) \{
451     \textcolor{keywordflow}{return} ErrorCode::FRAME\_SIZE\_ERROR;
452   \}
453   lefttoparse -= kFramePushPromiseSize;
454   outPromisedStream = parseUint31(cursor);
455   \textcolor{keywordflow}{if} (outPromisedStream == 0 ||
456       outPromisedStream & 0x1) \{
457     \textcolor{comment}{// client MUST reserve an even stream id greater than 0}
458     \textcolor{keywordflow}{return} ErrorCode::PROTOCOL\_ERROR;
459   \}
460   \textcolor{keywordflow}{if} (lefttoparse < padding) \{
461     \textcolor{keywordflow}{return} ErrorCode::PROTOCOL\_ERROR;
462   \}
463   cursor.clone(outBuf, lefttoparse);
464   \textcolor{keywordflow}{return} skipPadding(cursor, padding, kStrictPadding);
465 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Rst\+Stream@{parse\+Rst\+Stream}}
\index{parse\+Rst\+Stream@{parse\+Rst\+Stream}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Rst\+Stream(folly\+::io\+::\+Cursor \&cursor, const Frame\+Header \&header, Error\+Code \&out\+Code) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Rst\+Stream (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{{\bf Error\+Code} \&}]{out\+Code}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a90fc6172eb2c80a9fd67ebb622b51c58}
This function parses the section of the R\+S\+T\+\_\+\+S\+T\+R\+E\+AM frame after the common frame header. It pulls header.\+length bytes from the cursor, so it is the caller\textquotesingle{}s responsibility to ensure there is enough data available.


\begin{DoxyParams}{Parameters}
{\em cursor} & The cursor to pull data from. \\
\hline
{\em header} & The frame header for the frame being parsed. \\
\hline
{\em out\+Code} & The error code received in the frame. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
N\+O\+\_\+\+E\+R\+R\+OR for successful parse. The connection error code to return in a G\+O\+A\+W\+AY frame if failure. 
\end{DoxyReturn}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Rst\+Stream@{parse\+Rst\+Stream}}
\index{parse\+Rst\+Stream@{parse\+Rst\+Stream}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Rst\+Stream(\+Cursor \&cursor, const Frame\+Header \&header, Error\+Code \&out\+Code) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Rst\+Stream (
\begin{DoxyParamCaption}
\item[{Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{{\bf Error\+Code} \&}]{out\+Code}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_ace8b46dfa602a02274d693dc6cb88ba1}


Definition at line 397 of file H\+T\+T\+P2\+Framer.\+cpp.



References k\+Frame\+Rst\+Stream\+Size.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Rst\+Stream(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
399                                             \{
400   DCHECK\_LE(header.length, cursor.totalLength());
401   \textcolor{keywordflow}{if} (header.length != kFrameRstStreamSize) \{
402     \textcolor{keywordflow}{return} ErrorCode::FRAME\_SIZE\_ERROR;
403   \}
404   \textcolor{keywordflow}{if} (header.stream == 0) \{
405     \textcolor{keywordflow}{return} ErrorCode::PROTOCOL\_ERROR;
406   \}
407   \textcolor{keywordflow}{return} parseErrorCode(cursor, outCode);
408 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Settings@{parse\+Settings}}
\index{parse\+Settings@{parse\+Settings}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Settings(folly\+::io\+::\+Cursor \&cursor, const Frame\+Header \&header, std\+::deque$<$ Setting\+Pair $>$ \&settings) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Settings (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{std\+::deque$<$ {\bf Setting\+Pair} $>$ \&}]{settings}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a1969f697213b94879ee08d9534f2c695}
This function parses the section of the S\+E\+T\+T\+I\+N\+GS frame after the common frame header. It pulls header.\+length bytes from the cursor, so it is the caller\textquotesingle{}s responsibility to ensure there is enough data available.


\begin{DoxyParams}{Parameters}
{\em cursor} & The cursor to pull data from. \\
\hline
{\em header} & The frame header for the frame being parsed. \\
\hline
{\em settings} & The settings received in this frame. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
N\+O\+\_\+\+E\+R\+R\+OR for successful parse. The connection error code to return in a G\+O\+A\+W\+AY frame if failure. 
\end{DoxyReturn}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Settings@{parse\+Settings}}
\index{parse\+Settings@{parse\+Settings}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Settings(\+Cursor \&cursor, const Frame\+Header \&header, std\+::deque$<$ Setting\+Pair $>$ \&settings) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Settings (
\begin{DoxyParamCaption}
\item[{Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{std\+::deque$<$ {\bf Setting\+Pair} $>$ \&}]{settings}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a6e25a85f73267497cb2849b395dd4480}


Definition at line 411 of file H\+T\+T\+P2\+Framer.\+cpp.



References A\+CK, and settings.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::on\+Ingress\+Upgrade\+Message(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Settings(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
413                                                         \{
414   DCHECK\_LE(header.length, cursor.totalLength());
415   \textcolor{keywordflow}{if} (header.stream != 0) \{
416     \textcolor{keywordflow}{return} ErrorCode::PROTOCOL\_ERROR;
417   \}
418   \textcolor{keywordflow}{if} (header.flags & ACK) \{
419     \textcolor{keywordflow}{if} (header.length != 0) \{
420       \textcolor{keywordflow}{return} ErrorCode::FRAME\_SIZE\_ERROR;
421     \}
422     \textcolor{keywordflow}{return} ErrorCode::NO\_ERROR;
423   \}
424 
425   \textcolor{keywordflow}{if} (header.length % 6 != 0) \{
426     \textcolor{keywordflow}{return} ErrorCode::FRAME\_SIZE\_ERROR;
427   \}
428   \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} length = header.length; length > 0; length -= 6) \{
429     uint16\_t \textcolor{keywordtype}{id} = cursor.readBE<uint16\_t>();
430     uint32\_t val = cursor.readBE<uint32\_t>();
431     settings.push\_back(std::make\_pair(SettingsId(\textcolor{keywordtype}{id}), val));
432   \}
433   \textcolor{keywordflow}{return} ErrorCode::NO\_ERROR;
434 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Window\+Update@{parse\+Window\+Update}}
\index{parse\+Window\+Update@{parse\+Window\+Update}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Window\+Update(folly\+::io\+::\+Cursor \&cursor, const Frame\+Header \&header, uint32\+\_\+t \&out\+Amount) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Window\+Update (
\begin{DoxyParamCaption}
\item[{folly\+::io\+::\+Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{uint32\+\_\+t \&}]{out\+Amount}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_af33ae396b0ca9e1683e39406cf0da3bf}
This function parses the section of the W\+I\+N\+D\+O\+W\+\_\+\+U\+P\+D\+A\+TE frame after the common frame header. The caller must ensure there is header.\+length bytes available in the cursor.


\begin{DoxyParams}{Parameters}
{\em cursor} & The cursor to pull data from. \\
\hline
{\em header} & The frame header for the frame being parsed. \\
\hline
{\em out\+Amount} & The amount to increment the stream\textquotesingle{}s window by. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
N\+O\+\_\+\+E\+R\+R\+OR for successful parse. The connection error code to return in a G\+O\+A\+W\+AY frame if failure. 
\end{DoxyReturn}
\index{proxygen\+::http2@{proxygen\+::http2}!parse\+Window\+Update@{parse\+Window\+Update}}
\index{parse\+Window\+Update@{parse\+Window\+Update}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{parse\+Window\+Update(\+Cursor \&cursor, const Frame\+Header \&header, uint32\+\_\+t \&out\+Amount) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Error\+Code} proxygen\+::http2\+::parse\+Window\+Update (
\begin{DoxyParamCaption}
\item[{Cursor \&}]{cursor, }
\item[{const {\bf Frame\+Header} \&}]{header, }
\item[{uint32\+\_\+t \&}]{out\+Amount}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a6f44e79f624bb945b88f2892ccf917f7}


Definition at line 509 of file H\+T\+T\+P2\+Framer.\+cpp.



References k\+Frame\+Window\+Update\+Size.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Window\+Update(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
511                                                 \{
512   DCHECK\_LE(header.length, cursor.totalLength());
513   \textcolor{keywordflow}{if} (header.length != kFrameWindowUpdateSize) \{
514     \textcolor{keywordflow}{return} ErrorCode::FRAME\_SIZE\_ERROR;
515   \}
516   outAmount = parseUint31(cursor);
517   \textcolor{keywordflow}{return} ErrorCode::NO\_ERROR;
518 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Alt\+Svc@{write\+Alt\+Svc}}
\index{write\+Alt\+Svc@{write\+Alt\+Svc}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Alt\+Svc(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint32\+\_\+t stream, uint32\+\_\+t max\+Age, uint16\+\_\+t port, folly\+::\+String\+Piece protocol, folly\+::\+String\+Piece host, folly\+::\+String\+Piece origin) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Alt\+Svc (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{uint32\+\_\+t}]{stream, }
\item[{uint32\+\_\+t}]{max\+Age, }
\item[{uint16\+\_\+t}]{port, }
\item[{folly\+::\+String\+Piece}]{protocol, }
\item[{folly\+::\+String\+Piece}]{host, }
\item[{folly\+::\+String\+Piece}]{origin}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_ae386380be3b0abfc99c284b0847e9f8a}
Generate an entire A\+L\+T\+S\+VC frame, including the common frame header.


\begin{DoxyParams}{Parameters}
{\em write\+Buf} & The output queue to write to. It may grow or add underlying buffers inside this function. \\
\hline
{\em stream} & The stream to do Alt-\/\+Svc on. May be zero. \\
\hline
{\em max\+Age} & The max age field. \\
\hline
{\em port} & The port the alternative service is on. \\
\hline
{\em protocol} & The alternative service protocol string. \\
\hline
{\em host} & The alternative service host name. \\
\hline
{\em origin} & The origin the alternative service is applicable to. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes written to write\+Buf. 
\end{DoxyReturn}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Alt\+Svc@{write\+Alt\+Svc}}
\index{write\+Alt\+Svc@{write\+Alt\+Svc}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Alt\+Svc(\+I\+O\+Buf\+Queue \&queue, uint32\+\_\+t stream, uint32\+\_\+t max\+Age, uint16\+\_\+t port, String\+Piece protocol, String\+Piece host, String\+Piece origin) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Alt\+Svc (
\begin{DoxyParamCaption}
\item[{I\+O\+Buf\+Queue \&}]{queue, }
\item[{uint32\+\_\+t}]{stream, }
\item[{uint32\+\_\+t}]{max\+Age, }
\item[{uint16\+\_\+t}]{port, }
\item[{String\+Piece}]{protocol, }
\item[{String\+Piece}]{host, }
\item[{String\+Piece}]{origin}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_ac62ca5d32ca699b53001801317c6bc2f}


Definition at line 891 of file H\+T\+T\+P2\+Framer.\+cpp.



References k\+Frame\+Alt\+Svc\+Size\+Base, and k\+Frame\+Header\+Size.



Referenced by T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
897                                          \{
898   \textcolor{keyword}{const} \textcolor{keyword}{auto} protoLen = protocol.size();
899   \textcolor{keyword}{const} \textcolor{keyword}{auto} hostLen = host.size();
900   \textcolor{keyword}{const} \textcolor{keyword}{auto} originLen = origin.size();
901   \textcolor{keyword}{const} \textcolor{keyword}{auto} frameLen = protoLen + hostLen + originLen + kFrameAltSvcSizeBase;
902 
903   writeFrameHeader(queue, frameLen, FrameType::ALTSVC, 0, stream, kNoPadding,
904                    folly::none, \textcolor{keyword}{nullptr});
905   QueueAppender appender(&queue, frameLen);
906   appender.writeBE<uint32\_t>(maxAge);
907   appender.writeBE<uint16\_t>(port);
908   appender.writeBE<uint8\_t>(protoLen);
909   appender.push(reinterpret\_cast<const uint8\_t*>(protocol.data()), protoLen);
910   appender.writeBE<uint8\_t>(hostLen);
911   appender.push(reinterpret\_cast<const uint8\_t*>(host.data()), hostLen);
912   appender.push(reinterpret\_cast<const uint8\_t*>(origin.data()), originLen);
913   \textcolor{keywordflow}{return} kFrameHeaderSize + frameLen;
914 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Certificate@{write\+Certificate}}
\index{write\+Certificate@{write\+Certificate}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Certificate(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint16\+\_\+t cert\+Id, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ authenticator, bool to\+Be\+Continued)}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Certificate (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{uint16\+\_\+t}]{cert\+Id, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{authenticator, }
\item[{bool}]{to\+Be\+Continued}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1http2_ad3f57a008853e71d693bd7799d68d6d6}
Generate an entire C\+E\+R\+T\+I\+F\+I\+C\+A\+TE frame, including the common frame header.


\begin{DoxyParams}{Parameters}
{\em write\+Buf} & The output queue to write to. It may grow or add underlying buffers inside this function. \\
\hline
{\em cert\+Id} & The opaque Cert-\/\+ID of this frame which is used to correlate subsequent certificate-\/related frames with this certificate. \\
\hline
{\em authenticator} & The encoded authenticator fragment. \\
\hline
{\em to\+Be\+Continued} & Indicates whether there is additional authenticator fragment. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes written to write\+Buf. 
\end{DoxyReturn}


Definition at line 937 of file H\+T\+T\+P2\+Framer.\+cpp.



References k\+Frame\+Certificate\+Size\+Base, k\+Frame\+Header\+Size, and T\+O\+\_\+\+B\+E\+\_\+\+C\+O\+N\+T\+I\+N\+U\+ED.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Certificate(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
940                                             \{
941   uint8\_t flags = 0;
942   \textcolor{keywordflow}{if} (toBeContinued) \{
943     flags |= TO_BE_CONTINUED;
944   \}
945   \textcolor{keyword}{const} \textcolor{keyword}{auto} dataLen =
946       authenticator
947           ? kFrameCertificateSizeBase + authenticator->computeChainDataLength()
948           : kFrameCertificateSizeBase;
949   \textcolor{comment}{// The CERTIFICATE\_REQUEST frame must be sent on stream 0.}
950   \textcolor{keyword}{const} \textcolor{keyword}{auto} frameLen = writeFrameHeader(writeBuf,
951                                          dataLen,
952                                          FrameType::CERTIFICATE,
953                                          flags,
954                                          0,
955                                          kNoPadding,
956                                          folly::none,
957                                          \textcolor{keyword}{nullptr});
958   QueueAppender appender(&writeBuf, frameLen);
959   appender.writeBE<uint16\_t>(certId);
960   writeBuf.append(std::move(authenticator));
961   \textcolor{keywordflow}{return} kFrameHeaderSize + frameLen;
962 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Certificate\+Request@{write\+Certificate\+Request}}
\index{write\+Certificate\+Request@{write\+Certificate\+Request}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Certificate\+Request(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint16\+\_\+t request\+Id, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ auth\+Request)}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Certificate\+Request (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{uint16\+\_\+t}]{request\+Id, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{auth\+Request}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1http2_a06560f7fa4be11902f327d2a89a13bfa}
Generate an entire C\+E\+R\+T\+I\+F\+I\+C\+A\+T\+E\+\_\+\+R\+E\+Q\+U\+E\+ST frame, including the common frame header.


\begin{DoxyParams}{Parameters}
{\em write\+Buf} & The output queue to write to. It may grow or add underlying buffers inside this function. \\
\hline
{\em request\+Id} & The opaque Request-\/\+ID of this used to correlate subsequent certificate-\/related frames with this request. \\
\hline
{\em auth\+Request} & The encoded authenticator request. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes written to write\+Buf. 
\end{DoxyReturn}


Definition at line 916 of file H\+T\+T\+P2\+Framer.\+cpp.



References k\+Frame\+Certificate\+Request\+Size\+Base, and k\+Frame\+Header\+Size.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Certificate\+Request(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
918                                                                       \{
919   \textcolor{keyword}{const} \textcolor{keyword}{auto} dataLen = authRequest ? kFrameCertificateRequestSizeBase +
920                                          authRequest->computeChainDataLength()
921                                    : kFrameCertificateRequestSizeBase;
922   \textcolor{comment}{// The CERTIFICATE\_REQUEST frame must be sent on stream 0.}
923   \textcolor{keyword}{const} \textcolor{keyword}{auto} frameLen = writeFrameHeader(writeBuf,
924                                          dataLen,
925                                          FrameType::CERTIFICATE\_REQUEST,
926                                          0,
927                                          0,
928                                          kNoPadding,
929                                          folly::none,
930                                          \textcolor{keyword}{nullptr});
931   QueueAppender appender(&writeBuf, frameLen);
932   appender.writeBE<uint16\_t>(requestId);
933   writeBuf.append(std::move(authRequest));
934   \textcolor{keywordflow}{return} kFrameHeaderSize + frameLen;
935 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Continuation@{write\+Continuation}}
\index{write\+Continuation@{write\+Continuation}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Continuation(folly\+::\+I\+O\+Buf\+Queue \&queue, uint32\+\_\+t stream, bool end\+Headers, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ headers) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Continuation (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{queue, }
\item[{uint32\+\_\+t}]{stream, }
\item[{bool}]{end\+Headers, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{headers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_aeb57c0820f06d9ddeda48a190409f4ae}
Generate an entire C\+O\+N\+T\+I\+N\+U\+A\+T\+I\+ON frame, including the common frame header. The combined length of the data buffer and the padding M\+U\+ST N\+OT exceed 2$^\wedge$14 -\/ 3, which is k\+Max\+Frame\+Payload\+Length minus the two bytes to encode the length of the padding.


\begin{DoxyParams}{Parameters}
{\em write\+Buf} & The output queue to write to. It may grow or add underlying buffers inside this function. \\
\hline
{\em stream} & The stream identifier of the D\+A\+TA frame. \\
\hline
{\em end\+Headers} & True iff more C\+O\+N\+T\+I\+N\+U\+A\+T\+I\+ON frames will follow. \\
\hline
{\em headers} & The encoded headers data to write out. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes written to write\+Buf. 
\end{DoxyReturn}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Continuation@{write\+Continuation}}
\index{write\+Continuation@{write\+Continuation}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Continuation(\+I\+O\+Buf\+Queue \&queue, uint32\+\_\+t stream, bool end\+Headers, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ headers) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Continuation (
\begin{DoxyParamCaption}
\item[{I\+O\+Buf\+Queue \&}]{queue, }
\item[{uint32\+\_\+t}]{stream, }
\item[{bool}]{end\+Headers, }
\item[{std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$}]{headers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_afc8f14a3880352baa4ef50869bac548d}


Definition at line 873 of file H\+T\+T\+P2\+Framer.\+cpp.



References E\+N\+D\+\_\+\+H\+E\+A\+D\+E\+RS, and k\+Frame\+Header\+Size.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Continuation(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
876                                                          \{
877   DCHECK\_NE(0, stream);
878   \textcolor{keyword}{const} \textcolor{keyword}{auto} dataLen = headers->computeChainDataLength();
879   \textcolor{keyword}{const} \textcolor{keyword}{auto} frameLen = writeFrameHeader(queue,
880                                          dataLen,
881                                          FrameType::CONTINUATION,
882                                          endHeaders ? END_HEADERS : 0,
883                                          stream,
884                                          kNoPadding,
885                                          folly::none,
886                                          std::move(headers));
887   \textcolor{keywordflow}{return} kFrameHeaderSize + frameLen;
888 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Data@{write\+Data}}
\index{write\+Data@{write\+Data}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Data(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ data, uint32\+\_\+t stream, folly\+::\+Optional$<$ uint8\+\_\+t $>$ padding, bool end\+Stream, bool reuse\+I\+O\+Buf\+Headroom) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Data (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{data, }
\item[{uint32\+\_\+t}]{stream, }
\item[{folly\+::\+Optional$<$ uint8\+\_\+t $>$}]{padding, }
\item[{bool}]{end\+Stream, }
\item[{bool}]{reuse\+I\+O\+Buf\+Headroom}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a732aafdf50578c168c04f5c2befa0d74}
Generate an entire D\+A\+TA frame, including the common frame header. The combined length of the data buffer, the padding, and the padding length M\+U\+ST N\+OT exceed 2$^\wedge$14 -\/ 1, which is k\+Max\+Frame\+Payload\+Length.


\begin{DoxyParams}{Parameters}
{\em write\+Buf} & The output queue to write to. It may grow or add underlying buffers inside this function. \\
\hline
{\em data} & The body data to write out, can be nullptr for 0 length \\
\hline
{\em stream} & The stream identifier of the D\+A\+TA frame. \\
\hline
{\em padding} & If not k\+No\+Padding, adds 1 byte pad len and  pad bytes \\
\hline
{\em end\+Stream} & True iff this frame ends the stream. \\
\hline
{\em reuse\+I\+O\+Buf\+Headroom} & If H\+T\+T\+P2\+Framer should reuse headroom in data if headroom is enough for frame header \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes written to write\+Buf. 
\end{DoxyReturn}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Data@{write\+Data}}
\index{write\+Data@{write\+Data}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Data(\+I\+O\+Buf\+Queue \&queue, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ data, uint32\+\_\+t stream, folly\+::\+Optional$<$ uint8\+\_\+t $>$ padding, bool end\+Stream, bool reuse\+I\+O\+Buf\+Headroom) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Data (
\begin{DoxyParamCaption}
\item[{I\+O\+Buf\+Queue \&}]{queue, }
\item[{std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$}]{data, }
\item[{uint32\+\_\+t}]{stream, }
\item[{folly\+::\+Optional$<$ uint8\+\_\+t $>$}]{padding, }
\item[{bool}]{end\+Stream, }
\item[{bool}]{reuse\+I\+O\+Buf\+Headroom}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_aa14ee5896f4e0aece957a06c902584d3}


Definition at line 611 of file H\+T\+T\+P2\+Framer.\+cpp.



References E\+N\+D\+\_\+\+S\+T\+R\+E\+AM, and k\+Frame\+Header\+Size.



Referenced by H\+T\+T\+P2\+Framer\+Test\+::data\+Frame\+Test(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Body(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+E\+O\+M(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
616                                             \{
617   DCHECK\_NE(0, stream);
618   uint8\_t flags = 0;
619   \textcolor{keywordflow}{if} (endStream) \{
620     flags |= END_STREAM;
621   \}
622   \textcolor{keyword}{const} uint64\_t dataLen = data ? data->computeChainDataLength() : 0;
623   \textcolor{comment}{// Caller must not exceed peer setting for MAX\_FRAME\_SIZE}
624   \textcolor{comment}{// TODO: look into using headroom from data to hold the frame header}
625   \textcolor{keyword}{const} \textcolor{keyword}{auto} frameLen = writeFrameHeader(queue,
626                                          dataLen,
627                                          FrameType::DATA,
628                                          flags,
629                                          stream,
630                                          padding,
631                                          folly::none,
632                                          std::move(data),
633                                          reuseIOBufHeadroom);
634   writePadding(queue, padding);
635   \textcolor{keywordflow}{return} kFrameHeaderSize + frameLen;
636 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Ex\+Headers@{write\+Ex\+Headers}}
\index{write\+Ex\+Headers@{write\+Ex\+Headers}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Ex\+Headers(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ headers, uint32\+\_\+t stream, const H\+T\+T\+P\+Codec\+::\+Ex\+Attributes \&ex\+Attributes, const folly\+::\+Optional$<$ Priority\+Update $>$ \&priority, const folly\+::\+Optional$<$ uint8\+\_\+t $>$ \&padding, bool end\+Stream, bool end\+Headers) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Ex\+Headers (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{headers, }
\item[{uint32\+\_\+t}]{stream, }
\item[{const {\bf H\+T\+T\+P\+Codec\+::\+Ex\+Attributes} \&}]{ex\+Attributes, }
\item[{const folly\+::\+Optional$<$ {\bf Priority\+Update} $>$ \&}]{priority, }
\item[{const folly\+::\+Optional$<$ uint8\+\_\+t $>$ \&}]{padding, }
\item[{bool}]{end\+Stream, }
\item[{bool}]{end\+Headers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a84065fefe5389a6389b8ce2b6191df8e}
Generate an experimental Ex\+H\+E\+A\+D\+E\+RS frame, including the common frame header. The combined length of the data buffer and the padding and priority fields M\+U\+ST N\+OT exceed 2$^\wedge$14 -\/ 1, which is k\+Max\+Frame\+Payload\+Length.


\begin{DoxyParams}{Parameters}
{\em write\+Buf} & The output queue to write to. It may grow or add underlying buffers inside this function. \\
\hline
{\em headers} & The encoded headers data to write out. \\
\hline
{\em stream} & The stream identifier of the Ex\+H\+E\+A\+D\+E\+RS frame. \\
\hline
{\em ex\+Attributes} & Attributes specific to Ex\+H\+E\+A\+D\+E\+RS frame. \\
\hline
{\em priority} & If present, the priority depedency information to update the stream with. \\
\hline
{\em padding} & If not k\+No\+Padding, adds 1 byte pad len and  pad bytes \\
\hline
{\em end\+Stream} & True iff this frame ends the stream. \\
\hline
{\em end\+Headers} & True iff no C\+O\+N\+T\+I\+N\+U\+A\+T\+I\+ON frames will follow this frame. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes written to write\+Buf. 
\end{DoxyReturn}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Ex\+Headers@{write\+Ex\+Headers}}
\index{write\+Ex\+Headers@{write\+Ex\+Headers}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Ex\+Headers(\+I\+O\+Buf\+Queue \&queue, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ headers, uint32\+\_\+t stream, const H\+T\+T\+P\+Codec\+::\+Ex\+Attributes \&ex\+Attributes, const folly\+::\+Optional$<$ Priority\+Update $>$ \&priority, const folly\+::\+Optional$<$ uint8\+\_\+t $>$ \&padding, bool end\+Stream, bool end\+Headers) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Ex\+Headers (
\begin{DoxyParamCaption}
\item[{I\+O\+Buf\+Queue \&}]{queue, }
\item[{std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$}]{headers, }
\item[{uint32\+\_\+t}]{stream, }
\item[{const {\bf H\+T\+T\+P\+Codec\+::\+Ex\+Attributes} \&}]{ex\+Attributes, }
\item[{const folly\+::\+Optional$<$ {\bf Priority\+Update} $>$ \&}]{priority, }
\item[{const folly\+::\+Optional$<$ uint8\+\_\+t $>$ \&}]{padding, }
\item[{bool}]{end\+Stream, }
\item[{bool}]{end\+Headers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_affe06c5d213993f9dadc3d19e52e85b9}


Definition at line 672 of file H\+T\+T\+P2\+Framer.\+cpp.



References E\+N\+D\+\_\+\+H\+E\+A\+D\+E\+RS, E\+N\+D\+\_\+\+S\+T\+R\+E\+AM, k\+Frame\+Header\+Size, k\+Frame\+Stream\+I\+D\+Size, P\+R\+I\+O\+R\+I\+TY, and U\+N\+I\+D\+I\+R\+E\+C\+T\+I\+O\+N\+AL.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Header\+Impl(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
679                                          \{
680   DCHECK\_NE(0, stream);
681   DCHECK\_NE(0, exAttributes.controlStream);
682   DCHECK\_EQ(0, ~kUint31Mask & stream);
683   DCHECK\_EQ(0, ~kUint31Mask & exAttributes.controlStream);
684   DCHECK(0x1 & exAttributes.controlStream) <<
685     \textcolor{stringliteral}{"controlStream should be initiated by client"};
686 
687   \textcolor{keyword}{const} \textcolor{keyword}{auto} dataLen = (headers) ? headers->computeChainDataLength() : 0;
688   uint32\_t flags = 0;
689   \textcolor{keywordflow}{if} (priority) \{
690     flags |= PRIORITY;
691   \}
692   \textcolor{keywordflow}{if} (endStream) \{
693     flags |= END_STREAM;
694   \}
695   \textcolor{keywordflow}{if} (endHeaders) \{
696     flags |= END_HEADERS;
697   \}
698   \textcolor{keywordflow}{if} (exAttributes.unidirectional) \{
699     flags |= UNIDIRECTIONAL;
700   \}
701 
702   \textcolor{keyword}{const} \textcolor{keyword}{auto} frameLen = writeFrameHeader(queue,
703                                          dataLen + kFrameStreamIDSize,
704                                          FrameType::EX\_HEADERS,
705                                          flags,
706                                          stream,
707                                          padding,
708                                          priority,
709                                          \textcolor{keyword}{nullptr});
710   QueueAppender appender(&queue, frameLen);
711   appender.writeBE<uint32\_t>(exAttributes.controlStream);
712   queue.append(std::move(headers));
713   writePadding(queue, padding);
714   \textcolor{keywordflow}{return} kFrameHeaderSize + frameLen;
715 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Goaway@{write\+Goaway}}
\index{write\+Goaway@{write\+Goaway}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Goaway(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint32\+\_\+t last\+Stream\+I\+D, Error\+Code error\+Code, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ debug\+Data=nullptr) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Goaway (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{uint32\+\_\+t}]{last\+Stream\+ID, }
\item[{{\bf Error\+Code}}]{error\+Code, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{debug\+Data = {\ttfamily {\bf nullptr}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_ab68b3e3440180958af6d26101e291990}
Generate an entire G\+O\+A\+W\+AY frame, including the common frame header. We do not implement the optional opaque data.


\begin{DoxyParams}{Parameters}
{\em write\+Buf} & The output queue to write to. It may grow or add underlying buffers inside this function. \\
\hline
{\em last\+Stream\+ID} & The identifier of the last stream accepted. \\
\hline
{\em error\+Code} & The error code returned in the frame. \\
\hline
{\em debug\+Data} & Optional debug information to add to the frame \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes written to write\+Buf. 
\end{DoxyReturn}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Goaway@{write\+Goaway}}
\index{write\+Goaway@{write\+Goaway}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Goaway(\+I\+O\+Buf\+Queue \&queue, uint32\+\_\+t last\+Stream\+I\+D, Error\+Code error\+Code, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ debug\+Data) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Goaway (
\begin{DoxyParamCaption}
\item[{I\+O\+Buf\+Queue \&}]{queue, }
\item[{uint32\+\_\+t}]{last\+Stream\+ID, }
\item[{{\bf Error\+Code}}]{error\+Code, }
\item[{std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$}]{debug\+Data}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a0efe6deef4fa11f6e6501c41c480d448}


Definition at line 832 of file H\+T\+T\+P2\+Framer.\+cpp.



References proxygen\+::spdy\+::\+G\+O\+A\+W\+AY, k\+Frame\+Goaway\+Size, and k\+Frame\+Header\+Size.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Goaway(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
835                                                      \{
836   uint32\_t debugLen = debugData ? debugData->computeChainDataLength() : 0;
837   DCHECK\_EQ(0, ~kLengthMask & debugLen);
838   \textcolor{keyword}{const} \textcolor{keyword}{auto} frameLen = writeFrameHeader(queue,
839                                          kFrameGoawaySize + debugLen,
840                                          FrameType::GOAWAY,
841                                          0,
842                                          0,
843                                          kNoPadding,
844                                          folly::none,
845                                          \textcolor{keyword}{nullptr});
846   QueueAppender appender(&queue, frameLen);
847   appender.writeBE<uint32\_t>(lastStreamID);
848   appender.writeBE<uint32\_t>(\textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(errorCode));
849   queue.append(std::move(debugData));
850   \textcolor{keywordflow}{return} kFrameHeaderSize + frameLen;
851 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Headers@{write\+Headers}}
\index{write\+Headers@{write\+Headers}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Headers(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ headers, uint32\+\_\+t stream, folly\+::\+Optional$<$ Priority\+Update $>$ priority, folly\+::\+Optional$<$ uint8\+\_\+t $>$ padding, bool end\+Stream, bool end\+Headers) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Headers (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{headers, }
\item[{uint32\+\_\+t}]{stream, }
\item[{folly\+::\+Optional$<$ {\bf Priority\+Update} $>$}]{priority, }
\item[{folly\+::\+Optional$<$ uint8\+\_\+t $>$}]{padding, }
\item[{bool}]{end\+Stream, }
\item[{bool}]{end\+Headers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a6cbbd1fe26a121bf76e7f58b49d4e2a7}
Generate an entire H\+E\+A\+D\+E\+RS frame, including the common frame header. The combined length of the data buffer and the padding and priority fields M\+U\+ST N\+OT exceed 2$^\wedge$14 -\/ 1, which is k\+Max\+Frame\+Payload\+Length.


\begin{DoxyParams}{Parameters}
{\em write\+Buf} & The output queue to write to. It may grow or add underlying buffers inside this function. \\
\hline
{\em headers} & The encoded headers data to write out. \\
\hline
{\em stream} & The stream identifier of the H\+E\+A\+D\+E\+RS frame. \\
\hline
{\em priority} & If present, the priority depedency information to update the stream with. \\
\hline
{\em padding} & If not k\+No\+Padding, adds 1 byte pad len and  pad bytes \\
\hline
{\em end\+Stream} & True iff this frame ends the stream. \\
\hline
{\em end\+Headers} & True iff no C\+O\+N\+T\+I\+N\+U\+A\+T\+I\+ON frames will follow this frame. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes written to write\+Buf. 
\end{DoxyReturn}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Headers@{write\+Headers}}
\index{write\+Headers@{write\+Headers}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Headers(\+I\+O\+Buf\+Queue \&queue, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ headers, uint32\+\_\+t stream, folly\+::\+Optional$<$ Priority\+Update $>$ priority, folly\+::\+Optional$<$ uint8\+\_\+t $>$ padding, bool end\+Stream, bool end\+Headers) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Headers (
\begin{DoxyParamCaption}
\item[{I\+O\+Buf\+Queue \&}]{queue, }
\item[{std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$}]{headers, }
\item[{uint32\+\_\+t}]{stream, }
\item[{folly\+::\+Optional$<$ {\bf Priority\+Update} $>$}]{priority, }
\item[{folly\+::\+Optional$<$ uint8\+\_\+t $>$}]{padding, }
\item[{bool}]{end\+Stream, }
\item[{bool}]{end\+Headers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a29b5dd2c8a8e429a8a059e48ee30b008}


Definition at line 639 of file H\+T\+T\+P2\+Framer.\+cpp.



References E\+N\+D\+\_\+\+H\+E\+A\+D\+E\+RS, E\+N\+D\+\_\+\+S\+T\+R\+E\+AM, proxygen\+::spdy\+::\+H\+E\+A\+D\+E\+RS, k\+Frame\+Header\+Size, and P\+R\+I\+O\+R\+I\+TY.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Header\+Impl(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Trailers(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
645                                        \{
646   DCHECK\_NE(0, stream);
647   \textcolor{keyword}{const} \textcolor{keyword}{auto} dataLen = (headers) ? headers->computeChainDataLength() : 0;
648   uint32\_t flags = 0;
649   \textcolor{keywordflow}{if} (priority) \{
650     flags |= PRIORITY;
651   \}
652   \textcolor{keywordflow}{if} (endStream) \{
653     flags |= END_STREAM;
654   \}
655   \textcolor{keywordflow}{if} (endHeaders) \{
656     flags |= END_HEADERS;
657   \}
658   \textcolor{comment}{// padding flags handled directly inside writeFrameHeader()}
659   \textcolor{keyword}{const} \textcolor{keyword}{auto} frameLen = writeFrameHeader(queue,
660                                          dataLen,
661                                          FrameType::HEADERS,
662                                          flags,
663                                          stream,
664                                          padding,
665                                          priority,
666                                          std::move(headers));
667   writePadding(queue, padding);
668   \textcolor{keywordflow}{return} kFrameHeaderSize + frameLen;
669 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Ping@{write\+Ping}}
\index{write\+Ping@{write\+Ping}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Ping(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint64\+\_\+t data, bool ack) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Ping (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{uint64\+\_\+t}]{data, }
\item[{bool}]{ack}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_aa72fa179f3b99131532ce4f531956f90}
Generate an entire P\+I\+NG frame, including the common frame header.


\begin{DoxyParams}{Parameters}
{\em write\+Buf} & The output queue to write to. It may grow or add underlying buffers inside this function. \\
\hline
{\em data} & The opaque data to include. \\
\hline
{\em ack} & True iff this is a ping response. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes written to write\+Buf. 
\end{DoxyReturn}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Ping@{write\+Ping}}
\index{write\+Ping@{write\+Ping}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Ping(\+I\+O\+Buf\+Queue \&queue, uint64\+\_\+t opaque\+Data, bool ack) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Ping (
\begin{DoxyParamCaption}
\item[{I\+O\+Buf\+Queue \&}]{queue, }
\item[{uint64\+\_\+t}]{opaque\+Data, }
\item[{bool}]{ack}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_abf9ce633c1618b205b744c82f29e62ba}


Definition at line 816 of file H\+T\+T\+P2\+Framer.\+cpp.



References A\+CK, k\+Frame\+Header\+Size, k\+Frame\+Ping\+Size, and proxygen\+::spdy\+::\+P\+I\+NG.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Ping\+Reply(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Ping\+Request(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
818                              \{
819   \textcolor{keyword}{const} \textcolor{keyword}{auto} frameLen = writeFrameHeader(queue,
820                                          kFramePingSize,
821                                          FrameType::PING,
822                                          ack ? ACK : 0,
823                                          0,
824                                          kNoPadding,
825                                          folly::none,
826                                          \textcolor{keyword}{nullptr});
827   queue.append(&opaqueData, \textcolor{keyword}{sizeof}(opaqueData));
828   \textcolor{keywordflow}{return} kFrameHeaderSize + frameLen;
829 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Priority@{write\+Priority}}
\index{write\+Priority@{write\+Priority}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Priority(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint32\+\_\+t stream, Priority\+Update priority) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Priority (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{uint32\+\_\+t}]{stream, }
\item[{{\bf Priority\+Update}}]{priority}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a363b9727c6dff71261761c487bfaefbc}
Generate an entire P\+R\+I\+O\+R\+I\+TY frame, including the common frame header.


\begin{DoxyParams}{Parameters}
{\em write\+Buf} & The output queue to write to. It may grow or add underlying buffers inside this function. \\
\hline
{\em stream} & The stream identifier of the D\+A\+TA frame. \\
\hline
{\em priority} & The priority depedency information to update the stream with. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes written to write\+Buf. 
\end{DoxyReturn}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Priority@{write\+Priority}}
\index{write\+Priority@{write\+Priority}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Priority(\+I\+O\+Buf\+Queue \&queue, uint32\+\_\+t stream, Priority\+Update priority) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Priority (
\begin{DoxyParamCaption}
\item[{I\+O\+Buf\+Queue \&}]{queue, }
\item[{uint32\+\_\+t}]{stream, }
\item[{{\bf Priority\+Update}}]{priority}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a4efd4c2bf18d722813fd7c94e1b1b700}


Definition at line 718 of file H\+T\+T\+P2\+Framer.\+cpp.



References k\+Frame\+Header\+Size, k\+Frame\+Priority\+Size, and P\+R\+I\+O\+R\+I\+TY.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Priority(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
720                                                 \{
721   DCHECK\_NE(0, stream);
722   \textcolor{keyword}{const} \textcolor{keyword}{auto} frameLen = writeFrameHeader(queue,
723                                          kFramePrioritySize,
724                                          FrameType::PRIORITY,
725                                          0,
726                                          stream,
727                                          kNoPadding,
728                                          priority,
729                                          \textcolor{keyword}{nullptr});
730   \textcolor{keywordflow}{return} kFrameHeaderSize + frameLen;
731 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Push\+Promise@{write\+Push\+Promise}}
\index{write\+Push\+Promise@{write\+Push\+Promise}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Push\+Promise(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint32\+\_\+t associated\+Stream, uint32\+\_\+t promised\+Stream, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ headers, folly\+::\+Optional$<$ uint8\+\_\+t $>$ padding, bool end\+Headers) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Push\+Promise (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{uint32\+\_\+t}]{associated\+Stream, }
\item[{uint32\+\_\+t}]{promised\+Stream, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{headers, }
\item[{folly\+::\+Optional$<$ uint8\+\_\+t $>$}]{padding, }
\item[{bool}]{end\+Headers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_ac093bed076886a98cf4eac179f7ac047}
Writes an entire P\+U\+S\+H\+\_\+\+P\+R\+O\+M\+I\+SE frame, including the common frame header.


\begin{DoxyParams}{Parameters}
{\em write\+Buf} & The output queue to write to. It may grow or add underlying buffers inside this function. \\
\hline
{\em associated\+Stream} & The identifier of the stream the promised stream is associated with. \\
\hline
{\em promised\+Stream} & The identifier of the promised stream. \\
\hline
{\em headers} & The encoded headers to include in the push promise frame. \\
\hline
{\em padding} & If not k\+No\+Padding, adds 1 byte pad len and  pad bytes \\
\hline
{\em end\+Headers} & True iff no C\+O\+N\+T\+I\+N\+U\+A\+T\+I\+ON frames will follow this frame. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes written to write\+Buf/ 
\end{DoxyReturn}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Push\+Promise@{write\+Push\+Promise}}
\index{write\+Push\+Promise@{write\+Push\+Promise}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Push\+Promise(\+I\+O\+Buf\+Queue \&queue, uint32\+\_\+t associated\+Stream, uint32\+\_\+t promised\+Stream, std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$ headers, folly\+::\+Optional$<$ uint8\+\_\+t $>$ padding, bool end\+Headers) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Push\+Promise (
\begin{DoxyParamCaption}
\item[{I\+O\+Buf\+Queue \&}]{queue, }
\item[{uint32\+\_\+t}]{associated\+Stream, }
\item[{uint32\+\_\+t}]{promised\+Stream, }
\item[{std\+::unique\+\_\+ptr$<$ I\+O\+Buf $>$}]{headers, }
\item[{folly\+::\+Optional$<$ uint8\+\_\+t $>$}]{padding, }
\item[{bool}]{end\+Headers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_ae2a15fa0032e67720130ae44f32ea8de}


Definition at line 787 of file H\+T\+T\+P2\+Framer.\+cpp.



References E\+N\+D\+\_\+\+H\+E\+A\+D\+E\+RS, k\+Frame\+Header\+Size, and k\+Frame\+Push\+Promise\+Size.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Header\+Impl(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
792                                            \{
793   DCHECK\_NE(0, promisedStream);
794   DCHECK\_NE(0, associatedStream);
795   DCHECK\_EQ(0, 0x1 & promisedStream);
796   DCHECK\_EQ(1, 0x1 & associatedStream);
797   DCHECK\_EQ(0, ~kUint31Mask & promisedStream);
798 
799   \textcolor{keyword}{const} \textcolor{keyword}{auto} dataLen = headers->computeChainDataLength();
800   \textcolor{keyword}{const} \textcolor{keyword}{auto} frameLen = writeFrameHeader(queue,
801                                          dataLen + kFramePushPromiseSize,
802                                          FrameType::PUSH\_PROMISE,
803                                          endHeaders ? END_HEADERS : 0,
804                                          associatedStream,
805                                          padding,
806                                          folly::none,
807                                          \textcolor{keyword}{nullptr});
808   QueueAppender appender(&queue, frameLen);
809   appender.writeBE<uint32\_t>(promisedStream);
810   queue.append(std::move(headers));
811   writePadding(queue, padding);
812   \textcolor{keywordflow}{return} kFrameHeaderSize + frameLen;
813 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Rst\+Stream@{write\+Rst\+Stream}}
\index{write\+Rst\+Stream@{write\+Rst\+Stream}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Rst\+Stream(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint32\+\_\+t stream, Error\+Code error\+Code) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Rst\+Stream (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{uint32\+\_\+t}]{stream, }
\item[{{\bf Error\+Code}}]{error\+Code}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a0186adc04a02224e6ce4d89eb7f6bdda}
Generate an entire R\+S\+T\+\_\+\+S\+T\+R\+E\+AM frame, including the common frame header.


\begin{DoxyParams}{Parameters}
{\em write\+Buf} & The output queue to write to. It may grow or add underlying buffers inside this function. \\
\hline
{\em stream} & The identifier of the stream to reset. \\
\hline
{\em error\+Code} & The error code returned in the frame. \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes written to write\+Buf. 
\end{DoxyReturn}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Rst\+Stream@{write\+Rst\+Stream}}
\index{write\+Rst\+Stream@{write\+Rst\+Stream}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Rst\+Stream(\+I\+O\+Buf\+Queue \&queue, uint32\+\_\+t stream, Error\+Code error\+Code) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Rst\+Stream (
\begin{DoxyParamCaption}
\item[{I\+O\+Buf\+Queue \&}]{queue, }
\item[{uint32\+\_\+t}]{stream, }
\item[{{\bf Error\+Code}}]{error\+Code}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a6c55af05653809b17f6bc099c323f16b}


Definition at line 734 of file H\+T\+T\+P2\+Framer.\+cpp.



References k\+Frame\+Header\+Size, k\+Frame\+Rst\+Stream\+Size, and proxygen\+::spdy\+::\+R\+S\+T\+\_\+\+S\+T\+R\+E\+AM.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Rst\+Stream(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
736                                              \{
737   DCHECK\_NE(0, stream);
738   \textcolor{keyword}{const} \textcolor{keyword}{auto} frameLen = writeFrameHeader(queue,
739                                          kFrameRstStreamSize,
740                                          FrameType::RST_STREAM,
741                                          0,
742                                          stream,
743                                          kNoPadding,
744                                          folly::none,
745                                          \textcolor{keyword}{nullptr});
746   QueueAppender appender(&queue, frameLen);
747   appender.writeBE<uint32\_t>(\textcolor{keyword}{static\_cast<}uint32\_t\textcolor{keyword}{>}(errorCode));
748   \textcolor{keywordflow}{return} kFrameHeaderSize + frameLen;
749 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Settings@{write\+Settings}}
\index{write\+Settings@{write\+Settings}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Settings(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, const std\+::deque$<$ Setting\+Pair $>$ \&settings)}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Settings (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{const std\+::deque$<$ {\bf Setting\+Pair} $>$ \&}]{settings}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1http2_aba8c9d75f7c00526644cacb5c87ed97c}
Generate an entire S\+E\+T\+T\+I\+N\+GS frame, including the common frame header.


\begin{DoxyParams}{Parameters}
{\em write\+Buf} & The output queue to write to. It may grow or add underlying buffers inside this function. \\
\hline
{\em settings} & The settings to send \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes written to write\+Buf. 
\end{DoxyReturn}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Settings@{write\+Settings}}
\index{write\+Settings@{write\+Settings}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Settings(\+I\+O\+Buf\+Queue \&queue, const std\+::deque$<$ Setting\+Pair $>$ \&settings)}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Settings (
\begin{DoxyParamCaption}
\item[{I\+O\+Buf\+Queue \&}]{queue, }
\item[{const std\+::deque$<$ {\bf Setting\+Pair} $>$ \&}]{settings}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1http2_aae16751d9101cdc1046ff5837d5737ea}


Definition at line 752 of file H\+T\+T\+P2\+Framer.\+cpp.



References k\+Frame\+Header\+Size, and proxygen\+::spdy\+::\+S\+E\+T\+T\+I\+N\+GS.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Settings(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
753                                                      \{
754   \textcolor{keyword}{const} \textcolor{keyword}{auto} settingsSize = settings.size() * 6;
755   \textcolor{keyword}{const} \textcolor{keyword}{auto} frameLen = writeFrameHeader(queue,
756                                          settingsSize,
757                                          FrameType::SETTINGS,
758                                          0,
759                                          0,
760                                          kNoPadding,
761                                          folly::none,
762                                          \textcolor{keyword}{nullptr});
763   QueueAppender appender(&queue, settingsSize);
764   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& setting: settings) \{
765     DCHECK\_LE(static\_cast<uint32\_t>(setting.first),
766               std::numeric\_limits<uint16\_t>::max());
767     appender.writeBE<uint16\_t>(\textcolor{keyword}{static\_cast<}uint16\_t\textcolor{keyword}{>}(setting.first));
768     appender.writeBE<uint32\_t>(setting.second);
769   \}
770   \textcolor{keywordflow}{return} kFrameHeaderSize + frameLen;
771 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Settings\+Ack@{write\+Settings\+Ack}}
\index{write\+Settings\+Ack@{write\+Settings\+Ack}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Settings\+Ack(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf)}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Settings\+Ack (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1http2_ac66743bb0bd5a37974447381afdc9a86}
Writes an entire empty S\+E\+T\+T\+I\+N\+GS frame, including the common frame header. No settings can be transmitted with this frame. \index{proxygen\+::http2@{proxygen\+::http2}!write\+Settings\+Ack@{write\+Settings\+Ack}}
\index{write\+Settings\+Ack@{write\+Settings\+Ack}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Settings\+Ack(\+I\+O\+Buf\+Queue \&queue)}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Settings\+Ack (
\begin{DoxyParamCaption}
\item[{I\+O\+Buf\+Queue \&}]{queue}
\end{DoxyParamCaption}
)}\label{namespaceproxygen_1_1http2_a8fc55657f9a8856cfc9186cb1e9a35cd}


Definition at line 774 of file H\+T\+T\+P2\+Framer.\+cpp.



References A\+CK, k\+Frame\+Header\+Size, and proxygen\+::spdy\+::\+S\+E\+T\+T\+I\+N\+GS.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Settings\+Ack(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
774                                     \{
775   writeFrameHeader(queue,
776                    0,
777                    FrameType::SETTINGS,
778                    ACK,
779                    0,
780                    kNoPadding,
781                    folly::none,
782                    \textcolor{keyword}{nullptr});
783   \textcolor{keywordflow}{return} kFrameHeaderSize;
784 \}
\end{DoxyCode}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Window\+Update@{write\+Window\+Update}}
\index{write\+Window\+Update@{write\+Window\+Update}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Window\+Update(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, uint32\+\_\+t stream, uint32\+\_\+t amount) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Window\+Update (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{uint32\+\_\+t}]{stream, }
\item[{uint32\+\_\+t}]{amount}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_ad26a948b7eb84e350a0f9b4655c93e62}
Generate an entire W\+I\+N\+D\+O\+W\+\_\+\+U\+P\+D\+A\+TE frame, including the common frame header. $\vert$amount$\vert$ M\+U\+ST be between 1 to 2$^\wedge$31 -\/ 1 inclusive


\begin{DoxyParams}{Parameters}
{\em write\+Buf} & The output queue to write to. It may grow or add underlying buffers inside this function. \\
\hline
{\em stream} & The stream to send a W\+I\+N\+D\+O\+W\+\_\+\+U\+P\+D\+A\+TE on \\
\hline
{\em amount} & The number of bytes to AK \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
The number of bytes written to write\+Buf. 
\end{DoxyReturn}
\index{proxygen\+::http2@{proxygen\+::http2}!write\+Window\+Update@{write\+Window\+Update}}
\index{write\+Window\+Update@{write\+Window\+Update}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{write\+Window\+Update(\+I\+O\+Buf\+Queue \&queue, uint32\+\_\+t stream, uint32\+\_\+t amount) noexcept}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::http2\+::write\+Window\+Update (
\begin{DoxyParamCaption}
\item[{I\+O\+Buf\+Queue \&}]{queue, }
\item[{uint32\+\_\+t}]{stream, }
\item[{uint32\+\_\+t}]{amount}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [noexcept]}}\label{namespaceproxygen_1_1http2_a77dc563c237dc7e46a734dd167db2602}


Definition at line 854 of file H\+T\+T\+P2\+Framer.\+cpp.



References k\+Frame\+Header\+Size, k\+Frame\+Window\+Update\+Size, and proxygen\+::spdy\+::\+W\+I\+N\+D\+O\+W\+\_\+\+U\+P\+D\+A\+TE.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Window\+Update(), and T\+E\+S\+T\+\_\+\+F().


\begin{DoxyCode}
856                                             \{
857   \textcolor{keyword}{const} \textcolor{keyword}{auto} frameLen = writeFrameHeader(queue,
858                                          kFrameWindowUpdateSize,
859                                          FrameType::WINDOW_UPDATE,
860                                          0,
861                                          stream,
862                                          kNoPadding,
863                                          folly::none,
864                                          \textcolor{keyword}{nullptr});
865   DCHECK\_EQ(0, ~kUint31Mask & amount);
866   DCHECK\_LT(0, amount);
867   QueueAppender appender(&queue, kFrameWindowUpdateSize);
868   appender.writeBE<uint32\_t>(amount);
869   \textcolor{keywordflow}{return} kFrameHeaderSize + frameLen;
870 \}
\end{DoxyCode}


\subsection{Variable Documentation}
\index{proxygen\+::http2@{proxygen\+::http2}!Default\+Priority@{Default\+Priority}}
\index{Default\+Priority@{Default\+Priority}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{Default\+Priority}]{\setlength{\rightskip}{0pt plus 5cm}{\bf F\+B\+\_\+\+E\+X\+P\+O\+RT} const {\bf Priority\+Update} proxygen\+::http2\+::\+Default\+Priority \{0, false, 15\}}\label{namespaceproxygen_1_1http2_a9d6bc6481640269a7770347be1f72fd5}


Definition at line 21 of file H\+T\+T\+P2\+Framer.\+cpp.



Referenced by proxygen\+::\+H\+T\+T\+P\+Session\+::get\+Message\+Priority(), and proxygen\+::\+H\+T\+T\+P\+Session\+::session\+Byte\+Offset().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Connection\+Preface@{k\+Connection\+Preface}}
\index{k\+Connection\+Preface@{k\+Connection\+Preface}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Connection\+Preface}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string proxygen\+::http2\+::k\+Connection\+Preface}\label{namespaceproxygen_1_1http2_a950486b7ccda737f4a916a30c1c299d8}


Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Connection\+Preface(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::on\+Ingress(), and T\+E\+S\+T\+\_\+\+F().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Frame\+Alt\+Svc\+Size\+Base@{k\+Frame\+Alt\+Svc\+Size\+Base}}
\index{k\+Frame\+Alt\+Svc\+Size\+Base@{k\+Frame\+Alt\+Svc\+Size\+Base}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Frame\+Alt\+Svc\+Size\+Base}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t proxygen\+::http2\+::k\+Frame\+Alt\+Svc\+Size\+Base = 8}\label{namespaceproxygen_1_1http2_a43158adcefe2deb25c1db58c580279b1}


Definition at line 43 of file H\+T\+T\+P2\+Constants.\+cpp.



Referenced by parse\+Alt\+Svc(), and write\+Alt\+Svc().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Frame\+Certificate\+Request\+Size\+Base@{k\+Frame\+Certificate\+Request\+Size\+Base}}
\index{k\+Frame\+Certificate\+Request\+Size\+Base@{k\+Frame\+Certificate\+Request\+Size\+Base}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Frame\+Certificate\+Request\+Size\+Base}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t proxygen\+::http2\+::k\+Frame\+Certificate\+Request\+Size\+Base = 2}\label{namespaceproxygen_1_1http2_a445a53ca16efb379796a885aff7a678e}


Definition at line 40 of file H\+T\+T\+P2\+Constants.\+cpp.



Referenced by parse\+Certificate\+Request(), T\+E\+S\+T\+\_\+\+F(), and write\+Certificate\+Request().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Frame\+Certificate\+Size\+Base@{k\+Frame\+Certificate\+Size\+Base}}
\index{k\+Frame\+Certificate\+Size\+Base@{k\+Frame\+Certificate\+Size\+Base}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Frame\+Certificate\+Size\+Base}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t proxygen\+::http2\+::k\+Frame\+Certificate\+Size\+Base = 2}\label{namespaceproxygen_1_1http2_ae20b9d98ecf437daa4f96a3bfc55d56c}


Definition at line 41 of file H\+T\+T\+P2\+Constants.\+cpp.



Referenced by parse\+Certificate(), T\+E\+S\+T\+\_\+\+F(), and write\+Certificate().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Frame\+Goaway\+Size@{k\+Frame\+Goaway\+Size}}
\index{k\+Frame\+Goaway\+Size@{k\+Frame\+Goaway\+Size}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Frame\+Goaway\+Size}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t proxygen\+::http2\+::k\+Frame\+Goaway\+Size = 8}\label{namespaceproxygen_1_1http2_a2eb10ab5068320693be754992ae5574e}


Definition at line 38 of file H\+T\+T\+P2\+Constants.\+cpp.



Referenced by parse\+Goaway(), T\+E\+S\+T\+\_\+\+F(), and write\+Goaway().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Frame\+Headers\+Base\+Max\+Size@{k\+Frame\+Headers\+Base\+Max\+Size}}
\index{k\+Frame\+Headers\+Base\+Max\+Size@{k\+Frame\+Headers\+Base\+Max\+Size}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Frame\+Headers\+Base\+Max\+Size}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t proxygen\+::http2\+::k\+Frame\+Headers\+Base\+Max\+Size = {\bf k\+Frame\+Priority\+Size} + 1}\label{namespaceproxygen_1_1http2_ab055361fdbbd871775c4d544f5d10ccf}


Definition at line 32 of file H\+T\+T\+P2\+Constants.\+cpp.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::encode\+Headers().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Frame\+Header\+Size@{k\+Frame\+Header\+Size}}
\index{k\+Frame\+Header\+Size@{k\+Frame\+Header\+Size}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Frame\+Header\+Size}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t proxygen\+::http2\+::k\+Frame\+Header\+Size = 9}\label{namespaceproxygen_1_1http2_a4035b862543c0ca5ff3709556c49086d}


Definition at line 30 of file H\+T\+T\+P2\+Constants.\+cpp.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::encode\+Headers(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::on\+Ingress(), parse\+Frame\+Header(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::request\+Upgrade(), T\+E\+S\+T\+\_\+\+F(), write\+Alt\+Svc(), write\+Certificate(), write\+Certificate\+Request(), write\+Continuation(), write\+Data(), write\+Ex\+Headers(), write\+Frame\+Header\+Manual(), write\+Goaway(), write\+Headers(), write\+Ping(), write\+Priority(), write\+Push\+Promise(), write\+Rst\+Stream(), write\+Settings(), write\+Settings\+Ack(), and write\+Window\+Update().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Frame\+Ping\+Size@{k\+Frame\+Ping\+Size}}
\index{k\+Frame\+Ping\+Size@{k\+Frame\+Ping\+Size}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Frame\+Ping\+Size}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t proxygen\+::http2\+::k\+Frame\+Ping\+Size = 8}\label{namespaceproxygen_1_1http2_a41214eb777cae66877cdcc04add9ff0f}


Definition at line 37 of file H\+T\+T\+P2\+Constants.\+cpp.



Referenced by parse\+Ping(), and write\+Ping().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Frame\+Priority\+Size@{k\+Frame\+Priority\+Size}}
\index{k\+Frame\+Priority\+Size@{k\+Frame\+Priority\+Size}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Frame\+Priority\+Size}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t proxygen\+::http2\+::k\+Frame\+Priority\+Size = 5}\label{namespaceproxygen_1_1http2_a2ef2eb006a752f25b63bfb297805631c}


Definition at line 33 of file H\+T\+T\+P2\+Constants.\+cpp.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Header\+Impl(), parse\+Ex\+Headers(), parse\+Headers(), parse\+Priority(), T\+E\+S\+T\+\_\+\+F(), and write\+Priority().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Frame\+Push\+Promise\+Size@{k\+Frame\+Push\+Promise\+Size}}
\index{k\+Frame\+Push\+Promise\+Size@{k\+Frame\+Push\+Promise\+Size}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Frame\+Push\+Promise\+Size}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t proxygen\+::http2\+::k\+Frame\+Push\+Promise\+Size = 4}\label{namespaceproxygen_1_1http2_abc4bf174d0d65f45171e3cea0fea3a15}


Definition at line 36 of file H\+T\+T\+P2\+Constants.\+cpp.



Referenced by parse\+Push\+Promise(), and write\+Push\+Promise().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Frame\+Rst\+Stream\+Size@{k\+Frame\+Rst\+Stream\+Size}}
\index{k\+Frame\+Rst\+Stream\+Size@{k\+Frame\+Rst\+Stream\+Size}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Frame\+Rst\+Stream\+Size}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t proxygen\+::http2\+::k\+Frame\+Rst\+Stream\+Size = 4}\label{namespaceproxygen_1_1http2_a1dca88d3417008bfd104fcbf19e83bba}


Definition at line 35 of file H\+T\+T\+P2\+Constants.\+cpp.



Referenced by parse\+Rst\+Stream(), T\+E\+S\+T\+\_\+\+F(), and write\+Rst\+Stream().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Frame\+Stream\+I\+D\+Size@{k\+Frame\+Stream\+I\+D\+Size}}
\index{k\+Frame\+Stream\+I\+D\+Size@{k\+Frame\+Stream\+I\+D\+Size}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Frame\+Stream\+I\+D\+Size}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t proxygen\+::http2\+::k\+Frame\+Stream\+I\+D\+Size = 4}\label{namespaceproxygen_1_1http2_aa2d5fdfcdf118bc1ed1298c1d7eeb8d2}


Definition at line 34 of file H\+T\+T\+P2\+Constants.\+cpp.



Referenced by parse\+Ex\+Headers(), and write\+Ex\+Headers().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Frame\+Window\+Update\+Size@{k\+Frame\+Window\+Update\+Size}}
\index{k\+Frame\+Window\+Update\+Size@{k\+Frame\+Window\+Update\+Size}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Frame\+Window\+Update\+Size}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t proxygen\+::http2\+::k\+Frame\+Window\+Update\+Size = 4}\label{namespaceproxygen_1_1http2_afc6d3afbce0ed1f1f902cf365c543512}


Definition at line 39 of file H\+T\+T\+P2\+Constants.\+cpp.



Referenced by parse\+Window\+Update(), T\+E\+S\+T\+\_\+\+F(), and write\+Window\+Update().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Initial\+Window@{k\+Initial\+Window}}
\index{k\+Initial\+Window@{k\+Initial\+Window}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Initial\+Window}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t proxygen\+::http2\+::k\+Initial\+Window = (1u $<$$<$ 16) -\/ 1}\label{namespaceproxygen_1_1http2_a285488ceb67f66fe8203e5378f70334b}


Definition at line 48 of file H\+T\+T\+P2\+Constants.\+cpp.



Referenced by proxygen\+::\+S\+P\+D\+Y\+Codec\+::get\+Default\+Window\+Size(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::get\+Default\+Window\+Size(), S\+P\+D\+Y31\+Downstream\+Test\+::\+S\+P\+D\+Y31\+Downstream\+Test(), T\+E\+S\+T(), T\+E\+S\+T\+\_\+\+F(), and Mock\+Codec\+Downstream\+Test\+::test\+Conn\+Flow\+Control\+Blocked().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Max\+Authenticator\+Buf\+Size@{k\+Max\+Authenticator\+Buf\+Size}}
\index{k\+Max\+Authenticator\+Buf\+Size@{k\+Max\+Authenticator\+Buf\+Size}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Max\+Authenticator\+Buf\+Size}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t proxygen\+::http2\+::k\+Max\+Authenticator\+Buf\+Size = 0x20000}\label{namespaceproxygen_1_1http2_aebafdfb573a05465b2a2e90b5feff59a}


Definition at line 52 of file H\+T\+T\+P2\+Constants.\+cpp.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::parse\+Certificate().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Max\+Frame\+Payload\+Length@{k\+Max\+Frame\+Payload\+Length}}
\index{k\+Max\+Frame\+Payload\+Length@{k\+Max\+Frame\+Payload\+Length}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Max\+Frame\+Payload\+Length}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t proxygen\+::http2\+::k\+Max\+Frame\+Payload\+Length = (1u $<$$<$ 24) -\/ 1}\label{namespaceproxygen_1_1http2_ac0c68679178463270c516ddae0380fc2}


Definition at line 46 of file H\+T\+T\+P2\+Constants.\+cpp.



Referenced by H\+T\+T\+P2\+Framer\+Test\+::data\+Frame\+Test(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::handle\+Settings(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::on\+Ingress\+Upgrade\+Message(), and T\+E\+S\+T\+\_\+\+F().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Max\+Frame\+Payload\+Length\+Min@{k\+Max\+Frame\+Payload\+Length\+Min}}
\index{k\+Max\+Frame\+Payload\+Length\+Min@{k\+Max\+Frame\+Payload\+Length\+Min}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Max\+Frame\+Payload\+Length\+Min}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t proxygen\+::http2\+::k\+Max\+Frame\+Payload\+Length\+Min = (1u $<$$<$ 14)}\label{namespaceproxygen_1_1http2_a31534407d24163973cc35bbd0f98a0ba}


Definition at line 45 of file H\+T\+T\+P2\+Constants.\+cpp.



Referenced by proxygen\+::get\+Big\+Get\+Request(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::handle\+Settings(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::max\+Recv\+Frame\+Size(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::max\+Send\+Frame\+Size(), T\+E\+S\+T\+\_\+\+F(), and H\+T\+T\+P2\+Codec\+Test\+::test\+Frame\+Size\+Limit().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Max\+Header\+Table\+Size@{k\+Max\+Header\+Table\+Size}}
\index{k\+Max\+Header\+Table\+Size@{k\+Max\+Header\+Table\+Size}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Max\+Header\+Table\+Size}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t proxygen\+::http2\+::k\+Max\+Header\+Table\+Size = (1u $<$$<$ 16)}\label{namespaceproxygen_1_1http2_adb70b297ac61d3f0b8729b131cae4cad}


Definition at line 50 of file H\+T\+T\+P2\+Constants.\+cpp.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::handle\+Settings().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Max\+Stream\+ID@{k\+Max\+Stream\+ID}}
\index{k\+Max\+Stream\+ID@{k\+Max\+Stream\+ID}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Max\+Stream\+ID}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t proxygen\+::http2\+::k\+Max\+Stream\+ID = (1u $<$$<$ 31) -\/ 1}\label{namespaceproxygen_1_1http2_a414777c98f0a5c5e78f3d058c8480eaf}


Definition at line 47 of file H\+T\+T\+P2\+Constants.\+cpp.

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Max\+Window\+Update\+Size@{k\+Max\+Window\+Update\+Size}}
\index{k\+Max\+Window\+Update\+Size@{k\+Max\+Window\+Update\+Size}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Max\+Window\+Update\+Size}]{\setlength{\rightskip}{0pt plus 5cm}const uint32\+\_\+t proxygen\+::http2\+::k\+Max\+Window\+Update\+Size = (1u $<$$<$ 31) -\/ 1}\label{namespaceproxygen_1_1http2_ac959007c9791443acd020c9a562c1bfe}


Definition at line 49 of file H\+T\+T\+P2\+Constants.\+cpp.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::handle\+Settings(), and T\+E\+S\+T\+\_\+\+F().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Min\+Experimental\+Frame\+Type@{k\+Min\+Experimental\+Frame\+Type}}
\index{k\+Min\+Experimental\+Frame\+Type@{k\+Min\+Experimental\+Frame\+Type}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Min\+Experimental\+Frame\+Type}]{\setlength{\rightskip}{0pt plus 5cm}const uint8\+\_\+t proxygen\+::http2\+::k\+Min\+Experimental\+Frame\+Type = 0xf0}\label{namespaceproxygen_1_1http2_ae4e37fbdf8dc1f8e39e40803d4fbb38e}


Definition at line 19 of file H\+T\+T\+P2\+Framer.\+cpp.

\index{proxygen\+::http2@{proxygen\+::http2}!k\+No\+Padding@{k\+No\+Padding}}
\index{k\+No\+Padding@{k\+No\+Padding}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+No\+Padding}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf Padding} proxygen\+::http2\+::k\+No\+Padding = folly\+::none}\label{namespaceproxygen_1_1http2_a235817c784b0c7d4cf29d577d8203ca5}


Definition at line 20 of file H\+T\+T\+P2\+Framer.\+cpp.



Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+E\+O\+M(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Header\+Impl(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::generate\+Trailers(), and T\+E\+S\+T\+\_\+\+F().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Protocol\+Cleartext\+String@{k\+Protocol\+Cleartext\+String}}
\index{k\+Protocol\+Cleartext\+String@{k\+Protocol\+Cleartext\+String}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Protocol\+Cleartext\+String}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string proxygen\+::http2\+::k\+Protocol\+Cleartext\+String}\label{namespaceproxygen_1_1http2_a4a4530236990b959d14d8a16d91d99cb}


Referenced by proxygen\+::\+Default\+H\+T\+T\+P\+Codec\+Factory\+::get\+Codec(), proxygen\+::\+H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+::\+H\+T\+T\+P\+Default\+Session\+Codec\+Factory(), proxygen\+::is\+Valid\+Codec\+Protocol\+Str(), proxygen\+::\+H\+T\+T\+P\+Server\+Acceptor\+::make\+Config(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::request\+Upgrade(), T\+E\+S\+T(), and H\+T\+T\+P\+Downstream\+Test$<$ C $>$\+::test\+Simple\+Upgrade().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Protocol\+Draft\+String@{k\+Protocol\+Draft\+String}}
\index{k\+Protocol\+Draft\+String@{k\+Protocol\+Draft\+String}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Protocol\+Draft\+String}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string proxygen\+::http2\+::k\+Protocol\+Draft\+String}\label{namespaceproxygen_1_1http2_ab7c60bfe17cbc7e26846ae904ecf3085}


Referenced by proxygen\+::\+Default\+H\+T\+T\+P\+Codec\+Factory\+::get\+Codec(), and proxygen\+::\+H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+::get\+Codec().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Protocol\+Experimental\+String@{k\+Protocol\+Experimental\+String}}
\index{k\+Protocol\+Experimental\+String@{k\+Protocol\+Experimental\+String}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Protocol\+Experimental\+String}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string proxygen\+::http2\+::k\+Protocol\+Experimental\+String}\label{namespaceproxygen_1_1http2_acc27f73a013f8c20468a4394ec5701ea}


Referenced by proxygen\+::\+Default\+H\+T\+T\+P\+Codec\+Factory\+::get\+Codec(), and proxygen\+::\+H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+::get\+Codec().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Protocol\+Settings\+Header@{k\+Protocol\+Settings\+Header}}
\index{k\+Protocol\+Settings\+Header@{k\+Protocol\+Settings\+Header}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Protocol\+Settings\+Header}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string proxygen\+::http2\+::k\+Protocol\+Settings\+Header}\label{namespaceproxygen_1_1http2_aa5c6cfbc28e3c0014edbb044c0a752c2}


Referenced by proxygen\+::\+H\+T\+T\+P2\+Codec\+::on\+Ingress\+Upgrade\+Message(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::request\+Upgrade(), and T\+E\+S\+T\+\_\+\+F().

\index{proxygen\+::http2@{proxygen\+::http2}!k\+Protocol\+String@{k\+Protocol\+String}}
\index{k\+Protocol\+String@{k\+Protocol\+String}!proxygen\+::http2@{proxygen\+::http2}}
\subsubsection[{k\+Protocol\+String}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string proxygen\+::http2\+::k\+Protocol\+String}\label{namespaceproxygen_1_1http2_a617ec2352707948ee6f85f207a4a7be3}


Referenced by proxygen\+::\+Default\+H\+T\+T\+P\+Codec\+Factory\+::get\+Codec(), proxygen\+::\+H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+::get\+Codec(), proxygen\+::is\+Valid\+Codec\+Protocol\+Str(), proxygen\+::\+H\+T\+T\+P2\+Codec\+::on\+Headers\+Complete(), and T\+E\+S\+T().

