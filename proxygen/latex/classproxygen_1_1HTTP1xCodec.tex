\section{proxygen\+:\+:H\+T\+T\+P1x\+Codec Class Reference}
\label{classproxygen_1_1HTTP1xCodec}\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}


{\ttfamily \#include $<$H\+T\+T\+P1x\+Codec.\+h$>$}

Inheritance diagram for proxygen\+:\+:H\+T\+T\+P1x\+Codec\+:\begin{figure}[H]
\begin{center}
\leavevmode
\includegraphics[height=2.000000cm]{classproxygen_1_1HTTP1xCodec}
\end{center}
\end{figure}
\subsection*{Public Member Functions}
\begin{DoxyCompactItemize}
\item 
{\bf H\+T\+T\+P1x\+Codec} ({\bf Transport\+Direction} direction, bool force\+Upstream1\+\_\+1=false)
\item 
{\bf $\sim$\+H\+T\+T\+P1x\+Codec} () override
\item 
{\bf H\+T\+T\+P1x\+Codec} ({\bf H\+T\+T\+P1x\+Codec} \&\&)=default
\item 
{\bf Codec\+Protocol} {\bf get\+Protocol} () const override
\item 
const std\+::string \& {\bf get\+User\+Agent} () const override
\item 
{\bf Transport\+Direction} {\bf get\+Transport\+Direction} () const override
\item 
{\bf Stream\+ID} {\bf create\+Stream} () override
\item 
void {\bf set\+Callback} ({\bf Callback} $\ast$callback) override
\item 
bool {\bf is\+Busy} () const override
\item 
void {\bf set\+Parser\+Paused} (bool paused) override
\item 
size\+\_\+t {\bf on\+Ingress} (const folly\+::\+I\+O\+Buf \&buf) override
\item 
void {\bf on\+Ingress\+E\+OF} () override
\item 
bool {\bf is\+Reusable} () const override
\item 
bool {\bf is\+Waiting\+To\+Drain} () const override
\item 
bool {\bf close\+On\+Egress\+Complete} () const override
\item 
bool {\bf supports\+Parallel\+Requests} () const override
\item 
bool {\bf supports\+Push\+Transactions} () const override
\item 
void {\bf generate\+Header} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} txn, const {\bf H\+T\+T\+P\+Message} \&msg, bool eom=false, {\bf H\+T\+T\+P\+Header\+Size} $\ast$size={\bf nullptr}) override
\item 
size\+\_\+t {\bf generate\+Body} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} txn, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ chain, folly\+::\+Optional$<$ uint8\+\_\+t $>$ padding, bool eom) override
\item 
size\+\_\+t {\bf generate\+Chunk\+Header} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} txn, size\+\_\+t length) override
\item 
size\+\_\+t {\bf generate\+Chunk\+Terminator} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} txn) override
\item 
size\+\_\+t {\bf generate\+Trailers} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} txn, const {\bf H\+T\+T\+P\+Headers} \&trailers) override
\item 
size\+\_\+t {\bf generate\+E\+OM} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} txn) override
\item 
size\+\_\+t {\bf generate\+Rst\+Stream} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} txn, {\bf Error\+Code} {\bf status\+Code}) override
\item 
size\+\_\+t {\bf generate\+Goaway} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, {\bf Stream\+ID} last\+Stream, {\bf Error\+Code} {\bf status\+Code}, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ debug\+Data={\bf nullptr}) override
\item 
void {\bf set\+Allowed\+Upgrade\+Protocols} (std\+::list$<$ std\+::string $>$ protocols)
\item 
const std\+::string \& {\bf get\+Allowed\+Upgrade\+Protocols} ()
\end{DoxyCompactItemize}
\subsection*{Static Public Member Functions}
\begin{DoxyCompactItemize}
\item 
static {\bf H\+T\+T\+P1x\+Codec} {\bf make\+Response\+Codec} (bool may\+Chunk\+Egress)
\item 
static bool {\bf supports\+Next\+Protocol} (const std\+::string \&npn)
\end{DoxyCompactItemize}
\subsection*{Private Types}
\begin{DoxyCompactItemize}
\item 
enum {\bf Header\+Parse\+State} \+: uint8\+\_\+t \{ \\*
{\bf Header\+Parse\+State\+::k\+Parsing\+Header\+Idle}, 
{\bf Header\+Parse\+State\+::k\+Parsing\+Header\+Start}, 
{\bf Header\+Parse\+State\+::k\+Parsing\+Header\+Name}, 
{\bf Header\+Parse\+State\+::k\+Parsing\+Header\+Value}, 
\\*
{\bf Header\+Parse\+State\+::k\+Parsing\+Headers\+Complete}, 
{\bf Header\+Parse\+State\+::k\+Parsing\+Trailer\+Name}, 
{\bf Header\+Parse\+State\+::k\+Parsing\+Trailer\+Value}
 \}
\item 
enum {\bf Keepalive\+Requested} \+: uint8\+\_\+t \{ {\bf Keepalive\+Requested\+::\+U\+N\+S\+ET}, 
{\bf Keepalive\+Requested\+::\+E\+N\+A\+B\+L\+ED}, 
{\bf Keepalive\+Requested\+::\+D\+I\+S\+A\+B\+L\+ED}
 \}
\end{DoxyCompactItemize}
\subsection*{Private Member Functions}
\begin{DoxyCompactItemize}
\item 
std\+::string {\bf generate\+Websocket\+Key} () const 
\item 
std\+::string {\bf generate\+Websocket\+Accept} (const std\+::string \&accept\+Key) const 
\item 
void {\bf add\+Date\+Header} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, size\+\_\+t \&len)
\item 
bool {\bf is\+Parsing\+Headers} () const 
\item 
bool {\bf is\+Parsing\+Header\+Or\+Trailer\+Name} () const 
\item 
void {\bf on\+Parser\+Error} (const char $\ast$what={\bf nullptr})
\item 
void {\bf push\+Header\+Name\+And\+Value} ({\bf H\+T\+T\+P\+Headers} \&hdrs)
\item 
void {\bf serialize\+Websocket\+Header} (folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, size\+\_\+t \&len, bool upstream)
\item 
int {\bf on\+Message\+Begin} ()
\item 
int {\bf on\+U\+RL} (const char $\ast$buf, size\+\_\+t len)
\item 
int {\bf on\+Reason} (const char $\ast$buf, size\+\_\+t len)
\item 
int {\bf on\+Header\+Field} (const char $\ast$buf, size\+\_\+t len)
\item 
int {\bf on\+Header\+Value} (const char $\ast$buf, size\+\_\+t len)
\item 
int {\bf on\+Headers\+Complete} (size\+\_\+t len)
\item 
int {\bf on\+Body} (const char $\ast$buf, size\+\_\+t len)
\item 
int {\bf on\+Chunk\+Header} (size\+\_\+t len)
\item 
int {\bf on\+Chunk\+Complete} ()
\item 
int {\bf on\+Message\+Complete} ()
\end{DoxyCompactItemize}
\subsection*{Static Private Member Functions}
\begin{DoxyCompactItemize}
\item 
static int {\bf on\+Message\+Begin\+CB} ({\bf http\+\_\+parser} $\ast${\bf parser})
\item 
static int {\bf on\+Path\+CB} ({\bf http\+\_\+parser} $\ast${\bf parser}, const char $\ast$buf, size\+\_\+t len)
\item 
static int {\bf on\+Query\+String\+CB} ({\bf http\+\_\+parser} $\ast${\bf parser}, const char $\ast$buf, size\+\_\+t len)
\item 
static int {\bf on\+Url\+CB} ({\bf http\+\_\+parser} $\ast${\bf parser}, const char $\ast$buf, size\+\_\+t len)
\item 
static int {\bf on\+Reason\+CB} ({\bf http\+\_\+parser} $\ast${\bf parser}, const char $\ast$buf, size\+\_\+t len)
\item 
static int {\bf on\+Header\+Field\+CB} ({\bf http\+\_\+parser} $\ast${\bf parser}, const char $\ast$buf, size\+\_\+t len)
\item 
static int {\bf on\+Header\+Value\+CB} ({\bf http\+\_\+parser} $\ast${\bf parser}, const char $\ast$buf, size\+\_\+t len)
\item 
static int {\bf on\+Headers\+Complete\+CB} ({\bf http\+\_\+parser} $\ast${\bf parser}, const char $\ast$buf, size\+\_\+t len)
\item 
static int {\bf on\+Body\+CB} ({\bf http\+\_\+parser} $\ast${\bf parser}, const char $\ast$buf, size\+\_\+t len)
\item 
static int {\bf on\+Chunk\+Header\+CB} ({\bf http\+\_\+parser} $\ast${\bf parser})
\item 
static int {\bf on\+Chunk\+Complete\+CB} ({\bf http\+\_\+parser} $\ast${\bf parser})
\item 
static int {\bf on\+Message\+Complete\+CB} ({\bf http\+\_\+parser} $\ast${\bf parser})
\item 
static const {\bf http\+\_\+parser\+\_\+settings} $\ast$ {\bf get\+Parser\+Settings} ()
\end{DoxyCompactItemize}
\subsection*{Private Attributes}
\begin{DoxyCompactItemize}
\item 
std\+::string {\bf websock\+Accept\+Key\+\_\+}
\item 
{\bf H\+T\+T\+P\+Codec\+::\+Callback} $\ast$ {\bf callback\+\_\+}
\item 
{\bf Stream\+ID} {\bf ingress\+Txn\+I\+D\+\_\+}
\item 
{\bf Stream\+ID} {\bf egress\+Txn\+I\+D\+\_\+}
\item 
{\bf http\+\_\+parser} {\bf parser\+\_\+}
\item 
const folly\+::\+I\+O\+Buf $\ast$ {\bf current\+Ingress\+Buf\+\_\+}
\item 
std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Message} $>$ {\bf msg\+\_\+}
\item 
std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Message} $>$ {\bf upgrade\+Request\+\_\+}
\item 
std\+::unique\+\_\+ptr$<$ {\bf H\+T\+T\+P\+Headers} $>$ {\bf trailers\+\_\+}
\item 
std\+::string {\bf current\+Header\+Name\+\_\+}
\item 
folly\+::\+String\+Piece {\bf current\+Header\+Name\+String\+Piece\+\_\+}
\item 
std\+::string {\bf current\+Header\+Value\+\_\+}
\item 
std\+::string {\bf url\+\_\+}
\item 
std\+::string {\bf user\+Agent\+\_\+}
\item 
std\+::string {\bf reason\+\_\+}
\item 
std\+::string {\bf upgrade\+Header\+\_\+}
\item 
std\+::string {\bf allowed\+Native\+Upgrades\+\_\+}
\item 
{\bf H\+T\+T\+P\+Header\+Size} {\bf header\+Size\+\_\+}
\item 
{\bf Header\+Parse\+State} {\bf header\+Parse\+State\+\_\+}
\item 
{\bf Transport\+Direction} {\bf transport\+Direction\+\_\+}
\item 
{\bf Keepalive\+Requested} {\bf keepalive\+Requested\+\_\+}
\item 
std\+::pair$<$ {\bf Codec\+Protocol}, std\+::string $>$ {\bf upgrade\+Result\+\_\+}
\item 
bool {\bf force\+Upstream1\+\_\+1\+\_\+}\+:1
\item 
bool {\bf parser\+Active\+\_\+}\+:1
\item 
bool {\bf pending\+E\+O\+F\+\_\+}\+:1
\item 
bool {\bf parser\+Paused\+\_\+}\+:1
\item 
bool {\bf parser\+Error\+\_\+}\+:1
\item 
bool {\bf request\+Pending\+\_\+}\+:1
\item 
bool {\bf response\+Pending\+\_\+}\+:1
\item 
bool {\bf egress\+Chunked\+\_\+}\+:1
\item 
bool {\bf in\+Chunk\+\_\+}\+:1
\item 
bool {\bf last\+Chunk\+Written\+\_\+}\+:1
\item 
bool {\bf keepalive\+\_\+}\+:1
\item 
bool {\bf disable\+Keepalive\+Pending\+\_\+}\+:1
\item 
bool {\bf connect\+Request\+\_\+}\+:1
\item 
bool {\bf head\+Request\+\_\+}\+:1
\item 
bool {\bf expect\+No\+Response\+Body\+\_\+}\+:1
\item 
bool {\bf may\+Chunk\+Egress\+\_\+}\+:1
\item 
bool {\bf is1xx\+Response\+\_\+}\+:1
\item 
bool {\bf in\+Recv\+Last\+Chunk\+\_\+}\+:1
\item 
bool {\bf ingress\+Upgrade\+\_\+}\+:1
\item 
bool {\bf ingress\+Upgrade\+Complete\+\_\+}\+:1
\item 
bool {\bf egress\+Upgrade\+\_\+}\+:1
\item 
bool {\bf native\+Upgrade\+\_\+}\+:1
\item 
bool {\bf headers\+Complete\+\_\+}\+:1
\end{DoxyCompactItemize}
\subsection*{Additional Inherited Members}


\subsection{Detailed Description}


Definition at line 21 of file H\+T\+T\+P1x\+Codec.\+h.



\subsection{Member Enumeration Documentation}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!Header\+Parse\+State@{Header\+Parse\+State}}
\index{Header\+Parse\+State@{Header\+Parse\+State}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{Header\+Parse\+State}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+H\+T\+T\+P1x\+Codec\+::\+Header\+Parse\+State} \+: uint8\+\_\+t\hspace{0.3cm}{\ttfamily [strong]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_ad6b27ceb52069afc3f5260deb4a487f1}
Simple state model used to track the parsing of H\+T\+TP headers \begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{k\+Parsing\+Header\+Idle@{k\+Parsing\+Header\+Idle}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!k\+Parsing\+Header\+Idle@{k\+Parsing\+Header\+Idle}}\item[{\em 
k\+Parsing\+Header\+Idle\label{classproxygen_1_1HTTP1xCodec_ad6b27ceb52069afc3f5260deb4a487f1ac916ac3fc01f9e3e0243f0fde5d34fa0}
}]\index{k\+Parsing\+Header\+Start@{k\+Parsing\+Header\+Start}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!k\+Parsing\+Header\+Start@{k\+Parsing\+Header\+Start}}\item[{\em 
k\+Parsing\+Header\+Start\label{classproxygen_1_1HTTP1xCodec_ad6b27ceb52069afc3f5260deb4a487f1a2df55bed1747b556380b4bacb2b2432d}
}]\index{k\+Parsing\+Header\+Name@{k\+Parsing\+Header\+Name}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!k\+Parsing\+Header\+Name@{k\+Parsing\+Header\+Name}}\item[{\em 
k\+Parsing\+Header\+Name\label{classproxygen_1_1HTTP1xCodec_ad6b27ceb52069afc3f5260deb4a487f1a77e54ab638a73d0aad7c3bec8e6ca594}
}]\index{k\+Parsing\+Header\+Value@{k\+Parsing\+Header\+Value}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!k\+Parsing\+Header\+Value@{k\+Parsing\+Header\+Value}}\item[{\em 
k\+Parsing\+Header\+Value\label{classproxygen_1_1HTTP1xCodec_ad6b27ceb52069afc3f5260deb4a487f1a73245b2363d1f01e6931f7f147b6b695}
}]\index{k\+Parsing\+Headers\+Complete@{k\+Parsing\+Headers\+Complete}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!k\+Parsing\+Headers\+Complete@{k\+Parsing\+Headers\+Complete}}\item[{\em 
k\+Parsing\+Headers\+Complete\label{classproxygen_1_1HTTP1xCodec_ad6b27ceb52069afc3f5260deb4a487f1ac3e8cd8b00b1178306026ecb4d9f7374}
}]\index{k\+Parsing\+Trailer\+Name@{k\+Parsing\+Trailer\+Name}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!k\+Parsing\+Trailer\+Name@{k\+Parsing\+Trailer\+Name}}\item[{\em 
k\+Parsing\+Trailer\+Name\label{classproxygen_1_1HTTP1xCodec_ad6b27ceb52069afc3f5260deb4a487f1aba499fcd9dab56e6789501c59792d026}
}]\index{k\+Parsing\+Trailer\+Value@{k\+Parsing\+Trailer\+Value}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!k\+Parsing\+Trailer\+Value@{k\+Parsing\+Trailer\+Value}}\item[{\em 
k\+Parsing\+Trailer\+Value\label{classproxygen_1_1HTTP1xCodec_ad6b27ceb52069afc3f5260deb4a487f1a02d7bd2f7807956ad46ee629d5aa0652}
}]\end{description}
\end{Desc}


Definition at line 99 of file H\+T\+T\+P1x\+Codec.\+h.


\begin{DoxyCode}
99                               : uint8\_t \{
100     kParsingHeaderIdle,
101     kParsingHeaderStart,
102     kParsingHeaderName,
103     kParsingHeaderValue,
104     kParsingHeadersComplete,
105     kParsingTrailerName,
106     kParsingTrailerValue
107   \};
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!Keepalive\+Requested@{Keepalive\+Requested}}
\index{Keepalive\+Requested@{Keepalive\+Requested}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{Keepalive\+Requested}]{\setlength{\rightskip}{0pt plus 5cm}enum {\bf proxygen\+::\+H\+T\+T\+P1x\+Codec\+::\+Keepalive\+Requested} \+: uint8\+\_\+t\hspace{0.3cm}{\ttfamily [strong]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_ad288be6ba74a5f18c6280f4677a1eb0b}
Used to keep track of whether a client requested keep-\/alive. This is only useful to support H\+T\+TP 1.\+0 keep-\/alive for a downstream connection where keep-\/alive is disabled unless the client requested it. \begin{Desc}
\item[Enumerator]\par
\begin{description}
\index{U\+N\+S\+ET@{U\+N\+S\+ET}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!U\+N\+S\+ET@{U\+N\+S\+ET}}\item[{\em 
U\+N\+S\+ET\label{classproxygen_1_1HTTP1xCodec_ad288be6ba74a5f18c6280f4677a1eb0ba666a87025ab0d8965e221050c8948001}
}]\index{E\+N\+A\+B\+L\+ED@{E\+N\+A\+B\+L\+ED}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!E\+N\+A\+B\+L\+ED@{E\+N\+A\+B\+L\+ED}}\item[{\em 
E\+N\+A\+B\+L\+ED\label{classproxygen_1_1HTTP1xCodec_ad288be6ba74a5f18c6280f4677a1eb0bac8cf6eea8f096ed51160b484d97c5bbd}
}]\index{D\+I\+S\+A\+B\+L\+ED@{D\+I\+S\+A\+B\+L\+ED}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!D\+I\+S\+A\+B\+L\+ED@{D\+I\+S\+A\+B\+L\+ED}}\item[{\em 
D\+I\+S\+A\+B\+L\+ED\label{classproxygen_1_1HTTP1xCodec_ad288be6ba74a5f18c6280f4677a1eb0ba055c1a591abb0e8cd86dc969727bcc0b}
}]\end{description}
\end{Desc}


Definition at line 116 of file H\+T\+T\+P1x\+Codec.\+h.


\begin{DoxyCode}
116                                 : uint8\_t \{
117     UNSET,
118     ENABLED,  \textcolor{comment}{// incoming message requested keepalive}
119     DISABLED,   \textcolor{comment}{// incoming message disabled keepalive}
120   \};
\end{DoxyCode}


\subsection{Constructor \& Destructor Documentation}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!H\+T\+T\+P1x\+Codec@{H\+T\+T\+P1x\+Codec}}
\index{H\+T\+T\+P1x\+Codec@{H\+T\+T\+P1x\+Codec}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{H\+T\+T\+P1x\+Codec(\+Transport\+Direction direction, bool force\+Upstream1\+\_\+1=false)}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+H\+T\+T\+P1x\+Codec\+::\+H\+T\+T\+P1x\+Codec (
\begin{DoxyParamCaption}
\item[{{\bf Transport\+Direction}}]{direction, }
\item[{bool}]{force\+Upstream1\+\_\+1 = {\ttfamily false}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [explicit]}}\label{classproxygen_1_1HTTP1xCodec_a785642e5353b4948ee882661b1c9e1f6}


Definition at line 81 of file H\+T\+T\+P1x\+Codec.\+cpp.



References http\+\_\+parser\+::data, proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, http\+\_\+parser\+\_\+init(), H\+T\+T\+P\+\_\+\+R\+E\+Q\+U\+E\+ST, H\+T\+T\+P\+\_\+\+R\+E\+S\+P\+O\+N\+SE, parser\+\_\+, and proxygen\+::\+U\+P\+S\+T\+R\+E\+AM.


\begin{DoxyCode}
82     : callback_(\textcolor{keyword}{nullptr}),
83       ingressTxnID_(0),
84       egressTxnID_(0),
85       currentIngressBuf_(\textcolor{keyword}{nullptr}),
86       headerParseState_(HeaderParseState::kParsingHeaderIdle),
87       transportDirection_(direction),
88       keepaliveRequested_(KeepaliveRequested::UNSET),
89       forceUpstream1_1_(forceUpstream1\_1),
90       parserActive_(\textcolor{keyword}{false}),
91       pendingEOF_(\textcolor{keyword}{false}),
92       parserPaused_(\textcolor{keyword}{false}),
93       parserError_(\textcolor{keyword}{false}),
94       requestPending_(\textcolor{keyword}{false}),
95       responsePending_(\textcolor{keyword}{false}),
96       egressChunked_(\textcolor{keyword}{false}),
97       inChunk_(\textcolor{keyword}{false}),
98       lastChunkWritten_(\textcolor{keyword}{false}),
99       keepalive_(\textcolor{keyword}{true}),
100       disableKeepalivePending_(\textcolor{keyword}{false}),
101       connectRequest_(\textcolor{keyword}{false}),
102       headRequest_(\textcolor{keyword}{false}),
103       expectNoResponseBody_(\textcolor{keyword}{false}),
104       mayChunkEgress_(\textcolor{keyword}{false}),
105       is1xxResponse_(\textcolor{keyword}{false}),
106       inRecvLastChunk_(\textcolor{keyword}{false}),
107       ingressUpgrade_(\textcolor{keyword}{false}),
108       ingressUpgradeComplete_(\textcolor{keyword}{false}),
109       egressUpgrade_(\textcolor{keyword}{false}),
110       nativeUpgrade_(\textcolor{keyword}{false}),
111       headersComplete_(\textcolor{keyword}{false}) \{
112   \textcolor{keywordflow}{switch} (direction) \{
113   \textcolor{keywordflow}{case} TransportDirection::DOWNSTREAM:
114     http_parser_init(&parser_, HTTP_REQUEST);
115     \textcolor{keywordflow}{break};
116   \textcolor{keywordflow}{case} TransportDirection::UPSTREAM:
117     http_parser_init(&parser_, HTTP_RESPONSE);
118     \textcolor{keywordflow}{break};
119   \textcolor{keywordflow}{default}:
120     LOG(FATAL) << \textcolor{stringliteral}{"Unknown transport direction."};
121   \}
122   parser_.data = \textcolor{keyword}{this};
123 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!````~H\+T\+T\+P1x\+Codec@{$\sim$\+H\+T\+T\+P1x\+Codec}}
\index{````~H\+T\+T\+P1x\+Codec@{$\sim$\+H\+T\+T\+P1x\+Codec}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{$\sim$\+H\+T\+T\+P1x\+Codec() override}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+H\+T\+T\+P1x\+Codec\+::$\sim$\+H\+T\+T\+P1x\+Codec (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}}\label{classproxygen_1_1HTTP1xCodec_a18a4de43d6cab6d4915923312d4b0ca7}


Definition at line 125 of file H\+T\+T\+P1x\+Codec.\+cpp.


\begin{DoxyCode}
125                           \{
126   \textcolor{comment}{// This code used to throw a parse error there were unterminated headers}
127   \textcolor{comment}{// being parsed.  None of the cases where this can happen relied on the parse}
128   \textcolor{comment}{// error.}
129 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!H\+T\+T\+P1x\+Codec@{H\+T\+T\+P1x\+Codec}}
\index{H\+T\+T\+P1x\+Codec@{H\+T\+T\+P1x\+Codec}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{H\+T\+T\+P1x\+Codec(\+H\+T\+T\+P1x\+Codec \&\&)=default}]{\setlength{\rightskip}{0pt plus 5cm}proxygen\+::\+H\+T\+T\+P1x\+Codec\+::\+H\+T\+T\+P1x\+Codec (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P1x\+Codec} \&\&}]{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [default]}}\label{classproxygen_1_1HTTP1xCodec_a0eb063ca6395fc5e807546be6328efa3}


\subsection{Member Function Documentation}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!add\+Date\+Header@{add\+Date\+Header}}
\index{add\+Date\+Header@{add\+Date\+Header}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{add\+Date\+Header(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, size\+\_\+t \&len)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P1x\+Codec\+::add\+Date\+Header (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{size\+\_\+t \&}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a5b1b97e0d72a78f7939d3e28246ec032}


Definition at line 306 of file H\+T\+T\+P1x\+Codec.\+cpp.



References append\+Literal, and proxygen\+::\+H\+T\+T\+P\+Message\+::format\+Date\+Header().



Referenced by generate\+Header().


\begin{DoxyCode}
306                                                             \{
307   appendLiteral(writeBuf, len, \textcolor{stringliteral}{"Date: "});
308   appendString(writeBuf, len, HTTPMessage::formatDateHeader());
309   appendLiteral(writeBuf, len, CRLF);
310 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!close\+On\+Egress\+Complete@{close\+On\+Egress\+Complete}}
\index{close\+On\+Egress\+Complete@{close\+On\+Egress\+Complete}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{close\+On\+Egress\+Complete() const override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::close\+On\+Egress\+Complete (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP1xCodec_a6ac8586d4ec02853f64844556e19e412}
Checks whether the socket needs to be closed when E\+OM is sent. This is used during C\+O\+N\+N\+E\+CT when E\+OF needs to be sent after upgrade to notify the server 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a4f32afc7d536aba32c44d78e183abfbf}.



Definition at line 57 of file H\+T\+T\+P1x\+Codec.\+h.



References egress\+Upgrade\+\_\+.


\begin{DoxyCode}
57 \{ \textcolor{keywordflow}{return} egressUpgrade_; \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!create\+Stream@{create\+Stream}}
\index{create\+Stream@{create\+Stream}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{create\+Stream() override}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Codec\+::\+Stream\+ID} proxygen\+::\+H\+T\+T\+P1x\+Codec\+::create\+Stream (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP1xCodec_a05bc575dd965f6575224f674fae7c876}
Reserve a stream ID. \begin{DoxyReturn}{Returns}
A stream ID on success, or zero on error. 
\end{DoxyReturn}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_acf86dd965f7732f70403449d11bddcbe}.



Definition at line 132 of file H\+T\+T\+P1x\+Codec.\+cpp.



References proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, egress\+Txn\+I\+D\+\_\+, ingress\+Txn\+I\+D\+\_\+, and transport\+Direction\+\_\+.



Referenced by get\+Transport\+Direction(), T\+E\+S\+T(), and T\+E\+S\+T\+\_\+\+P().


\begin{DoxyCode}
132                           \{
133   \textcolor{keywordflow}{if} (transportDirection_ == TransportDirection::DOWNSTREAM) \{
134     \textcolor{keywordflow}{return} ++ingressTxnID_;
135   \} \textcolor{keywordflow}{else} \{
136     \textcolor{keywordflow}{return} ++egressTxnID_;
137   \}
138 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!generate\+Body@{generate\+Body}}
\index{generate\+Body@{generate\+Body}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{generate\+Body(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D txn, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ chain, folly\+::\+Optional$<$ uint8\+\_\+t $>$ padding, bool eom) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P1x\+Codec\+::generate\+Body (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{chain, }
\item[{folly\+::\+Optional$<$ uint8\+\_\+t $>$}]{padding, }
\item[{bool}]{eom}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP1xCodec_a9c67e2a6490c1bf1aa65cc850f4a2b57}
Write part of an egress message body.

This will automatically generate a chunk header and footer around the data if necessary (e.\+g. you haven\textquotesingle{}t manually sent a chunk header and the message should be chunked).


\begin{DoxyParams}{Parameters}
{\em padding} & Optionally add padding bytes to the body if possible \\
\hline
{\em eom} & implicitly generate the E\+OM marker with this body frame\\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
number of bytes written 
\end{DoxyReturn}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_ad914e07a10cf00dc93e9cb9e0c0205b3}.



Definition at line 657 of file H\+T\+T\+P1x\+Codec.\+cpp.



References egress\+Chunked\+\_\+, egress\+Txn\+I\+D\+\_\+, generate\+E\+O\+M(), and in\+Chunk\+\_\+.



Referenced by supports\+Push\+Transactions(), and T\+E\+S\+T().


\begin{DoxyCode}
661                                            \{
662   DCHECK\_EQ(txn, egressTxnID_);
663   \textcolor{keywordflow}{if} (!chain) \{
664     \textcolor{keywordflow}{return} 0;
665   \}
666   \textcolor{keywordtype}{size\_t} buflen = chain->computeChainDataLength();
667   \textcolor{keywordtype}{size\_t} totLen = buflen;
668   \textcolor{keywordflow}{if} (totLen == 0) \{
669     \textcolor{keywordflow}{if} (eom) \{
670       totLen += generateEOM(writeBuf, txn);
671     \}
672     \textcolor{keywordflow}{return} totLen;
673   \}
674 
675   \textcolor{keywordflow}{if} (egressChunked_ && !inChunk_) \{
676     \textcolor{keywordtype}{char} chunkLenBuf[32];
677     \textcolor{keywordtype}{int} rc = snprintf(chunkLenBuf, \textcolor{keyword}{sizeof}(chunkLenBuf), \textcolor{stringliteral}{"%zx\(\backslash\)r\(\backslash\)n"}, buflen);
678     CHECK\_GT(rc, 0);
679     CHECK\_LT(\textcolor{keywordtype}{size\_t}(rc), \textcolor{keyword}{sizeof}(chunkLenBuf));
680 
681     writeBuf.append(chunkLenBuf, rc);
682     totLen += rc;
683 
684     writeBuf.append(std::move(chain));
685     writeBuf.append(\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"}, 2);
686     totLen += 2;
687   \} \textcolor{keywordflow}{else} \{
688     writeBuf.append(std::move(chain));
689   \}
690   \textcolor{keywordflow}{if} (eom) \{
691     totLen += generateEOM(writeBuf, txn);
692   \}
693 
694   \textcolor{keywordflow}{return} totLen;
695 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!generate\+Chunk\+Header@{generate\+Chunk\+Header}}
\index{generate\+Chunk\+Header@{generate\+Chunk\+Header}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{generate\+Chunk\+Header(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D txn, size\+\_\+t length) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P1x\+Codec\+::generate\+Chunk\+Header (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream, }
\item[{size\+\_\+t}]{length}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP1xCodec_a50e8e488ed9d226f6857404eeea29cb7}
Write a body chunk header, if relevant. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a10a3cf44e3748bddd22d260a028c152c}.



Definition at line 697 of file H\+T\+T\+P1x\+Codec.\+cpp.



References egress\+Chunked\+\_\+, and in\+Chunk\+\_\+.



Referenced by supports\+Push\+Transactions().


\begin{DoxyCode}
699                                                        \{
700   \textcolor{comment}{// TODO: Format directly into the IOBuf, rather than copying after the fact.}
701   \textcolor{comment}{// IOBufQueue::append() currently forces us to copy.}
702 
703   CHECK(length) << \textcolor{stringliteral}{"use sendEOM to terminate the message using the "}
704                 << \textcolor{stringliteral}{"standard zero-length chunk. Don't "}
705                 << \textcolor{stringliteral}{"send zero-length chunks using this API."};
706   \textcolor{keywordflow}{if} (egressChunked_) \{
707     CHECK(!inChunk_);
708     inChunk_ = \textcolor{keyword}{true};
709     \textcolor{keywordtype}{char} chunkLenBuf[32];
710     \textcolor{keywordtype}{int} rc = snprintf(chunkLenBuf, \textcolor{keyword}{sizeof}(chunkLenBuf), \textcolor{stringliteral}{"%zx\(\backslash\)r\(\backslash\)n"}, length);
711     CHECK\_GT(rc, 0);
712     CHECK\_LT(\textcolor{keywordtype}{size\_t}(rc), \textcolor{keyword}{sizeof}(chunkLenBuf));
713 
714     writeBuf.append(chunkLenBuf, rc);
715     \textcolor{keywordflow}{return} rc;
716   \}
717 
718   \textcolor{keywordflow}{return} 0;
719 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!generate\+Chunk\+Terminator@{generate\+Chunk\+Terminator}}
\index{generate\+Chunk\+Terminator@{generate\+Chunk\+Terminator}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{generate\+Chunk\+Terminator(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D txn) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P1x\+Codec\+::generate\+Chunk\+Terminator (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP1xCodec_a82f5c381e3bbb09c203eafde3530510d}
Write a body chunk terminator, if relevant. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a6e20271ad023252b6fa877d95b413f26}.



Definition at line 721 of file H\+T\+T\+P1x\+Codec.\+cpp.



References egress\+Chunked\+\_\+, and in\+Chunk\+\_\+.



Referenced by supports\+Push\+Transactions().


\begin{DoxyCode}
722                                                         \{
723   \textcolor{keywordflow}{if} (egressChunked_ && inChunk_) \{
724     inChunk_ = \textcolor{keyword}{false};
725     writeBuf.append(\textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"}, 2);
726     \textcolor{keywordflow}{return} 2;
727   \}
728 
729   \textcolor{keywordflow}{return} 0;
730 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!generate\+E\+OM@{generate\+E\+OM}}
\index{generate\+E\+OM@{generate\+E\+OM}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{generate\+E\+O\+M(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D txn) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P1x\+Codec\+::generate\+E\+OM (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP1xCodec_acba8a17fcc4da3ebaecf7da19fe2aa4a}
Generate any protocol framing needed to finalize an egress message. This method must be called to complete a stream.

\begin{DoxyReturn}{Returns}
number of bytes written 
\end{DoxyReturn}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_aefa134de8aff8e9000092a9996546bd5}.



Definition at line 752 of file H\+T\+T\+P1x\+Codec.\+cpp.



References append\+Literal, proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, egress\+Chunked\+\_\+, egress\+Txn\+I\+D\+\_\+, head\+Request\+\_\+, in\+Chunk\+\_\+, last\+Chunk\+Written\+\_\+, request\+Pending\+\_\+, response\+Pending\+\_\+, transport\+Direction\+\_\+, and proxygen\+::\+U\+P\+S\+T\+R\+E\+AM.



Referenced by generate\+Body(), generate\+Header(), supports\+Push\+Transactions(), and T\+E\+S\+T().


\begin{DoxyCode}
752                                                                   \{
753   DCHECK\_EQ(txn, egressTxnID_);
754   \textcolor{keywordtype}{size\_t} len = 0;
755   \textcolor{keywordflow}{if} (egressChunked_) \{
756     CHECK(!inChunk_);
757     \textcolor{keywordflow}{if} (headRequest_ && transportDirection_ == TransportDirection::DOWNSTREAM) \{
758       lastChunkWritten_ = \textcolor{keyword}{true};
759     \} \textcolor{keywordflow}{else} \{
760       \textcolor{comment}{// appending a 0\(\backslash\)r\(\backslash\)n only if it's not a HEAD and downstream request}
761       \textcolor{keywordflow}{if} (!lastChunkWritten_) \{
762         lastChunkWritten_ = \textcolor{keyword}{true};
763         \textcolor{keywordflow}{if} (!(headRequest_ &&
764               transportDirection_ == TransportDirection::DOWNSTREAM)) \{
765           appendLiteral(writeBuf, len, \textcolor{stringliteral}{"0\(\backslash\)r\(\backslash\)n"});
766         \}
767       \}
768       appendLiteral(writeBuf, len, CRLF);
769     \}
770   \}
771   \textcolor{keywordflow}{switch} (transportDirection_) \{
772   \textcolor{keywordflow}{case} TransportDirection::DOWNSTREAM:
773     responsePending_ = \textcolor{keyword}{false};
774     \textcolor{keywordflow}{break};
775   \textcolor{keywordflow}{case} TransportDirection::UPSTREAM:
776     requestPending_ = \textcolor{keyword}{false};
777     \textcolor{keywordflow}{break};
778   \}
779   \textcolor{keywordflow}{return} len;
780 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!generate\+Goaway@{generate\+Goaway}}
\index{generate\+Goaway@{generate\+Goaway}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{generate\+Goaway(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D last\+Stream, Error\+Code status\+Code, std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$ debug\+Data=nullptr) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P1x\+Codec\+::generate\+Goaway (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{last\+Stream, }
\item[{{\bf Error\+Code}}]{code, }
\item[{std\+::unique\+\_\+ptr$<$ folly\+::\+I\+O\+Buf $>$}]{debug\+Data = {\ttfamily {\bf nullptr}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP1xCodec_a4dee1ae5ca15cca0edcf79fa70120941}
Generate any protocol framing needed to abort a connection. \begin{DoxyReturn}{Returns}
number of bytes written 
\end{DoxyReturn}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a22dec1b6d4dde73ea7380a28b937e545}.



Definition at line 791 of file H\+T\+T\+P1x\+Codec.\+cpp.



References disable\+Keepalive\+Pending\+\_\+.



Referenced by supports\+Push\+Transactions().


\begin{DoxyCode}
795                              \{
796   \textcolor{comment}{// statusCode ignored for HTTP/1.1}
797   \textcolor{comment}{// We won't be able to send anything else on the transport after this.}
798   disableKeepalivePending_ = \textcolor{keyword}{true};
799   \textcolor{keywordflow}{return} 0;
800 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!generate\+Header@{generate\+Header}}
\index{generate\+Header@{generate\+Header}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{generate\+Header(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D txn, const H\+T\+T\+P\+Message \&msg, bool eom=false, H\+T\+T\+P\+Header\+Size $\ast$size=nullptr) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P1x\+Codec\+::generate\+Header (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream, }
\item[{const {\bf H\+T\+T\+P\+Message} \&}]{msg, }
\item[{bool}]{eom = {\ttfamily false}, }
\item[{{\bf H\+T\+T\+P\+Header\+Size} $\ast$}]{size = {\ttfamily {\bf nullptr}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP1xCodec_a4c45650db9eb3d96ab6d091f4f67fbf7}
Write an egress message header. For pushed streams, you must specify the assoc\+Stream. 
\begin{DoxyRetVals}{Return values}
{\em size} & the size of the generated message, both the actual size and the size of the uncompressed data. \\
\hline
\end{DoxyRetVals}
\begin{DoxyReturn}{Returns}
None 
\end{DoxyReturn}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a572e25a01e0d36bb527db2dc39ca26b3}.



Definition at line 364 of file H\+T\+T\+P1x\+Codec.\+cpp.



References add\+Date\+Header(), append\+Literal, proxygen\+::case\+Insensitive\+Equal(), proxygen\+::\+C\+O\+N\+N\+E\+CT, connect\+Request\+\_\+, disable\+Keepalive\+Pending\+\_\+, proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, egress\+Chunked\+\_\+, egress\+Txn\+I\+D\+\_\+, egress\+Upgrade\+\_\+, E\+N\+A\+B\+L\+ED, proxygen\+::\+E\+R\+R\+OR, expect\+No\+Response\+Body\+\_\+, force\+Upstream1\+\_\+1\+\_\+, proxygen\+::\+H\+T\+T\+P\+Headers\+::for\+Each\+With\+Code(), generate\+E\+O\+M(), proxygen\+::\+G\+ET, proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Default\+Reason(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Headers(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+H\+T\+T\+P\+Version(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Is\+Chunked(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Method(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Method\+String(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Status\+Code(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+Status\+Message(), proxygen\+::\+H\+T\+T\+P\+Message\+::get\+U\+R\+L(), proxygen\+::\+H\+E\+AD, head\+Request\+\_\+, http\+\_\+parser\+::http\+\_\+major, http\+\_\+parser\+::http\+\_\+minor, ingress\+Txn\+I\+D\+\_\+, ingress\+Upgrade\+\_\+, proxygen\+::\+H\+T\+T\+P\+Message\+::is1xx\+Response(), is1xx\+Response\+\_\+, proxygen\+::\+H\+T\+T\+P\+Message\+::is\+Egress\+Websocket\+Upgrade(), keepalive\+\_\+, keepalive\+Requested\+\_\+, proxygen\+::\+H\+T\+T\+P\+Message\+::k\+H\+T\+T\+P\+Version10, proxygen\+::\+H\+T\+T\+P\+Message\+::k\+H\+T\+T\+P\+Version11, last\+Chunk\+Written\+\_\+, may\+Chunk\+Egress\+\_\+, proxygen\+::method\+To\+String(), parser\+\_\+, proxygen\+::\+P\+O\+ST, request\+Pending\+\_\+, proxygen\+::\+R\+F\+C2616\+::response\+Body\+Must\+Be\+Empty(), response\+Pending\+\_\+, serialize\+Websocket\+Header(), status\+Code, transport\+Direction\+\_\+, upgrade\+Header\+\_\+, proxygen\+::\+U\+P\+S\+T\+R\+E\+AM, and proxygen\+::\+H\+T\+T\+P\+Message\+::wants\+Keepalive().



Referenced by supports\+Push\+Transactions(), T\+E\+S\+T(), and T\+E\+S\+T\+\_\+\+P().


\begin{DoxyCode}
368                                                   \{
369   \textcolor{keywordflow}{if} (keepalive_ && disableKeepalivePending_) \{
370     keepalive_ = \textcolor{keyword}{false};
371   \}
372   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} upstream = (transportDirection_ == TransportDirection::UPSTREAM);
373   \textcolor{keyword}{const} \textcolor{keywordtype}{bool} downstream = !upstream;
374   \textcolor{keywordflow}{if} (upstream) \{
375     DCHECK\_EQ(txn, egressTxnID_);
376     requestPending_ = \textcolor{keyword}{true};
377     responsePending_ = \textcolor{keyword}{true};
378     connectRequest_ = (msg.getMethod() == HTTPMethod::CONNECT);
379     headRequest_ = (msg.getMethod() == HTTPMethod::HEAD);
380     expectNoResponseBody_ = connectRequest_ || headRequest_;
381   \} \textcolor{keywordflow}{else} \{
382     \textcolor{comment}{// In HTTP, transactions must be egressed sequentially -- no out of order}
383     \textcolor{comment}{// responses.  So txn must be egressTxnID\_ + 1.  Furthermore, we shouldn't}
384     \textcolor{comment}{// ever egress a response before we see a request, so txn can't}
385     \textcolor{comment}{// be > ingressTxnID\_}
386     \textcolor{keywordflow}{if} ((txn != egressTxnID_ + 1 &&
387          !(txn == egressTxnID_ && is1xxResponse_)) ||
388         (txn > ingressTxnID_)) \{
389       LOG(DFATAL) << \textcolor{stringliteral}{"Out of order, duplicate or premature HTTP response"};
390     \}
391     \textcolor{keywordflow}{if} (!is1xxResponse_) \{
392       ++egressTxnID_;
393     \}
394     is1xxResponse_ = msg.is1xxResponse() || msg.isEgressWebsocketUpgrade();
395 
396     expectNoResponseBody_ =
397       connectRequest_ || headRequest_ ||
398       RFC2616::responseBodyMustBeEmpty(msg.getStatusCode());
399   \}
400 
401   \textcolor{keywordtype}{int} statusCode = 0;
402   StringPiece statusMessage;
403   \textcolor{keywordflow}{if} (downstream) \{
404     statusCode = msg.getStatusCode();
405     statusMessage = msg.getStatusMessage();
406     \textcolor{comment}{// If a response to a websocket upgrade is being sent out, it must be 101.}
407     \textcolor{comment}{// This is required since the application may not have changed the status,}
408     \textcolor{comment}{// particularly when proxying between a H2 hop and a H1 hop.}
409     \textcolor{keywordflow}{if} (msg.isEgressWebsocketUpgrade()) \{
410       statusCode = 101;
411       statusMessage = HTTPMessage::getDefaultReason(101);
412     \}
413     \textcolor{keywordflow}{if} (connectRequest_ && (statusCode >= 200 && statusCode < 300)) \{
414       \textcolor{comment}{// Set egress upgrade flag if we are sending a 200 response}
415       \textcolor{comment}{// to a CONNECT request we received earlier.}
416       egressUpgrade_ = \textcolor{keyword}{true};
417     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (statusCode == 101) \{
418       \textcolor{comment}{// Set the upgrade flags if we upgraded after the request from client.}
419       ingressUpgrade_ = \textcolor{keyword}{true};
420       egressUpgrade_ = \textcolor{keyword}{true};
421     \}
422     \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (connectRequest_ && ingressUpgrade_) \{
423       \textcolor{comment}{// Disable upgrade when rejecting CONNECT request}
424       ingressUpgrade_ = \textcolor{keyword}{false};
425 
426       \textcolor{comment}{// This codec/session is no longer useful as we might have}
427       \textcolor{comment}{// forwarded some data before receiving the 200.}
428       keepalive_ = \textcolor{keyword}{false};
429     \}
430   \} \textcolor{keywordflow}{else} \{
431     \textcolor{keywordflow}{if} (connectRequest_ || msg.isEgressWebsocketUpgrade()) \{
432       \textcolor{comment}{// Sending a CONNECT request or a websocket upgrade request to an upstream}
433       \textcolor{comment}{// server. This is used to determine the chunked setting below.}
434       egressUpgrade_ = \textcolor{keyword}{true};
435     \}
436   \}
437 
438   egressChunked_ = msg.getIsChunked() && !egressUpgrade_;
439   lastChunkWritten_ = \textcolor{keyword}{false};
440   std::pair<uint8\_t, uint8\_t> version = msg.getHTTPVersion();
441   \textcolor{keywordflow}{if} (version > HTTPMessage::kHTTPVersion11) \{
442     version = HTTPMessage::kHTTPVersion11;
443   \}
444 
445   \textcolor{keywordtype}{size\_t} len = 0;
446   \textcolor{keywordflow}{switch} (transportDirection_) \{
447   \textcolor{keywordflow}{case} TransportDirection::DOWNSTREAM:
448     DCHECK\_NE(statusCode, 0);
449     \textcolor{keywordflow}{if} (version.first == 0 && version.second == 9) \{
450       \textcolor{keywordflow}{return};
451     \}
452     appendLiteral(writeBuf, len, \textcolor{stringliteral}{"HTTP/"});
453     appendUint(writeBuf, len, version.first);
454     appendLiteral(writeBuf, len, \textcolor{stringliteral}{"."});
455     appendUint(writeBuf, len, version.second);
456     appendLiteral(writeBuf, len, \textcolor{stringliteral}{" "});
457     appendUint(writeBuf, len, statusCode);
458     appendLiteral(writeBuf, len, \textcolor{stringliteral}{" "});
459     appendString(writeBuf, len, statusMessage);
460     \textcolor{keywordflow}{break};
461   \textcolor{keywordflow}{case} TransportDirection::UPSTREAM:
462     \textcolor{keywordflow}{if} (forceUpstream1_1_ && version < HTTPMessage::kHTTPVersion11) \{
463       version = HTTPMessage::kHTTPVersion11;
464     \}
465     \textcolor{keywordflow}{if} (msg.isEgressWebsocketUpgrade()) \{
466       appendString(writeBuf, len, methodToString(HTTPMethod::GET));
467     \} \textcolor{keywordflow}{else} \{
468       appendString(writeBuf, len, msg.getMethodString());
469     \}
470     appendLiteral(writeBuf, len, \textcolor{stringliteral}{" "});
471     appendString(writeBuf, len, msg.getURL());
472     appendLiteral(writeBuf, len, \textcolor{stringliteral}{" HTTP/"});
473     appendUint(writeBuf, len, version.first);
474     appendLiteral(writeBuf, len, \textcolor{stringliteral}{"."});
475     appendUint(writeBuf, len, version.second);
476     mayChunkEgress_ = (version.first == 1) && (version.second >= 1);
477     \textcolor{keywordflow}{if} (!upgradeHeader_.empty()) \{
478       LOG(DFATAL) << \textcolor{stringliteral}{"Attempted to pipeline HTTP request with pending upgrade"};
479       upgradeHeader_.clear();
480     \}
481     \textcolor{keywordflow}{break};
482   \}
483 
484   \textcolor{keywordflow}{if} (keepalive_ &&
485       (!msg.wantsKeepalive() ||
486        version.first < 1 ||
487        (downstream && version == HTTPMessage::kHTTPVersion10 &&
488         keepaliveRequested_ != KeepaliveRequested::ENABLED))) \{
489     \textcolor{comment}{// Disable keepalive if}
490     \textcolor{comment}{//  - the message asked to turn it off}
491     \textcolor{comment}{//  - it's HTTP/0.9}
492     \textcolor{comment}{//  - this is a response to a 1.0 request that didn't say keep-alive}
493     keepalive_ = \textcolor{keyword}{false};
494   \}
495   egressChunked_ &= mayChunkEgress_;
496   appendLiteral(writeBuf, len, CRLF);
497   \textcolor{keywordflow}{if} (version.first == 0 && version.second == 9) \{
498     parser_.http_major = 0;
499     parser_.http_minor = 9;
500     \textcolor{keywordflow}{return};
501   \}
502   \textcolor{keyword}{const} \textcolor{keywordtype}{string}* deferredContentLength = \textcolor{keyword}{nullptr};
503   \textcolor{keywordtype}{bool} hasTransferEncodingChunked = \textcolor{keyword}{false};
504   \textcolor{keywordtype}{bool} hasDateHeader = \textcolor{keyword}{false};
505   \textcolor{keywordtype}{bool} hasUpgradeHeader = \textcolor{keyword}{false};
506   std::vector<StringPiece> connectionTokens;
507   \textcolor{keywordtype}{size\_t} lastConnectionToken = 0;
508   \textcolor{keywordtype}{bool} egressWebsocketUpgrade = msg.isEgressWebsocketUpgrade();
509   \textcolor{keywordtype}{bool} hasUpgradeTokeninConnection = \textcolor{keyword}{false};
510   msg.getHeaders().forEachWithCode([&] (HTTPHeaderCode code,
511                                         \textcolor{keyword}{const} \textcolor{keywordtype}{string}& header,
512                                         \textcolor{keyword}{const} \textcolor{keywordtype}{string}& value) \{
513     \textcolor{keywordflow}{if} (code == HTTP\_HEADER\_CONTENT\_LENGTH) \{
514       \textcolor{comment}{// Write the Content-Length last (t1071703)}
515       deferredContentLength = &value;
516       \textcolor{keywordflow}{return}; \textcolor{comment}{// continue}
517     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (code == HTTP\_HEADER\_CONNECTION && (!is1xxResponse_ ||
518         egressWebsocketUpgrade)) \{
519       \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{string} kClose = \textcolor{stringliteral}{"close"};
520       \textcolor{keyword}{static} \textcolor{keyword}{const} \textcolor{keywordtype}{string} kKeepAlive = \textcolor{stringliteral}{"keep-alive"};
521       folly::split(\textcolor{charliteral}{','}, value, connectionTokens);
522       \textcolor{keywordflow}{for} (\textcolor{keyword}{auto} curConnectionToken = lastConnectionToken;
523            curConnectionToken < connectionTokens.size();
524            curConnectionToken++) \{
525         \textcolor{keyword}{auto} token = trimWhitespace(connectionTokens[curConnectionToken]);
526         \textcolor{keywordflow}{if} (caseInsensitiveEqual(token, \textcolor{stringliteral}{"upgrade"})) \{
527           hasUpgradeTokeninConnection = \textcolor{keyword}{true};
528         \}
529         \textcolor{keywordflow}{if} (caseInsensitiveEqual(token, kClose)) \{
530           keepalive_ = \textcolor{keyword}{false};
531         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!caseInsensitiveEqual(token, kKeepAlive)) \{
532           connectionTokens[lastConnectionToken++] = token;
533         \} \textcolor{comment}{// else eat the keep-alive token}
534       \}
535       connectionTokens.resize(lastConnectionToken);
536       \textcolor{comment}{// We'll generate a new Connection header based on the keepalive\_ state}
537       \textcolor{keywordflow}{return};
538     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (code == HTTP\_HEADER\_UPGRADE && txn == 1) \{
539       hasUpgradeHeader = \textcolor{keyword}{true};
540       \textcolor{keywordflow}{if} (upstream) \{
541         \textcolor{comment}{// save in case we get a 101 Switching Protocols}
542         upgradeHeader_ = value;
543       \}
544     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!hasTransferEncodingChunked &&
545                code == HTTP\_HEADER\_TRANSFER\_ENCODING) \{
546       \textcolor{keywordflow}{if} (!caseInsensitiveEqual(value, kChunked)) \{
547         \textcolor{keywordflow}{return};
548       \}
549       hasTransferEncodingChunked = \textcolor{keyword}{true};
550       \textcolor{keywordflow}{if} (!mayChunkEgress_) \{
551         \textcolor{keywordflow}{return};
552       \}
553     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!hasDateHeader && code == HTTP\_HEADER\_DATE) \{
554       hasDateHeader = \textcolor{keyword}{true};
555     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (egressWebsocketUpgrade &&
556         code == HTTP\_HEADER\_SEC\_WEBSOCKET\_KEY) \{
557       \textcolor{comment}{// will generate our own key per hop, not client's.}
558       \textcolor{keywordflow}{return};
559     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (egressWebsocketUpgrade &&
560         code == HTTP\_HEADER\_SEC\_WEBSOCKET\_ACCEPT) \{
561       \textcolor{comment}{// will generate our own accept per hop, not client's.}
562       \textcolor{keywordflow}{return};
563     \}
564     \textcolor{keywordtype}{size\_t} lineLen = header.length() + value.length() + 4; \textcolor{comment}{// 4 for ": " + CRLF}
565     \textcolor{keyword}{auto} writable = writeBuf.preallocate(lineLen,
566         std::max(lineLen, \textcolor{keywordtype}{size\_t}(2000)));
567     \textcolor{keywordtype}{char}* dst = (\textcolor{keywordtype}{char}*)writable.first;
568     memcpy(dst, header.data(), header.length());
569     dst += header.length();
570     *dst++ = \textcolor{charliteral}{':'};
571     *dst++ = \textcolor{charliteral}{' '};
572     memcpy(dst, value.data(), value.length());
573     dst += value.length();
574     *dst++ = \textcolor{charliteral}{'\(\backslash\)r'};
575     *dst = \textcolor{charliteral}{'\(\backslash\)n'};
576     DCHECK\_EQ(\textcolor{keywordtype}{size\_t}(++dst - (\textcolor{keywordtype}{char}*)writable.first), lineLen);
577     writeBuf.postallocate(lineLen);
578     len += lineLen;
579   \});
580   \textcolor{keywordtype}{bool} bodyCheck =
581     (downstream && keepalive_ && !expectNoResponseBody_ && !egressUpgrade_) ||
582     \textcolor{comment}{// auto chunk POSTs and any request that came to us chunked}
583     (upstream && ((msg.getMethod() == HTTPMethod::POST) || egressChunked_));
584   \textcolor{comment}{// TODO: 400 a 1.0 POST with no content-length}
585   \textcolor{comment}{// clear egressChunked\_ if the header wasn't actually set}
586   egressChunked_ &= hasTransferEncodingChunked;
587   \textcolor{keywordflow}{if} (bodyCheck && !egressChunked_ && !deferredContentLength) \{
588     \textcolor{comment}{// On a connection that would otherwise be eligible for keep-alive,}
589     \textcolor{comment}{// we're being asked to send a response message with no Content-Length,}
590     \textcolor{comment}{// no chunked encoding, and no special circumstances that would eliminate}
591     \textcolor{comment}{// the need for a response body. If the client supports chunking, turn}
592     \textcolor{comment}{// on chunked encoding now.  Otherwise, turn off keepalives on this}
593     \textcolor{comment}{// connection.}
594     \textcolor{keywordflow}{if} (!hasTransferEncodingChunked && mayChunkEgress_) \{
595       appendLiteral(writeBuf, len, \textcolor{stringliteral}{"Transfer-Encoding: chunked\(\backslash\)r\(\backslash\)n"});
596       egressChunked_ = \textcolor{keyword}{true};
597     \} \textcolor{keywordflow}{else} \{
598       keepalive_ = \textcolor{keyword}{false};
599     \}
600   \}
601   \textcolor{keywordflow}{if} (downstream && !hasDateHeader) \{
602     addDateHeader(writeBuf, len);
603   \}
604 
605   \textcolor{comment}{// websocket headers}
606   \textcolor{keywordflow}{if} (msg.isEgressWebsocketUpgrade()) \{
607     \textcolor{keywordflow}{if} (!hasUpgradeHeader && txn == 1) \{
608       \textcolor{comment}{// upgradeHeader\_ is set in serializeWwebsocketHeader for requests.}
609       serializeWebsocketHeader(writeBuf, len, upstream);
610       \textcolor{keywordflow}{if} (!hasUpgradeTokeninConnection) \{
611         connectionTokens.push\_back(kUpgradeConnectionToken);
612         lastConnectionToken++;
613       \}
614     \} \textcolor{keywordflow}{else} \{
615       LOG(ERROR) << folly::to<string>(\textcolor{stringliteral}{"Not serializing headers. "}
616           \textcolor{stringliteral}{"Upgrade headers present/txn: "},
617           hasUpgradeHeader, txn);
618     \}
619   \}
620 
621   \textcolor{keywordflow}{if} (!is1xxResponse_ || upstream || !connectionTokens.empty()) \{
622     \textcolor{comment}{// We don't seem to add keep-alive/close and let the application add any}
623     \textcolor{comment}{// for 1xx responses.}
624     appendLiteral(writeBuf, len, \textcolor{stringliteral}{"Connection: "});
625     \textcolor{keywordflow}{if} (connectionTokens.size() > 0) \{
626       appendString(writeBuf, len, folly::join(\textcolor{stringliteral}{", "}, connectionTokens));
627     \}
628     \textcolor{keywordflow}{if} (!is1xxResponse_) \{
629       \textcolor{keywordflow}{if} (connectionTokens.size() > 0) \{
630         appendString(writeBuf, len, \textcolor{stringliteral}{", "});
631       \}
632       \textcolor{keywordflow}{if} (keepalive_) \{
633         appendLiteral(writeBuf, len, \textcolor{stringliteral}{"keep-alive"});
634       \} \textcolor{keywordflow}{else} \{
635         appendLiteral(writeBuf, len, \textcolor{stringliteral}{"close"});
636       \}
637     \}
638     appendLiteral(writeBuf, len, \textcolor{stringliteral}{"\(\backslash\)r\(\backslash\)n"});
639   \}
640 
641   \textcolor{keywordflow}{if} (deferredContentLength) \{
642     appendLiteral(writeBuf, len, \textcolor{stringliteral}{"Content-Length: "});
643     appendString(writeBuf, len, *deferredContentLength);
644     appendLiteral(writeBuf, len, CRLF);
645   \}
646   appendLiteral(writeBuf, len, CRLF);
647   \textcolor{keywordflow}{if} (eom) \{
648     len += generateEOM(writeBuf, txn);
649   \}
650 
651   \textcolor{keywordflow}{if} (size) \{
652     size->compressed = 0;
653     size->uncompressed = len;
654   \}
655 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!generate\+Rst\+Stream@{generate\+Rst\+Stream}}
\index{generate\+Rst\+Stream@{generate\+Rst\+Stream}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{generate\+Rst\+Stream(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D txn, Error\+Code status\+Code) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P1x\+Codec\+::generate\+Rst\+Stream (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream, }
\item[{{\bf Error\+Code}}]{code}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP1xCodec_ab69a27d92f362ab0668cc7e9ed5ce2d9}
Generate any protocol framing needed to abort a stream. \begin{DoxyReturn}{Returns}
number of bytes written 
\end{DoxyReturn}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_adfb41670b50d0608a8beb934494109be}.



Definition at line 782 of file H\+T\+T\+P1x\+Codec.\+cpp.



References disable\+Keepalive\+Pending\+\_\+.



Referenced by supports\+Push\+Transactions().


\begin{DoxyCode}
784                                                    \{
785   \textcolor{comment}{// statusCode ignored for HTTP/1.1}
786   \textcolor{comment}{// We won't be able to send anything else on the transport after this.}
787   disableKeepalivePending_ = \textcolor{keyword}{true};
788   \textcolor{keywordflow}{return} 0;
789 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!generate\+Trailers@{generate\+Trailers}}
\index{generate\+Trailers@{generate\+Trailers}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{generate\+Trailers(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, Stream\+I\+D txn, const H\+T\+T\+P\+Headers \&trailers) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P1x\+Codec\+::generate\+Trailers (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{{\bf Stream\+ID}}]{stream, }
\item[{const {\bf H\+T\+T\+P\+Headers} \&}]{trailers}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP1xCodec_abbf26ac9719d15f2cfa3b30f409c266b}
Write the message trailers \begin{DoxyReturn}{Returns}
number of bytes written 
\end{DoxyReturn}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a097d1fa44f042101b2eeeb775de65289}.



Definition at line 733 of file H\+T\+T\+P1x\+Codec.\+cpp.



References append\+Literal, egress\+Chunked\+\_\+, egress\+Txn\+I\+D\+\_\+, proxygen\+::\+H\+T\+T\+P\+Headers\+::for\+Each(), in\+Chunk\+\_\+, and last\+Chunk\+Written\+\_\+.



Referenced by supports\+Push\+Transactions(), and T\+E\+S\+T().


\begin{DoxyCode}
735                                                            \{
736   DCHECK\_EQ(txn, egressTxnID_);
737   \textcolor{keywordtype}{size\_t} len = 0;
738   \textcolor{keywordflow}{if} (egressChunked_) \{
739     CHECK(!inChunk_);
740     appendLiteral(writeBuf, len, \textcolor{stringliteral}{"0\(\backslash\)r\(\backslash\)n"});
741     lastChunkWritten_ = \textcolor{keyword}{true};
742     trailers.forEach([&] (\textcolor{keyword}{const} \textcolor{keywordtype}{string}& trailer, \textcolor{keyword}{const} \textcolor{keywordtype}{string}& value) \{
743       appendString(writeBuf, len, trailer);
744       appendLiteral(writeBuf, len, \textcolor{stringliteral}{": "});
745       appendString(writeBuf, len, value);
746       appendLiteral(writeBuf, len, CRLF);
747     \});
748   \}
749   \textcolor{keywordflow}{return} len;
750 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!generate\+Websocket\+Accept@{generate\+Websocket\+Accept}}
\index{generate\+Websocket\+Accept@{generate\+Websocket\+Accept}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{generate\+Websocket\+Accept(const std\+::string \&accept\+Key) const }]{\setlength{\rightskip}{0pt plus 5cm}std\+::string proxygen\+::\+H\+T\+T\+P1x\+Codec\+::generate\+Websocket\+Accept (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{accept\+Key}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_ab851dab320da9ede29f7cd7cd85f44cd}


Definition at line 326 of file H\+T\+T\+P1x\+Codec.\+cpp.



References proxygen\+::\+Base64\+::encode(), and proxygen\+::k\+W\+S\+Magic\+String.



Referenced by on\+Headers\+Complete(), and serialize\+Websocket\+Header().


\begin{DoxyCode}
326                                                                \{
327   folly::ssl::OpenSSLHash::Digest digest;
328   digest.hash\_init(EVP\_sha1());
329   digest.hash\_update(folly::StringPiece(key));
330   digest.hash\_update(kWSMagicString);
331   std::array<unsigned char, 20> arr;
332   folly::MutableByteRange accept(arr.data(), arr.size());
333   digest.hash\_final(accept);
334   \textcolor{keywordflow}{return} Base64::encode(accept);
335 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!generate\+Websocket\+Key@{generate\+Websocket\+Key}}
\index{generate\+Websocket\+Key@{generate\+Websocket\+Key}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{generate\+Websocket\+Key() const }]{\setlength{\rightskip}{0pt plus 5cm}std\+::string proxygen\+::\+H\+T\+T\+P1x\+Codec\+::generate\+Websocket\+Key (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_abf2a33ee60834bae58a98169c56899fb}


Definition at line 319 of file H\+T\+T\+P1x\+Codec.\+cpp.



References proxygen\+::\+Base64\+::encode().



Referenced by serialize\+Websocket\+Header().


\begin{DoxyCode}
319                                         \{
320   std::array<unsigned char, 16> arr;
321   folly::Random::secureRandom(arr.data(), arr.size());
322   \textcolor{keywordflow}{return} Base64::encode(folly::ByteRange(arr.data(), arr.size()));
323 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!get\+Allowed\+Upgrade\+Protocols@{get\+Allowed\+Upgrade\+Protocols}}
\index{get\+Allowed\+Upgrade\+Protocols@{get\+Allowed\+Upgrade\+Protocols}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{get\+Allowed\+Upgrade\+Protocols()}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string \& proxygen\+::\+H\+T\+T\+P1x\+Codec\+::get\+Allowed\+Upgrade\+Protocols (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTP1xCodec_a3b8cb1f3df8906a9fa46097b9f0dbf46}


Definition at line 812 of file H\+T\+T\+P1x\+Codec.\+cpp.



References allowed\+Native\+Upgrades\+\_\+.



Referenced by supports\+Push\+Transactions(), and T\+E\+S\+T().


\begin{DoxyCode}
812                                                          \{
813   \textcolor{keywordflow}{return} allowedNativeUpgrades_;
814 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!get\+Parser\+Settings@{get\+Parser\+Settings}}
\index{get\+Parser\+Settings@{get\+Parser\+Settings}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{get\+Parser\+Settings()}]{\setlength{\rightskip}{0pt plus 5cm}const {\bf http\+\_\+parser\+\_\+settings} $\ast$ proxygen\+::\+H\+T\+T\+P1x\+Codec\+::get\+Parser\+Settings (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a937e7f3fd64e9a9f974621ac1b40b1d3}


Definition at line 158 of file H\+T\+T\+P1x\+Codec.\+cpp.



References http\+\_\+parser\+\_\+settings\+::on\+\_\+body, http\+\_\+parser\+\_\+settings\+::on\+\_\+chunk\+\_\+complete, http\+\_\+parser\+\_\+settings\+::on\+\_\+chunk\+\_\+header, http\+\_\+parser\+\_\+settings\+::on\+\_\+header\+\_\+field, http\+\_\+parser\+\_\+settings\+::on\+\_\+header\+\_\+value, http\+\_\+parser\+\_\+settings\+::on\+\_\+headers\+\_\+complete, http\+\_\+parser\+\_\+settings\+::on\+\_\+message\+\_\+begin, http\+\_\+parser\+\_\+settings\+::on\+\_\+message\+\_\+complete, http\+\_\+parser\+\_\+settings\+::on\+\_\+reason, http\+\_\+parser\+\_\+settings\+::on\+\_\+url, on\+Body\+C\+B(), on\+Chunk\+Complete\+C\+B(), on\+Chunk\+Header\+C\+B(), on\+Header\+Field\+C\+B(), on\+Headers\+Complete\+C\+B(), on\+Header\+Value\+C\+B(), on\+Message\+Begin\+C\+B(), on\+Message\+Complete\+C\+B(), on\+Reason\+C\+B(), and on\+Url\+C\+B().



Referenced by on\+Ingress(), and on\+Ingress\+E\+O\+F().


\begin{DoxyCode}
158                                                            \{
159   \textcolor{keyword}{static} http_parser_settings parserSettings = [] \{
160     http_parser_settings st;
161     st.on_message_begin = HTTP1xCodec::onMessageBeginCB;
162     st.on_url = HTTP1xCodec::onUrlCB;
163     st.on_header_field = HTTP1xCodec::onHeaderFieldCB;
164     st.on_header_value = HTTP1xCodec::onHeaderValueCB;
165     st.on_headers_complete = HTTP1xCodec::onHeadersCompleteCB;
166     st.on_body = HTTP1xCodec::onBodyCB;
167     st.on_message_complete = HTTP1xCodec::onMessageCompleteCB;
168     st.on_reason = HTTP1xCodec::onReasonCB;
169     st.on_chunk_header = HTTP1xCodec::onChunkHeaderCB;
170     st.on_chunk_complete = HTTP1xCodec::onChunkCompleteCB;
171     \textcolor{keywordflow}{return} st;
172   \}();
173   \textcolor{keywordflow}{return} &parserSettings;
174 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!get\+Protocol@{get\+Protocol}}
\index{get\+Protocol@{get\+Protocol}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{get\+Protocol() const override}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Codec\+Protocol} proxygen\+::\+H\+T\+T\+P1x\+Codec\+::get\+Protocol (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP1xCodec_a3eb13af0276cb480a35426440c37eb52}
Gets the session protocol currently used by the codec. This can be mapped to a string for logging and diagnostic use. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a3818f5333dbb3c19312984ac5f069969}.



Definition at line 36 of file H\+T\+T\+P1x\+Codec.\+h.



References proxygen\+::\+H\+T\+T\+P\+\_\+1\+\_\+1.



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
36                                              \{
37     \textcolor{keywordflow}{return} CodecProtocol::HTTP_1_1;
38   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!get\+Transport\+Direction@{get\+Transport\+Direction}}
\index{get\+Transport\+Direction@{get\+Transport\+Direction}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{get\+Transport\+Direction() const override}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Transport\+Direction} proxygen\+::\+H\+T\+T\+P1x\+Codec\+::get\+Transport\+Direction (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP1xCodec_ad2f3debb34c2cabcf497d149e022254d}
Get the transport direction of this codec\+: D\+O\+W\+N\+S\+T\+R\+E\+AM if the codec receives requests from clients or U\+P\+S\+T\+R\+E\+AM if the codec sends requests to servers. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_ae629d52a90a0a7f753e178bb0f3c973e}.



Definition at line 44 of file H\+T\+T\+P1x\+Codec.\+h.



References create\+Stream(), and transport\+Direction\+\_\+.


\begin{DoxyCode}
44                                                             \{
45     \textcolor{keywordflow}{return} transportDirection_;
46   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!get\+User\+Agent@{get\+User\+Agent}}
\index{get\+User\+Agent@{get\+User\+Agent}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{get\+User\+Agent() const override}]{\setlength{\rightskip}{0pt plus 5cm}const std\+::string\& proxygen\+::\+H\+T\+T\+P1x\+Codec\+::get\+User\+Agent (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP1xCodec_a275b18f84036733a84e43f9c69f9be28}
Gets the user agent string of the client. Thus, it is only meaningful for a D\+O\+W\+N\+S\+T\+R\+E\+AM session. Note that the value is available after \doxyref{on\+Headers\+Complete()}{p.}{classproxygen_1_1HTTP1xCodec_a27676fab5714bed165565d49eceddf17}. It can help in diagnosing the interactions between different codec implementation. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a0fc1b54808088c79076892d0d0d53275}.



Definition at line 40 of file H\+T\+T\+P1x\+Codec.\+h.



References user\+Agent\+\_\+.


\begin{DoxyCode}
40                                                  \{
41     \textcolor{keywordflow}{return} userAgent_;
42   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!is\+Busy@{is\+Busy}}
\index{is\+Busy@{is\+Busy}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{is\+Busy() const override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::is\+Busy (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP1xCodec_a67a49333e17aa867d1e2daf7dcfa6dd3}
Check whether the codec still has at least one H\+T\+TP stream to parse. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a342e3fd380c692a9ed1d9ad11ac73185}.



Definition at line 301 of file H\+T\+T\+P1x\+Codec.\+cpp.



References request\+Pending\+\_\+, and response\+Pending\+\_\+.



Referenced by set\+Callback().


\begin{DoxyCode}
301                           \{
302   \textcolor{keywordflow}{return} requestPending_ || responsePending_;
303 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!is\+Parsing\+Header\+Or\+Trailer\+Name@{is\+Parsing\+Header\+Or\+Trailer\+Name}}
\index{is\+Parsing\+Header\+Or\+Trailer\+Name@{is\+Parsing\+Header\+Or\+Trailer\+Name}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{is\+Parsing\+Header\+Or\+Trailer\+Name() const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::is\+Parsing\+Header\+Or\+Trailer\+Name (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a6577e396b22d82fed0ed77ad88aa7bde}
Check whether we\textquotesingle{}re currently parsing ingress header-\/or-\/trailer name 

Definition at line 131 of file H\+T\+T\+P1x\+Codec.\+h.



References header\+Parse\+State\+\_\+, k\+Parsing\+Header\+Name, k\+Parsing\+Trailer\+Name, on\+Body(), on\+Chunk\+Complete(), on\+Chunk\+Header(), on\+Header\+Field(), on\+Headers\+Complete(), on\+Header\+Value(), on\+Message\+Begin(), on\+Message\+Complete(), on\+Parser\+Error(), on\+Reason(), on\+U\+R\+L(), push\+Header\+Name\+And\+Value(), and serialize\+Websocket\+Header().



Referenced by on\+Header\+Field().


\begin{DoxyCode}
131                                             \{
132     \textcolor{keywordflow}{return} (headerParseState_ == HeaderParseState::kParsingHeaderName) ||
133         (headerParseState_ == HeaderParseState::kParsingTrailerName);
134   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!is\+Parsing\+Headers@{is\+Parsing\+Headers}}
\index{is\+Parsing\+Headers@{is\+Parsing\+Headers}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{is\+Parsing\+Headers() const }]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::is\+Parsing\+Headers (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_aa76d3057282665324de7520db9555d65}
Check whether we\textquotesingle{}re currently parsing ingress message headers 

Definition at line 125 of file H\+T\+T\+P1x\+Codec.\+h.



References header\+Parse\+State\+\_\+, k\+Parsing\+Header\+Idle, and k\+Parsing\+Headers\+Complete.



Referenced by on\+Body(), on\+Header\+Value(), and on\+Message\+Complete().


\begin{DoxyCode}
125                                 \{
126     \textcolor{keywordflow}{return} (headerParseState_ > HeaderParseState::kParsingHeaderIdle) &&
127        (headerParseState_ < HeaderParseState::kParsingHeadersComplete);
128   \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!is\+Reusable@{is\+Reusable}}
\index{is\+Reusable@{is\+Reusable}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{is\+Reusable() const override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::is\+Reusable (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP1xCodec_a892c4d6d8e0f1e42f636978e8eb8f010}
Check whether the codec can process new streams. Typically, an implementing subclass will return true when a new codec is created and false once it encounters a situation that would prevent reuse of the underlying transport (e.\+g., a \char`\"{}\+Connection\+: close\char`\"{} in H\+T\+T\+P/1.\+x). \begin{DoxyNote}{Note}
A return value of true means that the codec can process new connections at some reasonable point in the future; that may mean \char`\"{}immediately,\char`\"{} for codecs that support pipelined or interleaved requests, or \char`\"{}upon completion of the current
      stream\char`\"{} for codecs that do not. 
\end{DoxyNote}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a66436379f33e2510871cadeb4512f0b5}.



Definition at line 295 of file H\+T\+T\+P1x\+Codec.\+cpp.



References egress\+Upgrade\+\_\+, ingress\+Upgrade\+\_\+, keepalive\+\_\+, parser\+Error\+\_\+, and websock\+Accept\+Key\+\_\+.



Referenced by set\+Callback().


\begin{DoxyCode}
295                               \{
296   \textcolor{keywordflow}{return} keepalive_ && !egressUpgrade_ && !ingressUpgrade_ && !parserError_ &&
297     websockAcceptKey_.empty();
298 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!is\+Waiting\+To\+Drain@{is\+Waiting\+To\+Drain}}
\index{is\+Waiting\+To\+Drain@{is\+Waiting\+To\+Drain}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{is\+Waiting\+To\+Drain() const override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::is\+Waiting\+To\+Drain (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP1xCodec_a9640bab3af67e39e9ab05b3548365f64}
Returns true if this codec is in a state where it accepting new requests but will soon begin to reject new requests. For S\+P\+DY and H\+T\+T\+P/2, this is true when the first G\+O\+A\+W\+AY N\+O\+\_\+\+E\+R\+R\+OR is sent during graceful shutdown. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a844f3bc01e7c20a70da5b67deffb021a}.



Definition at line 54 of file H\+T\+T\+P1x\+Codec.\+h.


\begin{DoxyCode}
54 \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!make\+Response\+Codec@{make\+Response\+Codec}}
\index{make\+Response\+Codec@{make\+Response\+Codec}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{make\+Response\+Codec(bool may\+Chunk\+Egress)}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P1x\+Codec} proxygen\+::\+H\+T\+T\+P1x\+Codec\+::make\+Response\+Codec (
\begin{DoxyParamCaption}
\item[{bool}]{may\+Chunk\+Egress}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classproxygen_1_1HTTP1xCodec_ae2f1ae2af663dd3c68230efe64ab6f6d}


Definition at line 1384 of file H\+T\+T\+P1x\+Codec.\+cpp.



References proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, and may\+Chunk\+Egress\+\_\+.



Referenced by T\+E\+S\+T().


\begin{DoxyCode}
1384                                                               \{
1385   HTTP1xCodec codec(TransportDirection::DOWNSTREAM);
1386   codec.mayChunkEgress\_ = mayChunkEgress;
1387   \textcolor{keywordflow}{return} codec;
1388 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+Body@{on\+Body}}
\index{on\+Body@{on\+Body}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+Body(const char $\ast$buf, size\+\_\+t len)}]{\setlength{\rightskip}{0pt plus 5cm}int proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Body (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{buf, }
\item[{size\+\_\+t}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_aaa6db664b9ac8c764246138515b76a1e}


Definition at line 1144 of file H\+T\+T\+P1x\+Codec.\+cpp.



References callback\+\_\+, current\+Ingress\+Buf\+\_\+, ingress\+Txn\+I\+D\+\_\+, in\+Recv\+Last\+Chunk\+\_\+, is\+Parsing\+Headers(), and proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Body().



Referenced by is\+Parsing\+Header\+Or\+Trailer\+Name(), and on\+Body\+C\+B().


\begin{DoxyCode}
1144                                                \{
1145   DCHECK(!isParsingHeaders());
1146   DCHECK(!inRecvLastChunk_);
1147   CHECK\_NOTNULL(currentIngressBuf_);
1148   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* dataStart = (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)currentIngressBuf_->data();
1149   \textcolor{keyword}{const} \textcolor{keywordtype}{char}* dataEnd = dataStart + currentIngressBuf_->length();
1150   DCHECK\_GE(buf, dataStart);
1151   DCHECK\_LE(buf + len, dataEnd);
1152   unique\_ptr<IOBuf> clone(currentIngressBuf_->cloneOne());
1153   clone->trimStart(buf - dataStart);
1154   clone->trimEnd(dataEnd - (buf + len));
1155   DCHECK\_EQ(len, clone->computeChainDataLength());
1156   callback_->onBody(ingressTxnID_, std::move(clone), 0);
1157   \textcolor{keywordflow}{return} 0;
1158 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+Body\+CB@{on\+Body\+CB}}
\index{on\+Body\+CB@{on\+Body\+CB}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+Body\+C\+B(http\+\_\+parser $\ast$parser, const char $\ast$buf, size\+\_\+t len)}]{\setlength{\rightskip}{0pt plus 5cm}int proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Body\+CB (
\begin{DoxyParamCaption}
\item[{{\bf http\+\_\+parser} $\ast$}]{parser, }
\item[{const char $\ast$}]{buf, }
\item[{size\+\_\+t}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a60bea5692808b138c83bab7f6a5aa640}


Definition at line 1321 of file H\+T\+T\+P1x\+Codec.\+cpp.



References http\+\_\+parser\+::data, on\+Body(), on\+Parser\+Error(), and parser\+\_\+.



Referenced by get\+Parser\+Settings().


\begin{DoxyCode}
1321                                                                       \{
1322   HTTP1xCodec* codec = \textcolor{keyword}{static\_cast<}HTTP1xCodec*\textcolor{keyword}{>}(parser->data);
1323   DCHECK(codec != \textcolor{keyword}{nullptr});
1324   DCHECK\_EQ(&codec->parser\_, parser);
1325 
1326   \textcolor{keywordflow}{try} \{
1327     \textcolor{keywordflow}{return} codec->onBody(buf, len);
1328   \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} std::exception& ex) \{
1329     \textcolor{comment}{// Note: http\_parser appears to completely ignore the return value from the}
1330     \textcolor{comment}{// on\_body() callback.  There seems to be no way to abort parsing after an}
1331     \textcolor{comment}{// error in on\_body().}
1332     \textcolor{comment}{//}
1333     \textcolor{comment}{// We handle this by checking if error\_ is set after each call to}
1334     \textcolor{comment}{// http\_parser\_execute().}
1335     codec->onParserError(ex.what());
1336     \textcolor{keywordflow}{return} 1;
1337   \}
1338 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+Chunk\+Complete@{on\+Chunk\+Complete}}
\index{on\+Chunk\+Complete@{on\+Chunk\+Complete}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+Chunk\+Complete()}]{\setlength{\rightskip}{0pt plus 5cm}int proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Chunk\+Complete (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a8814e48056043e52cdf5f529ed3f5a10}


Definition at line 1171 of file H\+T\+T\+P1x\+Codec.\+cpp.



References callback\+\_\+, ingress\+Txn\+I\+D\+\_\+, in\+Recv\+Last\+Chunk\+\_\+, and proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Chunk\+Complete().



Referenced by is\+Parsing\+Header\+Or\+Trailer\+Name(), and on\+Chunk\+Complete\+C\+B().


\begin{DoxyCode}
1171                                  \{
1172   \textcolor{keywordflow}{if} (inRecvLastChunk_) \{
1173     inRecvLastChunk_ = \textcolor{keyword}{false};
1174   \} \textcolor{keywordflow}{else} \{
1175     callback_->onChunkComplete(ingressTxnID_);
1176   \}
1177   \textcolor{keywordflow}{return} 0;
1178 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+Chunk\+Complete\+CB@{on\+Chunk\+Complete\+CB}}
\index{on\+Chunk\+Complete\+CB@{on\+Chunk\+Complete\+CB}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+Chunk\+Complete\+C\+B(http\+\_\+parser $\ast$parser)}]{\setlength{\rightskip}{0pt plus 5cm}int proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Chunk\+Complete\+CB (
\begin{DoxyParamCaption}
\item[{{\bf http\+\_\+parser} $\ast$}]{parser}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a3bfe0830b0aa3154be0d3ced43691612}


Definition at line 1353 of file H\+T\+T\+P1x\+Codec.\+cpp.



References http\+\_\+parser\+::data, on\+Chunk\+Complete(), on\+Parser\+Error(), and parser\+\_\+.



Referenced by get\+Parser\+Settings().


\begin{DoxyCode}
1353                                                       \{
1354   HTTP1xCodec* codec = \textcolor{keyword}{static\_cast<}HTTP1xCodec*\textcolor{keyword}{>}(parser->data);
1355   DCHECK(codec != \textcolor{keyword}{nullptr});
1356   DCHECK\_EQ(&codec->parser\_, parser);
1357 
1358   \textcolor{keywordflow}{try} \{
1359     \textcolor{keywordflow}{return} codec->onChunkComplete();
1360   \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} std::exception& ex) \{
1361     codec->onParserError(ex.what());
1362     \textcolor{keywordflow}{return} 1;
1363   \}
1364 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+Chunk\+Header@{on\+Chunk\+Header}}
\index{on\+Chunk\+Header@{on\+Chunk\+Header}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+Chunk\+Header(size\+\_\+t len)}]{\setlength{\rightskip}{0pt plus 5cm}int proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Chunk\+Header (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a3c0d594db4269d761dee5c140f2833a0}


Definition at line 1160 of file H\+T\+T\+P1x\+Codec.\+cpp.



References callback\+\_\+, ingress\+Txn\+I\+D\+\_\+, in\+Recv\+Last\+Chunk\+\_\+, and proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Chunk\+Header().



Referenced by is\+Parsing\+Header\+Or\+Trailer\+Name(), and on\+Chunk\+Header\+C\+B().


\begin{DoxyCode}
1160                                          \{
1161   \textcolor{keywordflow}{if} (len > 0) \{
1162     callback_->onChunkHeader(ingressTxnID_, len);
1163   \} \textcolor{keywordflow}{else} \{
1164     VLOG(5) << \textcolor{stringliteral}{"Suppressed onChunkHeader callback for final zero length "}
1165             << \textcolor{stringliteral}{"chunk"};
1166     inRecvLastChunk_ = \textcolor{keyword}{true};
1167   \}
1168   \textcolor{keywordflow}{return} 0;
1169 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+Chunk\+Header\+CB@{on\+Chunk\+Header\+CB}}
\index{on\+Chunk\+Header\+CB@{on\+Chunk\+Header\+CB}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+Chunk\+Header\+C\+B(http\+\_\+parser $\ast$parser)}]{\setlength{\rightskip}{0pt plus 5cm}int proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Chunk\+Header\+CB (
\begin{DoxyParamCaption}
\item[{{\bf http\+\_\+parser} $\ast$}]{parser}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a03706b0ec9b56c24ea39c5c0b1ea8f03}


Definition at line 1340 of file H\+T\+T\+P1x\+Codec.\+cpp.



References http\+\_\+parser\+::content\+\_\+length, http\+\_\+parser\+::data, on\+Chunk\+Header(), on\+Parser\+Error(), and parser\+\_\+.



Referenced by get\+Parser\+Settings().


\begin{DoxyCode}
1340                                                     \{
1341   HTTP1xCodec* codec = \textcolor{keyword}{static\_cast<}HTTP1xCodec*\textcolor{keyword}{>}(parser->data);
1342   DCHECK(codec != \textcolor{keyword}{nullptr});
1343   DCHECK\_EQ(&codec->parser\_, parser);
1344 
1345   \textcolor{keywordflow}{try} \{
1346     \textcolor{keywordflow}{return} codec->onChunkHeader(parser->content_length);
1347   \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} std::exception& ex) \{
1348     codec->onParserError(ex.what());
1349     \textcolor{keywordflow}{return} 1;
1350   \}
1351 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+Header\+Field@{on\+Header\+Field}}
\index{on\+Header\+Field@{on\+Header\+Field}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+Header\+Field(const char $\ast$buf, size\+\_\+t len)}]{\setlength{\rightskip}{0pt plus 5cm}int proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Header\+Field (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{buf, }
\item[{size\+\_\+t}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a8c401635a6996807302ff2b59086e082}


Definition at line 866 of file H\+T\+T\+P1x\+Codec.\+cpp.



References current\+Header\+Name\+\_\+, current\+Header\+Name\+String\+Piece\+\_\+, header\+Parse\+State\+\_\+, is\+Parsing\+Header\+Or\+Trailer\+Name(), k\+Parsing\+Header\+Name, k\+Parsing\+Headers\+Complete, k\+Parsing\+Header\+Value, k\+Parsing\+Trailer\+Name, k\+Parsing\+Trailer\+Value, msg\+\_\+, push\+Header\+Name\+And\+Value(), and trailers\+\_\+.



Referenced by is\+Parsing\+Header\+Or\+Trailer\+Name(), and on\+Header\+Field\+C\+B().


\begin{DoxyCode}
866                                                       \{
867   \textcolor{keywordflow}{if} (headerParseState_ == HeaderParseState::kParsingHeaderValue) \{
868     pushHeaderNameAndValue(msg_->getHeaders());
869   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (headerParseState_ == HeaderParseState::kParsingTrailerValue) \{
870     \textcolor{keywordflow}{if} (!trailers_) \{
871       trailers_.reset(\textcolor{keyword}{new} HTTPHeaders());
872     \}
873     pushHeaderNameAndValue(*trailers_);
874   \}
875 
876   \textcolor{keywordflow}{if} (isParsingHeaderOrTrailerName()) \{
877 
878     \textcolor{comment}{// we're already parsing a header name}
879     \textcolor{keywordflow}{if} (currentHeaderName_.empty()) \{
880       \textcolor{comment}{// but we've been keeping it in currentHeaderNameStringPiece\_ until now}
881       \textcolor{keywordflow}{if} (currentHeaderNameStringPiece_.end() == buf) \{
882         \textcolor{comment}{// the header name we are currently reading is contiguous in memory,}
883         \textcolor{comment}{// and so we just adjust the right end of our StringPiece;}
884         \textcolor{comment}{// this is likely because onIngress() hasn't been called since we got}
885         \textcolor{comment}{// the previous chunk (otherwise currentHeaderName\_ would be nonempty)}
886         currentHeaderNameStringPiece_.advance(len);
887       \} \textcolor{keywordflow}{else} \{
888         \textcolor{comment}{// this is just for safety - if for any reason there is a discontinuity}
889         \textcolor{comment}{// even though we are during the same onIngress() call,}
890         \textcolor{comment}{// we fall back to currentHeaderName\_}
891         currentHeaderName_.assign(currentHeaderNameStringPiece_.begin(),
892                                   currentHeaderNameStringPiece_.size());
893         currentHeaderName_.append(buf, len);
894       \}
895     \} \textcolor{keywordflow}{else} \{
896       \textcolor{comment}{// we had already fallen back to currentHeaderName\_ before}
897       currentHeaderName_.append(buf, len);
898     \}
899 
900   \} \textcolor{keywordflow}{else} \{
901     \textcolor{comment}{// we're not yet parsing a header name - this is the first chunk}
902     \textcolor{comment}{// (typically, there is only one)}
903     currentHeaderNameStringPiece_.reset(buf, len);
904 
905     \textcolor{keywordflow}{if} (headerParseState_ >= HeaderParseState::kParsingHeadersComplete) \{
906       headerParseState_ = HeaderParseState::kParsingTrailerName;
907     \} \textcolor{keywordflow}{else} \{
908       headerParseState_ = HeaderParseState::kParsingHeaderName;
909     \}
910   \}
911   \textcolor{keywordflow}{return} 0;
912 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+Header\+Field\+CB@{on\+Header\+Field\+CB}}
\index{on\+Header\+Field\+CB@{on\+Header\+Field\+CB}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+Header\+Field\+C\+B(http\+\_\+parser $\ast$parser, const char $\ast$buf, size\+\_\+t len)}]{\setlength{\rightskip}{0pt plus 5cm}int proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Header\+Field\+CB (
\begin{DoxyParamCaption}
\item[{{\bf http\+\_\+parser} $\ast$}]{parser, }
\item[{const char $\ast$}]{buf, }
\item[{size\+\_\+t}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_abf4c336913965080bde360251e80ed01}


Definition at line 1278 of file H\+T\+T\+P1x\+Codec.\+cpp.



References http\+\_\+parser\+::data, on\+Header\+Field(), on\+Parser\+Error(), and parser\+\_\+.



Referenced by get\+Parser\+Settings().


\begin{DoxyCode}
1278                                                                              \{
1279   HTTP1xCodec* codec = \textcolor{keyword}{static\_cast<}HTTP1xCodec*\textcolor{keyword}{>}(parser->data);
1280   DCHECK(codec != \textcolor{keyword}{nullptr});
1281   DCHECK\_EQ(&codec->parser\_, parser);
1282 
1283   \textcolor{keywordflow}{try} \{
1284     \textcolor{keywordflow}{return} codec->onHeaderField(buf, len);
1285   \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} std::exception& ex) \{
1286     codec->onParserError(ex.what());
1287     \textcolor{keywordflow}{return} 1;
1288   \}
1289 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+Headers\+Complete@{on\+Headers\+Complete}}
\index{on\+Headers\+Complete@{on\+Headers\+Complete}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+Headers\+Complete(size\+\_\+t len)}]{\setlength{\rightskip}{0pt plus 5cm}int proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Headers\+Complete (
\begin{DoxyParamCaption}
\item[{size\+\_\+t}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a27676fab5714bed165565d49eceddf17}


Definition at line 926 of file H\+T\+T\+P1x\+Codec.\+cpp.



References allowed\+Native\+Upgrades\+\_\+, callback\+\_\+, proxygen\+::case\+Insensitive\+Equal(), proxygen\+::check\+For\+Protocol\+Upgrade(), proxygen\+::\+C\+O\+N\+N\+E\+CT, connect\+Request\+\_\+, D\+I\+S\+A\+B\+L\+ED, proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, egress\+Upgrade\+\_\+, E\+N\+A\+B\+L\+ED, proxygen\+::\+E\+R\+R\+OR, expect\+No\+Response\+Body\+\_\+, F\+\_\+\+C\+H\+U\+N\+K\+ED, F\+\_\+\+U\+P\+G\+R\+A\+DE, http\+\_\+parser\+::flags, generate\+Websocket\+Accept(), proxygen\+::get\+Codec\+Protocol\+String(), proxygen\+::\+Parse\+U\+R\+L\+::has\+Host(), proxygen\+::\+H\+E\+AD, header\+Parse\+State\+\_\+, headers\+Complete\+\_\+, header\+Size\+\_\+, head\+Request\+\_\+, proxygen\+::\+Parse\+U\+R\+L\+::host\+And\+Port(), proxygen\+::\+H\+T\+T\+P\+\_\+1\+\_\+1, http\+\_\+parser\+::http\+\_\+major, http\+\_\+method\+\_\+str(), http\+\_\+parser\+::http\+\_\+minor, ingress\+Txn\+I\+D\+\_\+, ingress\+Upgrade\+\_\+, is1xx\+Response\+\_\+, keepalive\+\_\+, keepalive\+Requested\+\_\+, k\+Parsing\+Headers\+Complete, k\+Parsing\+Header\+Value, may\+Chunk\+Egress\+\_\+, http\+\_\+parser\+::method, msg\+\_\+, native\+Upgrade\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Headers\+Complete(), proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Native\+Protocol\+Upgrade(), parser\+\_\+, push\+Header\+Name\+And\+Value(), reason\+\_\+, proxygen\+::\+R\+F\+C2616\+::response\+Body\+Must\+Be\+Empty(), http\+\_\+parser\+::status\+\_\+code, transport\+Direction\+\_\+, U\+N\+S\+ET, http\+\_\+parser\+::upgrade, upgrade\+Header\+\_\+, upgrade\+Request\+\_\+, upgrade\+Result\+\_\+, proxygen\+::\+U\+P\+S\+T\+R\+E\+AM, url\+\_\+, user\+Agent\+\_\+, and websock\+Accept\+Key\+\_\+.



Referenced by is\+Parsing\+Header\+Or\+Trailer\+Name(), on\+Headers\+Complete\+C\+B(), and on\+Ingress().


\begin{DoxyCode}
926                                          \{
927   \textcolor{keywordflow}{if} (headerParseState_ == HeaderParseState::kParsingHeaderValue) \{
928     pushHeaderNameAndValue(msg_->getHeaders());
929   \}
930 
931   \textcolor{comment}{// discard messages with folded or multiple valued Transfer-Encoding headers}
932   \textcolor{comment}{// ex : "chunked , zorg\(\backslash\)r\(\backslash\)n" or "\(\backslash\)r\(\backslash\)n chunked \(\backslash\)r\(\backslash\)n" (t12767790)}
933   HTTPHeaders& hdrs = msg_->getHeaders();
934   \textcolor{keyword}{const} std::string& headerVal =
935     hdrs.getSingleOrEmpty(HTTP\_HEADER\_TRANSFER\_ENCODING);
936   \textcolor{keywordflow}{if} (!headerVal.empty() && !caseInsensitiveEqual(headerVal, kChunked)) \{
937       LOG(ERROR) << \textcolor{stringliteral}{"Invalid Transfer-Encoding header. Value ="} << headerVal;
938       \textcolor{keywordflow}{return} -1;
939   \}
940 
941   \textcolor{comment}{// discard messages with multiple content-length headers (t12767790)}
942   \textcolor{keywordflow}{if} (hdrs.getNumberOfValues(HTTP\_HEADER\_CONTENT\_LENGTH) > 1) \{
943     \textcolor{comment}{// Only reject the message if the Content-Length headers have different}
944     \textcolor{comment}{// values}
945     folly::Optional<folly::StringPiece> contentLen;
946     \textcolor{keywordtype}{bool} error = hdrs.forEachValueOfHeader(
947         HTTP\_HEADER\_CONTENT\_LENGTH, [&] (folly::StringPiece value) -> \textcolor{keywordtype}{bool} \{
948       \textcolor{keywordflow}{if} (!contentLen.hasValue()) \{
949         contentLen = value;
950         \textcolor{keywordflow}{return} \textcolor{keyword}{false};
951       \}
952       \textcolor{keywordflow}{return} (contentLen.value() != value);
953     \});
954 
955     \textcolor{keywordflow}{if} (error) \{
956       LOG(ERROR) << \textcolor{stringliteral}{"Invalid message, multiple Content-Length headers"};
957       \textcolor{keywordflow}{return} -1;
958     \}
959   \}
960 
961   \textcolor{comment}{// Update the HTTPMessage with the values parsed from the header}
962   msg_->setHTTPVersion(parser_.http_major, parser_.http_minor);
963   msg_->setIsChunked((parser_.flags & F_CHUNKED));
964 
965   \textcolor{keywordflow}{if} (transportDirection_ == TransportDirection::DOWNSTREAM) \{
966     \textcolor{comment}{// Set the method type}
967     msg_->setMethod(http_method_str(static\_cast<http\_method>(parser_.method)));
968 
969     connectRequest_ = (msg_->getMethod() == HTTPMethod::CONNECT);
970 
971     \textcolor{comment}{// If this is a headers-only request, we shouldn't send}
972     \textcolor{comment}{// an entity-body in the response.}
973     headRequest_ = (msg_->getMethod() == HTTPMethod::HEAD);
974 
975     ParseURL parseUrl = msg_->setURL(std::move(url_));
976     url_.clear();
977 
978     \textcolor{keywordflow}{if} (parseUrl.hasHost()) \{
979       \textcolor{comment}{// RFC 2616 5.2.1 states "If Request-URI is an absoluteURI, the host}
980       \textcolor{comment}{// is part of the Request-URI. Any Host header field value in the}
981       \textcolor{comment}{// request MUST be ignored."}
982       \textcolor{keyword}{auto} hostAndPort = parseUrl.hostAndPort();
983       VLOG(4) << \textcolor{stringliteral}{"Adding inferred host header: "} << hostAndPort;
984       msg_->getHeaders().set(HTTP\_HEADER\_HOST, hostAndPort);
985     \}
986 
987     \textcolor{comment}{// If the client sent us an HTTP/1.x with x >= 1, we may send}
988     \textcolor{comment}{// chunked responses.}
989     mayChunkEgress_ = ((parser_.http_major == 1) && (parser_.http_minor >= 1));
990   \} \textcolor{keywordflow}{else} \{
991     msg_->setStatusCode(parser_.status_code);
992     msg_->setStatusMessage(std::move(reason_));
993     reason_.clear();
994   \}
995 
996   \textcolor{keyword}{auto} g = folly::makeGuard([\textcolor{keyword}{this}] \{
997       \textcolor{comment}{// Always clear the outbound upgrade header after we receive a response}
998       \textcolor{keywordflow}{if} (transportDirection_ == TransportDirection::UPSTREAM &&
999           parser_.status_code != 100) \{
1000         upgradeHeader\_.clear();
1001       \}
1002     \});
1003   headerParseState_ = HeaderParseState::kParsingHeadersComplete;
1004   \textcolor{keywordflow}{if} (transportDirection_ == TransportDirection::UPSTREAM) \{
1005     \textcolor{keywordflow}{if} (connectRequest_ &&
1006         (parser_.status_code >= 200 && parser_.status_code < 300)) \{
1007       \textcolor{comment}{// Enable upgrade if this is a 200 response to a CONNECT}
1008       \textcolor{comment}{// request we sent earlier}
1009       ingressUpgrade_ = \textcolor{keyword}{true};
1010     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (parser_.status_code == 101) \{
1011       \textcolor{comment}{// Set the upgrade flags if the server has upgraded.}
1012       \textcolor{keyword}{const} std::string& serverUpgrade =
1013         msg_->getHeaders().getSingleOrEmpty(HTTP\_HEADER\_UPGRADE);
1014       \textcolor{keywordflow}{if} (serverUpgrade.empty() ||
1015           upgradeHeader_.empty()) \{
1016         LOG(ERROR) << \textcolor{stringliteral}{"Invalid 101 response, empty upgrade headers"};
1017         \textcolor{keywordflow}{return} -1;
1018       \}
1019       \textcolor{keyword}{auto} result = checkForProtocolUpgrade(upgradeHeader_,
1020                                             serverUpgrade,
1021                                             \textcolor{keyword}{false} \textcolor{comment}{/* client mode */});
1022       \textcolor{keywordflow}{if} (result) \{
1023         ingressUpgrade_ = \textcolor{keyword}{true};
1024         egressUpgrade_ = \textcolor{keyword}{true};
1025         \textcolor{keywordflow}{if} (result->first != CodecProtocol::HTTP_1_1) \{
1026           \textcolor{keywordtype}{bool} success = callback_->onNativeProtocolUpgrade(
1027             ingressTxnID_, result->first, result->second, *msg_);
1028           \textcolor{keywordflow}{if} (success) \{
1029             nativeUpgrade_ = \textcolor{keyword}{true};
1030             msg_->setIsUpgraded(ingressUpgrade_);
1031             \textcolor{keywordflow}{return} 1;  \textcolor{comment}{// no message body if successful}
1032           \}
1033         \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (result->second == getCodecProtocolString(result->first)) \{
1034           \textcolor{comment}{// someone upgraded to http/1.1?  Reset upgrade flags}
1035           ingressUpgrade_ = \textcolor{keyword}{false};
1036           egressUpgrade_ = \textcolor{keyword}{false};
1037         \}
1038         \textcolor{comment}{// else, there's some non-native upgrade}
1039       \} \textcolor{keywordflow}{else} \{
1040         LOG(ERROR) << \textcolor{stringliteral}{"Invalid 101 response, client/server upgrade mismatch "}
1041           \textcolor{stringliteral}{"client="} << upgradeHeader_ << \textcolor{stringliteral}{" server="} << serverUpgrade;
1042         \textcolor{keywordflow}{return} -1;
1043       \}
1044     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (parser_.upgrade || parser_.flags & F_UPGRADE) \{
1045       \textcolor{comment}{// Ignore upgrade header for upstream response messages with status code}
1046       \textcolor{comment}{// different from 101 in case if it was not a response to CONNECT.}
1047       parser_.upgrade = \textcolor{keyword}{false};
1048       parser_.flags &= ~F_UPGRADE;
1049     \}
1050   \}
1051   \textcolor{keywordflow}{else} \{
1052     \textcolor{keywordflow}{if} (connectRequest_) \{
1053       \textcolor{comment}{// Enable upgrade by default for the CONNECT requests.}
1054       \textcolor{comment}{// If we locally reject CONNECT, we will disable this flag while}
1055       \textcolor{comment}{// sending the reject response. If we forward the req to upstream proxy,}
1056       \textcolor{comment}{// we will start forwarding data to the proxy without waiting for}
1057       \textcolor{comment}{// the response from the proxy server.}
1058       ingressUpgrade_ = \textcolor{keyword}{true};
1059     \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (!allowedNativeUpgrades_.empty() && ingressTxnID_ == 1) \{
1060       upgradeHeader_ = msg_->getHeaders().getSingleOrEmpty(HTTP\_HEADER\_UPGRADE);
1061       \textcolor{keywordflow}{if} (!upgradeHeader_.empty() && !allowedNativeUpgrades_.empty()) \{
1062         \textcolor{keyword}{auto} result = checkForProtocolUpgrade(upgradeHeader_,
1063                                               allowedNativeUpgrades_,
1064                                               \textcolor{keyword}{true} \textcolor{comment}{/* server mode */});
1065         \textcolor{keywordflow}{if} (result && result->first != CodecProtocol::HTTP_1_1) \{
1066           nativeUpgrade_ = \textcolor{keyword}{true};
1067           upgradeResult_ = *result;
1068           \textcolor{comment}{// unfortunately have to copy because msg\_ is passed to}
1069           \textcolor{comment}{// onHeadersComplete}
1070           upgradeRequest_ = std::make\_unique<HTTPMessage>(*msg\_);
1071         \}
1072       \}
1073     \}
1074   \}
1075   msg_->setIsUpgraded(ingressUpgrade_);
1076 
1077   \textcolor{keyword}{const} std::string& upgrade = hdrs.getSingleOrEmpty(HTTP\_HEADER\_UPGRADE);
1078   \textcolor{keywordflow}{if} (kUpgradeToken.equals(upgrade, folly::AsciiCaseInsensitive())) \{
1079     msg_->setIngressWebsocketUpgrade();
1080     \textcolor{keywordflow}{if} (transportDirection_ == TransportDirection::UPSTREAM) \{
1081       \textcolor{comment}{// response.}
1082       \textcolor{keyword}{const} std::string& accept = hdrs.getSingleOrEmpty(
1083           HTTP\_HEADER\_SEC\_WEBSOCKET\_ACCEPT);
1084       \textcolor{keywordflow}{if} (accept != websockAcceptKey_) \{
1085         LOG(ERROR) << \textcolor{stringliteral}{"Mismatch in expected ws accept key: "} <<
1086           \textcolor{stringliteral}{"upstream: "} << accept << \textcolor{stringliteral}{" expected: "} << websockAcceptKey_;
1087         \textcolor{keywordflow}{return} -1;
1088       \}
1089     \} \textcolor{keywordflow}{else} \{
1090       \textcolor{comment}{// request.}
1091       \textcolor{keyword}{auto} key = hdrs.getSingleOrEmpty(HTTP\_HEADER\_SEC\_WEBSOCKET\_KEY);
1092       DCHECK(websockAcceptKey_.empty());
1093       websockAcceptKey_ = generateWebsocketAccept(key);
1094     \}
1095   \}
1096 
1097   \textcolor{keywordtype}{bool} msgKeepalive = msg_->computeKeepalive();
1098   \textcolor{keywordflow}{if} (!msgKeepalive) \{
1099      keepalive_ = \textcolor{keyword}{false};
1100   \}
1101   \textcolor{keywordflow}{if} (transportDirection_ == TransportDirection::DOWNSTREAM) \{
1102     \textcolor{comment}{// Remember whether this was an HTTP 1.0 request with keepalive enabled}
1103     \textcolor{keywordflow}{if} (msgKeepalive && msg_->isHTTP1\_0() &&
1104           (keepaliveRequested_ == KeepaliveRequested::UNSET ||
1105            keepaliveRequested_ == KeepaliveRequested::ENABLED)) \{
1106       keepaliveRequested_ = KeepaliveRequested::ENABLED;
1107     \} \textcolor{keywordflow}{else} \{
1108       keepaliveRequested_ = KeepaliveRequested::DISABLED;
1109     \}
1110   \}
1111 
1112   \textcolor{comment}{// Determine whether the HTTP parser should ignore any headers}
1113   \textcolor{comment}{// that indicate the presence of a message body.  This is needed,}
1114   \textcolor{comment}{// for example, if the message is a response to a request with}
1115   \textcolor{comment}{// method==HEAD.}
1116   \textcolor{keywordtype}{bool} ignoreBody;
1117   \textcolor{keywordflow}{if} (transportDirection_ == TransportDirection::DOWNSTREAM) \{
1118     ignoreBody = \textcolor{keyword}{false};
1119   \} \textcolor{keywordflow}{else} \{
1120     is1xxResponse_ = msg_->is1xxResponse();
1121     \textcolor{keywordflow}{if} (expectNoResponseBody_) \{
1122       ignoreBody = \textcolor{keyword}{true};
1123     \} \textcolor{keywordflow}{else} \{
1124       ignoreBody = RFC2616::responseBodyMustBeEmpty(msg_->getStatusCode());
1125     \}
1126   \}
1127 
1128   headersComplete_ = \textcolor{keyword}{true};
1129   headerSize_.uncompressed += len;
1130   msg_->setIngressHeaderSize(headerSize_);
1131 
1132   \textcolor{keywordflow}{if} (userAgent_.empty()) \{
1133     userAgent_ = msg_->getHeaders().getSingleOrEmpty(HTTP\_HEADER\_USER\_AGENT);
1134   \}
1135   callback_->onHeadersComplete(ingressTxnID_, std::move(msg_));
1136 
1137   \textcolor{comment}{// 1 is a magic value that tells the http\_parser not to expect a}
1138   \textcolor{comment}{// message body even if the message header implied the presence}
1139   \textcolor{comment}{// of one (e.g., via a Content-Length)}
1140   \textcolor{keywordflow}{return} (ignoreBody) ? 1 : 0;
1141 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+Headers\+Complete\+CB@{on\+Headers\+Complete\+CB}}
\index{on\+Headers\+Complete\+CB@{on\+Headers\+Complete\+CB}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+Headers\+Complete\+C\+B(http\+\_\+parser $\ast$parser, const char $\ast$buf, size\+\_\+t len)}]{\setlength{\rightskip}{0pt plus 5cm}int proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Headers\+Complete\+CB (
\begin{DoxyParamCaption}
\item[{{\bf http\+\_\+parser} $\ast$}]{parser, }
\item[{const char $\ast$}]{buf, }
\item[{size\+\_\+t}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a859726b46a4c6e8353073e8940f9b9e0}


Definition at line 1305 of file H\+T\+T\+P1x\+Codec.\+cpp.



References http\+\_\+parser\+::data, on\+Headers\+Complete(), on\+Parser\+Error(), and parser\+\_\+.



Referenced by get\+Parser\+Settings().


\begin{DoxyCode}
1307                                                  \{
1308   HTTP1xCodec* codec = \textcolor{keyword}{static\_cast<}HTTP1xCodec*\textcolor{keyword}{>}(parser->data);
1309   DCHECK(codec != \textcolor{keyword}{nullptr});
1310   DCHECK\_EQ(&codec->parser\_, parser);
1311 
1312   \textcolor{keywordflow}{try} \{
1313     \textcolor{keywordflow}{return} codec->onHeadersComplete(len);
1314   \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} std::exception& ex) \{
1315     codec->onParserError(ex.what());
1316     \textcolor{keywordflow}{return} 3;
1317   \}
1318 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+Header\+Value@{on\+Header\+Value}}
\index{on\+Header\+Value@{on\+Header\+Value}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+Header\+Value(const char $\ast$buf, size\+\_\+t len)}]{\setlength{\rightskip}{0pt plus 5cm}int proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Header\+Value (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{buf, }
\item[{size\+\_\+t}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_aab289e7e017b9b9c980c6ccc22dd9b86}


Definition at line 915 of file H\+T\+T\+P1x\+Codec.\+cpp.



References current\+Header\+Value\+\_\+, header\+Parse\+State\+\_\+, is\+Parsing\+Headers(), k\+Parsing\+Header\+Value, and k\+Parsing\+Trailer\+Value.



Referenced by is\+Parsing\+Header\+Or\+Trailer\+Name(), and on\+Header\+Value\+C\+B().


\begin{DoxyCode}
915                                                       \{
916   \textcolor{keywordflow}{if} (isParsingHeaders()) \{
917     headerParseState_ = HeaderParseState::kParsingHeaderValue;
918   \} \textcolor{keywordflow}{else} \{
919     headerParseState_ = HeaderParseState::kParsingTrailerValue;
920   \}
921   currentHeaderValue_.append(buf, len);
922   \textcolor{keywordflow}{return} 0;
923 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+Header\+Value\+CB@{on\+Header\+Value\+CB}}
\index{on\+Header\+Value\+CB@{on\+Header\+Value\+CB}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+Header\+Value\+C\+B(http\+\_\+parser $\ast$parser, const char $\ast$buf, size\+\_\+t len)}]{\setlength{\rightskip}{0pt plus 5cm}int proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Header\+Value\+CB (
\begin{DoxyParamCaption}
\item[{{\bf http\+\_\+parser} $\ast$}]{parser, }
\item[{const char $\ast$}]{buf, }
\item[{size\+\_\+t}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a0be99af96d4b41338263d44b0072c510}


Definition at line 1292 of file H\+T\+T\+P1x\+Codec.\+cpp.



References http\+\_\+parser\+::data, on\+Header\+Value(), on\+Parser\+Error(), and parser\+\_\+.



Referenced by get\+Parser\+Settings().


\begin{DoxyCode}
1292                                                                              \{
1293   HTTP1xCodec* codec = \textcolor{keyword}{static\_cast<}HTTP1xCodec*\textcolor{keyword}{>}(parser->data);
1294   DCHECK(codec != \textcolor{keyword}{nullptr});
1295   DCHECK\_EQ(&codec->parser\_, parser);
1296 
1297   \textcolor{keywordflow}{try} \{
1298     \textcolor{keywordflow}{return} codec->onHeaderValue(buf, len);
1299   \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} std::exception& ex) \{
1300     codec->onParserError(ex.what());
1301     \textcolor{keywordflow}{return} 1;
1302   \}
1303 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+Ingress@{on\+Ingress}}
\index{on\+Ingress@{on\+Ingress}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+Ingress(const folly\+::\+I\+O\+Buf \&buf) override}]{\setlength{\rightskip}{0pt plus 5cm}size\+\_\+t proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Ingress (
\begin{DoxyParamCaption}
\item[{const folly\+::\+I\+O\+Buf \&}]{buf}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP1xCodec_a956adf4b9685d26198cedb7f51fc3b84}
Parse ingress data. 
\begin{DoxyParams}{Parameters}
{\em buf} & A single I\+O\+Buf of data to parse \\
\hline
\end{DoxyParams}
\begin{DoxyReturn}{Returns}
Number of bytes consumed. 
\end{DoxyReturn}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a44a623c547735db83ae472ba7f1af6df}.



Definition at line 177 of file H\+T\+T\+P1x\+Codec.\+cpp.



References callback\+\_\+, current\+Header\+Name\+\_\+, current\+Header\+Name\+String\+Piece\+\_\+, current\+Ingress\+Buf\+\_\+, get\+Parser\+Settings(), headers\+Complete\+\_\+, header\+Size\+\_\+, H\+P\+E\+\_\+\+OK, H\+P\+E\+\_\+\+P\+A\+U\+S\+ED, http\+\_\+parser\+::http\+\_\+major, http\+\_\+parser\+::http\+\_\+minor, H\+T\+T\+P\+\_\+\+P\+A\+R\+S\+E\+R\+\_\+\+E\+R\+R\+NO, http\+\_\+parser\+\_\+execute(), ingress\+Txn\+I\+D\+\_\+, ingress\+Upgrade\+Complete\+\_\+, msg\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Body(), on\+Headers\+Complete(), on\+Ingress\+E\+O\+F(), on\+Message\+Begin(), on\+Parser\+Error(), parser\+\_\+, parser\+Active\+\_\+, parser\+Error\+\_\+, pending\+E\+O\+F\+\_\+, transport\+Direction\+\_\+, and proxygen\+::\+U\+P\+S\+T\+R\+E\+AM.



Referenced by set\+Callback(), T\+E\+S\+T(), and T\+E\+S\+T\+\_\+\+P().


\begin{DoxyCode}
177                                        \{
178   \textcolor{keywordflow}{if} (parserError_) \{
179     \textcolor{keywordflow}{return} 0;
180   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (ingressUpgradeComplete_) \{
181     callback_->onBody(ingressTxnID_, buf.clone(), 0);
182     \textcolor{keywordflow}{return} buf.computeChainDataLength();
183   \} \textcolor{keywordflow}{else} \{
184     \textcolor{comment}{// Callers responsibility to prevent calling onIngress from a callback}
185     CHECK(!parserActive_);
186     parserActive_ = \textcolor{keyword}{true};
187     currentIngressBuf_ = &buf;
188     \textcolor{keywordflow}{if} (transportDirection_ == TransportDirection::UPSTREAM &&
189         parser_.http_major == 0 && parser_.http_minor == 9) \{
190       \textcolor{comment}{// HTTP/0.9 responses have no header block, so create a fake 200 response}
191       \textcolor{comment}{// and put the codec in upgrade mode}
192       onMessageBegin();
193       msg_->setStatusCode(200);
194       onHeadersComplete(0);
195       parserActive_ = \textcolor{keyword}{false};
196       ingressUpgradeComplete_ = \textcolor{keyword}{true};
197       \textcolor{keywordflow}{return} onIngress(buf);
198     \}
199     \textcolor{keywordtype}{size\_t} bytesParsed = http_parser_execute(&parser_,
200                                              getParserSettings(),
201                                              (\textcolor{keyword}{const} \textcolor{keywordtype}{char}*)buf.data(),
202                                              buf.length());
203     \textcolor{comment}{// in case we parsed a section of the headers but we're not done parsing}
204     \textcolor{comment}{// the headers we need to keep accounting of it for total header size}
205     \textcolor{keywordflow}{if} (!headersComplete_) \{
206       headerSize_.uncompressed += bytesParsed;
207     \}
208     parserActive_ = \textcolor{keyword}{false};
209     parserError_ = (HTTP_PARSER_ERRNO(&parser_) != HPE_OK) &&
210         (HTTP_PARSER_ERRNO(&parser_) != HPE_PAUSED);
211     \textcolor{keywordflow}{if} (parserError_) \{
212       onParserError();
213     \}
214     \textcolor{keywordflow}{if} (currentHeaderName_.empty() && !currentHeaderNameStringPiece_.empty()) \{
215       \textcolor{comment}{// we currently are storing a chunk of header name via pointers in}
216       \textcolor{comment}{// currentHeaderNameStringPiece\_, but the currentIngressBuf\_ is about to}
217       \textcolor{comment}{// vanish and so we need to copy over that data to currentHeaderName\_}
218       currentHeaderName_.assign(currentHeaderNameStringPiece_.begin(),
219                                 currentHeaderNameStringPiece_.size());
220     \}
221     currentIngressBuf_ = \textcolor{keyword}{nullptr};
222     \textcolor{keywordflow}{if} (pendingEOF_) \{
223       onIngressEOF();
224       pendingEOF_ = \textcolor{keyword}{false};
225     \}
226     \textcolor{keywordflow}{return} bytesParsed;
227   \}
228 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+Ingress\+E\+OF@{on\+Ingress\+E\+OF}}
\index{on\+Ingress\+E\+OF@{on\+Ingress\+E\+OF}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+Ingress\+E\+O\+F() override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Ingress\+E\+OF (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP1xCodec_abcbe15cffb1a2151b1a2e56e5adbe70b}
Finish parsing when the ingress stream has ended. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a23e624f386bd4f4740acb27cb72df169}.



Definition at line 231 of file H\+T\+T\+P1x\+Codec.\+cpp.



References callback\+\_\+, get\+Parser\+Settings(), H\+P\+E\+\_\+\+OK, H\+P\+E\+\_\+\+P\+A\+U\+S\+ED, H\+T\+T\+P\+\_\+\+P\+A\+R\+S\+E\+R\+\_\+\+E\+R\+R\+NO, http\+\_\+parser\+\_\+execute(), ingress\+Txn\+I\+D\+\_\+, ingress\+Upgrade\+Complete\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Message\+Complete(), on\+Parser\+Error(), parser\+\_\+, parser\+Active\+\_\+, parser\+Error\+\_\+, and pending\+E\+O\+F\+\_\+.



Referenced by on\+Ingress(), set\+Callback(), and T\+E\+S\+T().


\begin{DoxyCode}
231                           \{
232   \textcolor{keywordflow}{if} (parserError_) \{
233     \textcolor{keywordflow}{return};
234   \}
235   \textcolor{keywordflow}{if} (parserActive_) \{
236     pendingEOF_ = \textcolor{keyword}{true};
237     \textcolor{keywordflow}{return};
238   \}
239   \textcolor{keywordflow}{if} (ingressUpgradeComplete_) \{
240     callback_->onMessageComplete(ingressTxnID_, \textcolor{keyword}{false});
241     \textcolor{keywordflow}{return};
242   \}
243   parserActive_ = \textcolor{keyword}{true};
244   \textcolor{keywordflow}{if} (http_parser_execute(&parser_, getParserSettings(), \textcolor{keyword}{nullptr}, 0) != 0) \{
245     parserError_ = \textcolor{keyword}{true};
246   \} \textcolor{keywordflow}{else} \{
247     parserError_ = (HTTP_PARSER_ERRNO(&parser_) != HPE_OK) &&
248         (HTTP_PARSER_ERRNO(&parser_) != HPE_PAUSED);
249   \}
250   parserActive_ = \textcolor{keyword}{false};
251   \textcolor{keywordflow}{if} (parserError_) \{
252     onParserError();
253   \}
254 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+Message\+Begin@{on\+Message\+Begin}}
\index{on\+Message\+Begin@{on\+Message\+Begin}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+Message\+Begin()}]{\setlength{\rightskip}{0pt plus 5cm}int proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Message\+Begin (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a29934914059c9ba987c16f5f65ed9577}


Definition at line 817 of file H\+T\+T\+P1x\+Codec.\+cpp.



References callback\+\_\+, proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, header\+Parse\+State\+\_\+, headers\+Complete\+\_\+, header\+Size\+\_\+, ingress\+Txn\+I\+D\+\_\+, is1xx\+Response\+\_\+, k\+Parsing\+Header\+Start, msg\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Message\+Begin(), request\+Pending\+\_\+, response\+Pending\+\_\+, trailers\+\_\+, transport\+Direction\+\_\+, and proxygen\+::\+U\+P\+S\+T\+R\+E\+AM.



Referenced by is\+Parsing\+Header\+Or\+Trailer\+Name(), on\+Ingress(), and on\+Message\+Begin\+C\+B().


\begin{DoxyCode}
817                             \{
818   headersComplete_ = \textcolor{keyword}{false};
819   headerSize_.uncompressed = 0;
820   headerParseState_ = HeaderParseState::kParsingHeaderStart;
821   msg_.reset(\textcolor{keyword}{new} HTTPMessage());
822   trailers_.reset();
823   \textcolor{keywordflow}{if} (transportDirection_ == TransportDirection::DOWNSTREAM) \{
824     requestPending_ = \textcolor{keyword}{true};
825     responsePending_ = \textcolor{keyword}{true};
826   \}
827   \textcolor{comment}{// If there was a 1xx on this connection, don't increment the ingress txn id}
828   \textcolor{keywordflow}{if} (transportDirection_ == TransportDirection::DOWNSTREAM ||
829       !is1xxResponse_) \{
830     ++ingressTxnID_;
831   \}
832   \textcolor{keywordflow}{if} (transportDirection_ == TransportDirection::UPSTREAM) \{
833     is1xxResponse_ = \textcolor{keyword}{false};
834   \}
835   callback_->onMessageBegin(ingressTxnID_, msg_.get());
836   \textcolor{keywordflow}{return} 0;
837 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+Message\+Begin\+CB@{on\+Message\+Begin\+CB}}
\index{on\+Message\+Begin\+CB@{on\+Message\+Begin\+CB}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+Message\+Begin\+C\+B(http\+\_\+parser $\ast$parser)}]{\setlength{\rightskip}{0pt plus 5cm}int proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Message\+Begin\+CB (
\begin{DoxyParamCaption}
\item[{{\bf http\+\_\+parser} $\ast$}]{parser}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a6021fa658575daa6b03883423342aef4}


Definition at line 1236 of file H\+T\+T\+P1x\+Codec.\+cpp.



References http\+\_\+parser\+::data, on\+Message\+Begin(), on\+Parser\+Error(), and parser\+\_\+.



Referenced by get\+Parser\+Settings().


\begin{DoxyCode}
1236                                                  \{
1237   HTTP1xCodec* codec = \textcolor{keyword}{static\_cast<}HTTP1xCodec*\textcolor{keyword}{>}(parser->data);
1238   DCHECK(codec != \textcolor{keyword}{nullptr});
1239   DCHECK\_EQ(&codec->parser\_, parser);
1240 
1241   \textcolor{keywordflow}{try} \{
1242     \textcolor{keywordflow}{return} codec->onMessageBegin();
1243   \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} std::exception& ex) \{
1244     codec->onParserError(ex.what());
1245     \textcolor{keywordflow}{return} 1;
1246   \}
1247 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+Message\+Complete@{on\+Message\+Complete}}
\index{on\+Message\+Complete@{on\+Message\+Complete}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+Message\+Complete()}]{\setlength{\rightskip}{0pt plus 5cm}int proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Message\+Complete (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a5b63012f358bc08f916b8925b6680ec6}


Definition at line 1180 of file H\+T\+T\+P1x\+Codec.\+cpp.



References callback\+\_\+, proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, header\+Parse\+State\+\_\+, ingress\+Txn\+I\+D\+\_\+, ingress\+Upgrade\+\_\+, ingress\+Upgrade\+Complete\+\_\+, in\+Recv\+Last\+Chunk\+\_\+, is1xx\+Response\+\_\+, is\+Parsing\+Headers(), k\+Parsing\+Header\+Idle, k\+Parsing\+Trailer\+Value, native\+Upgrade\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Message\+Complete(), proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Native\+Protocol\+Upgrade(), proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Trailers\+Complete(), push\+Header\+Name\+And\+Value(), request\+Pending\+\_\+, response\+Pending\+\_\+, set\+Parser\+Paused(), trailers\+\_\+, transport\+Direction\+\_\+, upgrade\+Request\+\_\+, upgrade\+Result\+\_\+, and proxygen\+::\+U\+P\+S\+T\+R\+E\+AM.



Referenced by is\+Parsing\+Header\+Or\+Trailer\+Name(), and on\+Message\+Complete\+C\+B().


\begin{DoxyCode}
1180                                    \{
1181   DCHECK(!isParsingHeaders());
1182   DCHECK(!inRecvLastChunk_);
1183   \textcolor{keywordflow}{if} (headerParseState_ == HeaderParseState::kParsingTrailerValue) \{
1184     \textcolor{keywordflow}{if} (!trailers_) \{
1185       trailers_.reset(\textcolor{keyword}{new} HTTPHeaders());
1186     \}
1187     pushHeaderNameAndValue(*trailers_);
1188   \}
1189 
1190   headerParseState_ = HeaderParseState::kParsingHeaderIdle;
1191   \textcolor{keywordflow}{if} (trailers_) \{
1192     callback_->onTrailersComplete(ingressTxnID_, std::move(trailers_));
1193   \}
1194 
1195   \textcolor{keywordflow}{switch} (transportDirection_) \{
1196   \textcolor{keywordflow}{case} TransportDirection::DOWNSTREAM:
1197   \{
1198     requestPending_ = \textcolor{keyword}{false};
1199     \textcolor{keywordflow}{if} (upgradeRequest_) \{
1200       ingressUpgrade_ = callback_->onNativeProtocolUpgrade(
1201         ingressTxnID_, upgradeResult_.first, upgradeResult_.second,
1202         *upgradeRequest_);
1203       upgradeRequest_.reset();
1204     \}
1205     \textcolor{comment}{// else there was no match, OR we upgraded to http/1.1 OR someone specified}
1206     \textcolor{comment}{// a non-native protocol in the setAllowedUpgradeProtocols.  No-ops}
1207     \textcolor{keywordflow}{break};
1208   \}
1209   \textcolor{keywordflow}{case} TransportDirection::UPSTREAM:
1210     responsePending_ = is1xxResponse_;
1211   \}
1212 
1213   \textcolor{comment}{// For downstream, always call onMessageComplete. If native upgrade,}
1214   \textcolor{comment}{// pass upgrade=false. Else pass ingressUpgrade\_.}
1215   \textcolor{comment}{// For upstream, call onMessagComplete if not native upgrade.}
1216   \textcolor{keywordflow}{if} (!nativeUpgrade_) \{
1217     callback_->onMessageComplete(ingressTxnID_, ingressUpgrade_);
1218   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (transportDirection_ == TransportDirection::DOWNSTREAM) \{
1219     \textcolor{comment}{// native upgrade and downstream.}
1220     callback_->onMessageComplete(ingressTxnID_, \textcolor{keyword}{false});
1221   \}
1222   \textcolor{comment}{// else we suppressed onHeadersComplete, suppress onMessageComplete also.}
1223   \textcolor{comment}{// The new codec will handle these callbacks with the real message}
1224 
1225   \textcolor{keywordflow}{if} (ingressUpgrade_) \{
1226     ingressUpgradeComplete_ = \textcolor{keyword}{true};
1227     \textcolor{comment}{// If upgrade is complete, any pending data should not be parsed.}
1228     \textcolor{comment}{// It must be forwarded directly to the handler.}
1229     setParserPaused(\textcolor{keyword}{true});
1230   \}
1231 
1232   \textcolor{keywordflow}{return} 0;
1233 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+Message\+Complete\+CB@{on\+Message\+Complete\+CB}}
\index{on\+Message\+Complete\+CB@{on\+Message\+Complete\+CB}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+Message\+Complete\+C\+B(http\+\_\+parser $\ast$parser)}]{\setlength{\rightskip}{0pt plus 5cm}int proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Message\+Complete\+CB (
\begin{DoxyParamCaption}
\item[{{\bf http\+\_\+parser} $\ast$}]{parser}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a72ebbd4264586dbcf1dad29788090aab}


Definition at line 1367 of file H\+T\+T\+P1x\+Codec.\+cpp.



References http\+\_\+parser\+::data, on\+Message\+Complete(), on\+Parser\+Error(), and parser\+\_\+.



Referenced by get\+Parser\+Settings().


\begin{DoxyCode}
1367                                                     \{
1368   HTTP1xCodec* codec = \textcolor{keyword}{static\_cast<}HTTP1xCodec*\textcolor{keyword}{>}(parser->data);
1369   DCHECK(codec != \textcolor{keyword}{nullptr});
1370   DCHECK\_EQ(&codec->parser\_, parser);
1371 
1372   \textcolor{keywordflow}{try} \{
1373     \textcolor{keywordflow}{return} codec->onMessageComplete();
1374   \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} std::exception& ex) \{
1375     codec->onParserError(ex.what());
1376     \textcolor{keywordflow}{return} 1;
1377   \}
1378 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+Parser\+Error@{on\+Parser\+Error}}
\index{on\+Parser\+Error@{on\+Parser\+Error}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+Parser\+Error(const char $\ast$what=nullptr)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Parser\+Error (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{what = {\ttfamily {\bf nullptr}}}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a0538cbcf427cd6d9afc8377a16f6d6a7}
Invoked when a parsing error occurs. It will send an exception to the callback object to report the error and do any other cleanup needed. It optionally takes a message to pass to the generated \doxyref{H\+T\+T\+P\+Exception}{p.}{classproxygen_1_1HTTPException} passed to callback\+\_\+. 

Definition at line 257 of file H\+T\+T\+P1x\+Codec.\+cpp.



References callback\+\_\+, current\+Ingress\+Buf\+\_\+, proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, egress\+Txn\+I\+D\+\_\+, H\+P\+E\+\_\+\+H\+E\+A\+D\+E\+R\+\_\+\+O\+V\+E\+R\+F\+L\+OW, H\+P\+E\+\_\+\+H\+U\+G\+E\+\_\+\+C\+H\+U\+N\+K\+\_\+\+S\+I\+ZE, H\+P\+E\+\_\+\+H\+U\+G\+E\+\_\+\+C\+O\+N\+T\+E\+N\+T\+\_\+\+L\+E\+N\+G\+TH, H\+P\+E\+\_\+\+I\+N\+V\+A\+L\+I\+D\+\_\+\+C\+H\+U\+N\+K\+\_\+\+S\+I\+ZE, H\+P\+E\+\_\+\+I\+N\+V\+A\+L\+I\+D\+\_\+\+C\+O\+N\+S\+T\+A\+NT, H\+P\+E\+\_\+\+I\+N\+V\+A\+L\+I\+D\+\_\+\+E\+O\+F\+\_\+\+S\+T\+A\+TE, H\+P\+E\+\_\+\+I\+N\+V\+A\+L\+I\+D\+\_\+\+V\+E\+R\+S\+I\+ON, http\+\_\+errno\+\_\+description(), H\+T\+T\+P\+\_\+\+P\+A\+R\+S\+E\+R\+\_\+\+E\+R\+R\+NO, proxygen\+::\+H\+T\+T\+P\+Exception\+::\+I\+N\+G\+R\+E\+SS, ingress\+Txn\+I\+D\+\_\+, in\+Recv\+Last\+Chunk\+\_\+, proxygen\+::k\+Error\+E\+OF, proxygen\+::k\+Error\+Parse\+Body, proxygen\+::k\+Error\+Parse\+Header, proxygen\+::k\+Error\+Unknown, msg\+\_\+, proxygen\+::\+H\+T\+T\+P\+Codec\+::\+Callback\+::on\+Error(), parser\+\_\+, proxygen\+::\+H\+T\+T\+P\+Exception\+::set\+Current\+Ingress\+Buf(), proxygen\+::\+H\+T\+T\+P\+Exception\+::set\+Http\+Status\+Code(), proxygen\+::\+H\+T\+T\+P\+Exception\+::set\+Partial\+Msg(), proxygen\+::\+Exception\+::set\+Proxygen\+Error(), and transport\+Direction\+\_\+.



Referenced by is\+Parsing\+Header\+Or\+Trailer\+Name(), on\+Body\+C\+B(), on\+Chunk\+Complete\+C\+B(), on\+Chunk\+Header\+C\+B(), on\+Header\+Field\+C\+B(), on\+Headers\+Complete\+C\+B(), on\+Header\+Value\+C\+B(), on\+Ingress(), on\+Ingress\+E\+O\+F(), on\+Message\+Begin\+C\+B(), on\+Message\+Complete\+C\+B(), on\+Reason\+C\+B(), and on\+Url\+C\+B().


\begin{DoxyCode}
257                                            \{
258   inRecvLastChunk_ = \textcolor{keyword}{false};
259   http_errno parser\_errno = HTTP_PARSER_ERRNO(&parser_);
260   HTTPException error(HTTPException::Direction::INGRESS,
261                       what ? what : folly::to<std::string>(
262                         \textcolor{stringliteral}{"Error parsing message: "},
263                         http_errno_description(parser\_errno)
264                       ));
265   \textcolor{comment}{// generate a string of parsed headers so that we can pass it to callback}
266   \textcolor{keywordflow}{if} (msg_) \{
267     error.setPartialMsg(std::move(msg_));
268   \}
269   \textcolor{comment}{// store the ingress buffer}
270   \textcolor{keywordflow}{if} (currentIngressBuf_) \{
271     error.setCurrentIngressBuf(currentIngressBuf_->cloneOne());
272   \}
273   \textcolor{keywordflow}{if} (transportDirection_ == TransportDirection::DOWNSTREAM &&
274       egressTxnID_ < ingressTxnID_) \{
275     error.setHttpStatusCode(400);
276   \} \textcolor{comment}{// else we've already egressed a response for this txn, don't attempt a 400}
277   \textcolor{comment}{// See http\_parser.h for what these error codes mean}
278   \textcolor{keywordflow}{if} (parser\_errno == HPE_INVALID_EOF_STATE) \{
279     error.setProxygenError(kErrorEOF);
280   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (parser\_errno == HPE_HEADER_OVERFLOW ||
281              parser\_errno == HPE_INVALID_CONSTANT ||
282              (parser\_errno >= HPE_INVALID_VERSION &&
283               parser\_errno <= HPE_HUGE_CONTENT_LENGTH)) \{
284     error.setProxygenError(kErrorParseHeader);
285   \} \textcolor{keywordflow}{else} \textcolor{keywordflow}{if} (parser\_errno == HPE_INVALID_CHUNK_SIZE ||
286              parser\_errno == HPE_HUGE_CHUNK_SIZE) \{
287     error.setProxygenError(kErrorParseBody);
288   \} \textcolor{keywordflow}{else} \{
289     error.setProxygenError(kErrorUnknown);
290   \}
291   callback_->onError(ingressTxnID_, error);
292 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+Path\+CB@{on\+Path\+CB}}
\index{on\+Path\+CB@{on\+Path\+CB}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+Path\+C\+B(http\+\_\+parser $\ast$parser, const char $\ast$buf, size\+\_\+t len)}]{\setlength{\rightskip}{0pt plus 5cm}static int proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Path\+CB (
\begin{DoxyParamCaption}
\item[{{\bf http\+\_\+parser} $\ast$}]{parser, }
\item[{const char $\ast$}]{buf, }
\item[{size\+\_\+t}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_aa448ffaa0d56947b3267cc554ff2a6a7}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+Query\+String\+CB@{on\+Query\+String\+CB}}
\index{on\+Query\+String\+CB@{on\+Query\+String\+CB}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+Query\+String\+C\+B(http\+\_\+parser $\ast$parser, const char $\ast$buf, size\+\_\+t len)}]{\setlength{\rightskip}{0pt plus 5cm}static int proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Query\+String\+CB (
\begin{DoxyParamCaption}
\item[{{\bf http\+\_\+parser} $\ast$}]{parser, }
\item[{const char $\ast$}]{buf, }
\item[{size\+\_\+t}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_ac85c01c7ad753d4256b18cbea1cefe26}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+Reason@{on\+Reason}}
\index{on\+Reason@{on\+Reason}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+Reason(const char $\ast$buf, size\+\_\+t len)}]{\setlength{\rightskip}{0pt plus 5cm}int proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Reason (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{buf, }
\item[{size\+\_\+t}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a52da98ea713ae05947926ba5ef5d489b}


Definition at line 846 of file H\+T\+T\+P1x\+Codec.\+cpp.



References reason\+\_\+.



Referenced by is\+Parsing\+Header\+Or\+Trailer\+Name(), and on\+Reason\+C\+B().


\begin{DoxyCode}
846                                                  \{
847   reason_.append(buf, len);
848   \textcolor{keywordflow}{return} 0;
849 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+Reason\+CB@{on\+Reason\+CB}}
\index{on\+Reason\+CB@{on\+Reason\+CB}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+Reason\+C\+B(http\+\_\+parser $\ast$parser, const char $\ast$buf, size\+\_\+t len)}]{\setlength{\rightskip}{0pt plus 5cm}int proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Reason\+CB (
\begin{DoxyParamCaption}
\item[{{\bf http\+\_\+parser} $\ast$}]{parser, }
\item[{const char $\ast$}]{buf, }
\item[{size\+\_\+t}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a1bcd67710d22424f7195d47acfbf0078}


Definition at line 1264 of file H\+T\+T\+P1x\+Codec.\+cpp.



References http\+\_\+parser\+::data, on\+Parser\+Error(), on\+Reason(), and parser\+\_\+.



Referenced by get\+Parser\+Settings().


\begin{DoxyCode}
1264                                                                         \{
1265   HTTP1xCodec* codec = \textcolor{keyword}{static\_cast<}HTTP1xCodec*\textcolor{keyword}{>}(parser->data);
1266   DCHECK(codec != \textcolor{keyword}{nullptr});
1267   DCHECK\_EQ(&codec->parser\_, parser);
1268 
1269   \textcolor{keywordflow}{try} \{
1270     \textcolor{keywordflow}{return} codec->onReason(buf, len);
1271   \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} std::exception& ex) \{
1272     codec->onParserError(ex.what());
1273     \textcolor{keywordflow}{return} 1;
1274   \}
1275 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+U\+RL@{on\+U\+RL}}
\index{on\+U\+RL@{on\+U\+RL}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+U\+R\+L(const char $\ast$buf, size\+\_\+t len)}]{\setlength{\rightskip}{0pt plus 5cm}int proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+U\+RL (
\begin{DoxyParamCaption}
\item[{const char $\ast$}]{buf, }
\item[{size\+\_\+t}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_ac8ba5d81b6794136e42fe1d5cf4e2c02}


Definition at line 840 of file H\+T\+T\+P1x\+Codec.\+cpp.



References url\+\_\+.



Referenced by is\+Parsing\+Header\+Or\+Trailer\+Name(), and on\+Url\+C\+B().


\begin{DoxyCode}
840                                               \{
841   url_.append(buf, len);
842   \textcolor{keywordflow}{return} 0;
843 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!on\+Url\+CB@{on\+Url\+CB}}
\index{on\+Url\+CB@{on\+Url\+CB}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{on\+Url\+C\+B(http\+\_\+parser $\ast$parser, const char $\ast$buf, size\+\_\+t len)}]{\setlength{\rightskip}{0pt plus 5cm}int proxygen\+::\+H\+T\+T\+P1x\+Codec\+::on\+Url\+CB (
\begin{DoxyParamCaption}
\item[{{\bf http\+\_\+parser} $\ast$}]{parser, }
\item[{const char $\ast$}]{buf, }
\item[{size\+\_\+t}]{len}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a332e4b9813c1e24c89c1024c3c54fed9}


Definition at line 1250 of file H\+T\+T\+P1x\+Codec.\+cpp.



References http\+\_\+parser\+::data, on\+Parser\+Error(), on\+U\+R\+L(), and parser\+\_\+.



Referenced by get\+Parser\+Settings().


\begin{DoxyCode}
1250                                                                      \{
1251   HTTP1xCodec* codec = \textcolor{keyword}{static\_cast<}HTTP1xCodec*\textcolor{keyword}{>}(parser->data);
1252   DCHECK(codec != \textcolor{keyword}{nullptr});
1253   DCHECK\_EQ(&codec->parser\_, parser);
1254 
1255   \textcolor{keywordflow}{try} \{
1256     \textcolor{keywordflow}{return} codec->onURL(buf, len);
1257   \} \textcolor{keywordflow}{catch} (\textcolor{keyword}{const} std::exception& ex) \{
1258     codec->onParserError(ex.what());
1259     \textcolor{keywordflow}{return} 1;
1260   \}
1261 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!push\+Header\+Name\+And\+Value@{push\+Header\+Name\+And\+Value}}
\index{push\+Header\+Name\+And\+Value@{push\+Header\+Name\+And\+Value}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{push\+Header\+Name\+And\+Value(\+H\+T\+T\+P\+Headers \&hdrs)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P1x\+Codec\+::push\+Header\+Name\+And\+Value (
\begin{DoxyParamCaption}
\item[{{\bf H\+T\+T\+P\+Headers} \&}]{hdrs}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_af320367fa7e96010fc82273748189b30}
Push out header name-\/value pair to hdrs and clear current\+Header$\ast$\+\_\+ 

Definition at line 851 of file H\+T\+T\+P1x\+Codec.\+cpp.



References proxygen\+::\+H\+T\+T\+P\+Headers\+::add(), proxygen\+::\+H\+T\+T\+P\+Headers\+::add\+From\+Codec(), current\+Header\+Name\+\_\+, current\+Header\+Name\+String\+Piece\+\_\+, and current\+Header\+Value\+\_\+.



Referenced by is\+Parsing\+Header\+Or\+Trailer\+Name(), on\+Header\+Field(), on\+Headers\+Complete(), and on\+Message\+Complete().


\begin{DoxyCode}
851                                                           \{
852   \textcolor{keywordflow}{if} (LIKELY(currentHeaderName_.empty())) \{
853     hdrs.addFromCodec(currentHeaderNameStringPiece_.begin(),
854                       currentHeaderNameStringPiece_.size(),
855                       std::move(currentHeaderValue_));
856   \} \textcolor{keywordflow}{else} \{
857     hdrs.add(currentHeaderName_,
858              std::move(currentHeaderValue_));
859     currentHeaderName_.clear();
860   \}
861   currentHeaderNameStringPiece_.clear();
862   currentHeaderValue_.clear();
863 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!serialize\+Websocket\+Header@{serialize\+Websocket\+Header}}
\index{serialize\+Websocket\+Header@{serialize\+Websocket\+Header}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{serialize\+Websocket\+Header(folly\+::\+I\+O\+Buf\+Queue \&write\+Buf, size\+\_\+t \&len, bool upstream)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P1x\+Codec\+::serialize\+Websocket\+Header (
\begin{DoxyParamCaption}
\item[{folly\+::\+I\+O\+Buf\+Queue \&}]{write\+Buf, }
\item[{size\+\_\+t \&}]{len, }
\item[{bool}]{upstream}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a9e87870661bc54c6d7a560b4d26594d3}
Serialize websocket headers into a buffer 

Definition at line 337 of file H\+T\+T\+P1x\+Codec.\+cpp.



References append\+Literal, generate\+Websocket\+Accept(), generate\+Websocket\+Key(), upgrade\+Header\+\_\+, and websock\+Accept\+Key\+\_\+.



Referenced by generate\+Header(), and is\+Parsing\+Header\+Or\+Trailer\+Name().


\begin{DoxyCode}
339                                                           \{
340     \textcolor{keywordflow}{if} (upstream) \{
341       appendLiteral(writeBuf, len, \textcolor{stringliteral}{"Upgrade: "});
342       appendString(writeBuf, len, kUpgradeToken.str());
343       appendLiteral(writeBuf, len, CRLF);
344       upgradeHeader_ = kUpgradeToken.str();
345 
346       \textcolor{keyword}{auto} key = generateWebsocketKey();
347       appendLiteral(writeBuf, len, \textcolor{stringliteral}{"Sec-WebSocket-Key: "});
348       appendString(writeBuf, len, key);
349       appendLiteral(writeBuf, len, CRLF);
350       DCHECK(websockAcceptKey_.empty());
351       websockAcceptKey_ = generateWebsocketAccept(key);
352     \} \textcolor{keywordflow}{else} \{
353       appendLiteral(writeBuf, len, \textcolor{stringliteral}{"Upgrade: "});
354       appendString(writeBuf, len, kUpgradeToken.str());
355       appendLiteral(writeBuf, len, CRLF);
356 
357       appendLiteral(writeBuf, len, \textcolor{stringliteral}{"Sec-WebSocket-Accept: "});
358       appendString(writeBuf, len, websockAcceptKey_);
359       appendLiteral(writeBuf, len, CRLF);
360     \}
361 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!set\+Allowed\+Upgrade\+Protocols@{set\+Allowed\+Upgrade\+Protocols}}
\index{set\+Allowed\+Upgrade\+Protocols@{set\+Allowed\+Upgrade\+Protocols}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{set\+Allowed\+Upgrade\+Protocols(std\+::list$<$ std\+::string $>$ protocols)}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P1x\+Codec\+::set\+Allowed\+Upgrade\+Protocols (
\begin{DoxyParamCaption}
\item[{std\+::list$<$ std\+::string $>$}]{protocols}
\end{DoxyParamCaption}
)}\label{classproxygen_1_1HTTP1xCodec_a4b5b28285688c029ddfb711df7da41b7}


Definition at line 802 of file H\+T\+T\+P1x\+Codec.\+cpp.



References allowed\+Native\+Upgrades\+\_\+, proxygen\+::\+D\+O\+W\+N\+S\+T\+R\+E\+AM, and transport\+Direction\+\_\+.



Referenced by supports\+Push\+Transactions().


\begin{DoxyCode}
802                                                                          \{
803   CHECK(transportDirection_ == TransportDirection::DOWNSTREAM);
804   \textcolor{keywordflow}{for} (\textcolor{keyword}{const} \textcolor{keyword}{auto}& proto: protocols) \{
805     allowedNativeUpgrades_ += folly::to<string>(proto, \textcolor{stringliteral}{","});
806   \}
807   \textcolor{keywordflow}{if} (!allowedNativeUpgrades_.empty()) \{
808     allowedNativeUpgrades_.erase(allowedNativeUpgrades_.size() - 1);
809   \}
810 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!set\+Callback@{set\+Callback}}
\index{set\+Callback@{set\+Callback}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{set\+Callback(\+Callback $\ast$callback) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P1x\+Codec\+::set\+Callback (
\begin{DoxyParamCaption}
\item[{{\bf Callback} $\ast$}]{callback}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP1xCodec_ac682c3ead807f40bdd6f7c67c4272d4c}
Set the callback to notify on ingress events 
\begin{DoxyParams}{Parameters}
{\em callback} & The callback object \\
\hline
\end{DoxyParams}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a36c5a685435eefac5b9c4682995c56ac}.



Definition at line 48 of file H\+T\+T\+P1x\+Codec.\+h.



References callback\+\_\+, is\+Busy(), is\+Reusable(), on\+Ingress(), on\+Ingress\+E\+O\+F(), and set\+Parser\+Paused().



Referenced by proxygen\+::\+R\+F\+C1867\+Codec\+::\+R\+F\+C1867\+Codec(), T\+E\+S\+T(), and T\+E\+S\+T\+\_\+\+P().


\begin{DoxyCode}
48 \{ callback_ = callback; \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!set\+Parser\+Paused@{set\+Parser\+Paused}}
\index{set\+Parser\+Paused@{set\+Parser\+Paused}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{set\+Parser\+Paused(bool paused) override}]{\setlength{\rightskip}{0pt plus 5cm}void proxygen\+::\+H\+T\+T\+P1x\+Codec\+::set\+Parser\+Paused (
\begin{DoxyParamCaption}
\item[{bool}]{paused}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP1xCodec_a647ccc6839a17eb3d1c7833165f29648}
Pause or resume the ingress parser 
\begin{DoxyParams}{Parameters}
{\em paused} & Whether the caller wants the parser to be paused \\
\hline
\end{DoxyParams}


Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a82bd0706831dfc83898b162f58750e73}.



Definition at line 141 of file H\+T\+T\+P1x\+Codec.\+cpp.



References H\+P\+E\+\_\+\+OK, H\+P\+E\+\_\+\+P\+A\+U\+S\+ED, H\+T\+T\+P\+\_\+\+P\+A\+R\+S\+E\+R\+\_\+\+E\+R\+R\+NO, http\+\_\+parser\+\_\+pause(), parser\+\_\+, parser\+Error\+\_\+, and parser\+Paused\+\_\+.



Referenced by proxygen\+::\+R\+F\+C1867\+Codec\+::on\+Body(), proxygen\+::\+R\+F\+C1867\+Codec\+::on\+Error(), proxygen\+::\+R\+F\+C1867\+Codec\+::on\+Message\+Complete(), on\+Message\+Complete(), proxygen\+::\+R\+F\+C1867\+Codec\+::on\+Trailers\+Complete(), set\+Callback(), and T\+E\+S\+T().


\begin{DoxyCode}
141                                         \{
142   \textcolor{keywordflow}{if} ((paused == parserPaused_) || parserError_) \{
143     \textcolor{comment}{// If we're bailing early, we better be paused already}
144     DCHECK(parserError_ ||
145            (HTTP_PARSER_ERRNO(&parser_) == HPE_PAUSED) == paused);
146     \textcolor{keywordflow}{return};
147   \}
148   \textcolor{keywordflow}{if} (paused) \{
149     \textcolor{keywordflow}{if} (HTTP_PARSER_ERRNO(&parser_) == HPE_OK) \{
150       http_parser_pause(&parser_, 1);
151     \}
152   \} \textcolor{keywordflow}{else} \{
153     http_parser_pause(&parser_, 0);
154   \}
155   parserPaused_ = paused;
156 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!supports\+Next\+Protocol@{supports\+Next\+Protocol}}
\index{supports\+Next\+Protocol@{supports\+Next\+Protocol}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{supports\+Next\+Protocol(const std\+::string \&npn)}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::supports\+Next\+Protocol (
\begin{DoxyParamCaption}
\item[{const std\+::string \&}]{npn}
\end{DoxyParamCaption}
)\hspace{0.3cm}{\ttfamily [static]}}\label{classproxygen_1_1HTTP1xCodec_af263975899eaed538047de97e5fcf313}
\begin{DoxyReturn}{Returns}
true if the codec supports the given N\+PN protocol. 
\end{DoxyReturn}


Definition at line 1380 of file H\+T\+T\+P1x\+Codec.\+cpp.



Referenced by proxygen\+::\+Default\+H\+T\+T\+P\+Codec\+Factory\+::get\+Codec(), proxygen\+::\+H\+T\+T\+P\+Default\+Session\+Codec\+Factory\+::get\+Codec(), and supports\+Push\+Transactions().


\begin{DoxyCode}
1380                                                            \{
1381   \textcolor{keywordflow}{return} npn.length() == 8 && (npn == \textcolor{stringliteral}{"http/1.0"} || npn == \textcolor{stringliteral}{"http/1.1"});
1382 \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!supports\+Parallel\+Requests@{supports\+Parallel\+Requests}}
\index{supports\+Parallel\+Requests@{supports\+Parallel\+Requests}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{supports\+Parallel\+Requests() const override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::supports\+Parallel\+Requests (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP1xCodec_ab04eae86e19a1a4714f3dd0d5e4834ba}
Check whether the codec supports the processing of multiple requests in parallel. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_a8dfbc8c5bee0947e718742e541259be2}.



Definition at line 58 of file H\+T\+T\+P1x\+Codec.\+h.


\begin{DoxyCode}
58 \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}
\end{DoxyCode}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!supports\+Push\+Transactions@{supports\+Push\+Transactions}}
\index{supports\+Push\+Transactions@{supports\+Push\+Transactions}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{supports\+Push\+Transactions() const override}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::supports\+Push\+Transactions (
\begin{DoxyParamCaption}
{}
\end{DoxyParamCaption}
) const\hspace{0.3cm}{\ttfamily [inline]}, {\ttfamily [override]}, {\ttfamily [virtual]}}\label{classproxygen_1_1HTTP1xCodec_abcb663c6bed8c892384398a0aa3988ca}
Check whether the codec supports pushing resources from server to client. 

Implements {\bf proxygen\+::\+H\+T\+T\+P\+Codec} \doxyref{}{p.}{classproxygen_1_1HTTPCodec_aa43f8d4ffd6e30bf9e2c176fa5b9188c}.



Definition at line 59 of file H\+T\+T\+P1x\+Codec.\+h.



References generate\+Body(), generate\+Chunk\+Header(), generate\+Chunk\+Terminator(), generate\+E\+O\+M(), generate\+Goaway(), generate\+Header(), generate\+Rst\+Stream(), generate\+Trailers(), get\+Allowed\+Upgrade\+Protocols(), set\+Allowed\+Upgrade\+Protocols(), status\+Code, and supports\+Next\+Protocol().


\begin{DoxyCode}
59 \{ \textcolor{keywordflow}{return} \textcolor{keyword}{false}; \}
\end{DoxyCode}


\subsection{Member Data Documentation}
\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!allowed\+Native\+Upgrades\+\_\+@{allowed\+Native\+Upgrades\+\_\+}}
\index{allowed\+Native\+Upgrades\+\_\+@{allowed\+Native\+Upgrades\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{allowed\+Native\+Upgrades\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string proxygen\+::\+H\+T\+T\+P1x\+Codec\+::allowed\+Native\+Upgrades\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a91e9439b00b81d281e4a2189c32f8b17}


Definition at line 176 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by get\+Allowed\+Upgrade\+Protocols(), on\+Headers\+Complete(), and set\+Allowed\+Upgrade\+Protocols().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!callback\+\_\+@{callback\+\_\+}}
\index{callback\+\_\+@{callback\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{callback\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Codec\+::\+Callback}$\ast$ proxygen\+::\+H\+T\+T\+P1x\+Codec\+::callback\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a3cbf9ba9da471fdb333f36ea0a530349}


Definition at line 161 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by on\+Body(), on\+Chunk\+Complete(), on\+Chunk\+Header(), on\+Headers\+Complete(), on\+Ingress(), on\+Ingress\+E\+O\+F(), on\+Message\+Begin(), on\+Message\+Complete(), on\+Parser\+Error(), and set\+Callback().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!connect\+Request\+\_\+@{connect\+Request\+\_\+}}
\index{connect\+Request\+\_\+@{connect\+Request\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{connect\+Request\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::connect\+Request\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_ab9d5aaad0b232ff5e9503e66088bb631}


Definition at line 195 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by generate\+Header(), and on\+Headers\+Complete().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!current\+Header\+Name\+\_\+@{current\+Header\+Name\+\_\+}}
\index{current\+Header\+Name\+\_\+@{current\+Header\+Name\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{current\+Header\+Name\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string proxygen\+::\+H\+T\+T\+P1x\+Codec\+::current\+Header\+Name\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a873e5e8f585ae95618bf8ad336422471}


Definition at line 169 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by on\+Header\+Field(), on\+Ingress(), and push\+Header\+Name\+And\+Value().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!current\+Header\+Name\+String\+Piece\+\_\+@{current\+Header\+Name\+String\+Piece\+\_\+}}
\index{current\+Header\+Name\+String\+Piece\+\_\+@{current\+Header\+Name\+String\+Piece\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{current\+Header\+Name\+String\+Piece\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}folly\+::\+String\+Piece proxygen\+::\+H\+T\+T\+P1x\+Codec\+::current\+Header\+Name\+String\+Piece\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a6283ac3527865bcf105a800b234e3aa2}


Definition at line 170 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by on\+Header\+Field(), on\+Ingress(), and push\+Header\+Name\+And\+Value().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!current\+Header\+Value\+\_\+@{current\+Header\+Value\+\_\+}}
\index{current\+Header\+Value\+\_\+@{current\+Header\+Value\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{current\+Header\+Value\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string proxygen\+::\+H\+T\+T\+P1x\+Codec\+::current\+Header\+Value\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a8d0f01167a87a2193350ab7322507975}


Definition at line 171 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by on\+Header\+Value(), and push\+Header\+Name\+And\+Value().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!current\+Ingress\+Buf\+\_\+@{current\+Ingress\+Buf\+\_\+}}
\index{current\+Ingress\+Buf\+\_\+@{current\+Ingress\+Buf\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{current\+Ingress\+Buf\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}const folly\+::\+I\+O\+Buf$\ast$ proxygen\+::\+H\+T\+T\+P1x\+Codec\+::current\+Ingress\+Buf\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a289cfc560678ac19cfe1ddfce929857f}


Definition at line 165 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by on\+Body(), on\+Ingress(), and on\+Parser\+Error().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!disable\+Keepalive\+Pending\+\_\+@{disable\+Keepalive\+Pending\+\_\+}}
\index{disable\+Keepalive\+Pending\+\_\+@{disable\+Keepalive\+Pending\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{disable\+Keepalive\+Pending\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::disable\+Keepalive\+Pending\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_adcf71d76966a6abdd5efa157c397deb5}


Definition at line 193 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by generate\+Goaway(), generate\+Header(), and generate\+Rst\+Stream().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!egress\+Chunked\+\_\+@{egress\+Chunked\+\_\+}}
\index{egress\+Chunked\+\_\+@{egress\+Chunked\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{egress\+Chunked\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::egress\+Chunked\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a8b8d0bf8209a20e62ab666fa8f20719c}


Definition at line 189 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by generate\+Body(), generate\+Chunk\+Header(), generate\+Chunk\+Terminator(), generate\+E\+O\+M(), generate\+Header(), and generate\+Trailers().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!egress\+Txn\+I\+D\+\_\+@{egress\+Txn\+I\+D\+\_\+}}
\index{egress\+Txn\+I\+D\+\_\+@{egress\+Txn\+I\+D\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{egress\+Txn\+I\+D\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stream\+ID} proxygen\+::\+H\+T\+T\+P1x\+Codec\+::egress\+Txn\+I\+D\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_aa933da09cfa924b9daa888968e43c36d}


Definition at line 163 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by create\+Stream(), generate\+Body(), generate\+E\+O\+M(), generate\+Header(), generate\+Trailers(), and on\+Parser\+Error().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!egress\+Upgrade\+\_\+@{egress\+Upgrade\+\_\+}}
\index{egress\+Upgrade\+\_\+@{egress\+Upgrade\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{egress\+Upgrade\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::egress\+Upgrade\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a40435eb4cc340fafbc29ab6f68d3a064}


Definition at line 203 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by close\+On\+Egress\+Complete(), generate\+Header(), is\+Reusable(), and on\+Headers\+Complete().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!expect\+No\+Response\+Body\+\_\+@{expect\+No\+Response\+Body\+\_\+}}
\index{expect\+No\+Response\+Body\+\_\+@{expect\+No\+Response\+Body\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{expect\+No\+Response\+Body\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::expect\+No\+Response\+Body\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a2a6dcde241bf834683538d3cbc735bf7}


Definition at line 197 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by generate\+Header(), and on\+Headers\+Complete().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!force\+Upstream1\+\_\+1\+\_\+@{force\+Upstream1\+\_\+1\+\_\+}}
\index{force\+Upstream1\+\_\+1\+\_\+@{force\+Upstream1\+\_\+1\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{force\+Upstream1\+\_\+1\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::force\+Upstream1\+\_\+1\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_aa9acbe483674c08f2a32817eaaa3e245}


Definition at line 182 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by generate\+Header().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!header\+Parse\+State\+\_\+@{header\+Parse\+State\+\_\+}}
\index{header\+Parse\+State\+\_\+@{header\+Parse\+State\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{header\+Parse\+State\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Header\+Parse\+State} proxygen\+::\+H\+T\+T\+P1x\+Codec\+::header\+Parse\+State\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_aa9cea5cbd03a6797e51e86714e0f8b21}


Definition at line 178 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by is\+Parsing\+Header\+Or\+Trailer\+Name(), is\+Parsing\+Headers(), on\+Header\+Field(), on\+Headers\+Complete(), on\+Header\+Value(), on\+Message\+Begin(), and on\+Message\+Complete().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!headers\+Complete\+\_\+@{headers\+Complete\+\_\+}}
\index{headers\+Complete\+\_\+@{headers\+Complete\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{headers\+Complete\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::headers\+Complete\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_ad02191b56806cf4e172afca376ec23b4}


Definition at line 205 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by on\+Headers\+Complete(), on\+Ingress(), and on\+Message\+Begin().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!header\+Size\+\_\+@{header\+Size\+\_\+}}
\index{header\+Size\+\_\+@{header\+Size\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{header\+Size\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf H\+T\+T\+P\+Header\+Size} proxygen\+::\+H\+T\+T\+P1x\+Codec\+::header\+Size\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a976dcb012d4741a4c9c628db3e856f96}


Definition at line 177 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by on\+Headers\+Complete(), on\+Ingress(), and on\+Message\+Begin().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!head\+Request\+\_\+@{head\+Request\+\_\+}}
\index{head\+Request\+\_\+@{head\+Request\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{head\+Request\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::head\+Request\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a0181445988c2626273556075e4d52342}


Definition at line 196 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by generate\+E\+O\+M(), generate\+Header(), and on\+Headers\+Complete().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!in\+Chunk\+\_\+@{in\+Chunk\+\_\+}}
\index{in\+Chunk\+\_\+@{in\+Chunk\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{in\+Chunk\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::in\+Chunk\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_af0b5581eb5401468b000ca31dc7803f0}


Definition at line 190 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by generate\+Body(), generate\+Chunk\+Header(), generate\+Chunk\+Terminator(), generate\+E\+O\+M(), and generate\+Trailers().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!ingress\+Txn\+I\+D\+\_\+@{ingress\+Txn\+I\+D\+\_\+}}
\index{ingress\+Txn\+I\+D\+\_\+@{ingress\+Txn\+I\+D\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{ingress\+Txn\+I\+D\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Stream\+ID} proxygen\+::\+H\+T\+T\+P1x\+Codec\+::ingress\+Txn\+I\+D\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a2ff3a05a5a1abea7489a2a48bd3673c4}


Definition at line 162 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by create\+Stream(), generate\+Header(), on\+Body(), on\+Chunk\+Complete(), on\+Chunk\+Header(), on\+Headers\+Complete(), on\+Ingress(), on\+Ingress\+E\+O\+F(), on\+Message\+Begin(), on\+Message\+Complete(), and on\+Parser\+Error().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!ingress\+Upgrade\+\_\+@{ingress\+Upgrade\+\_\+}}
\index{ingress\+Upgrade\+\_\+@{ingress\+Upgrade\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{ingress\+Upgrade\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::ingress\+Upgrade\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a27d71fbadabed80be6efb88f6f6fba06}


Definition at line 201 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by generate\+Header(), is\+Reusable(), on\+Headers\+Complete(), and on\+Message\+Complete().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!ingress\+Upgrade\+Complete\+\_\+@{ingress\+Upgrade\+Complete\+\_\+}}
\index{ingress\+Upgrade\+Complete\+\_\+@{ingress\+Upgrade\+Complete\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{ingress\+Upgrade\+Complete\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::ingress\+Upgrade\+Complete\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_aa352a6bf96f18acc617995b335fe61cf}


Definition at line 202 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by on\+Ingress(), on\+Ingress\+E\+O\+F(), and on\+Message\+Complete().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!in\+Recv\+Last\+Chunk\+\_\+@{in\+Recv\+Last\+Chunk\+\_\+}}
\index{in\+Recv\+Last\+Chunk\+\_\+@{in\+Recv\+Last\+Chunk\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{in\+Recv\+Last\+Chunk\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::in\+Recv\+Last\+Chunk\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a9d72e64a89e789ef8ce5057501c4c2e2}


Definition at line 200 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by on\+Body(), on\+Chunk\+Complete(), on\+Chunk\+Header(), on\+Message\+Complete(), and on\+Parser\+Error().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!is1xx\+Response\+\_\+@{is1xx\+Response\+\_\+}}
\index{is1xx\+Response\+\_\+@{is1xx\+Response\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{is1xx\+Response\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::is1xx\+Response\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_ad6e58acb6db53d54b424ef94dca05d55}


Definition at line 199 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by generate\+Header(), on\+Headers\+Complete(), on\+Message\+Begin(), and on\+Message\+Complete().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!keepalive\+\_\+@{keepalive\+\_\+}}
\index{keepalive\+\_\+@{keepalive\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{keepalive\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::keepalive\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a56155e65d790b00ad2966bf3aa851de1}


Definition at line 192 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by generate\+Header(), is\+Reusable(), and on\+Headers\+Complete().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!keepalive\+Requested\+\_\+@{keepalive\+Requested\+\_\+}}
\index{keepalive\+Requested\+\_\+@{keepalive\+Requested\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{keepalive\+Requested\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Keepalive\+Requested} proxygen\+::\+H\+T\+T\+P1x\+Codec\+::keepalive\+Requested\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a31c5772485cce1f100bb4ddecde816bc}


Definition at line 180 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by generate\+Header(), and on\+Headers\+Complete().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!last\+Chunk\+Written\+\_\+@{last\+Chunk\+Written\+\_\+}}
\index{last\+Chunk\+Written\+\_\+@{last\+Chunk\+Written\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{last\+Chunk\+Written\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::last\+Chunk\+Written\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a3df7be00fdc2a8174c06a1f12937dd6f}


Definition at line 191 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by generate\+E\+O\+M(), generate\+Header(), and generate\+Trailers().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!may\+Chunk\+Egress\+\_\+@{may\+Chunk\+Egress\+\_\+}}
\index{may\+Chunk\+Egress\+\_\+@{may\+Chunk\+Egress\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{may\+Chunk\+Egress\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::may\+Chunk\+Egress\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_af856c187de9726f583bfd6c71d4a9dd6}


Definition at line 198 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by generate\+Header(), make\+Response\+Codec(), and on\+Headers\+Complete().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!msg\+\_\+@{msg\+\_\+}}
\index{msg\+\_\+@{msg\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{msg\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<${\bf H\+T\+T\+P\+Message}$>$ proxygen\+::\+H\+T\+T\+P1x\+Codec\+::msg\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_aedbf1f90bd69174afe206304ec706bea}


Definition at line 166 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by on\+Header\+Field(), on\+Headers\+Complete(), on\+Ingress(), on\+Message\+Begin(), and on\+Parser\+Error().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!native\+Upgrade\+\_\+@{native\+Upgrade\+\_\+}}
\index{native\+Upgrade\+\_\+@{native\+Upgrade\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{native\+Upgrade\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::native\+Upgrade\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_ad46c40e57419758e66877148e3acfb48}


Definition at line 204 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by on\+Headers\+Complete(), and on\+Message\+Complete().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!parser\+\_\+@{parser\+\_\+}}
\index{parser\+\_\+@{parser\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{parser\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf http\+\_\+parser} proxygen\+::\+H\+T\+T\+P1x\+Codec\+::parser\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_ac0abaf53b89624a78246f85ad025d0de}


Definition at line 164 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by generate\+Header(), H\+T\+T\+P1x\+Codec(), on\+Body\+C\+B(), on\+Chunk\+Complete\+C\+B(), on\+Chunk\+Header\+C\+B(), on\+Header\+Field\+C\+B(), on\+Headers\+Complete(), on\+Headers\+Complete\+C\+B(), on\+Header\+Value\+C\+B(), on\+Ingress(), on\+Ingress\+E\+O\+F(), on\+Message\+Begin\+C\+B(), on\+Message\+Complete\+C\+B(), on\+Parser\+Error(), on\+Reason\+C\+B(), on\+Url\+C\+B(), and set\+Parser\+Paused().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!parser\+Active\+\_\+@{parser\+Active\+\_\+}}
\index{parser\+Active\+\_\+@{parser\+Active\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{parser\+Active\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::parser\+Active\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a7aeb36c072968b2c40783bf6022743e9}


Definition at line 183 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by on\+Ingress(), and on\+Ingress\+E\+O\+F().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!parser\+Error\+\_\+@{parser\+Error\+\_\+}}
\index{parser\+Error\+\_\+@{parser\+Error\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{parser\+Error\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::parser\+Error\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a6fa54238bf60686d1c66cab0986659d1}


Definition at line 186 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by is\+Reusable(), on\+Ingress(), on\+Ingress\+E\+O\+F(), and set\+Parser\+Paused().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!parser\+Paused\+\_\+@{parser\+Paused\+\_\+}}
\index{parser\+Paused\+\_\+@{parser\+Paused\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{parser\+Paused\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::parser\+Paused\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a7bd44db2f8d64a85f2f7b127f9c4fd20}


Definition at line 185 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by set\+Parser\+Paused().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!pending\+E\+O\+F\+\_\+@{pending\+E\+O\+F\+\_\+}}
\index{pending\+E\+O\+F\+\_\+@{pending\+E\+O\+F\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{pending\+E\+O\+F\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::pending\+E\+O\+F\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a09e8360fbcfb3798d96d06eea21b812a}


Definition at line 184 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by on\+Ingress(), and on\+Ingress\+E\+O\+F().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!reason\+\_\+@{reason\+\_\+}}
\index{reason\+\_\+@{reason\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{reason\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string proxygen\+::\+H\+T\+T\+P1x\+Codec\+::reason\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a186fdf724f52ffbb29e4d18bdfac81b4}


Definition at line 174 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by on\+Headers\+Complete(), and on\+Reason().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!request\+Pending\+\_\+@{request\+Pending\+\_\+}}
\index{request\+Pending\+\_\+@{request\+Pending\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{request\+Pending\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::request\+Pending\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a4c13ae7ae47307c588ec5a7eff7947ce}


Definition at line 187 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by generate\+E\+O\+M(), generate\+Header(), is\+Busy(), on\+Message\+Begin(), and on\+Message\+Complete().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!response\+Pending\+\_\+@{response\+Pending\+\_\+}}
\index{response\+Pending\+\_\+@{response\+Pending\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{response\+Pending\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}bool proxygen\+::\+H\+T\+T\+P1x\+Codec\+::response\+Pending\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a67143e5f59239b7a8ca2c9a3af5f8a81}


Definition at line 188 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by generate\+E\+O\+M(), generate\+Header(), is\+Busy(), on\+Message\+Begin(), and on\+Message\+Complete().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!trailers\+\_\+@{trailers\+\_\+}}
\index{trailers\+\_\+@{trailers\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{trailers\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<${\bf H\+T\+T\+P\+Headers}$>$ proxygen\+::\+H\+T\+T\+P1x\+Codec\+::trailers\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_ae86c8af73ef76bbc315eb687a35424fb}


Definition at line 168 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by on\+Header\+Field(), on\+Message\+Begin(), and on\+Message\+Complete().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!transport\+Direction\+\_\+@{transport\+Direction\+\_\+}}
\index{transport\+Direction\+\_\+@{transport\+Direction\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{transport\+Direction\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}{\bf Transport\+Direction} proxygen\+::\+H\+T\+T\+P1x\+Codec\+::transport\+Direction\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_acdc5f4f93ee4ac01dc1dcb550344dad6}


Definition at line 179 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by create\+Stream(), generate\+E\+O\+M(), generate\+Header(), get\+Transport\+Direction(), on\+Headers\+Complete(), on\+Ingress(), on\+Message\+Begin(), on\+Message\+Complete(), on\+Parser\+Error(), and set\+Allowed\+Upgrade\+Protocols().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!upgrade\+Header\+\_\+@{upgrade\+Header\+\_\+}}
\index{upgrade\+Header\+\_\+@{upgrade\+Header\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{upgrade\+Header\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string proxygen\+::\+H\+T\+T\+P1x\+Codec\+::upgrade\+Header\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_ae6473f8b7a4eb00ad269390d03da4755}


Definition at line 175 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by generate\+Header(), on\+Headers\+Complete(), and serialize\+Websocket\+Header().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!upgrade\+Request\+\_\+@{upgrade\+Request\+\_\+}}
\index{upgrade\+Request\+\_\+@{upgrade\+Request\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{upgrade\+Request\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::unique\+\_\+ptr$<${\bf H\+T\+T\+P\+Message}$>$ proxygen\+::\+H\+T\+T\+P1x\+Codec\+::upgrade\+Request\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a3029d70e6690cd4ab7c68113032cfbd6}


Definition at line 167 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by on\+Headers\+Complete(), and on\+Message\+Complete().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!upgrade\+Result\+\_\+@{upgrade\+Result\+\_\+}}
\index{upgrade\+Result\+\_\+@{upgrade\+Result\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{upgrade\+Result\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::pair$<${\bf Codec\+Protocol}, std\+::string$>$ proxygen\+::\+H\+T\+T\+P1x\+Codec\+::upgrade\+Result\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a2acbc4ff9b4f84e55c1a972bfe38df4b}


Definition at line 181 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by on\+Headers\+Complete(), and on\+Message\+Complete().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!url\+\_\+@{url\+\_\+}}
\index{url\+\_\+@{url\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{url\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string proxygen\+::\+H\+T\+T\+P1x\+Codec\+::url\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a663ba6227d146a9554b3a6721500e794}


Definition at line 172 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by on\+Headers\+Complete(), and on\+U\+R\+L().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!user\+Agent\+\_\+@{user\+Agent\+\_\+}}
\index{user\+Agent\+\_\+@{user\+Agent\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{user\+Agent\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string proxygen\+::\+H\+T\+T\+P1x\+Codec\+::user\+Agent\+\_\+\hspace{0.3cm}{\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_aaddebf07118c1c05d299f52716bd2eb3}


Definition at line 173 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by get\+User\+Agent(), and on\+Headers\+Complete().

\index{proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}!websock\+Accept\+Key\+\_\+@{websock\+Accept\+Key\+\_\+}}
\index{websock\+Accept\+Key\+\_\+@{websock\+Accept\+Key\+\_\+}!proxygen\+::\+H\+T\+T\+P1x\+Codec@{proxygen\+::\+H\+T\+T\+P1x\+Codec}}
\subsubsection[{websock\+Accept\+Key\+\_\+}]{\setlength{\rightskip}{0pt plus 5cm}std\+::string proxygen\+::\+H\+T\+T\+P1x\+Codec\+::websock\+Accept\+Key\+\_\+\hspace{0.3cm}{\ttfamily [mutable]}, {\ttfamily [private]}}\label{classproxygen_1_1HTTP1xCodec_a77a070ca8bda15b88317393c55af82ec}


Definition at line 111 of file H\+T\+T\+P1x\+Codec.\+h.



Referenced by is\+Reusable(), on\+Headers\+Complete(), and serialize\+Websocket\+Header().



The documentation for this class was generated from the following files\+:\begin{DoxyCompactItemize}
\item 
proxygen/lib/http/codec/{\bf H\+T\+T\+P1x\+Codec.\+h}\item 
proxygen/lib/http/codec/{\bf H\+T\+T\+P1x\+Codec.\+cpp}\end{DoxyCompactItemize}
